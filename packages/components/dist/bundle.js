import * as Ue from "react";
import Ee, { createContext as Ge, useContext as xe, Children as it, forwardRef as Da, memo as Le, useState as P, useRef as Qe, useEffect as v, useMemo as Nn, isValidElement as ti, cloneElement as ni, Component as Yu, PureComponent as be, createRef as wr, useId as G$, useCallback as pn, useReducer as Y$, useLayoutEffect as K$, useSyncExternalStore as J$ } from "react";
import { Info as KB, AlertTriangle as X$, XCircle as JB, CheckCircle2 as XB, Loader2 as ri, Pause as Q$, Play as e3, RefreshCw as QB, Check as b0, ChevronDown as eI, X as w0, Search as tI, Image as t3, Heading1 as n3, Heading2 as r3, Quote as o3, Bold as i3, Italic as s3, Underline as a3, Code as l3, AlignLeft as u3, AlignRight as c3, AlignCenter as p3, AlignJustify as d3, ChevronRight as Ey, ChevronLeft as f3, Ellipsis as E1, MapPinned as h3 } from "lucide-react";
import { useActionData as C0, useNavigation as nI, useFetchers as rI, useLocation as O0, Link as g3, useNavigate as oI } from "@remix-run/react";
import { InputMask as m3 } from "@react-input/mask";
import * as oi from "react-dom";
import Ga, { createPortal as Cr } from "react-dom";
import { AnimatePresence as iI, motion as mu } from "framer-motion";
var En = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function th(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ly = { exports: {} }, cl = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var L1;
function v3() {
  if (L1) return cl;
  L1 = 1;
  var e = Ee, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, m = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: m, props: p, _owner: o.current };
  }
  return cl.Fragment = n, cl.jsx = s, cl.jsxs = s, cl;
}
var pl = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var P1;
function y3() {
  return P1 || (P1 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ee, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), f = Symbol.iterator, g = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[g];
      return typeof I == "function" ? I : null;
    }
    var x = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, Y = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          Y[ne - 1] = arguments[ne];
        D("error", b, Y);
      }
    }
    function D(b, I, Y) {
      {
        var ne = x.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (I += "%s", Y = Y.concat([le]));
        var ce = Y.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var O = !1, y = !1, C = !1, S = !1, U = !1, L;
    L = Symbol.for("react.module.reference");
    function F(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || U || b === o || b === u || b === c || S || b === m || O || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function B(b, I, Y) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = I.displayName || I.name || "";
      return le !== "" ? Y + "(" + le + ")" : Y;
    }
    function $(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var I = b;
            return $(I) + ".Consumer";
          case s:
            var Y = b;
            return $(Y._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, ae = le._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, q = 0, X, J, te, ee, k, j, H;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function Z() {
      {
        if (q === 0) {
          X = console.log, J = console.info, te = console.warn, ee = console.error, k = console.group, j = console.groupCollapsed, H = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function E() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: X
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: k
            }),
            groupCollapsed: z({}, b, {
              value: j
            }),
            groupEnd: z({}, b, {
              value: H
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = x.ReactCurrentDispatcher, R;
    function _(b, I, Y) {
      {
        if (R === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            R = ne && ne[1] || "";
          }
        return `
` + R + b;
      }
    }
    var W = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function N(b, I) {
      if (!b || W)
        return "";
      {
        var Y = A.get(b);
        if (Y !== void 0)
          return Y;
      }
      var ne;
      W = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = T.current, T.current = null, Z();
      try {
        if (I) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Re) {
              ne = Re;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Re) {
              ne = Re;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Re) {
            ne = Re;
          }
          b();
        }
      } catch (Re) {
        if (Re && ne && typeof Re.stack == "string") {
          for (var se = Re.stack.split(`
`), Be = ne.stack.split(`
`), we = se.length - 1, Oe = Be.length - 1; we >= 1 && Oe >= 0 && se[we] !== Be[Oe]; )
            Oe--;
          for (; we >= 1 && Oe >= 0; we--, Oe--)
            if (se[we] !== Be[Oe]) {
              if (we !== 1 || Oe !== 1)
                do
                  if (we--, Oe--, Oe < 0 || se[we] !== Be[Oe]) {
                    var qe = `
` + se[we].replace(" at new ", " at ");
                    return b.displayName && qe.includes("<anonymous>") && (qe = qe.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, qe), qe;
                  }
                while (we >= 1 && Oe >= 0);
              break;
            }
        }
      } finally {
        W = !1, T.current = ce, E(), Error.prepareStackTrace = le;
      }
      var Xt = b ? b.displayName || b.name : "", Ct = Xt ? _(Xt) : "";
      return typeof b == "function" && A.set(b, Ct), Ct;
    }
    function ue(b, I, Y) {
      return N(b, !1);
    }
    function ye(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, Y) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, ye(b));
      if (typeof b == "string")
        return _(b);
      switch (b) {
        case u:
          return _("Suspense");
        case c:
          return _("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, Y);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), I, Y);
            } catch {
            }
          }
        }
      return "";
    }
    var Ie = Object.prototype.hasOwnProperty, $e = {}, Ve = x.ReactDebugCurrentFrame;
    function Ne(b) {
      if (b) {
        var I = b._owner, Y = oe(b.type, b._source, I ? I.type : null);
        Ve.setExtraStackFrame(Y);
      } else
        Ve.setExtraStackFrame(null);
    }
    function Je(b, I, Y, ne, le) {
      {
        var ce = Function.call.bind(Ie);
        for (var ae in b)
          if (ce(b, ae)) {
            var se = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Be = Error((ne || "React class") + ": " + Y + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Be.name = "Invariant Violation", Be;
              }
              se = b[ae](I, ae, ne, Y, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (we) {
              se = we;
            }
            se && !(se instanceof Error) && (Ne(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", Y, ae, typeof se), Ne(null)), se instanceof Error && !(se.message in $e) && ($e[se.message] = !0, Ne(le), w("Failed %s type: %s", Y, se.message), Ne(null));
          }
      }
    }
    var Ye = Array.isArray;
    function Te(b) {
      return Ye(b);
    }
    function Ke(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, Y = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return Y;
      }
    }
    function nt(b) {
      try {
        return Me(b), !1;
      } catch {
        return !0;
      }
    }
    function Me(b) {
      return "" + b;
    }
    function Ae(b) {
      if (nt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(b)), Me(b);
    }
    var Fe = x.ReactCurrentOwner, He = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ze, et, _e;
    _e = {};
    function At(b) {
      if (Ie.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function rt(b) {
      if (Ie.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, I) {
      if (typeof b.ref == "string" && Fe.current && I && Fe.current.stateNode !== I) {
        var Y = V(Fe.current.type);
        _e[Y] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Fe.current.type), b.ref), _e[Y] = !0);
      }
    }
    function at(b, I) {
      {
        var Y = function() {
          ze || (ze = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: Y,
          configurable: !0
        });
      }
    }
    function qt(b, I) {
      {
        var Y = function() {
          et || (et = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: Y,
          configurable: !0
        });
      }
    }
    var lt = function(b, I, Y, ne, le, ce, ae) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: Y,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function Gt(b, I, Y, ne, le) {
      {
        var ce, ae = {}, se = null, Be = null;
        Y !== void 0 && (Ae(Y), se = "" + Y), rt(I) && (Ae(I.key), se = "" + I.key), At(I) && (Be = I.ref, ot(I, le));
        for (ce in I)
          Ie.call(I, ce) && !He.hasOwnProperty(ce) && (ae[ce] = I[ce]);
        if (b && b.defaultProps) {
          var we = b.defaultProps;
          for (ce in we)
            ae[ce] === void 0 && (ae[ce] = we[ce]);
        }
        if (se || Be) {
          var Oe = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && at(ae, Oe), Be && qt(ae, Oe);
        }
        return lt(b, se, Be, le, ne, Fe.current, ae);
      }
    }
    var Xe = x.ReactCurrentOwner, bt = x.ReactDebugCurrentFrame;
    function tt(b) {
      if (b) {
        var I = b._owner, Y = oe(b.type, b._source, I ? I.type : null);
        bt.setExtraStackFrame(Y);
      } else
        bt.setExtraStackFrame(null);
    }
    var Yt;
    Yt = !1;
    function ut(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function dn() {
      {
        if (Xe.current) {
          var b = V(Xe.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function Kt(b) {
      return "";
    }
    var fn = {};
    function Jt(b) {
      {
        var I = dn();
        if (!I) {
          var Y = typeof b == "string" ? b : b.displayName || b.name;
          Y && (I = `

Check the top-level render call using <` + Y + ">.");
        }
        return I;
      }
    }
    function hn(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var Y = Jt(I);
        if (fn[Y])
          return;
        fn[Y] = !0;
        var ne = "";
        b && b._owner && b._owner !== Xe.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), tt(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Y, ne), tt(null);
      }
    }
    function Fn(b, I) {
      {
        if (typeof b != "object")
          return;
        if (Te(b))
          for (var Y = 0; Y < b.length; Y++) {
            var ne = b[Y];
            ut(ne) && hn(ne, I);
          }
        else if (ut(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = h(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), ae; !(ae = ce.next()).done; )
              ut(ae.value) && hn(ae.value, I);
        }
      }
    }
    function wt(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var Y;
        if (typeof I == "function")
          Y = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          Y = I.propTypes;
        else
          return;
        if (Y) {
          var ne = V(I);
          Je(Y, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !Yt) {
          Yt = !0;
          var le = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function re(b) {
      {
        for (var I = Object.keys(b.props), Y = 0; Y < I.length; Y++) {
          var ne = I[Y];
          if (ne !== "children" && ne !== "key") {
            tt(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), tt(null);
            break;
          }
        }
        b.ref !== null && (tt(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var qr = {};
    function Gr(b, I, Y, ne, le, ce) {
      {
        var ae = F(b);
        if (!ae) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Be = Kt();
          Be ? se += Be : se += dn();
          var we;
          b === null ? we = "null" : Te(b) ? we = "array" : b !== void 0 && b.$$typeof === t ? (we = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : we = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", we, se);
        }
        var Oe = Gt(b, I, Y, le, ce);
        if (Oe == null)
          return Oe;
        if (ae) {
          var qe = I.children;
          if (qe !== void 0)
            if (ne)
              if (Te(qe)) {
                for (var Xt = 0; Xt < qe.length; Xt++)
                  Fn(qe[Xt], b);
                Object.freeze && Object.freeze(qe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Fn(qe, b);
        }
        if (Ie.call(I, "key")) {
          var Ct = V(b), Re = Object.keys(I).filter(function(gi) {
            return gi !== "key";
          }), Or = Re.length > 0 ? "{key: someKey, " + Re.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!qr[Ct + Or]) {
            var hi = Re.length > 0 ? "{" + Re.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Or, Ct, hi, Ct), qr[Ct + Or] = !0;
          }
        }
        return b === r ? re(Oe) : wt(Oe), Oe;
      }
    }
    function ci(b, I, Y) {
      return Gr(b, I, Y, !0);
    }
    function pi(b, I, Y) {
      return Gr(b, I, Y, !1);
    }
    var di = pi, fi = ci;
    pl.Fragment = r, pl.jsx = di, pl.jsxs = fi;
  }()), pl;
}
process.env.NODE_ENV === "production" ? Ly.exports = v3() : Ly.exports = y3();
var K = Ly.exports;
function b3(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ K.jsx("div", { className: r.trim(), ...n });
}
const sI = Ge({});
function w3() {
  return xe(sI);
}
function $Ce(e) {
  const { schema: t, children: n, className: r, ...o } = e, a = !((u) => {
    let c = !1;
    const p = (d) => {
      Array.isArray(d) ? d.forEach(p) : d && typeof d == "object" && "type" in d && (d.type === b3 ? c = !0 : d.props && d.props.children && p(d.props.children));
    };
    return p(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${t} ${a} ${r}`;
  return /* @__PURE__ */ K.jsx(sI.Provider, { value: e, children: /* @__PURE__ */ K.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function VCe(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ K.jsx("div", { className: r.trim(), ...n });
}
function HCe(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ K.jsx("div", { className: r.trim(), ...n });
}
function WCe(e) {
  const { className: t, ...n } = e, { schema: r } = w3(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ K.jsx(XB, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ K.jsx(JB, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ K.jsx(X$, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ K.jsx(KB, { className: o, ...n });
  }
}
function Ed(e, t) {
  return t ? /* @__PURE__ */ K.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ K.jsx(K.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function k1(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Ar(e) {
  var t, n;
  return k1(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(k1(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var aI = Symbol.for("immer-nothing"), S1 = Symbol.for("immer-draftable"), Co = Symbol.for("immer-state"), C3 = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Kr(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = C3[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Ua = Object.getPrototypeOf;
function ha(e) {
  return !!e && !!e[Co];
}
function ga(e) {
  var t;
  return e ? lI(e) || Array.isArray(e) || !!e[S1] || !!((t = e.constructor) != null && t[S1]) || rh(e) || oh(e) : !1;
}
var O3 = Object.prototype.constructor.toString();
function lI(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Ua(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === O3;
}
function Ld(e, t) {
  nh(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function nh(e) {
  const t = e[Co];
  return t ? t.type_ : Array.isArray(e) ? 1 : rh(e) ? 2 : oh(e) ? 3 : 0;
}
function Py(e, t) {
  return nh(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function uI(e, t, n) {
  const r = nh(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function x3(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function rh(e) {
  return e instanceof Map;
}
function oh(e) {
  return e instanceof Set;
}
function qs(e) {
  return e.copy_ || e.base_;
}
function ky(e, t) {
  if (rh(e))
    return new Map(e);
  if (oh(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = lI(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Co];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(Ua(e), r);
  } else {
    const r = Ua(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function x0(e, t = !1) {
  return ih(e) || ha(e) || !ga(e) || (nh(e) > 1 && (e.set = e.add = e.clear = e.delete = E3), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => x0(r, !0))), e;
}
function E3() {
  Kr(2);
}
function ih(e) {
  return Object.isFrozen(e);
}
var L3 = {};
function ma(e) {
  const t = L3[e];
  return t || Kr(0, e), t;
}
var vu;
function cI() {
  return vu;
}
function P3(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function D1(e, t) {
  t && (ma("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Sy(e) {
  Dy(e), e.drafts_.forEach(k3), e.drafts_ = null;
}
function Dy(e) {
  e === vu && (vu = e.parent_);
}
function M1(e) {
  return vu = P3(vu, e);
}
function k3(e) {
  const t = e[Co];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function T1(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Co].modified_ && (Sy(t), Kr(4)), ga(e) && (e = Pd(t, e), t.parent_ || kd(t, e)), t.patches_ && ma("Patches").generateReplacementPatches_(
    n[Co].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Pd(t, n, []), Sy(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== aI ? e : void 0;
}
function Pd(e, t, n) {
  if (ih(t))
    return t;
  const r = t[Co];
  if (!r)
    return Ld(
      t,
      (o, i) => j1(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return kd(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Ld(
      i,
      (a, l) => j1(e, r, o, a, l, n, s)
    ), kd(e, o, !1), n && e.patches_ && ma("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function j1(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && Kr(5), ha(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Py(t.assigned_, r) ? i.concat(r) : void 0, l = Pd(e, o, a);
    if (uI(n, r, l), ha(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (ga(o) && !ih(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Pd(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && kd(e, o);
  }
}
function kd(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && x0(t, n);
}
function S3(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : cI(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = E0;
  n && (o = [r], i = yu);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var E0 = {
  get(e, t) {
    if (t === Co)
      return e;
    const n = qs(e);
    if (!Py(n, t))
      return D3(e, n, t);
    const r = n[t];
    return e.finalized_ || !ga(r) ? r : r === nm(e.base_, t) ? (rm(e), e.copy_[t] = Ty(r, e)) : r;
  },
  has(e, t) {
    return t in qs(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(qs(e));
  },
  set(e, t, n) {
    const r = pI(qs(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = nm(qs(e), t), i = o == null ? void 0 : o[Co];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (x3(n, o) && (n !== void 0 || Py(e.base_, t)))
        return !0;
      rm(e), My(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return nm(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, rm(e), My(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = qs(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Kr(11);
  },
  getPrototypeOf(e) {
    return Ua(e.base_);
  },
  setPrototypeOf() {
    Kr(12);
  }
}, yu = {};
Ld(E0, (e, t) => {
  yu[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
yu.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Kr(13), yu.set.call(this, e, t, void 0);
};
yu.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Kr(14), E0.set.call(this, e[0], t, n, e[0]);
};
function nm(e, t) {
  const n = e[Co];
  return (n ? qs(n) : e)[t];
}
function D3(e, t, n) {
  var o;
  const r = pI(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function pI(e, t) {
  if (!(t in e))
    return;
  let n = Ua(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Ua(n);
  }
}
function My(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && My(e.parent_));
}
function rm(e) {
  e.copy_ || (e.copy_ = ky(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var M3 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(l = i, ...u) {
          return s.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && Kr(6), r !== void 0 && typeof r != "function" && Kr(7);
      let o;
      if (ga(t)) {
        const i = M1(this), s = Ty(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? Sy(i) : Dy(i);
        }
        return D1(i, r), T1(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === aI && (o = void 0), this.autoFreeze_ && x0(o, !0), r) {
          const i = [], s = [];
          ma("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        Kr(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (s, ...a) => this.produceWithPatches(s, (l) => t(l, ...a));
      let r, o;
      return [this.produce(t, n, (s, a) => {
        r = s, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ga(e) || Kr(8), ha(e) && (e = T3(e));
    const t = M1(this), n = Ty(e, void 0);
    return n[Co].isManual_ = !0, Dy(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Co];
    (!n || !n.isManual_) && Kr(9);
    const { scope_: r } = n;
    return D1(r, t), T1(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = ma("Patches").applyPatches_;
    return ha(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Ty(e, t) {
  const n = rh(e) ? ma("MapSet").proxyMap_(e, t) : oh(e) ? ma("MapSet").proxySet_(e, t) : S3(e, t);
  return (t ? t.scope_ : cI()).drafts_.push(n), n;
}
function T3(e) {
  return ha(e) || Kr(10, e), dI(e);
}
function dI(e) {
  if (!ga(e) || ih(e))
    return e;
  const t = e[Co];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = ky(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = ky(e, !0);
  return Ld(n, (r, o) => {
    uI(n, r, dI(o));
  }), t && (t.finalized_ = !1), n;
}
var Oo = new M3(), L0 = Oo.produce;
Oo.produceWithPatches.bind(
  Oo
);
Oo.setAutoFreeze.bind(Oo);
Oo.setUseStrictShallowCopy.bind(Oo);
Oo.applyPatches.bind(Oo);
var _1 = Oo.createDraft.bind(Oo), A1 = Oo.finishDraft.bind(Oo), j3 = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ie.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, _3 = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = Ot.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, A3 = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = pe.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Sd = /* @__PURE__ */ new WeakMap(), Dd = /* @__PURE__ */ new WeakMap(), ql = /* @__PURE__ */ new WeakMap(), fI = /* @__PURE__ */ new WeakMap(), B1 = /* @__PURE__ */ new WeakMap(), I1 = /* @__PURE__ */ new WeakMap(), N1 = /* @__PURE__ */ new WeakMap(), ie = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = ie.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return ie.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return ie.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return ie.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return ie.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && ie.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return ie.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && ie.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && ie.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && ie.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && ie.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && ie.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!ie.isAncestor(t, e) && !ie.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (ie.equals(i, r) || ie.endsBefore(i, r) || ie.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (ie.equals(s, r) || ie.isAncestor(s, r))
          return null;
        ie.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        ie.equals(a, r) || ie.endsBefore(a, r) ? r[a.length - 1] -= 1 : ie.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (ie.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else ie.endsBefore(u, r) ? r[u.length - 1] += 1 : ie.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (ie.equals(p, d))
          return r;
        if (ie.isAncestor(p, r) || ie.equals(p, r)) {
          var m = d.slice();
          return ie.endsBefore(p, d) && p.length < d.length && (m[p.length - 1] -= 1), m.concat(r.slice(p.length));
        } else ie.isSibling(p, d) && (ie.isAncestor(d, r) || ie.equals(d, r)) ? ie.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : ie.endsBefore(d, r) || ie.equals(d, r) || ie.isAncestor(d, r) ? (ie.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : ie.endsBefore(p, r) && (ie.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function bu(e) {
  "@babel/helpers - typeof";
  return bu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, bu(e);
}
function B3(e, t) {
  if (bu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (bu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function I3(e) {
  var t = B3(e, "string");
  return bu(t) === "symbol" ? t : String(t);
}
function Ur(e, t, n) {
  return t = I3(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function F1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? F1(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : F1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var N3 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = je.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of pe.points(t))
          t[l] = Ot.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = je.leaf(e, u), m = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = m + p + f, t)
        for (var [g, h] of pe.points(t))
          t[h] = Ot.transform(g, n);
      break;
    }
    case "merge_node": {
      var {
        path: x
      } = n, w = je.get(e, x), D = ie.previous(x), O = je.get(e, D), y = je.parent(e, x), C = x[x.length - 1];
      if (Ze.isText(w) && Ze.isText(O))
        O.text += w.text;
      else if (!Ze.isText(w) && !Ze.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(x, "] to nodes of different interfaces: ").concat(Sr.stringify(w), " ").concat(Sr.stringify(O)));
      if (y.children.splice(C, 1), t)
        for (var [S, U] of pe.points(t))
          t[U] = Ot.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: F
      } = n;
      if (ie.isAncestor(L, F))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(F, "] because the destination is inside itself."));
      var B = je.get(e, L), $ = je.parent(e, L), V = L[L.length - 1];
      $.children.splice(V, 1);
      var z = ie.transform(L, n), q = je.get(e, ie.parent(z)), X = z[z.length - 1];
      if (q.children.splice(X, 0, B), t)
        for (var [J, te] of pe.points(t))
          t[te] = Ot.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, k = ee[ee.length - 1], j = je.parent(e, ee);
      if (j.children.splice(k, 1), t)
        for (var [H, M] of pe.points(t)) {
          var Z = Ot.transform(H, n);
          if (t != null && Z != null)
            t[M] = Z;
          else {
            var E = void 0, T = void 0;
            for (var [R, _] of je.texts(e))
              if (ie.compare(_, ee) === -1)
                E = [R, _];
              else {
                T = [R, _];
                break;
              }
            var W = !1;
            E && T && (ie.equals(T[1], ee) ? W = !ie.hasPrevious(T[1]) : W = ie.common(E[1], ee).length < ie.common(T[1], ee).length), E && !W ? (H.path = E[1], H.offset = E[0].text.length) : T ? (H.path = T[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: N
      } = n;
      if (N.length === 0) break;
      var ue = je.leaf(e, A), ye = ue.text.slice(0, Q), oe = ue.text.slice(Q + N.length);
      if (ue.text = ye + oe, t)
        for (var [Ie, $e] of pe.points(t))
          t[$e] = Ot.transform(Ie, n);
      break;
    }
    case "set_node": {
      var {
        path: Ve,
        properties: Ne,
        newProperties: Je
      } = n;
      if (Ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ye = je.get(e, Ve);
      for (var Te in Je) {
        if (Te === "children" || Te === "text")
          throw new Error('Cannot set the "'.concat(Te, '" property of nodes!'));
        var Ke = Je[Te];
        Ke == null ? delete Ye[Te] : Ye[Te] = Ke;
      }
      for (var nt in Ne)
        Je.hasOwnProperty(nt) || delete Ye[nt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Me
      } = n;
      if (Me == null)
        t = Me;
      else {
        if (t == null) {
          if (!pe.isRange(Me))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Sr.stringify(Me), " when there is no current selection."));
          t = dl({}, Me);
        }
        for (var Ae in Me) {
          var Fe = Me[Ae];
          if (Fe == null) {
            if (Ae === "anchor" || Ae === "focus")
              throw new Error('Cannot remove the "'.concat(Ae, '" selection property'));
            delete t[Ae];
          } else
            t[Ae] = Fe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: He,
        position: ze,
        properties: et
      } = n;
      if (He.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(He, "] because the root node cannot be split."));
      var _e = je.get(e, He), At = je.parent(e, He), rt = He[He.length - 1], ot;
      if (Ze.isText(_e)) {
        var at = _e.text.slice(0, ze), qt = _e.text.slice(ze);
        _e.text = at, ot = dl(dl({}, et), {}, {
          text: qt
        });
      } else {
        var lt = _e.children.slice(0, ze), Gt = _e.children.slice(ze);
        _e.children = lt, ot = dl(dl({}, et), {}, {
          children: Gt
        });
      }
      if (At.children.splice(rt + 1, 0, ot), t)
        for (var [Xe, bt] of pe.points(t))
          t[bt] = Ot.transform(Xe, n);
      break;
    }
  }
  return t;
}, F3 = {
  transform(e, t) {
    e.children = _1(e.children);
    var n = e.selection && _1(e.selection);
    try {
      n = N3(e, n, t);
    } finally {
      e.children = A1(e.children), n ? e.selection = ha(n) ? A1(n) : n : e.selection = null;
    }
  }
}, R3 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, z3 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, hI = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Ar(r) && Ar(o)) {
      if (!hI(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function U3(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Ti(e, t) {
  if (e == null) return {};
  var n = U3(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var $3 = ["anchor", "focus"];
function R1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function V3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? R1(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : R1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pe = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return pe.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = pe.edges(e);
    return t;
  },
  equals(e, t) {
    return Ot.equals(e.anchor, t.anchor) && Ot.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (pe.isRange(t)) {
      if (pe.includes(e, t.anchor) || pe.includes(e, t.focus))
        return !0;
      var [n, r] = pe.edges(e), [o, i] = pe.edges(t);
      return Ot.isBefore(n, o) && Ot.isAfter(r, i);
    }
    var [s, a] = pe.edges(e), l = !1, u = !1;
    return Ot.isPoint(t) ? (l = Ot.compare(t, s) >= 0, u = Ot.compare(t, a) <= 0) : (l = ie.compare(t, s.path) >= 0, u = ie.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Ti(e, $3), [r, o] = pe.edges(e), [i, s] = pe.edges(t), a = Ot.isBefore(r, i) ? i : r, l = Ot.isBefore(o, s) ? o : s;
    return Ot.isBefore(l, a) ? null : V3({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Ot.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Ot.equals(t, n);
  },
  isExpanded(e) {
    return !pe.isCollapsed(e);
  },
  isForward(e) {
    return !pe.isBackward(e);
  },
  isRange(e) {
    return Ar(e) && Ot.isPoint(e.anchor) && Ot.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = pe.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return L0(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = pe.isCollapsed(r);
        pe.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? pe.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = Ot.transform(r.anchor, t, {
        affinity: i
      }), u = Ot.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, z1 = (e) => Ar(e) && je.isNodeList(e.children) && !G.isEditor(e), We = {
  isAncestor(e) {
    return Ar(e) && je.isNodeList(e.children);
  },
  isElement: z1,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => We.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return z1(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, H3 = ["children"], W3 = ["text"], U1 = /* @__PURE__ */ new WeakMap(), je = {
  ancestor(e, t) {
    var n = je.get(e, t);
    if (Ze.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Sr.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ie.ancestors(t, n)) {
        var o = je.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Ze.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Sr.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Sr.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = je.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = je.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = ie.common(t, n), o = je.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = je.get(e, t);
    if (G.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Sr.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of je.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of je.nodes(e, t))
        We.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (We.isAncestor(e)) {
      var t = Ti(e, H3);
      return t;
    } else {
      var t = Ti(e, W3);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = je.get(e, n); r && !(Ze.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Ze.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Sr.stringify(e)));
    var n = L0({
      children: e.children
    }, (r) => {
      var [o, i] = pe.edges(t), s = je.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, m] = d;
          return !pe.includes(t, m);
        }
      });
      for (var [, a] of s) {
        if (!pe.includes(t, a)) {
          var l = je.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (ie.equals(a, i.path)) {
          var c = je.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (ie.equals(a, o.path)) {
          var p = je.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      G.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ze.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Sr.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ze.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Ze.isText(e) || We.isElement(e) || G.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = U1.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => je.isNode(r));
    return U1.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = je.get(e, n); r && !(Ze.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = je.get(e, t);
    if (!Ze.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Sr.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ie.levels(t, n)) {
        var o = je.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return We.isElement(e) && We.isElementProps(t) && We.matches(e, t) || Ze.isText(e) && Ze.isTextProps(t) && Ze.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? ie.isBefore(a, i) : ie.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !Ze.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          ie.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = je.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = ie.next(a);
          if (je.has(e, c)) {
            a = c, l = je.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = ie.previous(a);
          a = p, l = je.get(e, a);
          continue;
        }
        a = ie.parent(a), l = je.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = ie.parent(t), r = je.get(e, n);
    if (Ze.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Ze.isText(e) ? e.text : e.children.map(je.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of je.nodes(e, t))
        Ze.isText(n) && (yield [n, r]);
    }();
  }
};
function $1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $1(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ms = {
  isNodeOperation(e) {
    return ms.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Ar(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return ie.isPath(e.path) && je.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ie.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && ie.isPath(e.path) && Ar(e.properties);
      case "move_node":
        return ie.isPath(e.path) && ie.isPath(e.newPath);
      case "remove_node":
        return ie.isPath(e.path) && je.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ie.isPath(e.path);
      case "set_node":
        return ie.isPath(e.path) && Ar(e.properties) && Ar(e.newProperties);
      case "set_selection":
        return e.properties === null && pe.isRange(e.newProperties) || e.newProperties === null && pe.isRange(e.properties) || Ar(e.properties) && Ar(e.newProperties);
      case "split_node":
        return ie.isPath(e.path) && typeof e.position == "number" && Ar(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => ms.isOperation(t));
  },
  isSelectionOperation(e) {
    return ms.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return ms.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Rn(Rn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Rn(Rn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Rn(Rn({}, e), {}, {
          type: "split_node",
          path: ie.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (ie.equals(t, n))
          return e;
        if (ie.isSibling(n, t))
          return Rn(Rn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = ie.transform(n, e), o = ie.transform(ie.next(n), e);
        return Rn(Rn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Rn(Rn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Rn(Rn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return Rn(Rn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? Rn(Rn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Rn(Rn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : Rn(Rn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return Rn(Rn({}, e), {}, {
          type: "merge_node",
          path: ie.next(e.path)
        });
    }
  }
}, V1 = /* @__PURE__ */ new WeakMap(), Z3 = (e) => {
  var t = V1.get(e);
  if (t !== void 0)
    return t;
  if (!Ar(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Ar(e.marks)) && (e.selection === null || pe.isRange(e.selection)) && je.isNodeList(e.children) && ms.isOperationList(e.operations);
  return V1.set(e, n), n;
}, G = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Z3(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, q3 = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(ie.isPath);
  }
};
function H1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function W1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? H1(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : H1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ot = {
  compare(e, t) {
    var n = ie.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Ot.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Ot.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && ie.equals(e.path, t.path);
  },
  isPoint(e) {
    return Ar(e) && typeof e.offset == "number" && ie.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return L0(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = ie.transform(i, t, n);
          break;
        }
        case "insert_text": {
          ie.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          ie.equals(t.path, i) && (r.offset += t.position), r.path = ie.transform(i, t, n);
          break;
        }
        case "remove_text": {
          ie.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (ie.equals(t.path, i) || ie.isAncestor(t.path, i))
            return null;
          r.path = ie.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (ie.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = ie.transform(i, t, W1(W1({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = ie.transform(i, t, n);
          break;
        }
      }
    });
  }
}, Z1 = void 0, Sr = {
  setScrubber(e) {
    Z1 = e;
  },
  stringify(e) {
    return JSON.stringify(e, Z1);
  }
}, G3 = ["text"], Y3 = ["anchor", "focus"];
function q1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? q1(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : q1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ze = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = Ti(i, G3);
      return s;
    }
    return hI(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Ar(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Ze.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [mi({}, e)];
    for (var r of t) {
      var o = Ti(r, Y3), [i, s] = pe.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, m = l;
        if (l += d, u <= m && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === m) || u > l || c < m || c === m && m !== 0) {
          a.push(p);
          continue;
        }
        var f = p, g = void 0, h = void 0;
        if (c < l) {
          var x = c - m;
          h = mi(mi({}, f), {}, {
            text: f.text.slice(x)
          }), f = mi(mi({}, f), {}, {
            text: f.text.slice(0, x)
          });
        }
        if (u > m) {
          var w = u - m;
          g = mi(mi({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = mi(mi({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), g && a.push(g), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, P0 = (e) => e.selection ? e.selection : e.children.length > 0 ? G.end(e, []) : [0], Ya = (e, t) => {
  var [n] = G.node(e, t);
  return (r) => r === n;
}, k0 = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? tV(t) : t, i = st.None, s = st.None, a = 0, l = null, u = null;
  for (var c of o) {
    var p = c.codePointAt(0);
    if (!p) break;
    var d = fV(c, p);
    if ([i, s] = r ? [s, d] : [d, i], ja(i, st.ZWJ) && ja(s, st.ExtPict) && (r ? l = G1(t.substring(0, a)) : l = G1(t.substring(0, t.length - a)), !l) || ja(i, st.RI) && ja(s, st.RI) && (u !== null ? u = !u : r ? u = !0 : u = yV(t.substring(0, t.length - a)), !u) || i !== st.None && s !== st.None && gV(i, s))
      break;
    a += c.length;
  }
  return a || 1;
}, K3 = /\s/, J3 = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, X3 = /['\u2018\u2019]/, Q3 = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = k0(t, n), [s, a] = S0(t, i, n);
    if (eV(s, a, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = a;
  }
  return r;
}, S0 = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, eV = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (K3.test(t))
    return !1;
  if (X3.test(t)) {
    var o = k0(n, r), [i, s] = S0(n, o, r);
    if (e(i, s, r))
      return !0;
  }
  return !J3.test(t);
}, tV = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (rV(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (nV(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, nV = (e) => e >= 55296 && e <= 56319, rV = (e) => e >= 56320 && e <= 57343, st;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(st || (st = {}));
var oV = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, iV = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, sV = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, aV = /^[\u1100-\u115F\uA960-\uA97C]$/, lV = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, uV = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, cV = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, pV = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, dV = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, fV = (e, t) => {
  var n = st.Any;
  return e.search(oV) !== -1 && (n |= st.Extend), t === 8205 && (n |= st.ZWJ), t >= 127462 && t <= 127487 && (n |= st.RI), e.search(iV) !== -1 && (n |= st.Prepend), e.search(sV) !== -1 && (n |= st.SpacingMark), e.search(aV) !== -1 && (n |= st.L), e.search(lV) !== -1 && (n |= st.V), e.search(uV) !== -1 && (n |= st.T), e.search(cV) !== -1 && (n |= st.LV), e.search(pV) !== -1 && (n |= st.LVT), e.search(dV) !== -1 && (n |= st.ExtPict), n;
};
function ja(e, t) {
  return (e & t) !== 0;
}
var hV = [
  // GB6
  [st.L, st.L | st.V | st.LV | st.LVT],
  // GB7
  [st.LV | st.V, st.V | st.T],
  // GB8
  [st.LVT | st.T, st.T],
  // GB9
  [st.Any, st.Extend | st.ZWJ],
  // GB9a
  [st.Any, st.SpacingMark],
  // GB9b
  [st.Prepend, st.Any],
  // GB11
  [st.ZWJ, st.ExtPict],
  // GB12 and GB13
  [st.RI, st.RI]
];
function gV(e, t) {
  return hV.findIndex((n) => ja(e, n[0]) && ja(t, n[1])) === -1;
}
var mV = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, G1 = (e) => e.search(mV) !== -1, vV = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, yV = (e) => {
  var t = e.match(vV);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, bV = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    G.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = P0(e)
      } = n;
      if (ie.isPath(o) && (o = G.range(e, o)), pe.isRange(o))
        if (pe.isCollapsed(o))
          o = o.anchor;
        else {
          var i = pe.end(o);
          if (!r && G.void(e, {
            at: i
          }))
            return;
          var s = pe.start(o), a = G.pointRef(e, s), l = G.pointRef(e, i);
          Ce.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Ce.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && G.void(e, {
        at: o
      }) || G.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function Y1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Y1(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Y1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ce = jc(jc(jc(jc({}, F3), R3), z3), bV), pd = /* @__PURE__ */ new WeakMap(), wV = (e) => pd.get(e) || !1, CV = (e, t, n) => {
  var r = pd.get(e) || !1;
  pd.set(e, !0);
  try {
    t(), n();
  } finally {
    pd.set(e, r);
  }
};
function gI(e, t, n) {
  var r = Sd.get(e) || [], o = Dd.get(e) || /* @__PURE__ */ new Set(), i, s, a = (p) => {
    if (p) {
      var d = p.join(",");
      s.has(d) || (s.add(d), i.push(p));
    }
  };
  if (n) {
    i = [], s = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      a(u);
    }
  } else
    i = r, s = o;
  for (var c of t)
    a(c);
  Sd.set(e, i), Dd.set(e, s);
}
var OV = (e, t) => {
  for (var n of G.pathRefs(e))
    j3.transform(n, t);
  for (var r of G.pointRefs(e))
    _3.transform(r, t);
  for (var o of G.rangeRefs(e))
    A3.transform(o, t);
  if (!wV(e)) {
    var i = ie.operationCanTransformPath(t) ? (s) => ie.transform(s, t) : void 0;
    gI(e, e.getDirtyPaths(t), i);
  }
  Ce.transform(e, t), e.operations.push(t), G.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), ql.get(e) || (ql.set(e, !0), Promise.resolve().then(() => {
    ql.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, xV = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return ie.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = ie.levels(o), s = Ze.isText(r) ? [] : Array.from(je.nodes(r), (F) => {
        var [, B] = F;
        return o.concat(B);
      });
      return [...i, ...s];
    }
    case "merge_node": {
      var {
        path: a
      } = t, l = ie.ancestors(a), u = ie.previous(a);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: p
      } = t;
      if (ie.equals(c, p))
        return [];
      var d = [], m = [];
      for (var f of ie.ancestors(c)) {
        var g = ie.transform(f, t);
        d.push(g);
      }
      for (var h of ie.ancestors(p)) {
        var x = ie.transform(h, t);
        m.push(x);
      }
      var w = m[m.length - 1], D = p[p.length - 1], O = w.concat(D);
      return [...d, ...m, O];
    }
    case "remove_node": {
      var {
        path: y
      } = t, C = ie.ancestors(y);
      return [...C];
    }
    case "split_node": {
      var {
        path: S
      } = t, U = ie.levels(S), L = ie.next(S);
      return [...U, L];
    }
    default:
      return [];
  }
}, EV = (e) => {
  var {
    selection: t
  } = e;
  return t ? je.fragment(e, t) : [];
}, LV = (e, t) => {
  var [n, r] = t;
  if (!Ze.isText(n)) {
    if (We.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      Ce.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = G.isEditor(n) ? !1 : We.isElement(n) && (e.isInline(n) || n.children.length === 0 || Ze.isText(n.children[0]) || e.isInline(n.children[0])), s = 0, a = 0; a < n.children.length; a++, s++) {
      var l = je.get(e, r);
      if (!Ze.isText(l)) {
        var u = l.children[s], c = l.children[s - 1], p = a === n.children.length - 1, d = Ze.isText(u) || We.isElement(u) && e.isInline(u);
        if (d !== i)
          Ce.removeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--;
        else if (We.isElement(u)) {
          if (e.isInline(u)) {
            if (c == null || !Ze.isText(c)) {
              var m = {
                text: ""
              };
              Ce.insertNodes(e, m, {
                at: r.concat(s),
                voids: !0
              }), s++;
            } else if (p) {
              var f = {
                text: ""
              };
              Ce.insertNodes(e, f, {
                at: r.concat(s + 1),
                voids: !0
              }), s++;
            }
          }
        } else {
          if (!Ze.isText(u) && !("children" in u)) {
            var g = u;
            g.children = [];
          }
          c != null && Ze.isText(c) && (Ze.equals(u, c, {
            loose: !0
          }) ? (Ce.mergeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--) : c.text === "" ? (Ce.removeNodes(e, {
            at: r.concat(s - 1),
            voids: !0
          }), s--) : u.text === "" && (Ce.removeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--));
        }
      }
    }
  }
}, PV = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, kV = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: s
  } = n;
  if (i) {
    var a = G.path(t, i), l = o === "lowest";
    for (var [u, c] of G.levels(t, {
      at: a,
      voids: r,
      match: s,
      reverse: l
    }))
      if (!Ze.isText(u)) {
        if (pe.isRange(i)) {
          if (ie.isAncestor(c, i.anchor.path) && ie.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!ie.equals(a, c))
          return [u, c];
      }
  }
};
function K1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function J1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? K1(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : K1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var SV = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (p, d) => {
      if (!Ze.isText(p))
        return !1;
      var [m, f] = G.parent(e, d);
      return !e.isVoid(m) || e.markableVoid(m);
    }, i = pe.isExpanded(r), s = !1;
    if (!i) {
      var [a, l] = G.node(e, r);
      if (a && o(a, l)) {
        var [u] = G.parent(e, l);
        s = u && e.markableVoid(u);
      }
    }
    if (i || s)
      Ce.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = J1(J1({}, G.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, ql.get(e) || e.onChange();
    }
  }
};
function X1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Q1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? X1(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : X1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var DV = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = G.point(t, n, {
    edge: "end"
  }), i = G.end(t, []), s = {
    anchor: o,
    focus: i
  }, {
    distance: a = 1
  } = r, l = 0, u;
  for (var c of G.positions(t, Q1(Q1({}, r), {}, {
    at: s
  }))) {
    if (l > a)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function eO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eO(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var MV = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = G.start(t, []), i = G.point(t, n, {
    edge: "start"
  }), s = {
    anchor: o,
    focus: i
  }, {
    distance: a = 1
  } = r, l = 0, u;
  for (var c of G.positions(t, tO(tO({}, r), {}, {
    at: s,
    reverse: !0
  }))) {
    if (l > a)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, TV = (e, t) => {
  var {
    selection: n
  } = e;
  n && pe.isCollapsed(n) && Ce.delete(e, {
    unit: t,
    reverse: !0
  });
}, jV = (e, t) => {
  var {
    selection: n
  } = e;
  n && pe.isCollapsed(n) && Ce.delete(e, {
    unit: t
  });
}, _V = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && pe.isExpanded(r) && Ce.delete(t, {
    reverse: n === "backward"
  });
}, AV = (e, t) => [G.start(e, t), G.end(e, t)];
function nO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nO(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var BV = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return G.above(t, rO(rO({}, n), {}, {
    match: (r) => We.isElement(r) && G.isElementReadOnly(t, r)
  }));
}, IV = (e, t) => G.point(e, t, {
  edge: "end"
}), NV = (e, t) => {
  var n = G.path(e, t, {
    edge: "start"
  });
  return G.node(e, n);
}, FV = (e, t) => {
  var n = G.range(e, t);
  return je.fragment(e, n);
};
function oO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oO(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var RV = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return G.above(t, iO(iO({}, n), {}, {
    match: (r) => We.isElement(r) && G.isVoid(t, r)
  }));
}, zV = (e, t) => t.children.some((n) => We.isElement(n) && G.isBlock(e, n)), UV = (e, t) => t.children.some((n) => Ze.isText(n) || G.isInline(e, n)), $V = (e, t) => je.has(e, t), VV = (e, t) => t.children.every((n) => Ze.isText(n)), HV = (e) => {
  Ce.splitNodes(e, {
    always: !0
  });
}, WV = (e, t, n) => {
  Ce.insertNodes(e, t, n);
}, ZV = (e) => {
  Ce.splitNodes(e, {
    always: !0
  });
};
function sO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qV(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sO(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var GV = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var s = qV({
        text: n
      }, i);
      Ce.insertNodes(t, s, {
        at: r.at,
        voids: r.voids
      });
    } else
      Ce.insertText(t, n, r);
    t.marks = null;
  }
}, YV = (e, t) => !e.isInline(t), KV = (e, t, n) => G.isStart(e, t, n) || G.isEnd(e, t, n), JV = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && Ze.isText(r) && r.text === "" && !e.isVoid(t);
}, XV = (e, t, n) => {
  var r = G.end(e, n);
  return Ot.equals(t, r);
}, QV = (e) => {
  var t = fI.get(e);
  return t === void 0 ? !0 : t;
}, eH = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = G.start(e, n);
  return Ot.equals(t, r);
}, tH = (e, t) => {
  var n = G.path(e, t, {
    edge: "end"
  });
  return G.node(e, n);
}, nH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = G.path(t, n, r), i = je.leaf(t, o);
  return [i, o];
};
function rH(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var s = [], a = G.path(e, n);
      for (var [l, u] of je.levels(e, a))
        if (i(l, u) && (s.push([l, u]), !o && We.isElement(l) && G.isVoid(e, l)))
          break;
      r && s.reverse(), yield* s;
    }
  }();
}
var oH = ["text"], iH = ["text"], sH = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (pe.isExpanded(r)) {
    var s = G.isEnd(t, o, o.path);
    if (s) {
      var a = G.after(t, o);
      a && (o = a);
    }
    var [l] = G.nodes(t, {
      match: Ze.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = Ti(u, oH);
      return c;
    } else
      return {};
  }
  var {
    path: p
  } = o, [d] = G.leaf(t, p);
  if (o.offset === 0) {
    var m = G.previous(t, {
      at: p,
      match: Ze.isText
    }), f = G.above(t, {
      match: (O) => We.isElement(O) && G.isVoid(t, O) && t.markableVoid(O)
    });
    if (!f) {
      var g = G.above(t, {
        match: (O) => We.isElement(O) && G.isBlock(t, O)
      });
      if (m && g) {
        var [h, x] = m, [, w] = g;
        ie.isAncestor(w, x) && (d = h);
      }
    }
  }
  var D = Ti(d, iH);
  return D;
}, aH = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: s = t.selection
  } = n;
  if (s) {
    var a = G.after(t, s, {
      voids: o
    });
    if (a) {
      var [, l] = G.last(t, []), u = [a.path, l];
      if (ie.isPath(s) && s.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (ie.isPath(s)) {
          var [c] = G.parent(t, s);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = G.nodes(t, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, lH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = G.path(t, n, r), i = je.get(t, o);
  return [i, o];
};
function uH(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: s = !1,
      ignoreNonSelectable: a = !1
    } = t, {
      match: l
    } = t;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if (q3.isSpan(n))
        u = n[0], c = n[1];
      else {
        var p = G.path(e, n, {
          edge: "start"
        }), d = G.path(e, n, {
          edge: "end"
        });
        u = i ? d : p, c = i ? p : d;
      }
      var m = je.nodes(e, {
        reverse: i,
        from: u,
        to: c,
        pass: (O) => {
          var [y] = O;
          return We.isElement(y) ? !!(!s && (G.isVoid(e, y) || G.isElementReadOnly(e, y)) || a && !G.isSelectable(e, y)) : !1;
        }
      }), f = [], g;
      for (var [h, x] of m)
        if (!(a && We.isElement(h) && !G.isSelectable(e, h))) {
          var w = g && ie.compare(x, g[1]) === 0;
          if (!(r === "highest" && w)) {
            if (!l(h, x)) {
              if (o && !w && Ze.isText(h))
                return;
              continue;
            }
            if (r === "lowest" && w) {
              g = [h, x];
              continue;
            }
            var D = r === "lowest" ? g : [h, x];
            D && (o ? f.push(D) : yield D), g = [h, x];
          }
        }
      r === "lowest" && g && (o ? f.push(g) : yield g), o && (yield* f);
    }
  }();
}
var cH = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => Sd.get(c) || [], s = (c) => Dd.get(c) || /* @__PURE__ */ new Set(), a = (c) => {
    var p = i(c).pop(), d = p.join(",");
    return s(c).delete(d), p;
  };
  if (G.isNormalizing(t)) {
    if (r) {
      var l = Array.from(je.nodes(t), (c) => {
        var [, p] = c;
        return p;
      }), u = new Set(l.map((c) => c.join(",")));
      Sd.set(t, l), Dd.set(t, u);
    }
    i(t).length !== 0 && G.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (je.has(t, c)) {
          var p = G.node(t, c), [d, m] = p;
          We.isElement(d) && d.children.length === 0 && t.normalizeNode(p, {
            operation: o
          });
        }
      for (var f = i(t), g = f.length, h = 0; f.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: f,
          iteration: h,
          initialDirtyPathsLength: g,
          operation: o
        }))
          return;
        var x = a(t);
        if (je.has(t, x)) {
          var w = G.node(t, x);
          t.normalizeNode(w, {
            operation: o
          });
        }
        h++, f = i(t);
      }
    });
  }
}, pH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = G.path(t, n, r), i = ie.parent(o), s = G.node(t, i);
  return s;
}, dH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = G.pathRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = G.pathRefs(t);
  return s.add(i), i;
}, fH = (e) => {
  var t = B1.get(e);
  return t || (t = /* @__PURE__ */ new Set(), B1.set(e, t)), t;
}, hH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (ie.isPath(n)) {
    if (i === "start") {
      var [, s] = je.first(t, n);
      n = s;
    } else if (i === "end") {
      var [, a] = je.last(t, n);
      n = a;
    }
  }
  return pe.isRange(n) && (i === "start" ? n = pe.start(n) : i === "end" ? n = pe.end(n) : n = ie.common(n.anchor.path, n.focus.path)), Ot.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, gH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = G.pointRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = G.pointRefs(t);
  return s.add(i), i;
}, mH = (e) => {
  var t = I1.get(e);
  return t || (t = /* @__PURE__ */ new Set(), I1.set(e, t)), t;
}, vH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (ie.isPath(n)) {
    var i;
    if (o === "end") {
      var [, s] = je.last(t, n);
      i = s;
    } else {
      var [, a] = je.first(t, n);
      i = a;
    }
    var l = je.get(t, i);
    if (!Ze.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (pe.isRange(n)) {
    var [u, c] = pe.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function yH(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: s = !1
    } = t;
    if (!n)
      return;
    var a = G.range(e, n), [l, u] = pe.edges(a), c = o ? u : l, p = !1, d = "", m = 0, f = 0, g = 0;
    for (var [h, x] of G.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: s
    })) {
      if (We.isElement(h)) {
        if (!i && (e.isVoid(h) || e.isElementReadOnly(h))) {
          yield G.start(e, x);
          continue;
        }
        if (e.isInline(h)) continue;
        if (G.hasInlines(e, h)) {
          var w = ie.isAncestor(x, u.path) ? u : G.end(e, x), D = ie.isAncestor(x, l.path) ? l : G.start(e, x);
          d = G.string(e, {
            anchor: D,
            focus: w
          }, {
            voids: i
          }), p = !0;
        }
      }
      if (Ze.isText(h)) {
        var O = ie.equals(x, c.path);
        for (O ? (f = o ? c.offset : h.text.length - c.offset, g = c.offset) : (f = h.text.length, g = o ? f : 0), (O || p || r === "offset") && (yield {
          path: x,
          offset: g
        }, p = !1); ; ) {
          if (m === 0) {
            if (d === "") break;
            m = y(d, r, o), d = S0(d, m, o)[1];
          }
          if (g = o ? g - m : g + m, f = f - m, f < 0) {
            m = -f;
            break;
          }
          m = 0, yield {
            path: x,
            offset: g
          };
        }
      }
    }
    function y(C, S, U) {
      return S === "character" ? k0(C, U) : S === "word" ? Q3(C, U) : S === "line" || S === "block" ? C.length : 1;
    }
  }();
}
var bH = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: s = t.selection
  } = n;
  if (s) {
    var a = G.before(t, s, {
      voids: o
    });
    if (a) {
      var [, l] = G.first(t, []), u = [a.path, l];
      if (ie.isPath(s) && s.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (ie.isPath(s)) {
          var [c] = G.parent(t, s);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = G.nodes(t, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, wH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = G.rangeRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = G.rangeRefs(t);
  return s.add(i), i;
}, CH = (e) => {
  var t = N1.get(e);
  return t || (t = /* @__PURE__ */ new Set(), N1.set(e, t)), t;
}, OH = (e, t, n) => {
  if (pe.isRange(t) && !n)
    return t;
  var r = G.start(e, t), o = G.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function aO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aO(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var EH = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, p) => {
      if (!Ze.isText(c))
        return !1;
      var [d, m] = G.parent(e, p);
      return !e.isVoid(d) || e.markableVoid(d);
    }, o = pe.isExpanded(n), i = !1;
    if (!o) {
      var [s, a] = G.node(e, n);
      if (s && r(s, a)) {
        var [l] = G.parent(e, a);
        i = l && e.markableVoid(l);
      }
    }
    if (o || i)
      Ce.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = xH({}, G.marks(e) || {});
      delete u[t], e.marks = u, ql.get(e) || e.onChange();
    }
  }
}, LH = (e, t) => {
  fI.set(e, t);
}, PH = (e, t) => G.point(e, t, {
  edge: "start"
}), kH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = G.range(t, n), [s, a] = pe.edges(i), l = "";
  for (var [u, c] of G.nodes(t, {
    at: i,
    match: Ze.isText,
    voids: o
  })) {
    var p = u.text;
    ie.equals(c, a.path) && (p = p.slice(0, a.offset)), ie.equals(c, s.path) && (p = p.slice(s.offset)), l += p;
  }
  return l;
}, SH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, s] = pe.edges(n);
  if (i.offset !== 0 || s.offset !== 0 || pe.isCollapsed(n) || ie.hasPrevious(s.path))
    return n;
  var a = G.above(t, {
    at: s,
    match: (f) => We.isElement(f) && G.isBlock(t, f),
    voids: o
  }), l = a ? a[1] : [], u = G.start(t, i), c = {
    anchor: u,
    focus: s
  }, p = !0;
  for (var [d, m] of G.nodes(t, {
    at: c,
    match: Ze.isText,
    reverse: !0,
    voids: o
  })) {
    if (p) {
      p = !1;
      continue;
    }
    if (d.text !== "" || ie.isBefore(m, l)) {
      s = {
        path: m,
        offset: d.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: s
  };
}, DH = (e, t) => {
  var n = G.isNormalizing(e);
  G.setNormalizing(e, !1);
  try {
    t();
  } finally {
    G.setNormalizing(e, n);
  }
  G.normalize(e);
}, MH = (e, t, n) => {
  var [r, o] = t;
  return We.isElement(r) && G.isEmpty(e, r) || Ze.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, TH = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  G.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: s = "character",
      distance: a = 1,
      voids: l = !1
    } = n, {
      at: u = t.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var p = !1;
      if (pe.isRange(u) && pe.isCollapsed(u) && (p = !0, u = u.anchor), Ot.isPoint(u)) {
        var d = G.void(t, {
          at: u,
          mode: "highest"
        });
        if (!l && d) {
          var [, m] = d;
          u = m;
        } else {
          var f = {
            unit: s,
            distance: a
          }, g = i ? G.before(t, u, f) || G.start(t, []) : G.after(t, u, f) || G.end(t, []);
          u = {
            anchor: u,
            focus: g
          }, c = !0;
        }
      }
      if (ie.isPath(u)) {
        Ce.removeNodes(t, {
          at: u,
          voids: l
        });
        return;
      }
      if (!pe.isCollapsed(u)) {
        if (!c) {
          var [, h] = pe.edges(u), x = G.end(t, []);
          Ot.equals(h, x) || (u = G.unhangRange(t, u, {
            voids: l
          }));
        }
        var [w, D] = pe.edges(u), O = G.above(t, {
          match: (ye) => We.isElement(ye) && G.isBlock(t, ye),
          at: w,
          voids: l
        }), y = G.above(t, {
          match: (ye) => We.isElement(ye) && G.isBlock(t, ye),
          at: D,
          voids: l
        }), C = O && y && !ie.equals(O[1], y[1]), S = ie.equals(w.path, D.path), U = l ? null : (r = G.void(t, {
          at: w,
          mode: "highest"
        })) !== null && r !== void 0 ? r : G.elementReadOnly(t, {
          at: w,
          mode: "highest"
        }), L = l ? null : (o = G.void(t, {
          at: D,
          mode: "highest"
        })) !== null && o !== void 0 ? o : G.elementReadOnly(t, {
          at: D,
          mode: "highest"
        });
        if (U) {
          var F = G.before(t, w);
          F && O && ie.isAncestor(O[1], F.path) && (w = F);
        }
        if (L) {
          var B = G.after(t, D);
          B && y && ie.isAncestor(y[1], B.path) && (D = B);
        }
        var $ = [], V;
        for (var z of G.nodes(t, {
          at: u,
          voids: l
        })) {
          var [q, X] = z;
          V && ie.compare(X, V) === 0 || (!l && We.isElement(q) && (G.isVoid(t, q) || G.isElementReadOnly(t, q)) || !ie.isCommon(X, w.path) && !ie.isCommon(X, D.path)) && ($.push(z), V = X);
        }
        var J = Array.from($, (ye) => {
          var [, oe] = ye;
          return G.pathRef(t, oe);
        }), te = G.pointRef(t, w), ee = G.pointRef(t, D), k = "";
        if (!S && !U) {
          var j = te.current, [H] = G.leaf(t, j), {
            path: M
          } = j, {
            offset: Z
          } = w, E = H.text.slice(Z);
          E.length > 0 && (t.apply({
            type: "remove_text",
            path: M,
            offset: Z,
            text: E
          }), k = E);
        }
        if (J.reverse().map((ye) => ye.unref()).filter((ye) => ye !== null).forEach((ye) => Ce.removeNodes(t, {
          at: ye,
          voids: l
        })), !L) {
          var T = ee.current, [R] = G.leaf(t, T), {
            path: _
          } = T, W = S ? w.offset : 0, A = R.text.slice(W, D.offset);
          A.length > 0 && (t.apply({
            type: "remove_text",
            path: _,
            offset: W,
            text: A
          }), k = A);
        }
        !S && C && ee.current && te.current && Ce.mergeNodes(t, {
          at: ee.current,
          hanging: !0,
          voids: l
        }), p && i && s === "character" && k.length > 1 && k.match(/[\u0E00-\u0E7F]+/) && Ce.insertText(t, k.slice(0, k.length - a));
        var Q = te.unref(), N = ee.unref(), ue = i ? Q || N : N || Q;
        n.at == null && ue && Ce.select(t, ue);
      }
    }
  });
}, jH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  G.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: s = P0(t),
      batchDirty: a = !0
    } = r;
    if (n.length) {
      if (pe.isRange(s))
        if (o || (s = G.unhangRange(t, s, {
          voids: i
        })), pe.isCollapsed(s))
          s = s.anchor;
        else {
          var [, l] = pe.edges(s);
          if (!i && G.void(t, {
            at: l
          }))
            return;
          var u = G.pointRef(t, l);
          Ce.delete(t, {
            at: s
          }), s = u.unref();
        }
      else ie.isPath(s) && (s = G.start(t, s));
      if (!(!i && G.void(t, {
        at: s
      }))) {
        var c = G.above(t, {
          at: s,
          match: (E) => We.isElement(E) && G.isInline(t, E),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, p] = c;
          if (G.isEnd(t, s, p)) {
            var d = G.after(t, p);
            s = d;
          } else if (G.isStart(t, s, p)) {
            var m = G.before(t, p);
            s = m;
          }
        }
        var f = G.above(t, {
          match: (E) => We.isElement(E) && G.isBlock(t, E),
          at: s,
          voids: i
        }), [, g] = f, h = G.isStart(t, s, g), x = G.isEnd(t, s, g), w = h && x, D = !h || h && x, O = !x, [, y] = je.first({
          children: n
        }, []), [, C] = je.last({
          children: n
        }, []), S = [], U = (E) => {
          var [T, R] = E, _ = R.length === 0;
          return _ ? !1 : w ? !0 : !(D && ie.isAncestor(R, y) && We.isElement(T) && !t.isVoid(T) && !t.isInline(T) || O && ie.isAncestor(R, C) && We.isElement(T) && !t.isVoid(T) && !t.isInline(T));
        };
        for (var L of je.nodes({
          children: n
        }, {
          pass: U
        }))
          U(L) && S.push(L);
        var F = [], B = [], $ = [], V = !0, z = !1;
        for (var [q] of S)
          We.isElement(q) && !t.isInline(q) ? (V = !1, z = !0, B.push(q)) : V ? F.push(q) : $.push(q);
        var [X] = G.nodes(t, {
          at: s,
          match: (E) => Ze.isText(E) || G.isInline(t, E),
          mode: "highest",
          voids: i
        }), [, J] = X, te = G.isStart(t, s, J), ee = G.isEnd(t, s, J), k = G.pathRef(t, x && !$.length ? ie.next(g) : g), j = G.pathRef(t, ee ? ie.next(J) : J);
        Ce.splitNodes(t, {
          at: s,
          match: (E) => z ? We.isElement(E) && G.isBlock(t, E) : Ze.isText(E) || G.isInline(t, E),
          mode: z ? "lowest" : "highest",
          always: z && (!h || F.length > 0) && (!x || $.length > 0),
          voids: i
        });
        var H = G.pathRef(t, !te || te && ee ? ie.next(J) : J);
        if (Ce.insertNodes(t, F, {
          at: H.current,
          match: (E) => Ze.isText(E) || G.isInline(t, E),
          mode: "highest",
          voids: i,
          batchDirty: a
        }), w && !F.length && B.length && !$.length && Ce.delete(t, {
          at: g,
          voids: i
        }), Ce.insertNodes(t, B, {
          at: k.current,
          match: (E) => We.isElement(E) && G.isBlock(t, E),
          mode: "lowest",
          voids: i,
          batchDirty: a
        }), Ce.insertNodes(t, $, {
          at: j.current,
          match: (E) => Ze.isText(E) || G.isInline(t, E),
          mode: "highest",
          voids: i,
          batchDirty: a
        }), !r.at) {
          var M;
          if ($.length > 0 && j.current ? M = ie.previous(j.current) : B.length > 0 && k.current ? M = ie.previous(k.current) : H.current && (M = ie.previous(H.current)), M) {
            var Z = G.end(t, M);
            Ce.select(t, Z);
          }
        }
        H.unref(), k.unref(), j.unref();
      }
    }
  });
}, _H = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      Ce.select(t, o.anchor);
    else if (r === "focus")
      Ce.select(t, o.focus);
    else if (r === "start") {
      var [i] = pe.edges(o);
      Ce.select(t, i);
    } else if (r === "end") {
      var [, s] = pe.edges(o);
      Ce.select(t, s);
    }
  } else return;
}, AH = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, BH = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: s = !1
  } = n, {
    edge: a = null
  } = n;
  if (r) {
    a === "start" && (a = pe.isBackward(r) ? "focus" : "anchor"), a === "end" && (a = pe.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, p = {};
    if (a == null || a === "anchor") {
      var d = s ? G.before(t, l, c) : G.after(t, l, c);
      d && (p.anchor = d);
    }
    if (a == null || a === "focus") {
      var m = s ? G.before(t, u, c) : G.after(t, u, c);
      m && (p.focus = m);
    }
    Ce.setSelection(t, p);
  }
}, IH = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = G.range(e, t), n) {
    Ce.setSelection(e, t);
    return;
  }
  if (!pe.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Sr.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function lO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lO(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var NH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = pe.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = pe.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: s,
      focus: a
    } = o, l = i === "anchor" ? s : a;
    Ce.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: uO(uO({}, l), n)
    });
  }
}, FH = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !Ot.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !Ot.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, RH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  G.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: s = "lowest",
      batchDirty: a = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (je.isNode(n) && (n = [n]), n.length !== 0) {
      var [p] = n;
      if (l || (l = P0(t), c !== !1 && (c = !0)), c == null && (c = !1), pe.isRange(l))
        if (o || (l = G.unhangRange(t, l, {
          voids: i
        })), pe.isCollapsed(l))
          l = l.anchor;
        else {
          var [, d] = pe.edges(l), m = G.pointRef(t, d);
          Ce.delete(t, {
            at: l
          }), l = m.unref();
        }
      if (Ot.isPoint(l)) {
        u == null && (Ze.isText(p) ? u = (F) => Ze.isText(F) : t.isInline(p) ? u = (F) => Ze.isText(F) || G.isInline(t, F) : u = (F) => We.isElement(F) && G.isBlock(t, F));
        var [f] = G.nodes(t, {
          at: l.path,
          match: u,
          mode: s,
          voids: i
        });
        if (f) {
          var [, g] = f, h = G.pathRef(t, g), x = G.isEnd(t, l, g);
          Ce.splitNodes(t, {
            at: l,
            match: u,
            mode: s,
            voids: i
          });
          var w = h.unref();
          l = x ? ie.next(w) : w;
        } else
          return;
      }
      var D = ie.parent(l), O = l[l.length - 1];
      if (!(!i && G.void(t, {
        at: D
      }))) {
        if (a) {
          var y = [], C = ie.levels(D);
          CV(t, () => {
            var F = function() {
              var V = D.concat(O);
              O++;
              var z = {
                type: "insert_node",
                path: V,
                node: B
              };
              t.apply(z), l = ie.next(l), y.push(z), Ze.isText ? C.push(...Array.from(je.nodes(B), (q) => {
                var [, X] = q;
                return V.concat(X);
              })) : C.push(V);
            };
            for (var B of n)
              F();
          }, () => {
            gI(t, C, (F) => {
              var B = F;
              for (var $ of y)
                if (ie.operationCanTransformPath($) && (B = ie.transform(B, $), !B))
                  return null;
              return B;
            });
          });
        } else
          for (var S of n) {
            var U = D.concat(O);
            O++, t.apply({
              type: "insert_node",
              path: U,
              node: S
            }), l = ie.next(l);
          }
        if (l = ie.previous(l), c) {
          var L = G.end(t, l);
          L && Ce.select(t, L);
        }
      }
    }
  });
}, zH = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  G.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: s
    } = n;
    if (s == null && (s = ie.isPath(r) ? Ya(t, r) : (O) => We.isElement(O) && G.isBlock(t, O)), !!r) {
      var a = G.nodes(t, {
        at: r,
        match: s,
        mode: o,
        voids: i
      }), l = Array.from(a, (O) => {
        var [, y] = O;
        return G.pathRef(t, y);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var p = G.node(t, ie.parent(c)), [d, m] = p, f = c[c.length - 1], {
          length: g
        } = d.children;
        if (g === 1) {
          var h = ie.next(m);
          Ce.moveNodes(t, {
            at: c,
            to: h,
            voids: i
          }), Ce.removeNodes(t, {
            at: m,
            voids: i
          });
        } else if (f === 0)
          Ce.moveNodes(t, {
            at: c,
            to: m,
            voids: i
          });
        else if (f === g - 1) {
          var x = ie.next(m);
          Ce.moveNodes(t, {
            at: c,
            to: x,
            voids: i
          });
        } else {
          var w = ie.next(c), D = ie.next(m);
          Ce.splitNodes(t, {
            at: w,
            voids: i
          }), Ce.moveNodes(t, {
            at: c,
            to: D,
            voids: i
          });
        }
      }
    }
  });
}, UH = ["text"], $H = ["children"], mI = (e, t) => {
  if (We.isElement(t)) {
    var n = t;
    return G.isVoid(e, t) ? !0 : n.children.length === 1 ? mI(e, n.children[0]) : !1;
  } else return !G.isEditor(t);
}, VH = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  G.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: s = !1,
      mode: a = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (ie.isPath(o)) {
          var [l] = G.parent(t, o);
          r = (F) => l.children.includes(F);
        } else
          r = (F) => We.isElement(F) && G.isBlock(t, F);
      if (!i && pe.isRange(o) && (o = G.unhangRange(t, o, {
        voids: s
      })), pe.isRange(o))
        if (pe.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = pe.edges(o), c = G.pointRef(t, u);
          Ce.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && Ce.select(t, o);
        }
      var [p] = G.nodes(t, {
        at: o,
        match: r,
        voids: s,
        mode: a
      }), d = G.previous(t, {
        at: o,
        match: r,
        voids: s,
        mode: a
      });
      if (!(!p || !d)) {
        var [m, f] = p, [g, h] = d;
        if (!(f.length === 0 || h.length === 0)) {
          var x = ie.next(h), w = ie.common(f, h), D = ie.isSibling(f, h), O = Array.from(G.levels(t, {
            at: f
          }), (F) => {
            var [B] = F;
            return B;
          }).slice(w.length).slice(0, -1), y = G.above(t, {
            at: f,
            mode: "highest",
            match: (F) => O.includes(F) && mI(t, F)
          }), C = y && G.pathRef(t, y[1]), S, U;
          if (Ze.isText(m) && Ze.isText(g)) {
            var L = Ti(m, UH);
            U = g.text.length, S = L;
          } else if (We.isElement(m) && We.isElement(g)) {
            var L = Ti(m, $H);
            U = g.children.length, S = L;
          } else
            throw new Error("Cannot merge the node at path [".concat(f, "] with the previous sibling because it is not the same kind: ").concat(Sr.stringify(m), " ").concat(Sr.stringify(g)));
          D || Ce.moveNodes(t, {
            at: f,
            to: x,
            voids: s
          }), C && Ce.removeNodes(t, {
            at: C.current,
            voids: s
          }), G.shouldMergeNodesRemovePrevNode(t, d, p) ? Ce.removeNodes(t, {
            at: h,
            voids: s
          }) : t.apply({
            type: "merge_node",
            path: x,
            position: U,
            properties: S
          }), C && C.unref();
        }
      }
    }
  });
}, HH = (e, t) => {
  G.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: s
    } = t;
    if (r) {
      s == null && (s = ie.isPath(r) ? Ya(e, r) : (m) => We.isElement(m) && G.isBlock(e, m));
      var a = G.pathRef(e, n), l = G.nodes(e, {
        at: r,
        match: s,
        mode: o,
        voids: i
      }), u = Array.from(l, (m) => {
        var [, f] = m;
        return G.pathRef(e, f);
      });
      for (var c of u) {
        var p = c.unref(), d = a.current;
        p.length !== 0 && e.apply({
          type: "move_node",
          path: p,
          newPath: d
        }), a.current && ie.isSibling(d, p) && ie.isAfter(d, p) && (a.current = ie.next(a.current));
      }
      a.unref();
    }
  });
}, WH = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  G.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: s = t.selection,
      match: a
    } = n;
    if (s) {
      a == null && (a = ie.isPath(s) ? Ya(t, s) : (m) => We.isElement(m) && G.isBlock(t, m)), !r && pe.isRange(s) && (s = G.unhangRange(t, s, {
        voids: o
      }));
      var l = G.nodes(t, {
        at: s,
        match: a,
        mode: i,
        voids: o
      }), u = Array.from(l, (m) => {
        var [, f] = m;
        return G.pathRef(t, f);
      });
      for (var c of u) {
        var p = c.unref();
        if (p) {
          var [d] = G.node(t, p);
          t.apply({
            type: "remove_node",
            path: p,
            node: d
          });
        }
      }
    }
  });
}, ZH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  G.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: s,
      merge: a
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: p = !1
    } = r;
    if (i) {
      if (o == null && (o = ie.isPath(i) ? Ya(t, i) : (U) => We.isElement(U) && G.isBlock(t, U)), !l && pe.isRange(i) && (i = G.unhangRange(t, i, {
        voids: p
      })), c && pe.isRange(i)) {
        if (pe.isCollapsed(i) && G.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var d = G.rangeRef(t, i, {
          affinity: "inward"
        }), [m, f] = pe.edges(i), g = u === "lowest" ? "lowest" : "highest", h = G.isEnd(t, f, f.path);
        Ce.splitNodes(t, {
          at: f,
          match: o,
          mode: g,
          voids: p,
          always: !h
        });
        var x = G.isStart(t, m, m.path);
        Ce.splitNodes(t, {
          at: m,
          match: o,
          mode: g,
          voids: p,
          always: !x
        }), i = d.unref(), r.at == null && Ce.select(t, i);
      }
      s || (s = (U, L) => U !== L);
      for (var [w, D] of G.nodes(t, {
        at: i,
        match: o,
        mode: u,
        voids: p
      })) {
        var O = {}, y = {};
        if (D.length !== 0) {
          var C = !1;
          for (var S in n)
            S === "children" || S === "text" || s(n[S], w[S]) && (C = !0, w.hasOwnProperty(S) && (O[S] = w[S]), a ? n[S] != null && (y[S] = a(w[S], n[S])) : n[S] != null && (y[S] = n[S]));
          C && t.apply({
            type: "set_node",
            path: D,
            properties: O,
            newProperties: y
          });
        }
      }
    }
  });
}, qH = (e, t) => {
  if (pe.isCollapsed(t))
    return t.anchor;
  var [, n] = pe.edges(t), r = G.pointRef(e, n);
  return Ce.delete(e, {
    at: t
  }), r.unref();
}, GH = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  G.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: s = t.selection,
      height: a = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (ee) => We.isElement(ee) && G.isBlock(t, ee)), pe.isRange(s) && (s = qH(t, s)), ie.isPath(s)) {
      var u = s, c = G.point(t, u), [p] = G.parent(t, u);
      i = (ee) => ee === p, a = c.path.length - u.length + 1, s = c, l = !0;
    }
    if (s) {
      var d = G.pointRef(t, s, {
        affinity: "backward"
      }), m;
      try {
        var [f] = G.nodes(t, {
          at: s,
          match: i,
          mode: r,
          voids: o
        });
        if (!f)
          return;
        var g = G.void(t, {
          at: s,
          mode: "highest"
        }), h = 0;
        if (!o && g) {
          var [x, w] = g;
          if (We.isElement(x) && t.isInline(x)) {
            var D = G.after(t, w);
            if (!D) {
              var O = {
                text: ""
              }, y = ie.next(w);
              Ce.insertNodes(t, O, {
                at: y,
                voids: o
              }), D = G.point(t, y);
            }
            s = D, l = !0;
          }
          var C = s.path.length - w.length;
          a = C + 1, l = !0;
        }
        m = G.pointRef(t, s);
        var S = s.path.length - a, [, U] = f, L = s.path.slice(0, S), F = a === 0 ? s.offset : s.path[S] + h;
        for (var [B, $] of G.levels(t, {
          at: L,
          reverse: !0,
          voids: o
        })) {
          var V = !1;
          if ($.length < U.length || $.length === 0 || !o && We.isElement(B) && G.isVoid(t, B))
            break;
          var z = d.current, q = G.isEnd(t, z, $);
          if (l || !d || !G.isEdge(t, z, $)) {
            V = !0;
            var X = je.extractProps(B);
            t.apply({
              type: "split_node",
              path: $,
              position: F,
              properties: X
            });
          }
          F = $[$.length - 1] + (V || q ? 1 : 0);
        }
        if (n.at == null) {
          var J = m.current || G.end(t, []);
          Ce.select(t, J);
        }
      } finally {
        var te;
        d.unref(), (te = m) === null || te === void 0 || te.unref();
      }
    }
  });
}, YH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  Ce.setNodes(t, o, r);
}, KH = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  G.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: s = t.selection,
      match: a
    } = n;
    if (s) {
      a == null && (a = ie.isPath(s) ? Ya(t, s) : (m) => We.isElement(m) && G.isBlock(t, m)), ie.isPath(s) && (s = G.range(t, s));
      var l = pe.isRange(s) ? G.rangeRef(t, s) : null, u = G.nodes(t, {
        at: s,
        match: a,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (m) => {
          var [, f] = m;
          return G.pathRef(t, f);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), p = function() {
        var f = d.unref(), [g] = G.node(t, f), h = G.range(t, f);
        o && l && (h = pe.intersection(l.current, h)), Ce.liftNodes(t, {
          at: h,
          match: (x) => We.isAncestor(g) && g.children.includes(x),
          voids: i
        });
      };
      for (var d of c)
        p();
      l && l.unref();
    }
  });
};
function cO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cO(Object(n), !0).forEach(function(r) {
      Ur(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var JH = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  G.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: s = !1
    } = r, {
      match: a,
      at: l = t.selection
    } = r;
    if (l) {
      if (a == null && (ie.isPath(l) ? a = Ya(t, l) : t.isInline(n) ? a = (h) => We.isElement(h) && G.isInline(t, h) || Ze.isText(h) : a = (h) => We.isElement(h) && G.isBlock(t, h)), i && pe.isRange(l)) {
        var [u, c] = pe.edges(l), p = G.rangeRef(t, l, {
          affinity: "inward"
        });
        Ce.splitNodes(t, {
          at: c,
          match: a,
          voids: s
        }), Ce.splitNodes(t, {
          at: u,
          match: a,
          voids: s
        }), l = p.unref(), r.at == null && Ce.select(t, l);
      }
      var d = Array.from(G.nodes(t, {
        at: l,
        match: t.isInline(n) ? (h) => We.isElement(h) && G.isBlock(t, h) : (h) => G.isEditor(h),
        mode: "lowest",
        voids: s
      })), m = function() {
        var x = pe.isRange(l) ? pe.intersection(l, G.range(t, g)) : l;
        if (!x)
          return 0;
        var w = Array.from(G.nodes(t, {
          at: x,
          match: a,
          mode: o,
          voids: s
        }));
        if (w.length > 0) {
          var [D] = w, O = w[w.length - 1], [, y] = D, [, C] = O;
          if (y.length === 0 && C.length === 0)
            return 0;
          var S = ie.equals(y, C) ? ie.parent(y) : ie.common(y, C), U = G.range(t, y, C), L = G.node(t, S), [F] = L, B = S.length + 1, $ = ie.next(C.slice(0, B)), V = pO(pO({}, n), {}, {
            children: []
          });
          Ce.insertNodes(t, V, {
            at: $,
            voids: s
          }), Ce.moveNodes(t, {
            at: U,
            match: (z) => We.isAncestor(F) && F.children.includes(z),
            to: $.concat(0),
            voids: s
          });
        }
      }, f;
      for (var [, g] of d)
        f = m();
    }
  });
}, XH = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return OV(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return SV(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return TV(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jV(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _V(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return EV(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return HV(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ZV(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jH(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return WV(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return GV(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return LV(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return EH(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xV(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return PV(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kV(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return DV(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return MV(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _H(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return TH(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return AH(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return AV(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return BV(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return IV(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return NV(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return FV(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sH(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zV(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return UV(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $V(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return VV(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return RH(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return YV(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return KV(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return JV(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return XV(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return QV(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eH(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return tH(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nH(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rH(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zH(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return VH(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return BH(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return HH(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return aH(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lH(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return uH(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cH(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pH(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hH(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dH(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fH(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vH(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gH(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mH(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yH(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bH(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return OH(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wH(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return CH(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return WH(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return IH(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ZH(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return LH(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return NH(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return FH(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return GH(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return PH(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kH(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return SH(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return YH(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return KH(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return RV(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return DH(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return JH(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return MH(e, ...r);
    }
  };
  return e;
};
const vI = (e) => {
  if (Ze.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if (We.isElement(e)) {
    const t = e.children.map((r) => vI(r)).join(""), n = e.align || "left";
    switch (e.type) {
      case "image":
        return `<img src="${e.src}" class="align_${n}" />`;
      case "paragraph":
        return `<p class="align_${n}">${t}</p>`;
      case "blockQuote":
        return `<blockquote class="align_${n}">${t}</blockquote>`;
      case "bulletedList":
        return `<ul class="align_${n}">${t}</ul>`;
      case "headingOne":
        return `<h1 class="align_${n}">${t}</h1>`;
      case "headingTwo":
        return `<h2 class="align_${n}">${t}</h2>`;
      case "listItem":
        return `<li class="align_${n}">${t}</li>`;
      case "numberedList":
        return `<ol class="align_${n}">${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, ZCe = (e) => e.map((t) => vI(t)).join("");
var yI = {}, D0 = {}, M0 = {};
Object.defineProperty(M0, "__esModule", { value: !0 });
M0.default = nW;
var dO = "html", fO = "head", _c = "body", QH = /<([a-zA-Z]+[0-9]?)/, hO = /<head[^]*>/i, gO = /<body[^]*>/i, Md = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, jy = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, mO = typeof window == "object" && window.DOMParser;
if (typeof mO == "function") {
  var eW = new mO(), tW = "text/html";
  jy = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), eW.parseFromString(e, tW);
  }, Md = jy;
}
if (typeof document == "object" && document.implementation) {
  var Ac = document.implementation.createHTMLDocument();
  Md = function(e, t) {
    if (t) {
      var n = Ac.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Ac;
    }
    return Ac.documentElement.innerHTML = e, Ac;
  };
}
var Bc = typeof document == "object" && document.createElement("template"), _y;
Bc && Bc.content && (_y = function(e) {
  return Bc.innerHTML = e, Bc.content.childNodes;
});
function nW(e) {
  var t, n, r = e.match(QH), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case dO: {
      var i = jy(e);
      if (!hO.test(e)) {
        var s = i.querySelector(fO);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!gO.test(e)) {
        var s = i.querySelector(_c);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(dO);
    }
    case fO:
    case _c: {
      var a = Md(e).querySelectorAll(o);
      return gO.test(e) && hO.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (_y)
        return _y(e);
      var s = Md(e, _c).querySelector(_c);
      return s.childNodes;
    }
  }
}
var sh = {}, T0 = {}, j0 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(j0);
var St = {}, ws = En && En.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Gl = En && En.__assign || function() {
  return Gl = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Gl.apply(this, arguments);
};
Object.defineProperty(St, "__esModule", { value: !0 });
St.cloneNode = St.hasChildren = St.isDocument = St.isDirective = St.isComment = St.isText = St.isCDATA = St.isTag = St.Element = St.Document = St.CDATA = St.NodeWithChildren = St.ProcessingInstruction = St.Comment = St.Text = St.DataNode = St.Node = void 0;
var oo = j0, _0 = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), A0(this, t);
    }, e;
  }()
);
St.Node = _0;
var ah = (
  /** @class */
  function(e) {
    ws(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(_0)
);
St.DataNode = ah;
var bI = (
  /** @class */
  function(e) {
    ws(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = oo.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ah)
);
St.Text = bI;
var wI = (
  /** @class */
  function(e) {
    ws(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = oo.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ah)
);
St.Comment = wI;
var CI = (
  /** @class */
  function(e) {
    ws(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = oo.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ah)
);
St.ProcessingInstruction = CI;
var lh = (
  /** @class */
  function(e) {
    ws(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(_0)
);
St.NodeWithChildren = lh;
var OI = (
  /** @class */
  function(e) {
    ws(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = oo.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(lh)
);
St.CDATA = OI;
var xI = (
  /** @class */
  function(e) {
    ws(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = oo.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(lh)
);
St.Document = xI;
var EI = (
  /** @class */
  function(e) {
    ws(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? oo.ElementType.Script : n === "style" ? oo.ElementType.Style : oo.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(lh)
);
St.Element = EI;
function LI(e) {
  return (0, oo.isTag)(e);
}
St.isTag = LI;
function PI(e) {
  return e.type === oo.ElementType.CDATA;
}
St.isCDATA = PI;
function kI(e) {
  return e.type === oo.ElementType.Text;
}
St.isText = kI;
function SI(e) {
  return e.type === oo.ElementType.Comment;
}
St.isComment = SI;
function DI(e) {
  return e.type === oo.ElementType.Directive;
}
St.isDirective = DI;
function MI(e) {
  return e.type === oo.ElementType.Root;
}
St.isDocument = MI;
function rW(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
St.hasChildren = rW;
function A0(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (kI(e))
    n = new bI(e.data);
  else if (SI(e))
    n = new wI(e.data);
  else if (LI(e)) {
    var r = t ? om(e.children) : [], o = new EI(e.name, Gl({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Gl({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Gl({}, e["x-attribsPrefix"])), n = o;
  } else if (PI(e)) {
    var r = t ? om(e.children) : [], i = new OI(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (MI(e)) {
    var r = t ? om(e.children) : [], s = new xI(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (DI(e)) {
    var a = new CI(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
St.cloneNode = A0;
function om(e) {
  for (var t = e.map(function(r) {
    return A0(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = En && En.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = En && En.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = j0, o = St;
  n(St, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(T0);
var TI = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(TI);
Object.defineProperty(sh, "__esModule", { value: !0 });
sh.formatAttributes = jI;
sh.formatDOM = _I;
var Ic = T0, oW = TI;
function iW(e) {
  return oW.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function jI(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function sW(e) {
  e = e.toLowerCase();
  var t = iW(e);
  return t || e;
}
function _I(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = sW(a.nodeName);
        o = new Ic.Element(l, jI(a.attributes)), o.children = _I(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Ic.Text(a.nodeValue);
        break;
      case 8:
        o = new Ic.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Ic.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var aW = En && En.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(D0, "__esModule", { value: !0 });
D0.default = pW;
var lW = aW(M0), uW = sh, cW = /<(![a-zA-Z\s]+)>/;
function pW(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(cW), n = t ? t[1] : void 0;
  return (0, uW.formatDOM)((0, lW.default)(e), null, n);
}
var uh = {}, Ro = {}, ch = {}, dW = 0;
ch.SAME = dW;
var fW = 1;
ch.CAMELCASE = fW;
ch.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const AI = 0, Cs = 1, ph = 2, dh = 3, B0 = 4, BI = 5, II = 6;
function hW(e) {
  return Dr.hasOwnProperty(e) ? Dr[e] : null;
}
function $r(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === ph || t === dh || t === B0, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const Dr = {}, gW = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
gW.forEach((e) => {
  Dr[e] = new $r(
    e,
    AI,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Dr[e] = new $r(
    e,
    Cs,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Dr[e] = new $r(
    e,
    ph,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Dr[e] = new $r(
    e,
    ph,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Dr[e] = new $r(
    e,
    dh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Dr[e] = new $r(
    e,
    dh,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Dr[e] = new $r(
    e,
    B0,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Dr[e] = new $r(
    e,
    II,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Dr[e] = new $r(
    e,
    BI,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const I0 = /[\-\:]([a-z])/g, N0 = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(I0, N0);
  Dr[t] = new $r(
    t,
    Cs,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(I0, N0);
  Dr[t] = new $r(
    t,
    Cs,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(I0, N0);
  Dr[t] = new $r(
    t,
    Cs,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Dr[e] = new $r(
    e,
    Cs,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const mW = "xlinkHref";
Dr[mW] = new $r(
  "xlinkHref",
  Cs,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Dr[e] = new $r(
    e,
    Cs,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: vW,
  SAME: yW,
  possibleStandardNames: vO
} = ch, bW = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", wW = bW + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", CW = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + wW + "]*$")
), OW = Object.keys(
  vO
).reduce((e, t) => {
  const n = vO[t];
  return n === yW ? e[t] = t : n === vW ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Ro.BOOLEAN = dh;
Ro.BOOLEANISH_STRING = ph;
Ro.NUMERIC = BI;
Ro.OVERLOADED_BOOLEAN = B0;
Ro.POSITIVE_NUMERIC = II;
Ro.RESERVED = AI;
Ro.STRING = Cs;
Ro.getPropertyInfo = hW;
Ro.isCustomAttribute = CW;
Ro.possibleStandardNames = OW;
var F0 = {}, R0 = {}, yO = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, xW = /\n/g, EW = /^\s*/, LW = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, PW = /^:\s*/, kW = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, SW = /^[;\s]*/, DW = /^\s+|\s+$/g, MW = `
`, bO = "/", wO = "*", Qs = "", TW = "comment", jW = "declaration", _W = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var g = f.match(xW);
    g && (n += g.length);
    var h = f.lastIndexOf(MW);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(g) {
      return g.position = new s(f), u(), g;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var g = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (g.reason = f, g.filename = t.source, g.line = n, g.column = r, g.source = e, !t.silent) throw g;
  }
  function l(f) {
    var g = f.exec(e);
    if (g) {
      var h = g[0];
      return o(h), e = e.slice(h.length), g;
    }
  }
  function u() {
    l(EW);
  }
  function c(f) {
    var g;
    for (f = f || []; g = p(); )
      g !== !1 && f.push(g);
    return f;
  }
  function p() {
    var f = i();
    if (!(bO != e.charAt(0) || wO != e.charAt(1))) {
      for (var g = 2; Qs != e.charAt(g) && (wO != e.charAt(g) || bO != e.charAt(g + 1)); )
        ++g;
      if (g += 2, Qs === e.charAt(g - 1))
        return a("End of comment missing");
      var h = e.slice(2, g - 2);
      return r += 2, o(h), e = e.slice(g), r += 2, f({
        type: TW,
        comment: h
      });
    }
  }
  function d() {
    var f = i(), g = l(LW);
    if (g) {
      if (p(), !l(PW)) return a("property missing ':'");
      var h = l(kW), x = f({
        type: jW,
        property: CO(g[0].replace(yO, Qs)),
        value: h ? CO(h[0].replace(yO, Qs)) : Qs
      });
      return l(SW), x;
    }
  }
  function m() {
    var f = [];
    c(f);
    for (var g; g = d(); )
      g !== !1 && (f.push(g), c(f));
    return f;
  }
  return u(), m();
};
function CO(e) {
  return e ? e.replace(DW, Qs) : Qs;
}
var AW = En && En.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(R0, "__esModule", { value: !0 });
R0.default = IW;
var BW = AW(_W);
function IW(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, BW.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var fh = {};
Object.defineProperty(fh, "__esModule", { value: !0 });
fh.camelCase = void 0;
var NW = /^--[a-zA-Z0-9_-]+$/, FW = /-([a-z])/g, RW = /^[^-]+$/, zW = /^-(webkit|moz|ms|o|khtml)-/, UW = /^-(ms)-/, $W = function(e) {
  return !e || RW.test(e) || NW.test(e);
}, VW = function(e, t) {
  return t.toUpperCase();
}, OO = function(e, t) {
  return "".concat(t, "-");
}, HW = function(e, t) {
  return t === void 0 && (t = {}), $W(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(UW, OO) : e = e.replace(zW, OO), e.replace(FW, VW));
};
fh.camelCase = HW;
var WW = En && En.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, ZW = WW(R0), qW = fh;
function Ay(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, ZW.default)(e, function(r, o) {
    r && o && (n[(0, qW.camelCase)(r, t)] = o);
  }), n;
}
Ay.default = Ay;
var GW = Ay;
(function(e) {
  var t = En && En.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Ee, r = t(GW), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(F0);
Object.defineProperty(uh, "__esModule", { value: !0 });
uh.default = XW;
var Fl = Ro, xO = F0, YW = ["checked", "value"], KW = ["input", "select", "textarea"], JW = {
  reset: !0,
  submit: !0
};
function XW(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && JW[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Fl.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = EO(s);
    if (a) {
      var l = (0, Fl.getPropertyInfo)(a);
      switch (YW.includes(a) && KW.includes(t) && !r && (a = EO("default" + s)), n[a] = i, l && l.type) {
        case Fl.BOOLEAN:
          n[a] = !0;
          break;
        case Fl.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    xO.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, xO.setStyleProp)(e.style, n), n;
}
function EO(e) {
  return Fl.possibleStandardNames[e];
}
var z0 = {}, QW = En && En.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(z0, "__esModule", { value: !0 });
z0.default = NI;
var im = Ee, e9 = QW(uh), Yl = F0, t9 = {
  cloneElement: im.cloneElement,
  createElement: im.createElement,
  isValidElement: im.isValidElement
};
function NI(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Yl.returnFirstArg, i = t.library || t9, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var m = !p.data.trim().length;
      if (m && p.parent && !(0, Yl.canTextBeChildOfNode)(p.parent) || t.trim && m)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, g = {};
    n9(f) ? ((0, Yl.setStyleProp)(f.attribs.style, f.attribs), g = f.attribs) : f.attribs && (g = (0, e9.default)(f.attribs, f.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (g.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? g.defaultValue = p.children[0].data : p.children && p.children.length && (h = NI(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), n.push(o(a(p.name, g, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function n9(e) {
  return Yl.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Yl.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = En && En.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(D0);
  e.htmlToDOM = n.default;
  var r = t(uh);
  e.attributesToProps = r.default;
  var o = t(z0);
  e.domToReact = o.default;
  var i = T0;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(yI);
const LO = /* @__PURE__ */ th(yI), r9 = LO.default || LO, By = (e) => {
  var r;
  if (typeof e == "string")
    return { text: e };
  const t = Array.isArray(e.props.children) ? e.props.children.map((o) => By(o)) : [{ text: e.props.children || "" }], n = (r = e.props.className) == null ? void 0 : r.replace("align_", "");
  switch (e.type) {
    case "img":
      return {
        type: "image",
        align: n,
        src: e.props.src,
        children: [{ text: "" }]
      };
    case "p":
      return { type: "paragraph", align: n, children: t };
    case "blockquote":
      return { type: "blockQuote", align: n, children: t };
    case "ul":
      return { type: "bulletedList", align: n, children: t };
    case "ol":
      return { type: "numberedList", align: n, children: t };
    case "li":
      return { type: "listItem", align: n, children: t };
    case "h1":
      return { type: "headingOne", align: n, children: t };
    case "h2":
      return { type: "headingTwo", align: n, children: t };
    case "strong":
      return { text: e.props.children, bold: !0 };
    case "code":
      return { text: e.props.children, code: !0 };
    case "em":
      return { text: e.props.children, italic: !0 };
    case "u":
      return { text: e.props.children, underline: !0 };
    default:
      return { text: e.props.children || "" };
  }
}, qCe = (e) => {
  const t = r9(e);
  return Array.isArray(t) ? t.map((n) => typeof n == "string" ? { text: n } : By(n)) : typeof t == "string" ? [{ text: t }] : [By(t)];
}, GCe = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function FI(e, t, n) {
  if (!e) return /* @__PURE__ */ K.jsx(K.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ K.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ K.jsx("p", { className: n, children: /* @__PURE__ */ K.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function YCe(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: s = "",
    children: a,
    ...l
  } = e, c = { md: 12, lg: 14 }[r], p = `arkynBadge ${t} ${n} ${r} ${s}`;
  return /* @__PURE__ */ K.jsxs("div", { className: p.trim(), ...l, children: [
    Ed(c, o),
    a,
    Ed(c, o)
  ] });
}
function KCe(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ K.jsx("div", { className: r.trim(), ...n });
}
function JCe(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ K.jsx("div", { className: o.trim(), ...r });
}
function XCe(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ K.jsx("aside", { className: r.trim(), ...n });
}
function QCe(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, s = it.count(r) === 0;
  return /* @__PURE__ */ K.jsx("tbody", { className: i.trim(), ...o, children: s ? /* @__PURE__ */ K.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ K.jsx("td", { colSpan: 100, children: /* @__PURE__ */ K.jsx("div", { children: t }) }) }) : r });
}
function e1e(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ K.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ K.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function t1e(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ K.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ K.jsx("table", { children: t }) });
}
function n1e(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ K.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ K.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ K.jsx("tr", { children: /* @__PURE__ */ K.jsx("th", { colSpan: 100, children: /* @__PURE__ */ K.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function r1e(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ K.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ K.jsx("tr", { children: n }),
    /* @__PURE__ */ K.jsx("tr", { className: "spacingRow" })
  ] });
}
var Ln = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function o9(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Iy = { exports: {} }, fl = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var PO;
function i9() {
  if (PO) return fl;
  PO = 1;
  var e = Ee, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, m = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: m, props: p, _owner: o.current };
  }
  return fl.Fragment = n, fl.jsx = s, fl.jsxs = s, fl;
}
var Nc = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var kO;
function s9() {
  return kO || (kO = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ee, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), f = Symbol.iterator, g = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[g];
      return typeof I == "function" ? I : null;
    }
    var x = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, Y = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          Y[ne - 1] = arguments[ne];
        D("error", b, Y);
      }
    }
    function D(b, I, Y) {
      {
        var ne = x.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (I += "%s", Y = Y.concat([le]));
        var ce = Y.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var O = !1, y = !1, C = !1, S = !1, U = !1, L;
    L = Symbol.for("react.module.reference");
    function F(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || U || b === o || b === u || b === c || S || b === m || O || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function B(b, I, Y) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = I.displayName || I.name || "";
      return le !== "" ? Y + "(" + le + ")" : Y;
    }
    function $(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var I = b;
            return $(I) + ".Consumer";
          case s:
            var Y = b;
            return $(Y._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, ae = le._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, q = 0, X, J, te, ee, k, j, H;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function Z() {
      {
        if (q === 0) {
          X = console.log, J = console.info, te = console.warn, ee = console.error, k = console.group, j = console.groupCollapsed, H = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function E() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: X
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: k
            }),
            groupCollapsed: z({}, b, {
              value: j
            }),
            groupEnd: z({}, b, {
              value: H
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = x.ReactCurrentDispatcher, R;
    function _(b, I, Y) {
      {
        if (R === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            R = ne && ne[1] || "";
          }
        return `
` + R + b;
      }
    }
    var W = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function N(b, I) {
      if (!b || W)
        return "";
      {
        var Y = A.get(b);
        if (Y !== void 0)
          return Y;
      }
      var ne;
      W = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = T.current, T.current = null, Z();
      try {
        if (I) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Re) {
              ne = Re;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Re) {
              ne = Re;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Re) {
            ne = Re;
          }
          b();
        }
      } catch (Re) {
        if (Re && ne && typeof Re.stack == "string") {
          for (var se = Re.stack.split(`
`), Be = ne.stack.split(`
`), we = se.length - 1, Oe = Be.length - 1; we >= 1 && Oe >= 0 && se[we] !== Be[Oe]; )
            Oe--;
          for (; we >= 1 && Oe >= 0; we--, Oe--)
            if (se[we] !== Be[Oe]) {
              if (we !== 1 || Oe !== 1)
                do
                  if (we--, Oe--, Oe < 0 || se[we] !== Be[Oe]) {
                    var qe = `
` + se[we].replace(" at new ", " at ");
                    return b.displayName && qe.includes("<anonymous>") && (qe = qe.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, qe), qe;
                  }
                while (we >= 1 && Oe >= 0);
              break;
            }
        }
      } finally {
        W = !1, T.current = ce, E(), Error.prepareStackTrace = le;
      }
      var Xt = b ? b.displayName || b.name : "", Ct = Xt ? _(Xt) : "";
      return typeof b == "function" && A.set(b, Ct), Ct;
    }
    function ue(b, I, Y) {
      return N(b, !1);
    }
    function ye(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, Y) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, ye(b));
      if (typeof b == "string")
        return _(b);
      switch (b) {
        case u:
          return _("Suspense");
        case c:
          return _("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, Y);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), I, Y);
            } catch {
            }
          }
        }
      return "";
    }
    var Ie = Object.prototype.hasOwnProperty, $e = {}, Ve = x.ReactDebugCurrentFrame;
    function Ne(b) {
      if (b) {
        var I = b._owner, Y = oe(b.type, b._source, I ? I.type : null);
        Ve.setExtraStackFrame(Y);
      } else
        Ve.setExtraStackFrame(null);
    }
    function Je(b, I, Y, ne, le) {
      {
        var ce = Function.call.bind(Ie);
        for (var ae in b)
          if (ce(b, ae)) {
            var se = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Be = Error((ne || "React class") + ": " + Y + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Be.name = "Invariant Violation", Be;
              }
              se = b[ae](I, ae, ne, Y, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (we) {
              se = we;
            }
            se && !(se instanceof Error) && (Ne(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", Y, ae, typeof se), Ne(null)), se instanceof Error && !(se.message in $e) && ($e[se.message] = !0, Ne(le), w("Failed %s type: %s", Y, se.message), Ne(null));
          }
      }
    }
    var Ye = Array.isArray;
    function Te(b) {
      return Ye(b);
    }
    function Ke(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, Y = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return Y;
      }
    }
    function nt(b) {
      try {
        return Me(b), !1;
      } catch {
        return !0;
      }
    }
    function Me(b) {
      return "" + b;
    }
    function Ae(b) {
      if (nt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(b)), Me(b);
    }
    var Fe = x.ReactCurrentOwner, He = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ze, et, _e;
    _e = {};
    function At(b) {
      if (Ie.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function rt(b) {
      if (Ie.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, I) {
      if (typeof b.ref == "string" && Fe.current && I && Fe.current.stateNode !== I) {
        var Y = V(Fe.current.type);
        _e[Y] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Fe.current.type), b.ref), _e[Y] = !0);
      }
    }
    function at(b, I) {
      {
        var Y = function() {
          ze || (ze = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: Y,
          configurable: !0
        });
      }
    }
    function qt(b, I) {
      {
        var Y = function() {
          et || (et = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: Y,
          configurable: !0
        });
      }
    }
    var lt = function(b, I, Y, ne, le, ce, ae) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: Y,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function Gt(b, I, Y, ne, le) {
      {
        var ce, ae = {}, se = null, Be = null;
        Y !== void 0 && (Ae(Y), se = "" + Y), rt(I) && (Ae(I.key), se = "" + I.key), At(I) && (Be = I.ref, ot(I, le));
        for (ce in I)
          Ie.call(I, ce) && !He.hasOwnProperty(ce) && (ae[ce] = I[ce]);
        if (b && b.defaultProps) {
          var we = b.defaultProps;
          for (ce in we)
            ae[ce] === void 0 && (ae[ce] = we[ce]);
        }
        if (se || Be) {
          var Oe = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && at(ae, Oe), Be && qt(ae, Oe);
        }
        return lt(b, se, Be, le, ne, Fe.current, ae);
      }
    }
    var Xe = x.ReactCurrentOwner, bt = x.ReactDebugCurrentFrame;
    function tt(b) {
      if (b) {
        var I = b._owner, Y = oe(b.type, b._source, I ? I.type : null);
        bt.setExtraStackFrame(Y);
      } else
        bt.setExtraStackFrame(null);
    }
    var Yt;
    Yt = !1;
    function ut(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function dn() {
      {
        if (Xe.current) {
          var b = V(Xe.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function Kt(b) {
      return "";
    }
    var fn = {};
    function Jt(b) {
      {
        var I = dn();
        if (!I) {
          var Y = typeof b == "string" ? b : b.displayName || b.name;
          Y && (I = `

Check the top-level render call using <` + Y + ">.");
        }
        return I;
      }
    }
    function hn(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var Y = Jt(I);
        if (fn[Y])
          return;
        fn[Y] = !0;
        var ne = "";
        b && b._owner && b._owner !== Xe.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), tt(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Y, ne), tt(null);
      }
    }
    function Fn(b, I) {
      {
        if (typeof b != "object")
          return;
        if (Te(b))
          for (var Y = 0; Y < b.length; Y++) {
            var ne = b[Y];
            ut(ne) && hn(ne, I);
          }
        else if (ut(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = h(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), ae; !(ae = ce.next()).done; )
              ut(ae.value) && hn(ae.value, I);
        }
      }
    }
    function wt(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var Y;
        if (typeof I == "function")
          Y = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          Y = I.propTypes;
        else
          return;
        if (Y) {
          var ne = V(I);
          Je(Y, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !Yt) {
          Yt = !0;
          var le = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function re(b) {
      {
        for (var I = Object.keys(b.props), Y = 0; Y < I.length; Y++) {
          var ne = I[Y];
          if (ne !== "children" && ne !== "key") {
            tt(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), tt(null);
            break;
          }
        }
        b.ref !== null && (tt(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var qr = {};
    function Gr(b, I, Y, ne, le, ce) {
      {
        var ae = F(b);
        if (!ae) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Be = Kt();
          Be ? se += Be : se += dn();
          var we;
          b === null ? we = "null" : Te(b) ? we = "array" : b !== void 0 && b.$$typeof === t ? (we = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : we = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", we, se);
        }
        var Oe = Gt(b, I, Y, le, ce);
        if (Oe == null)
          return Oe;
        if (ae) {
          var qe = I.children;
          if (qe !== void 0)
            if (ne)
              if (Te(qe)) {
                for (var Xt = 0; Xt < qe.length; Xt++)
                  Fn(qe[Xt], b);
                Object.freeze && Object.freeze(qe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Fn(qe, b);
        }
        if (Ie.call(I, "key")) {
          var Ct = V(b), Re = Object.keys(I).filter(function(gi) {
            return gi !== "key";
          }), Or = Re.length > 0 ? "{key: someKey, " + Re.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!qr[Ct + Or]) {
            var hi = Re.length > 0 ? "{" + Re.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Or, Ct, hi, Ct), qr[Ct + Or] = !0;
          }
        }
        return b === r ? re(Oe) : wt(Oe), Oe;
      }
    }
    function ci(b, I, Y) {
      return Gr(b, I, Y, !0);
    }
    function pi(b, I, Y) {
      return Gr(b, I, Y, !1);
    }
    var di = pi, fi = ci;
    Nc.Fragment = r, Nc.jsx = di, Nc.jsxs = fi;
  }()), Nc;
}
process.env.NODE_ENV === "production" ? Iy.exports = i9() : Iy.exports = s9();
var bn = Iy.exports;
Ge({});
function SO(e, t) {
  return t ? /* @__PURE__ */ bn.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ bn.jsx(bn.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function DO(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Br(e) {
  var t, n;
  return DO(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(DO(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var RI = Symbol.for("immer-nothing"), MO = Symbol.for("immer-draftable"), xo = Symbol.for("immer-state"), a9 = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Jr(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = a9[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var $a = Object.getPrototypeOf;
function va(e) {
  return !!e && !!e[xo];
}
function ya(e) {
  var t;
  return e ? zI(e) || Array.isArray(e) || !!e[MO] || !!((t = e.constructor) != null && t[MO]) || gh(e) || mh(e) : !1;
}
var l9 = Object.prototype.constructor.toString();
function zI(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = $a(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === l9;
}
function Td(e, t) {
  hh(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function hh(e) {
  const t = e[xo];
  return t ? t.type_ : Array.isArray(e) ? 1 : gh(e) ? 2 : mh(e) ? 3 : 0;
}
function Ny(e, t) {
  return hh(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function UI(e, t, n) {
  const r = hh(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function u9(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function gh(e) {
  return e instanceof Map;
}
function mh(e) {
  return e instanceof Set;
}
function Gs(e) {
  return e.copy_ || e.base_;
}
function Fy(e, t) {
  if (gh(e))
    return new Map(e);
  if (mh(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = zI(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[xo];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create($a(e), r);
  } else {
    const r = $a(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function U0(e, t = !1) {
  return vh(e) || va(e) || !ya(e) || (hh(e) > 1 && (e.set = e.add = e.clear = e.delete = c9), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => U0(r, !0))), e;
}
function c9() {
  Jr(2);
}
function vh(e) {
  return Object.isFrozen(e);
}
var p9 = {};
function ba(e) {
  const t = p9[e];
  return t || Jr(0, e), t;
}
var wu;
function $I() {
  return wu;
}
function d9(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function TO(e, t) {
  t && (ba("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Ry(e) {
  zy(e), e.drafts_.forEach(f9), e.drafts_ = null;
}
function zy(e) {
  e === wu && (wu = e.parent_);
}
function jO(e) {
  return wu = d9(wu, e);
}
function f9(e) {
  const t = e[xo];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function _O(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[xo].modified_ && (Ry(t), Jr(4)), ya(e) && (e = jd(t, e), t.parent_ || _d(t, e)), t.patches_ && ba("Patches").generateReplacementPatches_(
    n[xo].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = jd(t, n, []), Ry(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== RI ? e : void 0;
}
function jd(e, t, n) {
  if (vh(t))
    return t;
  const r = t[xo];
  if (!r)
    return Td(
      t,
      (o, i) => AO(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return _d(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Td(
      i,
      (a, l) => AO(e, r, o, a, l, n, s)
    ), _d(e, o, !1), n && e.patches_ && ba("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function AO(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && Jr(5), va(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Ny(t.assigned_, r) ? i.concat(r) : void 0, l = jd(e, o, a);
    if (UI(n, r, l), va(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (ya(o) && !vh(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    jd(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && _d(e, o);
  }
}
function _d(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && U0(t, n);
}
function h9(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : $I(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = $0;
  n && (o = [r], i = Cu);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var $0 = {
  get(e, t) {
    if (t === xo)
      return e;
    const n = Gs(e);
    if (!Ny(n, t))
      return g9(e, n, t);
    const r = n[t];
    return e.finalized_ || !ya(r) ? r : r === sm(e.base_, t) ? (am(e), e.copy_[t] = $y(r, e)) : r;
  },
  has(e, t) {
    return t in Gs(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Gs(e));
  },
  set(e, t, n) {
    const r = VI(Gs(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = sm(Gs(e), t), i = o == null ? void 0 : o[xo];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (u9(n, o) && (n !== void 0 || Ny(e.base_, t)))
        return !0;
      am(e), Uy(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return sm(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, am(e), Uy(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Gs(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Jr(11);
  },
  getPrototypeOf(e) {
    return $a(e.base_);
  },
  setPrototypeOf() {
    Jr(12);
  }
}, Cu = {};
Td($0, (e, t) => {
  Cu[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Cu.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Jr(13), Cu.set.call(this, e, t, void 0);
};
Cu.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Jr(14), $0.set.call(this, e[0], t, n, e[0]);
};
function sm(e, t) {
  const n = e[xo];
  return (n ? Gs(n) : e)[t];
}
function g9(e, t, n) {
  var r;
  const o = VI(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function VI(e, t) {
  if (!(t in e))
    return;
  let n = $a(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = $a(n);
  }
}
function Uy(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Uy(e.parent_));
}
function am(e) {
  e.copy_ || (e.copy_ = Fy(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var m9 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Jr(6), r !== void 0 && typeof r != "function" && Jr(7);
      let o;
      if (ya(t)) {
        const i = jO(this), s = $y(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? Ry(i) : zy(i);
        }
        return TO(i, r), _O(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === RI && (o = void 0), this.autoFreeze_ && U0(o, !0), r) {
          const i = [], s = [];
          ba("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        Jr(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ya(e) || Jr(8), va(e) && (e = v9(e));
    const t = jO(this), n = $y(e, void 0);
    return n[xo].isManual_ = !0, zy(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[xo];
    (!n || !n.isManual_) && Jr(9);
    const { scope_: r } = n;
    return TO(r, t), _O(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = ba("Patches").applyPatches_;
    return va(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function $y(e, t) {
  const n = gh(e) ? ba("MapSet").proxyMap_(e, t) : mh(e) ? ba("MapSet").proxySet_(e, t) : h9(e, t);
  return (t ? t.scope_ : $I()).drafts_.push(n), n;
}
function v9(e) {
  return va(e) || Jr(10, e), HI(e);
}
function HI(e) {
  if (!ya(e) || vh(e))
    return e;
  const t = e[xo];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Fy(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Fy(e, !0);
  return Td(n, (r, o) => {
    UI(n, r, HI(o));
  }), t && (t.finalized_ = !1), n;
}
var Eo = new m9(), V0 = Eo.produce;
Eo.produceWithPatches.bind(
  Eo
);
Eo.setAutoFreeze.bind(Eo);
Eo.setUseStrictShallowCopy.bind(Eo);
Eo.applyPatches.bind(Eo);
var BO = Eo.createDraft.bind(Eo), IO = Eo.finishDraft.bind(Eo), Pe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Pe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Pe.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Pe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Pe.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Pe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Pe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Pe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Pe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Pe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Pe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Pe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Pe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Pe.isAncestor(t, e) && !Pe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Pe.equals(i, r) || Pe.endsBefore(i, r) || Pe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (Pe.equals(s, r) || Pe.isAncestor(s, r))
          return null;
        Pe.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        Pe.equals(a, r) || Pe.endsBefore(a, r) ? r[a.length - 1] -= 1 : Pe.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Pe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Pe.endsBefore(u, r) ? r[u.length - 1] += 1 : Pe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Pe.equals(p, d))
          return r;
        if (Pe.isAncestor(p, r) || Pe.equals(p, r)) {
          var m = d.slice();
          return Pe.endsBefore(p, d) && p.length < d.length && (m[p.length - 1] -= 1), m.concat(r.slice(p.length));
        } else Pe.isSibling(p, d) && (Pe.isAncestor(d, r) || Pe.equals(d, r)) ? Pe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Pe.endsBefore(d, r) || Pe.equals(d, r) || Pe.isAncestor(d, r) ? (Pe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Pe.endsBefore(p, r) && (Pe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Ou(e) {
  "@babel/helpers - typeof";
  return Ou = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ou(e);
}
function y9(e, t) {
  if (Ou(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ou(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function b9(e) {
  var t = y9(e, "string");
  return Ou(t) === "symbol" ? t : String(t);
}
function Ka(e, t, n) {
  return t = b9(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function NO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NO(Object(n), !0).forEach(function(r) {
      Ka(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var w9 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = ct.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of xt.points(t))
          t[l] = _n.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = ct.leaf(e, u), m = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = m + p + f, t)
        for (var [g, h] of xt.points(t))
          t[h] = _n.transform(g, n);
      break;
    }
    case "merge_node": {
      var {
        path: x
      } = n, w = ct.get(e, x), D = Pe.previous(x), O = ct.get(e, D), y = ct.parent(e, x), C = x[x.length - 1];
      if (pr.isText(w) && pr.isText(O))
        O.text += w.text;
      else if (!pr.isText(w) && !pr.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(x, "] to nodes of different interfaces: ").concat(co.stringify(w), " ").concat(co.stringify(O)));
      if (y.children.splice(C, 1), t)
        for (var [S, U] of xt.points(t))
          t[U] = _n.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: F
      } = n;
      if (Pe.isAncestor(L, F))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(F, "] because the destination is inside itself."));
      var B = ct.get(e, L), $ = ct.parent(e, L), V = L[L.length - 1];
      $.children.splice(V, 1);
      var z = Pe.transform(L, n), q = ct.get(e, Pe.parent(z)), X = z[z.length - 1];
      if (q.children.splice(X, 0, B), t)
        for (var [J, te] of xt.points(t))
          t[te] = _n.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, k = ee[ee.length - 1], j = ct.parent(e, ee);
      if (j.children.splice(k, 1), t)
        for (var [H, M] of xt.points(t)) {
          var Z = _n.transform(H, n);
          if (t != null && Z != null)
            t[M] = Z;
          else {
            var E = void 0, T = void 0;
            for (var [R, _] of ct.texts(e))
              if (Pe.compare(_, ee) === -1)
                E = [R, _];
              else {
                T = [R, _];
                break;
              }
            var W = !1;
            E && T && (Pe.equals(T[1], ee) ? W = !Pe.hasPrevious(T[1]) : W = Pe.common(E[1], ee).length < Pe.common(T[1], ee).length), E && !W ? (H.path = E[1], H.offset = E[0].text.length) : T ? (H.path = T[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: N
      } = n;
      if (N.length === 0) break;
      var ue = ct.leaf(e, A), ye = ue.text.slice(0, Q), oe = ue.text.slice(Q + N.length);
      if (ue.text = ye + oe, t)
        for (var [Ie, $e] of xt.points(t))
          t[$e] = _n.transform(Ie, n);
      break;
    }
    case "set_node": {
      var {
        path: Ve,
        properties: Ne,
        newProperties: Je
      } = n;
      if (Ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ye = ct.get(e, Ve);
      for (var Te in Je) {
        if (Te === "children" || Te === "text")
          throw new Error('Cannot set the "'.concat(Te, '" property of nodes!'));
        var Ke = Je[Te];
        Ke == null ? delete Ye[Te] : Ye[Te] = Ke;
      }
      for (var nt in Ne)
        Je.hasOwnProperty(nt) || delete Ye[nt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Me
      } = n;
      if (Me == null)
        t = Me;
      else {
        if (t == null) {
          if (!xt.isRange(Me))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(co.stringify(Me), " when there is no current selection."));
          t = hl({}, Me);
        }
        for (var Ae in Me) {
          var Fe = Me[Ae];
          if (Fe == null) {
            if (Ae === "anchor" || Ae === "focus")
              throw new Error('Cannot remove the "'.concat(Ae, '" selection property'));
            delete t[Ae];
          } else
            t[Ae] = Fe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: He,
        position: ze,
        properties: et
      } = n;
      if (He.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(He, "] because the root node cannot be split."));
      var _e = ct.get(e, He), At = ct.parent(e, He), rt = He[He.length - 1], ot;
      if (pr.isText(_e)) {
        var at = _e.text.slice(0, ze), qt = _e.text.slice(ze);
        _e.text = at, ot = hl(hl({}, et), {}, {
          text: qt
        });
      } else {
        var lt = _e.children.slice(0, ze), Gt = _e.children.slice(ze);
        _e.children = lt, ot = hl(hl({}, et), {}, {
          children: Gt
        });
      }
      if (At.children.splice(rt + 1, 0, ot), t)
        for (var [Xe, bt] of xt.points(t))
          t[bt] = _n.transform(Xe, n);
      break;
    }
  }
  return t;
}, C9 = {
  transform(e, t) {
    e.children = BO(e.children);
    var n = e.selection && BO(e.selection);
    try {
      n = w9(e, n, t);
    } finally {
      e.children = IO(e.children), n ? e.selection = va(n) ? IO(n) : n : e.selection = null;
    }
  }
}, O9 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, x9 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, WI = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Br(r) && Br(o)) {
      if (!WI(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function E9(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function xu(e, t) {
  if (e == null) return {};
  var n = E9(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var L9 = ["anchor", "focus"];
function FO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function P9(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FO(Object(n), !0).forEach(function(r) {
      Ka(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return xt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = xt.edges(e);
    return t;
  },
  equals(e, t) {
    return _n.equals(e.anchor, t.anchor) && _n.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (xt.isRange(t)) {
      if (xt.includes(e, t.anchor) || xt.includes(e, t.focus))
        return !0;
      var [n, r] = xt.edges(e), [o, i] = xt.edges(t);
      return _n.isBefore(n, o) && _n.isAfter(r, i);
    }
    var [s, a] = xt.edges(e), l = !1, u = !1;
    return _n.isPoint(t) ? (l = _n.compare(t, s) >= 0, u = _n.compare(t, a) <= 0) : (l = Pe.compare(t, s.path) >= 0, u = Pe.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = xu(e, L9), [r, o] = xt.edges(e), [i, s] = xt.edges(t), a = _n.isBefore(r, i) ? i : r, l = _n.isBefore(o, s) ? o : s;
    return _n.isBefore(l, a) ? null : P9({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return _n.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return _n.equals(t, n);
  },
  isExpanded(e) {
    return !xt.isCollapsed(e);
  },
  isForward(e) {
    return !xt.isBackward(e);
  },
  isRange(e) {
    return Br(e) && _n.isPoint(e.anchor) && _n.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = xt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return V0(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = xt.isCollapsed(r);
        xt.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? xt.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = _n.transform(r.anchor, t, {
        affinity: i
      }), u = _n.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, RO = (e) => Br(e) && ct.isNodeList(e.children) && !wn.isEditor(e), Pi = {
  isAncestor(e) {
    return Br(e) && ct.isNodeList(e.children);
  },
  isElement: RO,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Pi.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return RO(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, k9 = ["children"], S9 = ["text"], zO = /* @__PURE__ */ new WeakMap(), ct = {
  ancestor(e, t) {
    var n = ct.get(e, t);
    if (pr.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(co.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Pe.ancestors(t, n)) {
        var o = ct.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (pr.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(co.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(co.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = ct.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = ct.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Pe.common(t, n), o = ct.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = ct.get(e, t);
    if (wn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(co.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ct.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ct.nodes(e, t))
        Pi.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Pi.isAncestor(e)) {
      var t = xu(e, k9);
      return t;
    } else {
      var t = xu(e, S9);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = ct.get(e, n); r && !(pr.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (pr.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(co.stringify(e)));
    var n = V0({
      children: e.children
    }, (r) => {
      var [o, i] = xt.edges(t), s = ct.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, m] = d;
          return !xt.includes(t, m);
        }
      });
      for (var [, a] of s) {
        if (!xt.includes(t, a)) {
          var l = ct.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (Pe.equals(a, i.path)) {
          var c = ct.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (Pe.equals(a, o.path)) {
          var p = ct.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      wn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (pr.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(co.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (pr.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return pr.isText(e) || Pi.isElement(e) || wn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = zO.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => ct.isNode(r));
    return zO.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = ct.get(e, n); r && !(pr.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = ct.get(e, t);
    if (!pr.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(co.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Pe.levels(t, n)) {
        var o = ct.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Pi.isElement(e) && Pi.isElementProps(t) && Pi.matches(e, t) || pr.isText(e) && pr.isTextProps(t) && pr.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? Pe.isBefore(a, i) : Pe.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !pr.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          Pe.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = ct.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = Pe.next(a);
          if (ct.has(e, c)) {
            a = c, l = ct.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = Pe.previous(a);
          a = p, l = ct.get(e, a);
          continue;
        }
        a = Pe.parent(a), l = ct.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Pe.parent(t), r = ct.get(e, n);
    if (pr.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return pr.isText(e) ? e.text : e.children.map(ct.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ct.nodes(e, t))
        pr.isText(n) && (yield [n, r]);
    }();
  }
};
function UO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UO(Object(n), !0).forEach(function(r) {
      Ka(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Rl = {
  isNodeOperation(e) {
    return Rl.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Br(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Pe.isPath(e.path) && ct.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Pe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Pe.isPath(e.path) && Br(e.properties);
      case "move_node":
        return Pe.isPath(e.path) && Pe.isPath(e.newPath);
      case "remove_node":
        return Pe.isPath(e.path) && ct.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Pe.isPath(e.path);
      case "set_node":
        return Pe.isPath(e.path) && Br(e.properties) && Br(e.newProperties);
      case "set_selection":
        return e.properties === null && xt.isRange(e.newProperties) || e.newProperties === null && xt.isRange(e.properties) || Br(e.properties) && Br(e.newProperties);
      case "split_node":
        return Pe.isPath(e.path) && typeof e.position == "number" && Br(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Rl.isOperation(t));
  },
  isSelectionOperation(e) {
    return Rl.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Rl.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return zn(zn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return zn(zn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return zn(zn({}, e), {}, {
          type: "split_node",
          path: Pe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Pe.equals(t, n))
          return e;
        if (Pe.isSibling(n, t))
          return zn(zn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Pe.transform(n, e), o = Pe.transform(Pe.next(n), e);
        return zn(zn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return zn(zn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return zn(zn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return zn(zn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? zn(zn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? zn(zn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : zn(zn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return zn(zn({}, e), {}, {
          type: "merge_node",
          path: Pe.next(e.path)
        });
    }
  }
}, $O = /* @__PURE__ */ new WeakMap(), D9 = (e) => {
  var t = $O.get(e);
  if (t !== void 0)
    return t;
  if (!Br(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Br(e.marks)) && (e.selection === null || xt.isRange(e.selection)) && ct.isNodeList(e.children) && Rl.isOperationList(e.operations);
  return $O.set(e, n), n;
}, wn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return D9(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function VO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function HO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VO(Object(n), !0).forEach(function(r) {
      Ka(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _n = {
  compare(e, t) {
    var n = Pe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return _n.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return _n.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Pe.equals(e.path, t.path);
  },
  isPoint(e) {
    return Br(e) && typeof e.offset == "number" && Pe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return V0(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Pe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Pe.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Pe.equals(t.path, i) && (r.offset += t.position), r.path = Pe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Pe.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Pe.equals(t.path, i) || Pe.isAncestor(t.path, i))
            return null;
          r.path = Pe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Pe.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = Pe.transform(i, t, HO(HO({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Pe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, WO = void 0, co = {
  setScrubber(e) {
    WO = e;
  },
  stringify(e) {
    return JSON.stringify(e, WO);
  }
}, M9 = ["text"], T9 = ["anchor", "focus"];
function ZO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZO(Object(n), !0).forEach(function(r) {
      Ka(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pr = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = xu(i, M9);
      return s;
    }
    return WI(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Br(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => pr.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [vi({}, e)];
    for (var r of t) {
      var o = xu(r, T9), [i, s] = xt.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, m = l;
        if (l += d, u <= m && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === m) || u > l || c < m || c === m && m !== 0) {
          a.push(p);
          continue;
        }
        var f = p, g = void 0, h = void 0;
        if (c < l) {
          var x = c - m;
          h = vi(vi({}, f), {}, {
            text: f.text.slice(x)
          }), f = vi(vi({}, f), {}, {
            text: f.text.slice(0, x)
          });
        }
        if (u > m) {
          var w = u - m;
          g = vi(vi({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = vi(vi({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), g && a.push(g), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, j9 = (e) => e.selection ? e.selection : e.children.length > 0 ? wn.end(e, []) : [0], Dn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Dn || (Dn = {}));
Dn.L, Dn.L | Dn.V | Dn.LV | Dn.LVT, Dn.LV | Dn.V, Dn.V | Dn.T, Dn.LVT | Dn.T, Dn.T, Dn.Any, Dn.Extend | Dn.ZWJ, Dn.Any, Dn.SpacingMark, Dn.Prepend, Dn.Any, Dn.ZWJ, Dn.ExtPict, Dn.RI, Dn.RI;
var _9 = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    wn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = j9(e)
      } = n;
      if (Pe.isPath(o) && (o = wn.range(e, o)), xt.isRange(o))
        if (xt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = xt.end(o);
          if (!r && wn.void(e, {
            at: i
          }))
            return;
          var s = xt.start(o), a = wn.pointRef(e, s), l = wn.pointRef(e, i);
          Ad.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Ad.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && wn.void(e, {
        at: o
      }) || wn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function qO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qO(Object(n), !0).forEach(function(r) {
      Ka(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ad = Fc(Fc(Fc(Fc({}, C9), O9), x9), _9), ZI = {}, H0 = {}, W0 = {};
Object.defineProperty(W0, "__esModule", { value: !0 });
W0.default = N9;
var GO = "html", YO = "head", Rc = "body", A9 = /<([a-zA-Z]+[0-9]?)/, KO = /<head[^]*>/i, JO = /<body[^]*>/i, Bd = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Vy = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, XO = typeof window == "object" && window.DOMParser;
if (typeof XO == "function") {
  var B9 = new XO(), I9 = "text/html";
  Vy = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), B9.parseFromString(e, I9);
  }, Bd = Vy;
}
if (typeof document == "object" && document.implementation) {
  var zc = document.implementation.createHTMLDocument();
  Bd = function(e, t) {
    if (t) {
      var n = zc.documentElement.querySelector(t);
      return n && (n.innerHTML = e), zc;
    }
    return zc.documentElement.innerHTML = e, zc;
  };
}
var Uc = typeof document == "object" && document.createElement("template"), Hy;
Uc && Uc.content && (Hy = function(e) {
  return Uc.innerHTML = e, Uc.content.childNodes;
});
function N9(e) {
  var t, n, r = e.match(A9), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case GO: {
      var i = Vy(e);
      if (!KO.test(e)) {
        var s = i.querySelector(YO);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!JO.test(e)) {
        var s = i.querySelector(Rc);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(GO);
    }
    case YO:
    case Rc: {
      var a = Bd(e).querySelectorAll(o);
      return JO.test(e) && KO.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (Hy)
        return Hy(e);
      var s = Bd(e, Rc).querySelector(Rc);
      return s.childNodes;
    }
  }
}
var yh = {}, Z0 = {}, q0 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(q0);
var Dt = {}, Os = Ln && Ln.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Kl = Ln && Ln.__assign || function() {
  return Kl = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Kl.apply(this, arguments);
};
Object.defineProperty(Dt, "__esModule", { value: !0 });
Dt.cloneNode = Dt.hasChildren = Dt.isDocument = Dt.isDirective = Dt.isComment = Dt.isText = Dt.isCDATA = Dt.isTag = Dt.Element = Dt.Document = Dt.CDATA = Dt.NodeWithChildren = Dt.ProcessingInstruction = Dt.Comment = Dt.Text = Dt.DataNode = Dt.Node = void 0;
var io = q0, G0 = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), Y0(this, t);
    }, e;
  }()
);
Dt.Node = G0;
var bh = (
  /** @class */
  function(e) {
    Os(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(G0)
);
Dt.DataNode = bh;
var qI = (
  /** @class */
  function(e) {
    Os(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = io.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bh)
);
Dt.Text = qI;
var GI = (
  /** @class */
  function(e) {
    Os(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = io.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bh)
);
Dt.Comment = GI;
var YI = (
  /** @class */
  function(e) {
    Os(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = io.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bh)
);
Dt.ProcessingInstruction = YI;
var wh = (
  /** @class */
  function(e) {
    Os(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(G0)
);
Dt.NodeWithChildren = wh;
var KI = (
  /** @class */
  function(e) {
    Os(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = io.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wh)
);
Dt.CDATA = KI;
var JI = (
  /** @class */
  function(e) {
    Os(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = io.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wh)
);
Dt.Document = JI;
var XI = (
  /** @class */
  function(e) {
    Os(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? io.ElementType.Script : n === "style" ? io.ElementType.Style : io.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wh)
);
Dt.Element = XI;
function QI(e) {
  return (0, io.isTag)(e);
}
Dt.isTag = QI;
function eN(e) {
  return e.type === io.ElementType.CDATA;
}
Dt.isCDATA = eN;
function tN(e) {
  return e.type === io.ElementType.Text;
}
Dt.isText = tN;
function nN(e) {
  return e.type === io.ElementType.Comment;
}
Dt.isComment = nN;
function rN(e) {
  return e.type === io.ElementType.Directive;
}
Dt.isDirective = rN;
function oN(e) {
  return e.type === io.ElementType.Root;
}
Dt.isDocument = oN;
function F9(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Dt.hasChildren = F9;
function Y0(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (tN(e))
    n = new qI(e.data);
  else if (nN(e))
    n = new GI(e.data);
  else if (QI(e)) {
    var r = t ? lm(e.children) : [], o = new XI(e.name, Kl({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Kl({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Kl({}, e["x-attribsPrefix"])), n = o;
  } else if (eN(e)) {
    var r = t ? lm(e.children) : [], i = new KI(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (oN(e)) {
    var r = t ? lm(e.children) : [], s = new JI(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (rN(e)) {
    var a = new YI(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Dt.cloneNode = Y0;
function lm(e) {
  for (var t = e.map(function(r) {
    return Y0(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Ln && Ln.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = Ln && Ln.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = q0, o = Dt;
  n(Dt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(Z0);
var iN = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(iN);
Object.defineProperty(yh, "__esModule", { value: !0 });
yh.formatAttributes = sN;
yh.formatDOM = aN;
var $c = Z0, R9 = iN;
function z9(e) {
  return R9.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function sN(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function U9(e) {
  e = e.toLowerCase();
  var t = z9(e);
  return t || e;
}
function aN(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = U9(a.nodeName);
        o = new $c.Element(l, sN(a.attributes)), o.children = aN(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new $c.Text(a.nodeValue);
        break;
      case 8:
        o = new $c.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new $c.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var $9 = Ln && Ln.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(H0, "__esModule", { value: !0 });
H0.default = Z9;
var V9 = $9(W0), H9 = yh, W9 = /<(![a-zA-Z\s]+)>/;
function Z9(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(W9), n = t ? t[1] : void 0;
  return (0, H9.formatDOM)((0, V9.default)(e), null, n);
}
var Ch = {}, zo = {}, Oh = {}, q9 = 0;
Oh.SAME = q9;
var G9 = 1;
Oh.CAMELCASE = G9;
Oh.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const lN = 0, xs = 1, xh = 2, Eh = 3, K0 = 4, uN = 5, cN = 6;
function Y9(e) {
  return Mr.hasOwnProperty(e) ? Mr[e] : null;
}
function Vr(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === xh || t === Eh || t === K0, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const Mr = {}, K9 = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
K9.forEach((e) => {
  Mr[e] = new Vr(
    e,
    lN,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Mr[e] = new Vr(
    e,
    xs,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Mr[e] = new Vr(
    e,
    xh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Mr[e] = new Vr(
    e,
    xh,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Mr[e] = new Vr(
    e,
    Eh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Mr[e] = new Vr(
    e,
    Eh,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Mr[e] = new Vr(
    e,
    K0,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Mr[e] = new Vr(
    e,
    cN,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Mr[e] = new Vr(
    e,
    uN,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const J0 = /[\-\:]([a-z])/g, X0 = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(J0, X0);
  Mr[t] = new Vr(
    t,
    xs,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(J0, X0);
  Mr[t] = new Vr(
    t,
    xs,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(J0, X0);
  Mr[t] = new Vr(
    t,
    xs,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Mr[e] = new Vr(
    e,
    xs,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const J9 = "xlinkHref";
Mr[J9] = new Vr(
  "xlinkHref",
  xs,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Mr[e] = new Vr(
    e,
    xs,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: X9,
  SAME: Q9,
  possibleStandardNames: QO
} = Oh, e6 = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", t6 = e6 + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", n6 = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + t6 + "]*$")
), r6 = Object.keys(
  QO
).reduce((e, t) => {
  const n = QO[t];
  return n === Q9 ? e[t] = t : n === X9 ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
zo.BOOLEAN = Eh;
zo.BOOLEANISH_STRING = xh;
zo.NUMERIC = uN;
zo.OVERLOADED_BOOLEAN = K0;
zo.POSITIVE_NUMERIC = cN;
zo.RESERVED = lN;
zo.STRING = xs;
zo.getPropertyInfo = Y9;
zo.isCustomAttribute = n6;
zo.possibleStandardNames = r6;
var Q0 = {}, ew = {}, ex = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, o6 = /\n/g, i6 = /^\s*/, s6 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, a6 = /^:\s*/, l6 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, u6 = /^[;\s]*/, c6 = /^\s+|\s+$/g, p6 = `
`, tx = "/", nx = "*", ea = "", d6 = "comment", f6 = "declaration", h6 = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var g = f.match(o6);
    g && (n += g.length);
    var h = f.lastIndexOf(p6);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(g) {
      return g.position = new s(f), u(), g;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var g = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (g.reason = f, g.filename = t.source, g.line = n, g.column = r, g.source = e, !t.silent) throw g;
  }
  function l(f) {
    var g = f.exec(e);
    if (g) {
      var h = g[0];
      return o(h), e = e.slice(h.length), g;
    }
  }
  function u() {
    l(i6);
  }
  function c(f) {
    var g;
    for (f = f || []; g = p(); )
      g !== !1 && f.push(g);
    return f;
  }
  function p() {
    var f = i();
    if (!(tx != e.charAt(0) || nx != e.charAt(1))) {
      for (var g = 2; ea != e.charAt(g) && (nx != e.charAt(g) || tx != e.charAt(g + 1)); )
        ++g;
      if (g += 2, ea === e.charAt(g - 1))
        return a("End of comment missing");
      var h = e.slice(2, g - 2);
      return r += 2, o(h), e = e.slice(g), r += 2, f({
        type: d6,
        comment: h
      });
    }
  }
  function d() {
    var f = i(), g = l(s6);
    if (g) {
      if (p(), !l(a6)) return a("property missing ':'");
      var h = l(l6), x = f({
        type: f6,
        property: rx(g[0].replace(ex, ea)),
        value: h ? rx(h[0].replace(ex, ea)) : ea
      });
      return l(u6), x;
    }
  }
  function m() {
    var f = [];
    c(f);
    for (var g; g = d(); )
      g !== !1 && (f.push(g), c(f));
    return f;
  }
  return u(), m();
};
function rx(e) {
  return e ? e.replace(c6, ea) : ea;
}
var g6 = Ln && Ln.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ew, "__esModule", { value: !0 });
ew.default = v6;
var m6 = g6(h6);
function v6(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, m6.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var Lh = {};
Object.defineProperty(Lh, "__esModule", { value: !0 });
Lh.camelCase = void 0;
var y6 = /^--[a-zA-Z0-9_-]+$/, b6 = /-([a-z])/g, w6 = /^[^-]+$/, C6 = /^-(webkit|moz|ms|o|khtml)-/, O6 = /^-(ms)-/, x6 = function(e) {
  return !e || w6.test(e) || y6.test(e);
}, E6 = function(e, t) {
  return t.toUpperCase();
}, ox = function(e, t) {
  return "".concat(t, "-");
}, L6 = function(e, t) {
  return t === void 0 && (t = {}), x6(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(O6, ox) : e = e.replace(C6, ox), e.replace(b6, E6));
};
Lh.camelCase = L6;
var P6 = Ln && Ln.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, k6 = P6(ew), S6 = Lh;
function Wy(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, k6.default)(e, function(r, o) {
    r && o && (n[(0, S6.camelCase)(r, t)] = o);
  }), n;
}
Wy.default = Wy;
var D6 = Wy;
(function(e) {
  var t = Ln && Ln.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Ee, r = t(D6), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Q0);
Object.defineProperty(Ch, "__esModule", { value: !0 });
Ch.default = _6;
var zl = zo, ix = Q0, M6 = ["checked", "value"], T6 = ["input", "select", "textarea"], j6 = {
  reset: !0,
  submit: !0
};
function _6(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && j6[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, zl.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = sx(s);
    if (a) {
      var l = (0, zl.getPropertyInfo)(a);
      switch (M6.includes(a) && T6.includes(t) && !r && (a = sx("default" + s)), n[a] = i, l && l.type) {
        case zl.BOOLEAN:
          n[a] = !0;
          break;
        case zl.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    ix.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, ix.setStyleProp)(e.style, n), n;
}
function sx(e) {
  return zl.possibleStandardNames[e];
}
var tw = {}, A6 = Ln && Ln.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(tw, "__esModule", { value: !0 });
tw.default = pN;
var um = Ee, B6 = A6(Ch), Jl = Q0, I6 = {
  cloneElement: um.cloneElement,
  createElement: um.createElement,
  isValidElement: um.isValidElement
};
function pN(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Jl.returnFirstArg, i = t.library || I6, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var m = !p.data.trim().length;
      if (m && p.parent && !(0, Jl.canTextBeChildOfNode)(p.parent) || t.trim && m)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, g = {};
    N6(f) ? ((0, Jl.setStyleProp)(f.attribs.style, f.attribs), g = f.attribs) : f.attribs && (g = (0, B6.default)(f.attribs, f.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (g.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? g.defaultValue = p.children[0].data : p.children && p.children.length && (h = pN(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), n.push(o(a(p.name, g, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function N6(e) {
  return Jl.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Jl.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Ln && Ln.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(H0);
  e.htmlToDOM = n.default;
  var r = t(Ch);
  e.attributesToProps = r.default;
  var o = t(tw);
  e.domToReact = o.default;
  var i = Z0;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(ZI);
const ax = /* @__PURE__ */ o9(ZI);
ax.default;
function F6(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ bn.jsx("div", { className: o.trim(), ...r });
}
var Pn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function R6(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Zy = { exports: {} }, gl = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lx;
function z6() {
  if (lx) return gl;
  lx = 1;
  var e = Ee, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, m = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: m, props: p, _owner: o.current };
  }
  return gl.Fragment = n, gl.jsx = s, gl.jsxs = s, gl;
}
var Vc = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ux;
function U6() {
  return ux || (ux = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ee, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), f = Symbol.iterator, g = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[g];
      return typeof I == "function" ? I : null;
    }
    var x = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, Y = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          Y[ne - 1] = arguments[ne];
        D("error", b, Y);
      }
    }
    function D(b, I, Y) {
      {
        var ne = x.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (I += "%s", Y = Y.concat([le]));
        var ce = Y.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var O = !1, y = !1, C = !1, S = !1, U = !1, L;
    L = Symbol.for("react.module.reference");
    function F(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || U || b === o || b === u || b === c || S || b === m || O || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function B(b, I, Y) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = I.displayName || I.name || "";
      return le !== "" ? Y + "(" + le + ")" : Y;
    }
    function $(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var I = b;
            return $(I) + ".Consumer";
          case s:
            var Y = b;
            return $(Y._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, ae = le._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, q = 0, X, J, te, ee, k, j, H;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function Z() {
      {
        if (q === 0) {
          X = console.log, J = console.info, te = console.warn, ee = console.error, k = console.group, j = console.groupCollapsed, H = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function E() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: X
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: k
            }),
            groupCollapsed: z({}, b, {
              value: j
            }),
            groupEnd: z({}, b, {
              value: H
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = x.ReactCurrentDispatcher, R;
    function _(b, I, Y) {
      {
        if (R === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            R = ne && ne[1] || "";
          }
        return `
` + R + b;
      }
    }
    var W = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function N(b, I) {
      if (!b || W)
        return "";
      {
        var Y = A.get(b);
        if (Y !== void 0)
          return Y;
      }
      var ne;
      W = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = T.current, T.current = null, Z();
      try {
        if (I) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Re) {
              ne = Re;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Re) {
              ne = Re;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Re) {
            ne = Re;
          }
          b();
        }
      } catch (Re) {
        if (Re && ne && typeof Re.stack == "string") {
          for (var se = Re.stack.split(`
`), Be = ne.stack.split(`
`), we = se.length - 1, Oe = Be.length - 1; we >= 1 && Oe >= 0 && se[we] !== Be[Oe]; )
            Oe--;
          for (; we >= 1 && Oe >= 0; we--, Oe--)
            if (se[we] !== Be[Oe]) {
              if (we !== 1 || Oe !== 1)
                do
                  if (we--, Oe--, Oe < 0 || se[we] !== Be[Oe]) {
                    var qe = `
` + se[we].replace(" at new ", " at ");
                    return b.displayName && qe.includes("<anonymous>") && (qe = qe.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, qe), qe;
                  }
                while (we >= 1 && Oe >= 0);
              break;
            }
        }
      } finally {
        W = !1, T.current = ce, E(), Error.prepareStackTrace = le;
      }
      var Xt = b ? b.displayName || b.name : "", Ct = Xt ? _(Xt) : "";
      return typeof b == "function" && A.set(b, Ct), Ct;
    }
    function ue(b, I, Y) {
      return N(b, !1);
    }
    function ye(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, Y) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, ye(b));
      if (typeof b == "string")
        return _(b);
      switch (b) {
        case u:
          return _("Suspense");
        case c:
          return _("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, Y);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), I, Y);
            } catch {
            }
          }
        }
      return "";
    }
    var Ie = Object.prototype.hasOwnProperty, $e = {}, Ve = x.ReactDebugCurrentFrame;
    function Ne(b) {
      if (b) {
        var I = b._owner, Y = oe(b.type, b._source, I ? I.type : null);
        Ve.setExtraStackFrame(Y);
      } else
        Ve.setExtraStackFrame(null);
    }
    function Je(b, I, Y, ne, le) {
      {
        var ce = Function.call.bind(Ie);
        for (var ae in b)
          if (ce(b, ae)) {
            var se = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Be = Error((ne || "React class") + ": " + Y + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Be.name = "Invariant Violation", Be;
              }
              se = b[ae](I, ae, ne, Y, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (we) {
              se = we;
            }
            se && !(se instanceof Error) && (Ne(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", Y, ae, typeof se), Ne(null)), se instanceof Error && !(se.message in $e) && ($e[se.message] = !0, Ne(le), w("Failed %s type: %s", Y, se.message), Ne(null));
          }
      }
    }
    var Ye = Array.isArray;
    function Te(b) {
      return Ye(b);
    }
    function Ke(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, Y = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return Y;
      }
    }
    function nt(b) {
      try {
        return Me(b), !1;
      } catch {
        return !0;
      }
    }
    function Me(b) {
      return "" + b;
    }
    function Ae(b) {
      if (nt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(b)), Me(b);
    }
    var Fe = x.ReactCurrentOwner, He = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ze, et, _e;
    _e = {};
    function At(b) {
      if (Ie.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function rt(b) {
      if (Ie.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, I) {
      if (typeof b.ref == "string" && Fe.current && I && Fe.current.stateNode !== I) {
        var Y = V(Fe.current.type);
        _e[Y] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Fe.current.type), b.ref), _e[Y] = !0);
      }
    }
    function at(b, I) {
      {
        var Y = function() {
          ze || (ze = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: Y,
          configurable: !0
        });
      }
    }
    function qt(b, I) {
      {
        var Y = function() {
          et || (et = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: Y,
          configurable: !0
        });
      }
    }
    var lt = function(b, I, Y, ne, le, ce, ae) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: Y,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function Gt(b, I, Y, ne, le) {
      {
        var ce, ae = {}, se = null, Be = null;
        Y !== void 0 && (Ae(Y), se = "" + Y), rt(I) && (Ae(I.key), se = "" + I.key), At(I) && (Be = I.ref, ot(I, le));
        for (ce in I)
          Ie.call(I, ce) && !He.hasOwnProperty(ce) && (ae[ce] = I[ce]);
        if (b && b.defaultProps) {
          var we = b.defaultProps;
          for (ce in we)
            ae[ce] === void 0 && (ae[ce] = we[ce]);
        }
        if (se || Be) {
          var Oe = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && at(ae, Oe), Be && qt(ae, Oe);
        }
        return lt(b, se, Be, le, ne, Fe.current, ae);
      }
    }
    var Xe = x.ReactCurrentOwner, bt = x.ReactDebugCurrentFrame;
    function tt(b) {
      if (b) {
        var I = b._owner, Y = oe(b.type, b._source, I ? I.type : null);
        bt.setExtraStackFrame(Y);
      } else
        bt.setExtraStackFrame(null);
    }
    var Yt;
    Yt = !1;
    function ut(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function dn() {
      {
        if (Xe.current) {
          var b = V(Xe.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function Kt(b) {
      return "";
    }
    var fn = {};
    function Jt(b) {
      {
        var I = dn();
        if (!I) {
          var Y = typeof b == "string" ? b : b.displayName || b.name;
          Y && (I = `

Check the top-level render call using <` + Y + ">.");
        }
        return I;
      }
    }
    function hn(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var Y = Jt(I);
        if (fn[Y])
          return;
        fn[Y] = !0;
        var ne = "";
        b && b._owner && b._owner !== Xe.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), tt(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Y, ne), tt(null);
      }
    }
    function Fn(b, I) {
      {
        if (typeof b != "object")
          return;
        if (Te(b))
          for (var Y = 0; Y < b.length; Y++) {
            var ne = b[Y];
            ut(ne) && hn(ne, I);
          }
        else if (ut(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = h(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), ae; !(ae = ce.next()).done; )
              ut(ae.value) && hn(ae.value, I);
        }
      }
    }
    function wt(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var Y;
        if (typeof I == "function")
          Y = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          Y = I.propTypes;
        else
          return;
        if (Y) {
          var ne = V(I);
          Je(Y, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !Yt) {
          Yt = !0;
          var le = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function re(b) {
      {
        for (var I = Object.keys(b.props), Y = 0; Y < I.length; Y++) {
          var ne = I[Y];
          if (ne !== "children" && ne !== "key") {
            tt(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), tt(null);
            break;
          }
        }
        b.ref !== null && (tt(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var qr = {};
    function Gr(b, I, Y, ne, le, ce) {
      {
        var ae = F(b);
        if (!ae) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Be = Kt();
          Be ? se += Be : se += dn();
          var we;
          b === null ? we = "null" : Te(b) ? we = "array" : b !== void 0 && b.$$typeof === t ? (we = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : we = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", we, se);
        }
        var Oe = Gt(b, I, Y, le, ce);
        if (Oe == null)
          return Oe;
        if (ae) {
          var qe = I.children;
          if (qe !== void 0)
            if (ne)
              if (Te(qe)) {
                for (var Xt = 0; Xt < qe.length; Xt++)
                  Fn(qe[Xt], b);
                Object.freeze && Object.freeze(qe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Fn(qe, b);
        }
        if (Ie.call(I, "key")) {
          var Ct = V(b), Re = Object.keys(I).filter(function(gi) {
            return gi !== "key";
          }), Or = Re.length > 0 ? "{key: someKey, " + Re.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!qr[Ct + Or]) {
            var hi = Re.length > 0 ? "{" + Re.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Or, Ct, hi, Ct), qr[Ct + Or] = !0;
          }
        }
        return b === r ? re(Oe) : wt(Oe), Oe;
      }
    }
    function ci(b, I, Y) {
      return Gr(b, I, Y, !0);
    }
    function pi(b, I, Y) {
      return Gr(b, I, Y, !1);
    }
    var di = pi, fi = ci;
    Vc.Fragment = r, Vc.jsx = di, Vc.jsxs = fi;
  }()), Vc;
}
process.env.NODE_ENV === "production" ? Zy.exports = z6() : Zy.exports = U6();
var to = Zy.exports;
Ge({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function cx(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Ir(e) {
  var t, n;
  return cx(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(cx(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var dN = Symbol.for("immer-nothing"), px = Symbol.for("immer-draftable"), Lo = Symbol.for("immer-state"), $6 = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Xr(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = $6[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Va = Object.getPrototypeOf;
function wa(e) {
  return !!e && !!e[Lo];
}
function Ca(e) {
  var t;
  return e ? fN(e) || Array.isArray(e) || !!e[px] || !!((t = e.constructor) != null && t[px]) || kh(e) || Sh(e) : !1;
}
var V6 = Object.prototype.constructor.toString();
function fN(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Va(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === V6;
}
function Id(e, t) {
  Ph(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Ph(e) {
  const t = e[Lo];
  return t ? t.type_ : Array.isArray(e) ? 1 : kh(e) ? 2 : Sh(e) ? 3 : 0;
}
function qy(e, t) {
  return Ph(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function hN(e, t, n) {
  const r = Ph(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function H6(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function kh(e) {
  return e instanceof Map;
}
function Sh(e) {
  return e instanceof Set;
}
function Ys(e) {
  return e.copy_ || e.base_;
}
function Gy(e, t) {
  if (kh(e))
    return new Map(e);
  if (Sh(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = fN(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Lo];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(Va(e), r);
  } else {
    const r = Va(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function nw(e, t = !1) {
  return Dh(e) || wa(e) || !Ca(e) || (Ph(e) > 1 && (e.set = e.add = e.clear = e.delete = W6), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => nw(r, !0))), e;
}
function W6() {
  Xr(2);
}
function Dh(e) {
  return Object.isFrozen(e);
}
var Z6 = {};
function Oa(e) {
  const t = Z6[e];
  return t || Xr(0, e), t;
}
var Eu;
function gN() {
  return Eu;
}
function q6(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function dx(e, t) {
  t && (Oa("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Yy(e) {
  Ky(e), e.drafts_.forEach(G6), e.drafts_ = null;
}
function Ky(e) {
  e === Eu && (Eu = e.parent_);
}
function fx(e) {
  return Eu = q6(Eu, e);
}
function G6(e) {
  const t = e[Lo];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function hx(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Lo].modified_ && (Yy(t), Xr(4)), Ca(e) && (e = Nd(t, e), t.parent_ || Fd(t, e)), t.patches_ && Oa("Patches").generateReplacementPatches_(
    n[Lo].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Nd(t, n, []), Yy(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== dN ? e : void 0;
}
function Nd(e, t, n) {
  if (Dh(t))
    return t;
  const r = t[Lo];
  if (!r)
    return Id(
      t,
      (o, i) => gx(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Fd(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Id(
      i,
      (a, l) => gx(e, r, o, a, l, n, s)
    ), Fd(e, o, !1), n && e.patches_ && Oa("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function gx(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && Xr(5), wa(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !qy(t.assigned_, r) ? i.concat(r) : void 0, l = Nd(e, o, a);
    if (hN(n, r, l), wa(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (Ca(o) && !Dh(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Nd(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Fd(e, o);
  }
}
function Fd(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && nw(t, n);
}
function Y6(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : gN(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = rw;
  n && (o = [r], i = Lu);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var rw = {
  get(e, t) {
    if (t === Lo)
      return e;
    const n = Ys(e);
    if (!qy(n, t))
      return K6(e, n, t);
    const r = n[t];
    return e.finalized_ || !Ca(r) ? r : r === cm(e.base_, t) ? (pm(e), e.copy_[t] = Xy(r, e)) : r;
  },
  has(e, t) {
    return t in Ys(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ys(e));
  },
  set(e, t, n) {
    const r = mN(Ys(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = cm(Ys(e), t), i = o == null ? void 0 : o[Lo];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (H6(n, o) && (n !== void 0 || qy(e.base_, t)))
        return !0;
      pm(e), Jy(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return cm(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, pm(e), Jy(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ys(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Xr(11);
  },
  getPrototypeOf(e) {
    return Va(e.base_);
  },
  setPrototypeOf() {
    Xr(12);
  }
}, Lu = {};
Id(rw, (e, t) => {
  Lu[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Lu.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Xr(13), Lu.set.call(this, e, t, void 0);
};
Lu.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Xr(14), rw.set.call(this, e[0], t, n, e[0]);
};
function cm(e, t) {
  const n = e[Lo];
  return (n ? Ys(n) : e)[t];
}
function K6(e, t, n) {
  var r;
  const o = mN(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function mN(e, t) {
  if (!(t in e))
    return;
  let n = Va(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Va(n);
  }
}
function Jy(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Jy(e.parent_));
}
function pm(e) {
  e.copy_ || (e.copy_ = Gy(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var J6 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Xr(6), r !== void 0 && typeof r != "function" && Xr(7);
      let o;
      if (Ca(t)) {
        const i = fx(this), s = Xy(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? Yy(i) : Ky(i);
        }
        return dx(i, r), hx(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === dN && (o = void 0), this.autoFreeze_ && nw(o, !0), r) {
          const i = [], s = [];
          Oa("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        Xr(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Ca(e) || Xr(8), wa(e) && (e = X6(e));
    const t = fx(this), n = Xy(e, void 0);
    return n[Lo].isManual_ = !0, Ky(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Lo];
    (!n || !n.isManual_) && Xr(9);
    const { scope_: r } = n;
    return dx(r, t), hx(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Oa("Patches").applyPatches_;
    return wa(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Xy(e, t) {
  const n = kh(e) ? Oa("MapSet").proxyMap_(e, t) : Sh(e) ? Oa("MapSet").proxySet_(e, t) : Y6(e, t);
  return (t ? t.scope_ : gN()).drafts_.push(n), n;
}
function X6(e) {
  return wa(e) || Xr(10, e), vN(e);
}
function vN(e) {
  if (!Ca(e) || Dh(e))
    return e;
  const t = e[Lo];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Gy(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Gy(e, !0);
  return Id(n, (r, o) => {
    hN(n, r, vN(o));
  }), t && (t.finalized_ = !1), n;
}
var Po = new J6(), ow = Po.produce;
Po.produceWithPatches.bind(
  Po
);
Po.setAutoFreeze.bind(Po);
Po.setUseStrictShallowCopy.bind(Po);
Po.applyPatches.bind(Po);
var mx = Po.createDraft.bind(Po), vx = Po.finishDraft.bind(Po), ke = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = ke.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return ke.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return ke.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return ke.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return ke.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && ke.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return ke.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && ke.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && ke.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && ke.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && ke.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && ke.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!ke.isAncestor(t, e) && !ke.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (ke.equals(i, r) || ke.endsBefore(i, r) || ke.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (ke.equals(s, r) || ke.isAncestor(s, r))
          return null;
        ke.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        ke.equals(a, r) || ke.endsBefore(a, r) ? r[a.length - 1] -= 1 : ke.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (ke.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else ke.endsBefore(u, r) ? r[u.length - 1] += 1 : ke.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (ke.equals(p, d))
          return r;
        if (ke.isAncestor(p, r) || ke.equals(p, r)) {
          var m = d.slice();
          return ke.endsBefore(p, d) && p.length < d.length && (m[p.length - 1] -= 1), m.concat(r.slice(p.length));
        } else ke.isSibling(p, d) && (ke.isAncestor(d, r) || ke.equals(d, r)) ? ke.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : ke.endsBefore(d, r) || ke.equals(d, r) || ke.isAncestor(d, r) ? (ke.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : ke.endsBefore(p, r) && (ke.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Pu(e) {
  "@babel/helpers - typeof";
  return Pu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Pu(e);
}
function Q6(e, t) {
  if (Pu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Pu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function e8(e) {
  var t = Q6(e, "string");
  return Pu(t) === "symbol" ? t : String(t);
}
function Ja(e, t, n) {
  return t = e8(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function yx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ml(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yx(Object(n), !0).forEach(function(r) {
      Ja(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var t8 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = pt.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of Et.points(t))
          t[l] = An.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = pt.leaf(e, u), m = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = m + p + f, t)
        for (var [g, h] of Et.points(t))
          t[h] = An.transform(g, n);
      break;
    }
    case "merge_node": {
      var {
        path: x
      } = n, w = pt.get(e, x), D = ke.previous(x), O = pt.get(e, D), y = pt.parent(e, x), C = x[x.length - 1];
      if (dr.isText(w) && dr.isText(O))
        O.text += w.text;
      else if (!dr.isText(w) && !dr.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(x, "] to nodes of different interfaces: ").concat(po.stringify(w), " ").concat(po.stringify(O)));
      if (y.children.splice(C, 1), t)
        for (var [S, U] of Et.points(t))
          t[U] = An.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: F
      } = n;
      if (ke.isAncestor(L, F))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(F, "] because the destination is inside itself."));
      var B = pt.get(e, L), $ = pt.parent(e, L), V = L[L.length - 1];
      $.children.splice(V, 1);
      var z = ke.transform(L, n), q = pt.get(e, ke.parent(z)), X = z[z.length - 1];
      if (q.children.splice(X, 0, B), t)
        for (var [J, te] of Et.points(t))
          t[te] = An.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, k = ee[ee.length - 1], j = pt.parent(e, ee);
      if (j.children.splice(k, 1), t)
        for (var [H, M] of Et.points(t)) {
          var Z = An.transform(H, n);
          if (t != null && Z != null)
            t[M] = Z;
          else {
            var E = void 0, T = void 0;
            for (var [R, _] of pt.texts(e))
              if (ke.compare(_, ee) === -1)
                E = [R, _];
              else {
                T = [R, _];
                break;
              }
            var W = !1;
            E && T && (ke.equals(T[1], ee) ? W = !ke.hasPrevious(T[1]) : W = ke.common(E[1], ee).length < ke.common(T[1], ee).length), E && !W ? (H.path = E[1], H.offset = E[0].text.length) : T ? (H.path = T[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: N
      } = n;
      if (N.length === 0) break;
      var ue = pt.leaf(e, A), ye = ue.text.slice(0, Q), oe = ue.text.slice(Q + N.length);
      if (ue.text = ye + oe, t)
        for (var [Ie, $e] of Et.points(t))
          t[$e] = An.transform(Ie, n);
      break;
    }
    case "set_node": {
      var {
        path: Ve,
        properties: Ne,
        newProperties: Je
      } = n;
      if (Ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ye = pt.get(e, Ve);
      for (var Te in Je) {
        if (Te === "children" || Te === "text")
          throw new Error('Cannot set the "'.concat(Te, '" property of nodes!'));
        var Ke = Je[Te];
        Ke == null ? delete Ye[Te] : Ye[Te] = Ke;
      }
      for (var nt in Ne)
        Je.hasOwnProperty(nt) || delete Ye[nt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Me
      } = n;
      if (Me == null)
        t = Me;
      else {
        if (t == null) {
          if (!Et.isRange(Me))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(po.stringify(Me), " when there is no current selection."));
          t = ml({}, Me);
        }
        for (var Ae in Me) {
          var Fe = Me[Ae];
          if (Fe == null) {
            if (Ae === "anchor" || Ae === "focus")
              throw new Error('Cannot remove the "'.concat(Ae, '" selection property'));
            delete t[Ae];
          } else
            t[Ae] = Fe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: He,
        position: ze,
        properties: et
      } = n;
      if (He.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(He, "] because the root node cannot be split."));
      var _e = pt.get(e, He), At = pt.parent(e, He), rt = He[He.length - 1], ot;
      if (dr.isText(_e)) {
        var at = _e.text.slice(0, ze), qt = _e.text.slice(ze);
        _e.text = at, ot = ml(ml({}, et), {}, {
          text: qt
        });
      } else {
        var lt = _e.children.slice(0, ze), Gt = _e.children.slice(ze);
        _e.children = lt, ot = ml(ml({}, et), {}, {
          children: Gt
        });
      }
      if (At.children.splice(rt + 1, 0, ot), t)
        for (var [Xe, bt] of Et.points(t))
          t[bt] = An.transform(Xe, n);
      break;
    }
  }
  return t;
}, n8 = {
  transform(e, t) {
    e.children = mx(e.children);
    var n = e.selection && mx(e.selection);
    try {
      n = t8(e, n, t);
    } finally {
      e.children = vx(e.children), n ? e.selection = wa(n) ? vx(n) : n : e.selection = null;
    }
  }
}, r8 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, o8 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, yN = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Ir(r) && Ir(o)) {
      if (!yN(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function i8(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function ku(e, t) {
  if (e == null) return {};
  var n = i8(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var s8 = ["anchor", "focus"];
function bx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function a8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bx(Object(n), !0).forEach(function(r) {
      Ja(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Et = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Et.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Et.edges(e);
    return t;
  },
  equals(e, t) {
    return An.equals(e.anchor, t.anchor) && An.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Et.isRange(t)) {
      if (Et.includes(e, t.anchor) || Et.includes(e, t.focus))
        return !0;
      var [n, r] = Et.edges(e), [o, i] = Et.edges(t);
      return An.isBefore(n, o) && An.isAfter(r, i);
    }
    var [s, a] = Et.edges(e), l = !1, u = !1;
    return An.isPoint(t) ? (l = An.compare(t, s) >= 0, u = An.compare(t, a) <= 0) : (l = ke.compare(t, s.path) >= 0, u = ke.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = ku(e, s8), [r, o] = Et.edges(e), [i, s] = Et.edges(t), a = An.isBefore(r, i) ? i : r, l = An.isBefore(o, s) ? o : s;
    return An.isBefore(l, a) ? null : a8({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return An.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return An.equals(t, n);
  },
  isExpanded(e) {
    return !Et.isCollapsed(e);
  },
  isForward(e) {
    return !Et.isBackward(e);
  },
  isRange(e) {
    return Ir(e) && An.isPoint(e.anchor) && An.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Et.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ow(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = Et.isCollapsed(r);
        Et.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? Et.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = An.transform(r.anchor, t, {
        affinity: i
      }), u = An.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, wx = (e) => Ir(e) && pt.isNodeList(e.children) && !Cn.isEditor(e), ki = {
  isAncestor(e) {
    return Ir(e) && pt.isNodeList(e.children);
  },
  isElement: wx,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => ki.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return wx(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, l8 = ["children"], u8 = ["text"], Cx = /* @__PURE__ */ new WeakMap(), pt = {
  ancestor(e, t) {
    var n = pt.get(e, t);
    if (dr.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(po.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ke.ancestors(t, n)) {
        var o = pt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (dr.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(po.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(po.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = pt.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = pt.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = ke.common(t, n), o = pt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = pt.get(e, t);
    if (Cn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(po.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of pt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of pt.nodes(e, t))
        ki.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (ki.isAncestor(e)) {
      var t = ku(e, l8);
      return t;
    } else {
      var t = ku(e, u8);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = pt.get(e, n); r && !(dr.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (dr.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(po.stringify(e)));
    var n = ow({
      children: e.children
    }, (r) => {
      var [o, i] = Et.edges(t), s = pt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, m] = d;
          return !Et.includes(t, m);
        }
      });
      for (var [, a] of s) {
        if (!Et.includes(t, a)) {
          var l = pt.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (ke.equals(a, i.path)) {
          var c = pt.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (ke.equals(a, o.path)) {
          var p = pt.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      Cn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (dr.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(po.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (dr.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return dr.isText(e) || ki.isElement(e) || Cn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = Cx.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => pt.isNode(r));
    return Cx.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = pt.get(e, n); r && !(dr.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = pt.get(e, t);
    if (!dr.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(po.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ke.levels(t, n)) {
        var o = pt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return ki.isElement(e) && ki.isElementProps(t) && ki.matches(e, t) || dr.isText(e) && dr.isTextProps(t) && dr.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? ke.isBefore(a, i) : ke.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !dr.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          ke.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = pt.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = ke.next(a);
          if (pt.has(e, c)) {
            a = c, l = pt.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = ke.previous(a);
          a = p, l = pt.get(e, a);
          continue;
        }
        a = ke.parent(a), l = pt.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = ke.parent(t), r = pt.get(e, n);
    if (dr.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return dr.isText(e) ? e.text : e.children.map(pt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of pt.nodes(e, t))
        dr.isText(n) && (yield [n, r]);
    }();
  }
};
function Ox(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Un(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ox(Object(n), !0).forEach(function(r) {
      Ja(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ox(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ul = {
  isNodeOperation(e) {
    return Ul.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Ir(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return ke.isPath(e.path) && pt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ke.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && ke.isPath(e.path) && Ir(e.properties);
      case "move_node":
        return ke.isPath(e.path) && ke.isPath(e.newPath);
      case "remove_node":
        return ke.isPath(e.path) && pt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ke.isPath(e.path);
      case "set_node":
        return ke.isPath(e.path) && Ir(e.properties) && Ir(e.newProperties);
      case "set_selection":
        return e.properties === null && Et.isRange(e.newProperties) || e.newProperties === null && Et.isRange(e.properties) || Ir(e.properties) && Ir(e.newProperties);
      case "split_node":
        return ke.isPath(e.path) && typeof e.position == "number" && Ir(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Ul.isOperation(t));
  },
  isSelectionOperation(e) {
    return Ul.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Ul.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Un(Un({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Un(Un({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Un(Un({}, e), {}, {
          type: "split_node",
          path: ke.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (ke.equals(t, n))
          return e;
        if (ke.isSibling(n, t))
          return Un(Un({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = ke.transform(n, e), o = ke.transform(ke.next(n), e);
        return Un(Un({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Un(Un({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Un(Un({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return Un(Un({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? Un(Un({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Un(Un({}, e), {}, {
          properties: null,
          newProperties: a
        }) : Un(Un({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return Un(Un({}, e), {}, {
          type: "merge_node",
          path: ke.next(e.path)
        });
    }
  }
}, xx = /* @__PURE__ */ new WeakMap(), c8 = (e) => {
  var t = xx.get(e);
  if (t !== void 0)
    return t;
  if (!Ir(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Ir(e.marks)) && (e.selection === null || Et.isRange(e.selection)) && pt.isNodeList(e.children) && Ul.isOperationList(e.operations);
  return xx.set(e, n), n;
}, Cn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return c8(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function Ex(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ex(Object(n), !0).forEach(function(r) {
      Ja(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ex(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var An = {
  compare(e, t) {
    var n = ke.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return An.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return An.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && ke.equals(e.path, t.path);
  },
  isPoint(e) {
    return Ir(e) && typeof e.offset == "number" && ke.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ow(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = ke.transform(i, t, n);
          break;
        }
        case "insert_text": {
          ke.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          ke.equals(t.path, i) && (r.offset += t.position), r.path = ke.transform(i, t, n);
          break;
        }
        case "remove_text": {
          ke.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (ke.equals(t.path, i) || ke.isAncestor(t.path, i))
            return null;
          r.path = ke.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (ke.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = ke.transform(i, t, Lx(Lx({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = ke.transform(i, t, n);
          break;
        }
      }
    });
  }
}, Px = void 0, po = {
  setScrubber(e) {
    Px = e;
  },
  stringify(e) {
    return JSON.stringify(e, Px);
  }
}, p8 = ["text"], d8 = ["anchor", "focus"];
function kx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kx(Object(n), !0).forEach(function(r) {
      Ja(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dr = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = ku(i, p8);
      return s;
    }
    return yN(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Ir(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => dr.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [yi({}, e)];
    for (var r of t) {
      var o = ku(r, d8), [i, s] = Et.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, m = l;
        if (l += d, u <= m && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === m) || u > l || c < m || c === m && m !== 0) {
          a.push(p);
          continue;
        }
        var f = p, g = void 0, h = void 0;
        if (c < l) {
          var x = c - m;
          h = yi(yi({}, f), {}, {
            text: f.text.slice(x)
          }), f = yi(yi({}, f), {}, {
            text: f.text.slice(0, x)
          });
        }
        if (u > m) {
          var w = u - m;
          g = yi(yi({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = yi(yi({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), g && a.push(g), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, f8 = (e) => e.selection ? e.selection : e.children.length > 0 ? Cn.end(e, []) : [0], Mn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Mn || (Mn = {}));
Mn.L, Mn.L | Mn.V | Mn.LV | Mn.LVT, Mn.LV | Mn.V, Mn.V | Mn.T, Mn.LVT | Mn.T, Mn.T, Mn.Any, Mn.Extend | Mn.ZWJ, Mn.Any, Mn.SpacingMark, Mn.Prepend, Mn.Any, Mn.ZWJ, Mn.ExtPict, Mn.RI, Mn.RI;
var h8 = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Cn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = f8(e)
      } = n;
      if (ke.isPath(o) && (o = Cn.range(e, o)), Et.isRange(o))
        if (Et.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Et.end(o);
          if (!r && Cn.void(e, {
            at: i
          }))
            return;
          var s = Et.start(o), a = Cn.pointRef(e, s), l = Cn.pointRef(e, i);
          Rd.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Rd.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Cn.void(e, {
        at: o
      }) || Cn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function Sx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Sx(Object(n), !0).forEach(function(r) {
      Ja(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Sx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Rd = Hc(Hc(Hc(Hc({}, n8), r8), o8), h8), bN = {}, iw = {}, sw = {};
Object.defineProperty(sw, "__esModule", { value: !0 });
sw.default = y8;
var Dx = "html", Mx = "head", Wc = "body", g8 = /<([a-zA-Z]+[0-9]?)/, Tx = /<head[^]*>/i, jx = /<body[^]*>/i, zd = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Qy = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, _x = typeof window == "object" && window.DOMParser;
if (typeof _x == "function") {
  var m8 = new _x(), v8 = "text/html";
  Qy = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), m8.parseFromString(e, v8);
  }, zd = Qy;
}
if (typeof document == "object" && document.implementation) {
  var Zc = document.implementation.createHTMLDocument();
  zd = function(e, t) {
    if (t) {
      var n = Zc.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Zc;
    }
    return Zc.documentElement.innerHTML = e, Zc;
  };
}
var qc = typeof document == "object" && document.createElement("template"), eb;
qc && qc.content && (eb = function(e) {
  return qc.innerHTML = e, qc.content.childNodes;
});
function y8(e) {
  var t, n, r = e.match(g8), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case Dx: {
      var i = Qy(e);
      if (!Tx.test(e)) {
        var s = i.querySelector(Mx);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!jx.test(e)) {
        var s = i.querySelector(Wc);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(Dx);
    }
    case Mx:
    case Wc: {
      var a = zd(e).querySelectorAll(o);
      return jx.test(e) && Tx.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (eb)
        return eb(e);
      var s = zd(e, Wc).querySelector(Wc);
      return s.childNodes;
    }
  }
}
var Mh = {}, aw = {}, lw = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(lw);
var Mt = {}, Es = Pn && Pn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Xl = Pn && Pn.__assign || function() {
  return Xl = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Xl.apply(this, arguments);
};
Object.defineProperty(Mt, "__esModule", { value: !0 });
Mt.cloneNode = Mt.hasChildren = Mt.isDocument = Mt.isDirective = Mt.isComment = Mt.isText = Mt.isCDATA = Mt.isTag = Mt.Element = Mt.Document = Mt.CDATA = Mt.NodeWithChildren = Mt.ProcessingInstruction = Mt.Comment = Mt.Text = Mt.DataNode = Mt.Node = void 0;
var so = lw, uw = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), cw(this, t);
    }, e;
  }()
);
Mt.Node = uw;
var Th = (
  /** @class */
  function(e) {
    Es(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uw)
);
Mt.DataNode = Th;
var wN = (
  /** @class */
  function(e) {
    Es(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = so.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Th)
);
Mt.Text = wN;
var CN = (
  /** @class */
  function(e) {
    Es(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = so.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Th)
);
Mt.Comment = CN;
var ON = (
  /** @class */
  function(e) {
    Es(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = so.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Th)
);
Mt.ProcessingInstruction = ON;
var jh = (
  /** @class */
  function(e) {
    Es(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uw)
);
Mt.NodeWithChildren = jh;
var xN = (
  /** @class */
  function(e) {
    Es(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = so.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(jh)
);
Mt.CDATA = xN;
var EN = (
  /** @class */
  function(e) {
    Es(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = so.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(jh)
);
Mt.Document = EN;
var LN = (
  /** @class */
  function(e) {
    Es(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? so.ElementType.Script : n === "style" ? so.ElementType.Style : so.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(jh)
);
Mt.Element = LN;
function PN(e) {
  return (0, so.isTag)(e);
}
Mt.isTag = PN;
function kN(e) {
  return e.type === so.ElementType.CDATA;
}
Mt.isCDATA = kN;
function SN(e) {
  return e.type === so.ElementType.Text;
}
Mt.isText = SN;
function DN(e) {
  return e.type === so.ElementType.Comment;
}
Mt.isComment = DN;
function MN(e) {
  return e.type === so.ElementType.Directive;
}
Mt.isDirective = MN;
function TN(e) {
  return e.type === so.ElementType.Root;
}
Mt.isDocument = TN;
function b8(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Mt.hasChildren = b8;
function cw(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (SN(e))
    n = new wN(e.data);
  else if (DN(e))
    n = new CN(e.data);
  else if (PN(e)) {
    var r = t ? dm(e.children) : [], o = new LN(e.name, Xl({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Xl({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Xl({}, e["x-attribsPrefix"])), n = o;
  } else if (kN(e)) {
    var r = t ? dm(e.children) : [], i = new xN(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (TN(e)) {
    var r = t ? dm(e.children) : [], s = new EN(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (MN(e)) {
    var a = new ON(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Mt.cloneNode = cw;
function dm(e) {
  for (var t = e.map(function(r) {
    return cw(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Pn && Pn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = Pn && Pn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = lw, o = Mt;
  n(Mt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(aw);
var jN = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(jN);
Object.defineProperty(Mh, "__esModule", { value: !0 });
Mh.formatAttributes = _N;
Mh.formatDOM = AN;
var Gc = aw, w8 = jN;
function C8(e) {
  return w8.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function _N(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function O8(e) {
  e = e.toLowerCase();
  var t = C8(e);
  return t || e;
}
function AN(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = O8(a.nodeName);
        o = new Gc.Element(l, _N(a.attributes)), o.children = AN(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Gc.Text(a.nodeValue);
        break;
      case 8:
        o = new Gc.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Gc.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var x8 = Pn && Pn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(iw, "__esModule", { value: !0 });
iw.default = k8;
var E8 = x8(sw), L8 = Mh, P8 = /<(![a-zA-Z\s]+)>/;
function k8(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(P8), n = t ? t[1] : void 0;
  return (0, L8.formatDOM)((0, E8.default)(e), null, n);
}
var _h = {}, Uo = {}, Ah = {}, S8 = 0;
Ah.SAME = S8;
var D8 = 1;
Ah.CAMELCASE = D8;
Ah.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const BN = 0, Ls = 1, Bh = 2, Ih = 3, pw = 4, IN = 5, NN = 6;
function M8(e) {
  return Tr.hasOwnProperty(e) ? Tr[e] : null;
}
function Hr(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === Bh || t === Ih || t === pw, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const Tr = {}, T8 = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
T8.forEach((e) => {
  Tr[e] = new Hr(
    e,
    BN,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Tr[e] = new Hr(
    e,
    Ls,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Tr[e] = new Hr(
    e,
    Bh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Tr[e] = new Hr(
    e,
    Bh,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Tr[e] = new Hr(
    e,
    Ih,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Tr[e] = new Hr(
    e,
    Ih,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Tr[e] = new Hr(
    e,
    pw,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Tr[e] = new Hr(
    e,
    NN,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Tr[e] = new Hr(
    e,
    IN,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const dw = /[\-\:]([a-z])/g, fw = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dw, fw);
  Tr[t] = new Hr(
    t,
    Ls,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dw, fw);
  Tr[t] = new Hr(
    t,
    Ls,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dw, fw);
  Tr[t] = new Hr(
    t,
    Ls,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Tr[e] = new Hr(
    e,
    Ls,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const j8 = "xlinkHref";
Tr[j8] = new Hr(
  "xlinkHref",
  Ls,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Tr[e] = new Hr(
    e,
    Ls,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: _8,
  SAME: A8,
  possibleStandardNames: Ax
} = Ah, B8 = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", I8 = B8 + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", N8 = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + I8 + "]*$")
), F8 = Object.keys(
  Ax
).reduce((e, t) => {
  const n = Ax[t];
  return n === A8 ? e[t] = t : n === _8 ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Uo.BOOLEAN = Ih;
Uo.BOOLEANISH_STRING = Bh;
Uo.NUMERIC = IN;
Uo.OVERLOADED_BOOLEAN = pw;
Uo.POSITIVE_NUMERIC = NN;
Uo.RESERVED = BN;
Uo.STRING = Ls;
Uo.getPropertyInfo = M8;
Uo.isCustomAttribute = N8;
Uo.possibleStandardNames = F8;
var hw = {}, gw = {}, Bx = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, R8 = /\n/g, z8 = /^\s*/, U8 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, $8 = /^:\s*/, V8 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, H8 = /^[;\s]*/, W8 = /^\s+|\s+$/g, Z8 = `
`, Ix = "/", Nx = "*", ta = "", q8 = "comment", G8 = "declaration", Y8 = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var g = f.match(R8);
    g && (n += g.length);
    var h = f.lastIndexOf(Z8);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(g) {
      return g.position = new s(f), u(), g;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var g = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (g.reason = f, g.filename = t.source, g.line = n, g.column = r, g.source = e, !t.silent) throw g;
  }
  function l(f) {
    var g = f.exec(e);
    if (g) {
      var h = g[0];
      return o(h), e = e.slice(h.length), g;
    }
  }
  function u() {
    l(z8);
  }
  function c(f) {
    var g;
    for (f = f || []; g = p(); )
      g !== !1 && f.push(g);
    return f;
  }
  function p() {
    var f = i();
    if (!(Ix != e.charAt(0) || Nx != e.charAt(1))) {
      for (var g = 2; ta != e.charAt(g) && (Nx != e.charAt(g) || Ix != e.charAt(g + 1)); )
        ++g;
      if (g += 2, ta === e.charAt(g - 1))
        return a("End of comment missing");
      var h = e.slice(2, g - 2);
      return r += 2, o(h), e = e.slice(g), r += 2, f({
        type: q8,
        comment: h
      });
    }
  }
  function d() {
    var f = i(), g = l(U8);
    if (g) {
      if (p(), !l($8)) return a("property missing ':'");
      var h = l(V8), x = f({
        type: G8,
        property: Fx(g[0].replace(Bx, ta)),
        value: h ? Fx(h[0].replace(Bx, ta)) : ta
      });
      return l(H8), x;
    }
  }
  function m() {
    var f = [];
    c(f);
    for (var g; g = d(); )
      g !== !1 && (f.push(g), c(f));
    return f;
  }
  return u(), m();
};
function Fx(e) {
  return e ? e.replace(W8, ta) : ta;
}
var K8 = Pn && Pn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(gw, "__esModule", { value: !0 });
gw.default = X8;
var J8 = K8(Y8);
function X8(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, J8.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var Nh = {};
Object.defineProperty(Nh, "__esModule", { value: !0 });
Nh.camelCase = void 0;
var Q8 = /^--[a-zA-Z0-9_-]+$/, e5 = /-([a-z])/g, t5 = /^[^-]+$/, n5 = /^-(webkit|moz|ms|o|khtml)-/, r5 = /^-(ms)-/, o5 = function(e) {
  return !e || t5.test(e) || Q8.test(e);
}, i5 = function(e, t) {
  return t.toUpperCase();
}, Rx = function(e, t) {
  return "".concat(t, "-");
}, s5 = function(e, t) {
  return t === void 0 && (t = {}), o5(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(r5, Rx) : e = e.replace(n5, Rx), e.replace(e5, i5));
};
Nh.camelCase = s5;
var a5 = Pn && Pn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, l5 = a5(gw), u5 = Nh;
function tb(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, l5.default)(e, function(r, o) {
    r && o && (n[(0, u5.camelCase)(r, t)] = o);
  }), n;
}
tb.default = tb;
var c5 = tb;
(function(e) {
  var t = Pn && Pn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Ee, r = t(c5), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(hw);
Object.defineProperty(_h, "__esModule", { value: !0 });
_h.default = h5;
var $l = Uo, zx = hw, p5 = ["checked", "value"], d5 = ["input", "select", "textarea"], f5 = {
  reset: !0,
  submit: !0
};
function h5(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && f5[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, $l.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = Ux(s);
    if (a) {
      var l = (0, $l.getPropertyInfo)(a);
      switch (p5.includes(a) && d5.includes(t) && !r && (a = Ux("default" + s)), n[a] = i, l && l.type) {
        case $l.BOOLEAN:
          n[a] = !0;
          break;
        case $l.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    zx.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, zx.setStyleProp)(e.style, n), n;
}
function Ux(e) {
  return $l.possibleStandardNames[e];
}
var mw = {}, g5 = Pn && Pn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(mw, "__esModule", { value: !0 });
mw.default = FN;
var fm = Ee, m5 = g5(_h), Ql = hw, v5 = {
  cloneElement: fm.cloneElement,
  createElement: fm.createElement,
  isValidElement: fm.isValidElement
};
function FN(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Ql.returnFirstArg, i = t.library || v5, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var m = !p.data.trim().length;
      if (m && p.parent && !(0, Ql.canTextBeChildOfNode)(p.parent) || t.trim && m)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, g = {};
    y5(f) ? ((0, Ql.setStyleProp)(f.attribs.style, f.attribs), g = f.attribs) : f.attribs && (g = (0, m5.default)(f.attribs, f.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (g.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? g.defaultValue = p.children[0].data : p.children && p.children.length && (h = FN(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), n.push(o(a(p.name, g, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function y5(e) {
  return Ql.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Ql.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Pn && Pn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(iw);
  e.htmlToDOM = n.default;
  var r = t(_h);
  e.attributesToProps = r.default;
  var o = t(mw);
  e.domToReact = o.default;
  var i = aw;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(bN);
const b5 = /* @__PURE__ */ R6(bN);
b5.default;
var kn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function w5(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var nb = { exports: {} }, vl = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $x;
function C5() {
  if ($x) return vl;
  $x = 1;
  var e = Ee, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, m = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: m, props: p, _owner: o.current };
  }
  return vl.Fragment = n, vl.jsx = s, vl.jsxs = s, vl;
}
var Yc = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Vx;
function O5() {
  return Vx || (Vx = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ee, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), f = Symbol.iterator, g = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[g];
      return typeof I == "function" ? I : null;
    }
    var x = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, Y = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          Y[ne - 1] = arguments[ne];
        D("error", b, Y);
      }
    }
    function D(b, I, Y) {
      {
        var ne = x.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (I += "%s", Y = Y.concat([le]));
        var ce = Y.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var O = !1, y = !1, C = !1, S = !1, U = !1, L;
    L = Symbol.for("react.module.reference");
    function F(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || U || b === o || b === u || b === c || S || b === m || O || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function B(b, I, Y) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = I.displayName || I.name || "";
      return le !== "" ? Y + "(" + le + ")" : Y;
    }
    function $(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var I = b;
            return $(I) + ".Consumer";
          case s:
            var Y = b;
            return $(Y._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, ae = le._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, q = 0, X, J, te, ee, k, j, H;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function Z() {
      {
        if (q === 0) {
          X = console.log, J = console.info, te = console.warn, ee = console.error, k = console.group, j = console.groupCollapsed, H = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function E() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: X
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: k
            }),
            groupCollapsed: z({}, b, {
              value: j
            }),
            groupEnd: z({}, b, {
              value: H
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = x.ReactCurrentDispatcher, R;
    function _(b, I, Y) {
      {
        if (R === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            R = ne && ne[1] || "";
          }
        return `
` + R + b;
      }
    }
    var W = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function N(b, I) {
      if (!b || W)
        return "";
      {
        var Y = A.get(b);
        if (Y !== void 0)
          return Y;
      }
      var ne;
      W = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = T.current, T.current = null, Z();
      try {
        if (I) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Re) {
              ne = Re;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Re) {
              ne = Re;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Re) {
            ne = Re;
          }
          b();
        }
      } catch (Re) {
        if (Re && ne && typeof Re.stack == "string") {
          for (var se = Re.stack.split(`
`), Be = ne.stack.split(`
`), we = se.length - 1, Oe = Be.length - 1; we >= 1 && Oe >= 0 && se[we] !== Be[Oe]; )
            Oe--;
          for (; we >= 1 && Oe >= 0; we--, Oe--)
            if (se[we] !== Be[Oe]) {
              if (we !== 1 || Oe !== 1)
                do
                  if (we--, Oe--, Oe < 0 || se[we] !== Be[Oe]) {
                    var qe = `
` + se[we].replace(" at new ", " at ");
                    return b.displayName && qe.includes("<anonymous>") && (qe = qe.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, qe), qe;
                  }
                while (we >= 1 && Oe >= 0);
              break;
            }
        }
      } finally {
        W = !1, T.current = ce, E(), Error.prepareStackTrace = le;
      }
      var Xt = b ? b.displayName || b.name : "", Ct = Xt ? _(Xt) : "";
      return typeof b == "function" && A.set(b, Ct), Ct;
    }
    function ue(b, I, Y) {
      return N(b, !1);
    }
    function ye(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, Y) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, ye(b));
      if (typeof b == "string")
        return _(b);
      switch (b) {
        case u:
          return _("Suspense");
        case c:
          return _("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, Y);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), I, Y);
            } catch {
            }
          }
        }
      return "";
    }
    var Ie = Object.prototype.hasOwnProperty, $e = {}, Ve = x.ReactDebugCurrentFrame;
    function Ne(b) {
      if (b) {
        var I = b._owner, Y = oe(b.type, b._source, I ? I.type : null);
        Ve.setExtraStackFrame(Y);
      } else
        Ve.setExtraStackFrame(null);
    }
    function Je(b, I, Y, ne, le) {
      {
        var ce = Function.call.bind(Ie);
        for (var ae in b)
          if (ce(b, ae)) {
            var se = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Be = Error((ne || "React class") + ": " + Y + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Be.name = "Invariant Violation", Be;
              }
              se = b[ae](I, ae, ne, Y, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (we) {
              se = we;
            }
            se && !(se instanceof Error) && (Ne(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", Y, ae, typeof se), Ne(null)), se instanceof Error && !(se.message in $e) && ($e[se.message] = !0, Ne(le), w("Failed %s type: %s", Y, se.message), Ne(null));
          }
      }
    }
    var Ye = Array.isArray;
    function Te(b) {
      return Ye(b);
    }
    function Ke(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, Y = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return Y;
      }
    }
    function nt(b) {
      try {
        return Me(b), !1;
      } catch {
        return !0;
      }
    }
    function Me(b) {
      return "" + b;
    }
    function Ae(b) {
      if (nt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(b)), Me(b);
    }
    var Fe = x.ReactCurrentOwner, He = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ze, et, _e;
    _e = {};
    function At(b) {
      if (Ie.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function rt(b) {
      if (Ie.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, I) {
      if (typeof b.ref == "string" && Fe.current && I && Fe.current.stateNode !== I) {
        var Y = V(Fe.current.type);
        _e[Y] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Fe.current.type), b.ref), _e[Y] = !0);
      }
    }
    function at(b, I) {
      {
        var Y = function() {
          ze || (ze = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: Y,
          configurable: !0
        });
      }
    }
    function qt(b, I) {
      {
        var Y = function() {
          et || (et = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: Y,
          configurable: !0
        });
      }
    }
    var lt = function(b, I, Y, ne, le, ce, ae) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: Y,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function Gt(b, I, Y, ne, le) {
      {
        var ce, ae = {}, se = null, Be = null;
        Y !== void 0 && (Ae(Y), se = "" + Y), rt(I) && (Ae(I.key), se = "" + I.key), At(I) && (Be = I.ref, ot(I, le));
        for (ce in I)
          Ie.call(I, ce) && !He.hasOwnProperty(ce) && (ae[ce] = I[ce]);
        if (b && b.defaultProps) {
          var we = b.defaultProps;
          for (ce in we)
            ae[ce] === void 0 && (ae[ce] = we[ce]);
        }
        if (se || Be) {
          var Oe = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && at(ae, Oe), Be && qt(ae, Oe);
        }
        return lt(b, se, Be, le, ne, Fe.current, ae);
      }
    }
    var Xe = x.ReactCurrentOwner, bt = x.ReactDebugCurrentFrame;
    function tt(b) {
      if (b) {
        var I = b._owner, Y = oe(b.type, b._source, I ? I.type : null);
        bt.setExtraStackFrame(Y);
      } else
        bt.setExtraStackFrame(null);
    }
    var Yt;
    Yt = !1;
    function ut(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function dn() {
      {
        if (Xe.current) {
          var b = V(Xe.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function Kt(b) {
      return "";
    }
    var fn = {};
    function Jt(b) {
      {
        var I = dn();
        if (!I) {
          var Y = typeof b == "string" ? b : b.displayName || b.name;
          Y && (I = `

Check the top-level render call using <` + Y + ">.");
        }
        return I;
      }
    }
    function hn(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var Y = Jt(I);
        if (fn[Y])
          return;
        fn[Y] = !0;
        var ne = "";
        b && b._owner && b._owner !== Xe.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), tt(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Y, ne), tt(null);
      }
    }
    function Fn(b, I) {
      {
        if (typeof b != "object")
          return;
        if (Te(b))
          for (var Y = 0; Y < b.length; Y++) {
            var ne = b[Y];
            ut(ne) && hn(ne, I);
          }
        else if (ut(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = h(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), ae; !(ae = ce.next()).done; )
              ut(ae.value) && hn(ae.value, I);
        }
      }
    }
    function wt(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var Y;
        if (typeof I == "function")
          Y = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          Y = I.propTypes;
        else
          return;
        if (Y) {
          var ne = V(I);
          Je(Y, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !Yt) {
          Yt = !0;
          var le = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function re(b) {
      {
        for (var I = Object.keys(b.props), Y = 0; Y < I.length; Y++) {
          var ne = I[Y];
          if (ne !== "children" && ne !== "key") {
            tt(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), tt(null);
            break;
          }
        }
        b.ref !== null && (tt(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var qr = {};
    function Gr(b, I, Y, ne, le, ce) {
      {
        var ae = F(b);
        if (!ae) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Be = Kt();
          Be ? se += Be : se += dn();
          var we;
          b === null ? we = "null" : Te(b) ? we = "array" : b !== void 0 && b.$$typeof === t ? (we = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : we = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", we, se);
        }
        var Oe = Gt(b, I, Y, le, ce);
        if (Oe == null)
          return Oe;
        if (ae) {
          var qe = I.children;
          if (qe !== void 0)
            if (ne)
              if (Te(qe)) {
                for (var Xt = 0; Xt < qe.length; Xt++)
                  Fn(qe[Xt], b);
                Object.freeze && Object.freeze(qe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Fn(qe, b);
        }
        if (Ie.call(I, "key")) {
          var Ct = V(b), Re = Object.keys(I).filter(function(gi) {
            return gi !== "key";
          }), Or = Re.length > 0 ? "{key: someKey, " + Re.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!qr[Ct + Or]) {
            var hi = Re.length > 0 ? "{" + Re.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Or, Ct, hi, Ct), qr[Ct + Or] = !0;
          }
        }
        return b === r ? re(Oe) : wt(Oe), Oe;
      }
    }
    function ci(b, I, Y) {
      return Gr(b, I, Y, !0);
    }
    function pi(b, I, Y) {
      return Gr(b, I, Y, !1);
    }
    var di = pi, fi = ci;
    Yc.Fragment = r, Yc.jsx = di, Yc.jsxs = fi;
  }()), Yc;
}
process.env.NODE_ENV === "production" ? nb.exports = C5() : nb.exports = O5();
var no = nb.exports;
Ge({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Hx(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Nr(e) {
  var t, n;
  return Hx(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(Hx(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var RN = Symbol.for("immer-nothing"), Wx = Symbol.for("immer-draftable"), ko = Symbol.for("immer-state"), x5 = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Qr(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = x5[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Ha = Object.getPrototypeOf;
function xa(e) {
  return !!e && !!e[ko];
}
function Ea(e) {
  var t;
  return e ? zN(e) || Array.isArray(e) || !!e[Wx] || !!((t = e.constructor) != null && t[Wx]) || Rh(e) || zh(e) : !1;
}
var E5 = Object.prototype.constructor.toString();
function zN(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Ha(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === E5;
}
function Ud(e, t) {
  Fh(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Fh(e) {
  const t = e[ko];
  return t ? t.type_ : Array.isArray(e) ? 1 : Rh(e) ? 2 : zh(e) ? 3 : 0;
}
function rb(e, t) {
  return Fh(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function UN(e, t, n) {
  const r = Fh(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function L5(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Rh(e) {
  return e instanceof Map;
}
function zh(e) {
  return e instanceof Set;
}
function Ks(e) {
  return e.copy_ || e.base_;
}
function ob(e, t) {
  if (Rh(e))
    return new Map(e);
  if (zh(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = zN(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ko];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(Ha(e), r);
  } else {
    const r = Ha(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function vw(e, t = !1) {
  return Uh(e) || xa(e) || !Ea(e) || (Fh(e) > 1 && (e.set = e.add = e.clear = e.delete = P5), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => vw(r, !0))), e;
}
function P5() {
  Qr(2);
}
function Uh(e) {
  return Object.isFrozen(e);
}
var k5 = {};
function La(e) {
  const t = k5[e];
  return t || Qr(0, e), t;
}
var Su;
function $N() {
  return Su;
}
function S5(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Zx(e, t) {
  t && (La("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function ib(e) {
  sb(e), e.drafts_.forEach(D5), e.drafts_ = null;
}
function sb(e) {
  e === Su && (Su = e.parent_);
}
function qx(e) {
  return Su = S5(Su, e);
}
function D5(e) {
  const t = e[ko];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function Gx(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ko].modified_ && (ib(t), Qr(4)), Ea(e) && (e = $d(t, e), t.parent_ || Vd(t, e)), t.patches_ && La("Patches").generateReplacementPatches_(
    n[ko].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = $d(t, n, []), ib(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== RN ? e : void 0;
}
function $d(e, t, n) {
  if (Uh(t))
    return t;
  const r = t[ko];
  if (!r)
    return Ud(
      t,
      (o, i) => Yx(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Vd(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Ud(
      i,
      (a, l) => Yx(e, r, o, a, l, n, s)
    ), Vd(e, o, !1), n && e.patches_ && La("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Yx(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && Qr(5), xa(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !rb(t.assigned_, r) ? i.concat(r) : void 0, l = $d(e, o, a);
    if (UN(n, r, l), xa(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (Ea(o) && !Uh(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    $d(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Vd(e, o);
  }
}
function Vd(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && vw(t, n);
}
function M5(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : $N(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = yw;
  n && (o = [r], i = Du);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var yw = {
  get(e, t) {
    if (t === ko)
      return e;
    const n = Ks(e);
    if (!rb(n, t))
      return T5(e, n, t);
    const r = n[t];
    return e.finalized_ || !Ea(r) ? r : r === hm(e.base_, t) ? (gm(e), e.copy_[t] = lb(r, e)) : r;
  },
  has(e, t) {
    return t in Ks(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ks(e));
  },
  set(e, t, n) {
    const r = VN(Ks(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = hm(Ks(e), t), i = o == null ? void 0 : o[ko];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (L5(n, o) && (n !== void 0 || rb(e.base_, t)))
        return !0;
      gm(e), ab(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return hm(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, gm(e), ab(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ks(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Qr(11);
  },
  getPrototypeOf(e) {
    return Ha(e.base_);
  },
  setPrototypeOf() {
    Qr(12);
  }
}, Du = {};
Ud(yw, (e, t) => {
  Du[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Du.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Qr(13), Du.set.call(this, e, t, void 0);
};
Du.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Qr(14), yw.set.call(this, e[0], t, n, e[0]);
};
function hm(e, t) {
  const n = e[ko];
  return (n ? Ks(n) : e)[t];
}
function T5(e, t, n) {
  var r;
  const o = VN(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function VN(e, t) {
  if (!(t in e))
    return;
  let n = Ha(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Ha(n);
  }
}
function ab(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && ab(e.parent_));
}
function gm(e) {
  e.copy_ || (e.copy_ = ob(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var j5 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Qr(6), r !== void 0 && typeof r != "function" && Qr(7);
      let o;
      if (Ea(t)) {
        const i = qx(this), s = lb(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? ib(i) : sb(i);
        }
        return Zx(i, r), Gx(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === RN && (o = void 0), this.autoFreeze_ && vw(o, !0), r) {
          const i = [], s = [];
          La("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        Qr(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Ea(e) || Qr(8), xa(e) && (e = _5(e));
    const t = qx(this), n = lb(e, void 0);
    return n[ko].isManual_ = !0, sb(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ko];
    (!n || !n.isManual_) && Qr(9);
    const { scope_: r } = n;
    return Zx(r, t), Gx(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = La("Patches").applyPatches_;
    return xa(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function lb(e, t) {
  const n = Rh(e) ? La("MapSet").proxyMap_(e, t) : zh(e) ? La("MapSet").proxySet_(e, t) : M5(e, t);
  return (t ? t.scope_ : $N()).drafts_.push(n), n;
}
function _5(e) {
  return xa(e) || Qr(10, e), HN(e);
}
function HN(e) {
  if (!Ea(e) || Uh(e))
    return e;
  const t = e[ko];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = ob(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = ob(e, !0);
  return Ud(n, (r, o) => {
    UN(n, r, HN(o));
  }), t && (t.finalized_ = !1), n;
}
var So = new j5(), bw = So.produce;
So.produceWithPatches.bind(
  So
);
So.setAutoFreeze.bind(So);
So.setUseStrictShallowCopy.bind(So);
So.applyPatches.bind(So);
var Kx = So.createDraft.bind(So), Jx = So.finishDraft.bind(So), Se = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Se.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Se.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Se.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Se.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Se.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Se.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Se.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Se.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Se.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Se.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Se.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Se.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Se.isAncestor(t, e) && !Se.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Se.equals(i, r) || Se.endsBefore(i, r) || Se.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (Se.equals(s, r) || Se.isAncestor(s, r))
          return null;
        Se.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        Se.equals(a, r) || Se.endsBefore(a, r) ? r[a.length - 1] -= 1 : Se.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Se.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Se.endsBefore(u, r) ? r[u.length - 1] += 1 : Se.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Se.equals(p, d))
          return r;
        if (Se.isAncestor(p, r) || Se.equals(p, r)) {
          var m = d.slice();
          return Se.endsBefore(p, d) && p.length < d.length && (m[p.length - 1] -= 1), m.concat(r.slice(p.length));
        } else Se.isSibling(p, d) && (Se.isAncestor(d, r) || Se.equals(d, r)) ? Se.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Se.endsBefore(d, r) || Se.equals(d, r) || Se.isAncestor(d, r) ? (Se.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Se.endsBefore(p, r) && (Se.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Mu(e) {
  "@babel/helpers - typeof";
  return Mu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Mu(e);
}
function A5(e, t) {
  if (Mu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Mu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function B5(e) {
  var t = A5(e, "string");
  return Mu(t) === "symbol" ? t : String(t);
}
function Xa(e, t, n) {
  return t = B5(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Xx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Xx(Object(n), !0).forEach(function(r) {
      Xa(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Xx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var I5 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = dt.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of Lt.points(t))
          t[l] = Bn.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = dt.leaf(e, u), m = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = m + p + f, t)
        for (var [g, h] of Lt.points(t))
          t[h] = Bn.transform(g, n);
      break;
    }
    case "merge_node": {
      var {
        path: x
      } = n, w = dt.get(e, x), D = Se.previous(x), O = dt.get(e, D), y = dt.parent(e, x), C = x[x.length - 1];
      if (fr.isText(w) && fr.isText(O))
        O.text += w.text;
      else if (!fr.isText(w) && !fr.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(x, "] to nodes of different interfaces: ").concat(fo.stringify(w), " ").concat(fo.stringify(O)));
      if (y.children.splice(C, 1), t)
        for (var [S, U] of Lt.points(t))
          t[U] = Bn.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: F
      } = n;
      if (Se.isAncestor(L, F))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(F, "] because the destination is inside itself."));
      var B = dt.get(e, L), $ = dt.parent(e, L), V = L[L.length - 1];
      $.children.splice(V, 1);
      var z = Se.transform(L, n), q = dt.get(e, Se.parent(z)), X = z[z.length - 1];
      if (q.children.splice(X, 0, B), t)
        for (var [J, te] of Lt.points(t))
          t[te] = Bn.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, k = ee[ee.length - 1], j = dt.parent(e, ee);
      if (j.children.splice(k, 1), t)
        for (var [H, M] of Lt.points(t)) {
          var Z = Bn.transform(H, n);
          if (t != null && Z != null)
            t[M] = Z;
          else {
            var E = void 0, T = void 0;
            for (var [R, _] of dt.texts(e))
              if (Se.compare(_, ee) === -1)
                E = [R, _];
              else {
                T = [R, _];
                break;
              }
            var W = !1;
            E && T && (Se.equals(T[1], ee) ? W = !Se.hasPrevious(T[1]) : W = Se.common(E[1], ee).length < Se.common(T[1], ee).length), E && !W ? (H.path = E[1], H.offset = E[0].text.length) : T ? (H.path = T[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: N
      } = n;
      if (N.length === 0) break;
      var ue = dt.leaf(e, A), ye = ue.text.slice(0, Q), oe = ue.text.slice(Q + N.length);
      if (ue.text = ye + oe, t)
        for (var [Ie, $e] of Lt.points(t))
          t[$e] = Bn.transform(Ie, n);
      break;
    }
    case "set_node": {
      var {
        path: Ve,
        properties: Ne,
        newProperties: Je
      } = n;
      if (Ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ye = dt.get(e, Ve);
      for (var Te in Je) {
        if (Te === "children" || Te === "text")
          throw new Error('Cannot set the "'.concat(Te, '" property of nodes!'));
        var Ke = Je[Te];
        Ke == null ? delete Ye[Te] : Ye[Te] = Ke;
      }
      for (var nt in Ne)
        Je.hasOwnProperty(nt) || delete Ye[nt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Me
      } = n;
      if (Me == null)
        t = Me;
      else {
        if (t == null) {
          if (!Lt.isRange(Me))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(fo.stringify(Me), " when there is no current selection."));
          t = yl({}, Me);
        }
        for (var Ae in Me) {
          var Fe = Me[Ae];
          if (Fe == null) {
            if (Ae === "anchor" || Ae === "focus")
              throw new Error('Cannot remove the "'.concat(Ae, '" selection property'));
            delete t[Ae];
          } else
            t[Ae] = Fe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: He,
        position: ze,
        properties: et
      } = n;
      if (He.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(He, "] because the root node cannot be split."));
      var _e = dt.get(e, He), At = dt.parent(e, He), rt = He[He.length - 1], ot;
      if (fr.isText(_e)) {
        var at = _e.text.slice(0, ze), qt = _e.text.slice(ze);
        _e.text = at, ot = yl(yl({}, et), {}, {
          text: qt
        });
      } else {
        var lt = _e.children.slice(0, ze), Gt = _e.children.slice(ze);
        _e.children = lt, ot = yl(yl({}, et), {}, {
          children: Gt
        });
      }
      if (At.children.splice(rt + 1, 0, ot), t)
        for (var [Xe, bt] of Lt.points(t))
          t[bt] = Bn.transform(Xe, n);
      break;
    }
  }
  return t;
}, N5 = {
  transform(e, t) {
    e.children = Kx(e.children);
    var n = e.selection && Kx(e.selection);
    try {
      n = I5(e, n, t);
    } finally {
      e.children = Jx(e.children), n ? e.selection = xa(n) ? Jx(n) : n : e.selection = null;
    }
  }
}, F5 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, R5 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, WN = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Nr(r) && Nr(o)) {
      if (!WN(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function z5(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Tu(e, t) {
  if (e == null) return {};
  var n = z5(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var U5 = ["anchor", "focus"];
function Qx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $5(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qx(Object(n), !0).forEach(function(r) {
      Xa(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Qx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Lt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Lt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Lt.edges(e);
    return t;
  },
  equals(e, t) {
    return Bn.equals(e.anchor, t.anchor) && Bn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Lt.isRange(t)) {
      if (Lt.includes(e, t.anchor) || Lt.includes(e, t.focus))
        return !0;
      var [n, r] = Lt.edges(e), [o, i] = Lt.edges(t);
      return Bn.isBefore(n, o) && Bn.isAfter(r, i);
    }
    var [s, a] = Lt.edges(e), l = !1, u = !1;
    return Bn.isPoint(t) ? (l = Bn.compare(t, s) >= 0, u = Bn.compare(t, a) <= 0) : (l = Se.compare(t, s.path) >= 0, u = Se.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Tu(e, U5), [r, o] = Lt.edges(e), [i, s] = Lt.edges(t), a = Bn.isBefore(r, i) ? i : r, l = Bn.isBefore(o, s) ? o : s;
    return Bn.isBefore(l, a) ? null : $5({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Bn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Bn.equals(t, n);
  },
  isExpanded(e) {
    return !Lt.isCollapsed(e);
  },
  isForward(e) {
    return !Lt.isBackward(e);
  },
  isRange(e) {
    return Nr(e) && Bn.isPoint(e.anchor) && Bn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Lt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return bw(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = Lt.isCollapsed(r);
        Lt.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? Lt.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = Bn.transform(r.anchor, t, {
        affinity: i
      }), u = Bn.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, eE = (e) => Nr(e) && dt.isNodeList(e.children) && !On.isEditor(e), Si = {
  isAncestor(e) {
    return Nr(e) && dt.isNodeList(e.children);
  },
  isElement: eE,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Si.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return eE(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, V5 = ["children"], H5 = ["text"], tE = /* @__PURE__ */ new WeakMap(), dt = {
  ancestor(e, t) {
    var n = dt.get(e, t);
    if (fr.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(fo.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Se.ancestors(t, n)) {
        var o = dt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (fr.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(fo.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(fo.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = dt.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = dt.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Se.common(t, n), o = dt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = dt.get(e, t);
    if (On.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(fo.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of dt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of dt.nodes(e, t))
        Si.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Si.isAncestor(e)) {
      var t = Tu(e, V5);
      return t;
    } else {
      var t = Tu(e, H5);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = dt.get(e, n); r && !(fr.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (fr.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(fo.stringify(e)));
    var n = bw({
      children: e.children
    }, (r) => {
      var [o, i] = Lt.edges(t), s = dt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, m] = d;
          return !Lt.includes(t, m);
        }
      });
      for (var [, a] of s) {
        if (!Lt.includes(t, a)) {
          var l = dt.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (Se.equals(a, i.path)) {
          var c = dt.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (Se.equals(a, o.path)) {
          var p = dt.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      On.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (fr.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(fo.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (fr.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return fr.isText(e) || Si.isElement(e) || On.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = tE.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => dt.isNode(r));
    return tE.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = dt.get(e, n); r && !(fr.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = dt.get(e, t);
    if (!fr.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(fo.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Se.levels(t, n)) {
        var o = dt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Si.isElement(e) && Si.isElementProps(t) && Si.matches(e, t) || fr.isText(e) && fr.isTextProps(t) && fr.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? Se.isBefore(a, i) : Se.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !fr.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          Se.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = dt.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = Se.next(a);
          if (dt.has(e, c)) {
            a = c, l = dt.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = Se.previous(a);
          a = p, l = dt.get(e, a);
          continue;
        }
        a = Se.parent(a), l = dt.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Se.parent(t), r = dt.get(e, n);
    if (fr.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return fr.isText(e) ? e.text : e.children.map(dt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of dt.nodes(e, t))
        fr.isText(n) && (yield [n, r]);
    }();
  }
};
function nE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $n(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nE(Object(n), !0).forEach(function(r) {
      Xa(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Vl = {
  isNodeOperation(e) {
    return Vl.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Nr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Se.isPath(e.path) && dt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Se.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Se.isPath(e.path) && Nr(e.properties);
      case "move_node":
        return Se.isPath(e.path) && Se.isPath(e.newPath);
      case "remove_node":
        return Se.isPath(e.path) && dt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Se.isPath(e.path);
      case "set_node":
        return Se.isPath(e.path) && Nr(e.properties) && Nr(e.newProperties);
      case "set_selection":
        return e.properties === null && Lt.isRange(e.newProperties) || e.newProperties === null && Lt.isRange(e.properties) || Nr(e.properties) && Nr(e.newProperties);
      case "split_node":
        return Se.isPath(e.path) && typeof e.position == "number" && Nr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Vl.isOperation(t));
  },
  isSelectionOperation(e) {
    return Vl.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Vl.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return $n($n({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return $n($n({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return $n($n({}, e), {}, {
          type: "split_node",
          path: Se.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Se.equals(t, n))
          return e;
        if (Se.isSibling(n, t))
          return $n($n({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Se.transform(n, e), o = Se.transform(Se.next(n), e);
        return $n($n({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return $n($n({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return $n($n({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return $n($n({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? $n($n({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? $n($n({}, e), {}, {
          properties: null,
          newProperties: a
        }) : $n($n({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return $n($n({}, e), {}, {
          type: "merge_node",
          path: Se.next(e.path)
        });
    }
  }
}, rE = /* @__PURE__ */ new WeakMap(), W5 = (e) => {
  var t = rE.get(e);
  if (t !== void 0)
    return t;
  if (!Nr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Nr(e.marks)) && (e.selection === null || Lt.isRange(e.selection)) && dt.isNodeList(e.children) && Vl.isOperationList(e.operations);
  return rE.set(e, n), n;
}, On = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return W5(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function oE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oE(Object(n), !0).forEach(function(r) {
      Xa(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Bn = {
  compare(e, t) {
    var n = Se.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Bn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Bn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Se.equals(e.path, t.path);
  },
  isPoint(e) {
    return Nr(e) && typeof e.offset == "number" && Se.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return bw(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Se.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Se.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Se.equals(t.path, i) && (r.offset += t.position), r.path = Se.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Se.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Se.equals(t.path, i) || Se.isAncestor(t.path, i))
            return null;
          r.path = Se.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Se.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = Se.transform(i, t, iE(iE({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Se.transform(i, t, n);
          break;
        }
      }
    });
  }
}, sE = void 0, fo = {
  setScrubber(e) {
    sE = e;
  },
  stringify(e) {
    return JSON.stringify(e, sE);
  }
}, Z5 = ["text"], q5 = ["anchor", "focus"];
function aE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aE(Object(n), !0).forEach(function(r) {
      Xa(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var fr = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = Tu(i, Z5);
      return s;
    }
    return WN(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Nr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => fr.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [bi({}, e)];
    for (var r of t) {
      var o = Tu(r, q5), [i, s] = Lt.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, m = l;
        if (l += d, u <= m && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === m) || u > l || c < m || c === m && m !== 0) {
          a.push(p);
          continue;
        }
        var f = p, g = void 0, h = void 0;
        if (c < l) {
          var x = c - m;
          h = bi(bi({}, f), {}, {
            text: f.text.slice(x)
          }), f = bi(bi({}, f), {}, {
            text: f.text.slice(0, x)
          });
        }
        if (u > m) {
          var w = u - m;
          g = bi(bi({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = bi(bi({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), g && a.push(g), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, G5 = (e) => e.selection ? e.selection : e.children.length > 0 ? On.end(e, []) : [0], Tn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Tn || (Tn = {}));
Tn.L, Tn.L | Tn.V | Tn.LV | Tn.LVT, Tn.LV | Tn.V, Tn.V | Tn.T, Tn.LVT | Tn.T, Tn.T, Tn.Any, Tn.Extend | Tn.ZWJ, Tn.Any, Tn.SpacingMark, Tn.Prepend, Tn.Any, Tn.ZWJ, Tn.ExtPict, Tn.RI, Tn.RI;
var Y5 = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    On.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = G5(e)
      } = n;
      if (Se.isPath(o) && (o = On.range(e, o)), Lt.isRange(o))
        if (Lt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Lt.end(o);
          if (!r && On.void(e, {
            at: i
          }))
            return;
          var s = Lt.start(o), a = On.pointRef(e, s), l = On.pointRef(e, i);
          Hd.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Hd.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && On.void(e, {
        at: o
      }) || On.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function lE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lE(Object(n), !0).forEach(function(r) {
      Xa(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Hd = Kc(Kc(Kc(Kc({}, N5), F5), R5), Y5), ZN = {}, ww = {}, Cw = {};
Object.defineProperty(Cw, "__esModule", { value: !0 });
Cw.default = Q5;
var uE = "html", cE = "head", Jc = "body", K5 = /<([a-zA-Z]+[0-9]?)/, pE = /<head[^]*>/i, dE = /<body[^]*>/i, Wd = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, ub = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, fE = typeof window == "object" && window.DOMParser;
if (typeof fE == "function") {
  var J5 = new fE(), X5 = "text/html";
  ub = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), J5.parseFromString(e, X5);
  }, Wd = ub;
}
if (typeof document == "object" && document.implementation) {
  var Xc = document.implementation.createHTMLDocument();
  Wd = function(e, t) {
    if (t) {
      var n = Xc.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Xc;
    }
    return Xc.documentElement.innerHTML = e, Xc;
  };
}
var Qc = typeof document == "object" && document.createElement("template"), cb;
Qc && Qc.content && (cb = function(e) {
  return Qc.innerHTML = e, Qc.content.childNodes;
});
function Q5(e) {
  var t, n, r = e.match(K5), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case uE: {
      var i = ub(e);
      if (!pE.test(e)) {
        var s = i.querySelector(cE);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!dE.test(e)) {
        var s = i.querySelector(Jc);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(uE);
    }
    case cE:
    case Jc: {
      var a = Wd(e).querySelectorAll(o);
      return dE.test(e) && pE.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (cb)
        return cb(e);
      var s = Wd(e, Jc).querySelector(Jc);
      return s.childNodes;
    }
  }
}
var $h = {}, Ow = {}, xw = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(xw);
var Tt = {}, Ps = kn && kn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), eu = kn && kn.__assign || function() {
  return eu = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, eu.apply(this, arguments);
};
Object.defineProperty(Tt, "__esModule", { value: !0 });
Tt.cloneNode = Tt.hasChildren = Tt.isDocument = Tt.isDirective = Tt.isComment = Tt.isText = Tt.isCDATA = Tt.isTag = Tt.Element = Tt.Document = Tt.CDATA = Tt.NodeWithChildren = Tt.ProcessingInstruction = Tt.Comment = Tt.Text = Tt.DataNode = Tt.Node = void 0;
var ao = xw, Ew = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), Lw(this, t);
    }, e;
  }()
);
Tt.Node = Ew;
var Vh = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ew)
);
Tt.DataNode = Vh;
var qN = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ao.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Vh)
);
Tt.Text = qN;
var GN = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ao.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Vh)
);
Tt.Comment = GN;
var YN = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = ao.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Vh)
);
Tt.ProcessingInstruction = YN;
var Hh = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ew)
);
Tt.NodeWithChildren = Hh;
var KN = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ao.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Hh)
);
Tt.CDATA = KN;
var JN = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ao.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Hh)
);
Tt.Document = JN;
var XN = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? ao.ElementType.Script : n === "style" ? ao.ElementType.Style : ao.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Hh)
);
Tt.Element = XN;
function QN(e) {
  return (0, ao.isTag)(e);
}
Tt.isTag = QN;
function eF(e) {
  return e.type === ao.ElementType.CDATA;
}
Tt.isCDATA = eF;
function tF(e) {
  return e.type === ao.ElementType.Text;
}
Tt.isText = tF;
function nF(e) {
  return e.type === ao.ElementType.Comment;
}
Tt.isComment = nF;
function rF(e) {
  return e.type === ao.ElementType.Directive;
}
Tt.isDirective = rF;
function oF(e) {
  return e.type === ao.ElementType.Root;
}
Tt.isDocument = oF;
function e4(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Tt.hasChildren = e4;
function Lw(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (tF(e))
    n = new qN(e.data);
  else if (nF(e))
    n = new GN(e.data);
  else if (QN(e)) {
    var r = t ? mm(e.children) : [], o = new XN(e.name, eu({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = eu({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = eu({}, e["x-attribsPrefix"])), n = o;
  } else if (eF(e)) {
    var r = t ? mm(e.children) : [], i = new KN(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (oF(e)) {
    var r = t ? mm(e.children) : [], s = new JN(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (rF(e)) {
    var a = new YN(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Tt.cloneNode = Lw;
function mm(e) {
  for (var t = e.map(function(r) {
    return Lw(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = kn && kn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = kn && kn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = xw, o = Tt;
  n(Tt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(Ow);
var iF = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(iF);
Object.defineProperty($h, "__esModule", { value: !0 });
$h.formatAttributes = sF;
$h.formatDOM = aF;
var ep = Ow, t4 = iF;
function n4(e) {
  return t4.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function sF(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function r4(e) {
  e = e.toLowerCase();
  var t = n4(e);
  return t || e;
}
function aF(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = r4(a.nodeName);
        o = new ep.Element(l, sF(a.attributes)), o.children = aF(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new ep.Text(a.nodeValue);
        break;
      case 8:
        o = new ep.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new ep.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var o4 = kn && kn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ww, "__esModule", { value: !0 });
ww.default = l4;
var i4 = o4(Cw), s4 = $h, a4 = /<(![a-zA-Z\s]+)>/;
function l4(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(a4), n = t ? t[1] : void 0;
  return (0, s4.formatDOM)((0, i4.default)(e), null, n);
}
var Wh = {}, $o = {}, Zh = {}, u4 = 0;
Zh.SAME = u4;
var c4 = 1;
Zh.CAMELCASE = c4;
Zh.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const lF = 0, ks = 1, qh = 2, Gh = 3, Pw = 4, uF = 5, cF = 6;
function p4(e) {
  return jr.hasOwnProperty(e) ? jr[e] : null;
}
function Wr(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === qh || t === Gh || t === Pw, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const jr = {}, d4 = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
d4.forEach((e) => {
  jr[e] = new Wr(
    e,
    lF,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  jr[e] = new Wr(
    e,
    ks,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  jr[e] = new Wr(
    e,
    qh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  jr[e] = new Wr(
    e,
    qh,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  jr[e] = new Wr(
    e,
    Gh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  jr[e] = new Wr(
    e,
    Gh,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  jr[e] = new Wr(
    e,
    Pw,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  jr[e] = new Wr(
    e,
    cF,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  jr[e] = new Wr(
    e,
    uF,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const kw = /[\-\:]([a-z])/g, Sw = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(kw, Sw);
  jr[t] = new Wr(
    t,
    ks,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(kw, Sw);
  jr[t] = new Wr(
    t,
    ks,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(kw, Sw);
  jr[t] = new Wr(
    t,
    ks,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  jr[e] = new Wr(
    e,
    ks,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const f4 = "xlinkHref";
jr[f4] = new Wr(
  "xlinkHref",
  ks,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  jr[e] = new Wr(
    e,
    ks,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: h4,
  SAME: g4,
  possibleStandardNames: hE
} = Zh, m4 = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", v4 = m4 + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", y4 = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + v4 + "]*$")
), b4 = Object.keys(
  hE
).reduce((e, t) => {
  const n = hE[t];
  return n === g4 ? e[t] = t : n === h4 ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
$o.BOOLEAN = Gh;
$o.BOOLEANISH_STRING = qh;
$o.NUMERIC = uF;
$o.OVERLOADED_BOOLEAN = Pw;
$o.POSITIVE_NUMERIC = cF;
$o.RESERVED = lF;
$o.STRING = ks;
$o.getPropertyInfo = p4;
$o.isCustomAttribute = y4;
$o.possibleStandardNames = b4;
var Dw = {}, Mw = {}, gE = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, w4 = /\n/g, C4 = /^\s*/, O4 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, x4 = /^:\s*/, E4 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, L4 = /^[;\s]*/, P4 = /^\s+|\s+$/g, k4 = `
`, mE = "/", vE = "*", na = "", S4 = "comment", D4 = "declaration", M4 = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var g = f.match(w4);
    g && (n += g.length);
    var h = f.lastIndexOf(k4);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(g) {
      return g.position = new s(f), u(), g;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var g = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (g.reason = f, g.filename = t.source, g.line = n, g.column = r, g.source = e, !t.silent) throw g;
  }
  function l(f) {
    var g = f.exec(e);
    if (g) {
      var h = g[0];
      return o(h), e = e.slice(h.length), g;
    }
  }
  function u() {
    l(C4);
  }
  function c(f) {
    var g;
    for (f = f || []; g = p(); )
      g !== !1 && f.push(g);
    return f;
  }
  function p() {
    var f = i();
    if (!(mE != e.charAt(0) || vE != e.charAt(1))) {
      for (var g = 2; na != e.charAt(g) && (vE != e.charAt(g) || mE != e.charAt(g + 1)); )
        ++g;
      if (g += 2, na === e.charAt(g - 1))
        return a("End of comment missing");
      var h = e.slice(2, g - 2);
      return r += 2, o(h), e = e.slice(g), r += 2, f({
        type: S4,
        comment: h
      });
    }
  }
  function d() {
    var f = i(), g = l(O4);
    if (g) {
      if (p(), !l(x4)) return a("property missing ':'");
      var h = l(E4), x = f({
        type: D4,
        property: yE(g[0].replace(gE, na)),
        value: h ? yE(h[0].replace(gE, na)) : na
      });
      return l(L4), x;
    }
  }
  function m() {
    var f = [];
    c(f);
    for (var g; g = d(); )
      g !== !1 && (f.push(g), c(f));
    return f;
  }
  return u(), m();
};
function yE(e) {
  return e ? e.replace(P4, na) : na;
}
var T4 = kn && kn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Mw, "__esModule", { value: !0 });
Mw.default = _4;
var j4 = T4(M4);
function _4(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, j4.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var Yh = {};
Object.defineProperty(Yh, "__esModule", { value: !0 });
Yh.camelCase = void 0;
var A4 = /^--[a-zA-Z0-9_-]+$/, B4 = /-([a-z])/g, I4 = /^[^-]+$/, N4 = /^-(webkit|moz|ms|o|khtml)-/, F4 = /^-(ms)-/, R4 = function(e) {
  return !e || I4.test(e) || A4.test(e);
}, z4 = function(e, t) {
  return t.toUpperCase();
}, bE = function(e, t) {
  return "".concat(t, "-");
}, U4 = function(e, t) {
  return t === void 0 && (t = {}), R4(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(F4, bE) : e = e.replace(N4, bE), e.replace(B4, z4));
};
Yh.camelCase = U4;
var $4 = kn && kn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, V4 = $4(Mw), H4 = Yh;
function pb(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, V4.default)(e, function(r, o) {
    r && o && (n[(0, H4.camelCase)(r, t)] = o);
  }), n;
}
pb.default = pb;
var W4 = pb;
(function(e) {
  var t = kn && kn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Ee, r = t(W4), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Dw);
Object.defineProperty(Wh, "__esModule", { value: !0 });
Wh.default = Y4;
var Hl = $o, wE = Dw, Z4 = ["checked", "value"], q4 = ["input", "select", "textarea"], G4 = {
  reset: !0,
  submit: !0
};
function Y4(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && G4[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Hl.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = CE(s);
    if (a) {
      var l = (0, Hl.getPropertyInfo)(a);
      switch (Z4.includes(a) && q4.includes(t) && !r && (a = CE("default" + s)), n[a] = i, l && l.type) {
        case Hl.BOOLEAN:
          n[a] = !0;
          break;
        case Hl.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    wE.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, wE.setStyleProp)(e.style, n), n;
}
function CE(e) {
  return Hl.possibleStandardNames[e];
}
var Tw = {}, K4 = kn && kn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Tw, "__esModule", { value: !0 });
Tw.default = pF;
var vm = Ee, J4 = K4(Wh), tu = Dw, X4 = {
  cloneElement: vm.cloneElement,
  createElement: vm.createElement,
  isValidElement: vm.isValidElement
};
function pF(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || tu.returnFirstArg, i = t.library || X4, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var m = !p.data.trim().length;
      if (m && p.parent && !(0, tu.canTextBeChildOfNode)(p.parent) || t.trim && m)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, g = {};
    Q4(f) ? ((0, tu.setStyleProp)(f.attribs.style, f.attribs), g = f.attribs) : f.attribs && (g = (0, J4.default)(f.attribs, f.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (g.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? g.defaultValue = p.children[0].data : p.children && p.children.length && (h = pF(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), n.push(o(a(p.name, g, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Q4(e) {
  return tu.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, tu.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = kn && kn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(ww);
  e.htmlToDOM = n.default;
  var r = t(Wh);
  e.attributesToProps = r.default;
  var o = t(Tw);
  e.domToReact = o.default;
  var i = Ow;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(ZN);
const e7 = /* @__PURE__ */ w5(ZN);
e7.default;
var Sn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function t7(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var db = { exports: {} }, bl = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var OE;
function n7() {
  if (OE) return bl;
  OE = 1;
  var e = Ee, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, m = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: m, props: p, _owner: o.current };
  }
  return bl.Fragment = n, bl.jsx = s, bl.jsxs = s, bl;
}
var tp = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xE;
function r7() {
  return xE || (xE = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ee, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), f = Symbol.iterator, g = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[g];
      return typeof I == "function" ? I : null;
    }
    var x = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, Y = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          Y[ne - 1] = arguments[ne];
        D("error", b, Y);
      }
    }
    function D(b, I, Y) {
      {
        var ne = x.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (I += "%s", Y = Y.concat([le]));
        var ce = Y.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var O = !1, y = !1, C = !1, S = !1, U = !1, L;
    L = Symbol.for("react.module.reference");
    function F(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || U || b === o || b === u || b === c || S || b === m || O || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function B(b, I, Y) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = I.displayName || I.name || "";
      return le !== "" ? Y + "(" + le + ")" : Y;
    }
    function $(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var I = b;
            return $(I) + ".Consumer";
          case s:
            var Y = b;
            return $(Y._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, ae = le._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, q = 0, X, J, te, ee, k, j, H;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function Z() {
      {
        if (q === 0) {
          X = console.log, J = console.info, te = console.warn, ee = console.error, k = console.group, j = console.groupCollapsed, H = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function E() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: X
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: k
            }),
            groupCollapsed: z({}, b, {
              value: j
            }),
            groupEnd: z({}, b, {
              value: H
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = x.ReactCurrentDispatcher, R;
    function _(b, I, Y) {
      {
        if (R === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            R = ne && ne[1] || "";
          }
        return `
` + R + b;
      }
    }
    var W = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function N(b, I) {
      if (!b || W)
        return "";
      {
        var Y = A.get(b);
        if (Y !== void 0)
          return Y;
      }
      var ne;
      W = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = T.current, T.current = null, Z();
      try {
        if (I) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Re) {
              ne = Re;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Re) {
              ne = Re;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Re) {
            ne = Re;
          }
          b();
        }
      } catch (Re) {
        if (Re && ne && typeof Re.stack == "string") {
          for (var se = Re.stack.split(`
`), Be = ne.stack.split(`
`), we = se.length - 1, Oe = Be.length - 1; we >= 1 && Oe >= 0 && se[we] !== Be[Oe]; )
            Oe--;
          for (; we >= 1 && Oe >= 0; we--, Oe--)
            if (se[we] !== Be[Oe]) {
              if (we !== 1 || Oe !== 1)
                do
                  if (we--, Oe--, Oe < 0 || se[we] !== Be[Oe]) {
                    var qe = `
` + se[we].replace(" at new ", " at ");
                    return b.displayName && qe.includes("<anonymous>") && (qe = qe.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, qe), qe;
                  }
                while (we >= 1 && Oe >= 0);
              break;
            }
        }
      } finally {
        W = !1, T.current = ce, E(), Error.prepareStackTrace = le;
      }
      var Xt = b ? b.displayName || b.name : "", Ct = Xt ? _(Xt) : "";
      return typeof b == "function" && A.set(b, Ct), Ct;
    }
    function ue(b, I, Y) {
      return N(b, !1);
    }
    function ye(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, Y) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, ye(b));
      if (typeof b == "string")
        return _(b);
      switch (b) {
        case u:
          return _("Suspense");
        case c:
          return _("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, Y);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), I, Y);
            } catch {
            }
          }
        }
      return "";
    }
    var Ie = Object.prototype.hasOwnProperty, $e = {}, Ve = x.ReactDebugCurrentFrame;
    function Ne(b) {
      if (b) {
        var I = b._owner, Y = oe(b.type, b._source, I ? I.type : null);
        Ve.setExtraStackFrame(Y);
      } else
        Ve.setExtraStackFrame(null);
    }
    function Je(b, I, Y, ne, le) {
      {
        var ce = Function.call.bind(Ie);
        for (var ae in b)
          if (ce(b, ae)) {
            var se = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Be = Error((ne || "React class") + ": " + Y + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Be.name = "Invariant Violation", Be;
              }
              se = b[ae](I, ae, ne, Y, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (we) {
              se = we;
            }
            se && !(se instanceof Error) && (Ne(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", Y, ae, typeof se), Ne(null)), se instanceof Error && !(se.message in $e) && ($e[se.message] = !0, Ne(le), w("Failed %s type: %s", Y, se.message), Ne(null));
          }
      }
    }
    var Ye = Array.isArray;
    function Te(b) {
      return Ye(b);
    }
    function Ke(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, Y = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return Y;
      }
    }
    function nt(b) {
      try {
        return Me(b), !1;
      } catch {
        return !0;
      }
    }
    function Me(b) {
      return "" + b;
    }
    function Ae(b) {
      if (nt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(b)), Me(b);
    }
    var Fe = x.ReactCurrentOwner, He = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ze, et, _e;
    _e = {};
    function At(b) {
      if (Ie.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function rt(b) {
      if (Ie.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, I) {
      if (typeof b.ref == "string" && Fe.current && I && Fe.current.stateNode !== I) {
        var Y = V(Fe.current.type);
        _e[Y] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Fe.current.type), b.ref), _e[Y] = !0);
      }
    }
    function at(b, I) {
      {
        var Y = function() {
          ze || (ze = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: Y,
          configurable: !0
        });
      }
    }
    function qt(b, I) {
      {
        var Y = function() {
          et || (et = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: Y,
          configurable: !0
        });
      }
    }
    var lt = function(b, I, Y, ne, le, ce, ae) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: Y,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function Gt(b, I, Y, ne, le) {
      {
        var ce, ae = {}, se = null, Be = null;
        Y !== void 0 && (Ae(Y), se = "" + Y), rt(I) && (Ae(I.key), se = "" + I.key), At(I) && (Be = I.ref, ot(I, le));
        for (ce in I)
          Ie.call(I, ce) && !He.hasOwnProperty(ce) && (ae[ce] = I[ce]);
        if (b && b.defaultProps) {
          var we = b.defaultProps;
          for (ce in we)
            ae[ce] === void 0 && (ae[ce] = we[ce]);
        }
        if (se || Be) {
          var Oe = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && at(ae, Oe), Be && qt(ae, Oe);
        }
        return lt(b, se, Be, le, ne, Fe.current, ae);
      }
    }
    var Xe = x.ReactCurrentOwner, bt = x.ReactDebugCurrentFrame;
    function tt(b) {
      if (b) {
        var I = b._owner, Y = oe(b.type, b._source, I ? I.type : null);
        bt.setExtraStackFrame(Y);
      } else
        bt.setExtraStackFrame(null);
    }
    var Yt;
    Yt = !1;
    function ut(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function dn() {
      {
        if (Xe.current) {
          var b = V(Xe.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function Kt(b) {
      return "";
    }
    var fn = {};
    function Jt(b) {
      {
        var I = dn();
        if (!I) {
          var Y = typeof b == "string" ? b : b.displayName || b.name;
          Y && (I = `

Check the top-level render call using <` + Y + ">.");
        }
        return I;
      }
    }
    function hn(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var Y = Jt(I);
        if (fn[Y])
          return;
        fn[Y] = !0;
        var ne = "";
        b && b._owner && b._owner !== Xe.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), tt(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Y, ne), tt(null);
      }
    }
    function Fn(b, I) {
      {
        if (typeof b != "object")
          return;
        if (Te(b))
          for (var Y = 0; Y < b.length; Y++) {
            var ne = b[Y];
            ut(ne) && hn(ne, I);
          }
        else if (ut(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = h(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), ae; !(ae = ce.next()).done; )
              ut(ae.value) && hn(ae.value, I);
        }
      }
    }
    function wt(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var Y;
        if (typeof I == "function")
          Y = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          Y = I.propTypes;
        else
          return;
        if (Y) {
          var ne = V(I);
          Je(Y, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !Yt) {
          Yt = !0;
          var le = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function re(b) {
      {
        for (var I = Object.keys(b.props), Y = 0; Y < I.length; Y++) {
          var ne = I[Y];
          if (ne !== "children" && ne !== "key") {
            tt(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), tt(null);
            break;
          }
        }
        b.ref !== null && (tt(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var qr = {};
    function Gr(b, I, Y, ne, le, ce) {
      {
        var ae = F(b);
        if (!ae) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Be = Kt();
          Be ? se += Be : se += dn();
          var we;
          b === null ? we = "null" : Te(b) ? we = "array" : b !== void 0 && b.$$typeof === t ? (we = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : we = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", we, se);
        }
        var Oe = Gt(b, I, Y, le, ce);
        if (Oe == null)
          return Oe;
        if (ae) {
          var qe = I.children;
          if (qe !== void 0)
            if (ne)
              if (Te(qe)) {
                for (var Xt = 0; Xt < qe.length; Xt++)
                  Fn(qe[Xt], b);
                Object.freeze && Object.freeze(qe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Fn(qe, b);
        }
        if (Ie.call(I, "key")) {
          var Ct = V(b), Re = Object.keys(I).filter(function(gi) {
            return gi !== "key";
          }), Or = Re.length > 0 ? "{key: someKey, " + Re.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!qr[Ct + Or]) {
            var hi = Re.length > 0 ? "{" + Re.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Or, Ct, hi, Ct), qr[Ct + Or] = !0;
          }
        }
        return b === r ? re(Oe) : wt(Oe), Oe;
      }
    }
    function ci(b, I, Y) {
      return Gr(b, I, Y, !0);
    }
    function pi(b, I, Y) {
      return Gr(b, I, Y, !1);
    }
    var di = pi, fi = ci;
    tp.Fragment = r, tp.jsx = di, tp.jsxs = fi;
  }()), tp;
}
process.env.NODE_ENV === "production" ? db.exports = n7() : db.exports = r7();
var ro = db.exports;
Ge({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function EE(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Fr(e) {
  var t, n;
  return EE(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(EE(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var dF = Symbol.for("immer-nothing"), LE = Symbol.for("immer-draftable"), Do = Symbol.for("immer-state"), o7 = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function eo(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = o7[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Wa = Object.getPrototypeOf;
function Pa(e) {
  return !!e && !!e[Do];
}
function ka(e) {
  var t;
  return e ? fF(e) || Array.isArray(e) || !!e[LE] || !!((t = e.constructor) != null && t[LE]) || Jh(e) || Xh(e) : !1;
}
var i7 = Object.prototype.constructor.toString();
function fF(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Wa(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === i7;
}
function Zd(e, t) {
  Kh(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Kh(e) {
  const t = e[Do];
  return t ? t.type_ : Array.isArray(e) ? 1 : Jh(e) ? 2 : Xh(e) ? 3 : 0;
}
function fb(e, t) {
  return Kh(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function hF(e, t, n) {
  const r = Kh(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function s7(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Jh(e) {
  return e instanceof Map;
}
function Xh(e) {
  return e instanceof Set;
}
function Js(e) {
  return e.copy_ || e.base_;
}
function hb(e, t) {
  if (Jh(e))
    return new Map(e);
  if (Xh(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = fF(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Do];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(Wa(e), r);
  } else {
    const r = Wa(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function jw(e, t = !1) {
  return Qh(e) || Pa(e) || !ka(e) || (Kh(e) > 1 && (e.set = e.add = e.clear = e.delete = a7), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => jw(r, !0))), e;
}
function a7() {
  eo(2);
}
function Qh(e) {
  return Object.isFrozen(e);
}
var l7 = {};
function Sa(e) {
  const t = l7[e];
  return t || eo(0, e), t;
}
var ju;
function gF() {
  return ju;
}
function u7(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function PE(e, t) {
  t && (Sa("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function gb(e) {
  mb(e), e.drafts_.forEach(c7), e.drafts_ = null;
}
function mb(e) {
  e === ju && (ju = e.parent_);
}
function kE(e) {
  return ju = u7(ju, e);
}
function c7(e) {
  const t = e[Do];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function SE(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Do].modified_ && (gb(t), eo(4)), ka(e) && (e = qd(t, e), t.parent_ || Gd(t, e)), t.patches_ && Sa("Patches").generateReplacementPatches_(
    n[Do].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = qd(t, n, []), gb(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== dF ? e : void 0;
}
function qd(e, t, n) {
  if (Qh(t))
    return t;
  const r = t[Do];
  if (!r)
    return Zd(
      t,
      (o, i) => DE(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Gd(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Zd(
      i,
      (a, l) => DE(e, r, o, a, l, n, s)
    ), Gd(e, o, !1), n && e.patches_ && Sa("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function DE(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && eo(5), Pa(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !fb(t.assigned_, r) ? i.concat(r) : void 0, l = qd(e, o, a);
    if (hF(n, r, l), Pa(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (ka(o) && !Qh(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    qd(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Gd(e, o);
  }
}
function Gd(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && jw(t, n);
}
function p7(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : gF(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = _w;
  n && (o = [r], i = _u);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var _w = {
  get(e, t) {
    if (t === Do)
      return e;
    const n = Js(e);
    if (!fb(n, t))
      return d7(e, n, t);
    const r = n[t];
    return e.finalized_ || !ka(r) ? r : r === ym(e.base_, t) ? (bm(e), e.copy_[t] = yb(r, e)) : r;
  },
  has(e, t) {
    return t in Js(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Js(e));
  },
  set(e, t, n) {
    const r = mF(Js(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = ym(Js(e), t), i = o == null ? void 0 : o[Do];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (s7(n, o) && (n !== void 0 || fb(e.base_, t)))
        return !0;
      bm(e), vb(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return ym(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, bm(e), vb(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Js(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    eo(11);
  },
  getPrototypeOf(e) {
    return Wa(e.base_);
  },
  setPrototypeOf() {
    eo(12);
  }
}, _u = {};
Zd(_w, (e, t) => {
  _u[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
_u.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && eo(13), _u.set.call(this, e, t, void 0);
};
_u.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && eo(14), _w.set.call(this, e[0], t, n, e[0]);
};
function ym(e, t) {
  const n = e[Do];
  return (n ? Js(n) : e)[t];
}
function d7(e, t, n) {
  var r;
  const o = mF(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function mF(e, t) {
  if (!(t in e))
    return;
  let n = Wa(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Wa(n);
  }
}
function vb(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && vb(e.parent_));
}
function bm(e) {
  e.copy_ || (e.copy_ = hb(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var f7 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && eo(6), r !== void 0 && typeof r != "function" && eo(7);
      let o;
      if (ka(t)) {
        const i = kE(this), s = yb(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? gb(i) : mb(i);
        }
        return PE(i, r), SE(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === dF && (o = void 0), this.autoFreeze_ && jw(o, !0), r) {
          const i = [], s = [];
          Sa("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        eo(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ka(e) || eo(8), Pa(e) && (e = h7(e));
    const t = kE(this), n = yb(e, void 0);
    return n[Do].isManual_ = !0, mb(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Do];
    (!n || !n.isManual_) && eo(9);
    const { scope_: r } = n;
    return PE(r, t), SE(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Sa("Patches").applyPatches_;
    return Pa(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function yb(e, t) {
  const n = Jh(e) ? Sa("MapSet").proxyMap_(e, t) : Xh(e) ? Sa("MapSet").proxySet_(e, t) : p7(e, t);
  return (t ? t.scope_ : gF()).drafts_.push(n), n;
}
function h7(e) {
  return Pa(e) || eo(10, e), vF(e);
}
function vF(e) {
  if (!ka(e) || Qh(e))
    return e;
  const t = e[Do];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = hb(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = hb(e, !0);
  return Zd(n, (r, o) => {
    hF(n, r, vF(o));
  }), t && (t.finalized_ = !1), n;
}
var Mo = new f7(), Aw = Mo.produce;
Mo.produceWithPatches.bind(
  Mo
);
Mo.setAutoFreeze.bind(Mo);
Mo.setUseStrictShallowCopy.bind(Mo);
Mo.applyPatches.bind(Mo);
var ME = Mo.createDraft.bind(Mo), TE = Mo.finishDraft.bind(Mo), De = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = De.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return De.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return De.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return De.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return De.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && De.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return De.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && De.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && De.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && De.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && De.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && De.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!De.isAncestor(t, e) && !De.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (De.equals(i, r) || De.endsBefore(i, r) || De.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (De.equals(s, r) || De.isAncestor(s, r))
          return null;
        De.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        De.equals(a, r) || De.endsBefore(a, r) ? r[a.length - 1] -= 1 : De.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (De.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else De.endsBefore(u, r) ? r[u.length - 1] += 1 : De.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (De.equals(p, d))
          return r;
        if (De.isAncestor(p, r) || De.equals(p, r)) {
          var m = d.slice();
          return De.endsBefore(p, d) && p.length < d.length && (m[p.length - 1] -= 1), m.concat(r.slice(p.length));
        } else De.isSibling(p, d) && (De.isAncestor(d, r) || De.equals(d, r)) ? De.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : De.endsBefore(d, r) || De.equals(d, r) || De.isAncestor(d, r) ? (De.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : De.endsBefore(p, r) && (De.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Au(e) {
  "@babel/helpers - typeof";
  return Au = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Au(e);
}
function g7(e, t) {
  if (Au(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Au(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function m7(e) {
  var t = g7(e, "string");
  return Au(t) === "symbol" ? t : String(t);
}
function Qa(e, t, n) {
  return t = m7(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function jE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jE(Object(n), !0).forEach(function(r) {
      Qa(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var v7 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = ft.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of Pt.points(t))
          t[l] = In.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = ft.leaf(e, u), m = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = m + p + f, t)
        for (var [g, h] of Pt.points(t))
          t[h] = In.transform(g, n);
      break;
    }
    case "merge_node": {
      var {
        path: x
      } = n, w = ft.get(e, x), D = De.previous(x), O = ft.get(e, D), y = ft.parent(e, x), C = x[x.length - 1];
      if (hr.isText(w) && hr.isText(O))
        O.text += w.text;
      else if (!hr.isText(w) && !hr.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(x, "] to nodes of different interfaces: ").concat(ho.stringify(w), " ").concat(ho.stringify(O)));
      if (y.children.splice(C, 1), t)
        for (var [S, U] of Pt.points(t))
          t[U] = In.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: F
      } = n;
      if (De.isAncestor(L, F))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(F, "] because the destination is inside itself."));
      var B = ft.get(e, L), $ = ft.parent(e, L), V = L[L.length - 1];
      $.children.splice(V, 1);
      var z = De.transform(L, n), q = ft.get(e, De.parent(z)), X = z[z.length - 1];
      if (q.children.splice(X, 0, B), t)
        for (var [J, te] of Pt.points(t))
          t[te] = In.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, k = ee[ee.length - 1], j = ft.parent(e, ee);
      if (j.children.splice(k, 1), t)
        for (var [H, M] of Pt.points(t)) {
          var Z = In.transform(H, n);
          if (t != null && Z != null)
            t[M] = Z;
          else {
            var E = void 0, T = void 0;
            for (var [R, _] of ft.texts(e))
              if (De.compare(_, ee) === -1)
                E = [R, _];
              else {
                T = [R, _];
                break;
              }
            var W = !1;
            E && T && (De.equals(T[1], ee) ? W = !De.hasPrevious(T[1]) : W = De.common(E[1], ee).length < De.common(T[1], ee).length), E && !W ? (H.path = E[1], H.offset = E[0].text.length) : T ? (H.path = T[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: N
      } = n;
      if (N.length === 0) break;
      var ue = ft.leaf(e, A), ye = ue.text.slice(0, Q), oe = ue.text.slice(Q + N.length);
      if (ue.text = ye + oe, t)
        for (var [Ie, $e] of Pt.points(t))
          t[$e] = In.transform(Ie, n);
      break;
    }
    case "set_node": {
      var {
        path: Ve,
        properties: Ne,
        newProperties: Je
      } = n;
      if (Ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ye = ft.get(e, Ve);
      for (var Te in Je) {
        if (Te === "children" || Te === "text")
          throw new Error('Cannot set the "'.concat(Te, '" property of nodes!'));
        var Ke = Je[Te];
        Ke == null ? delete Ye[Te] : Ye[Te] = Ke;
      }
      for (var nt in Ne)
        Je.hasOwnProperty(nt) || delete Ye[nt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Me
      } = n;
      if (Me == null)
        t = Me;
      else {
        if (t == null) {
          if (!Pt.isRange(Me))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(ho.stringify(Me), " when there is no current selection."));
          t = wl({}, Me);
        }
        for (var Ae in Me) {
          var Fe = Me[Ae];
          if (Fe == null) {
            if (Ae === "anchor" || Ae === "focus")
              throw new Error('Cannot remove the "'.concat(Ae, '" selection property'));
            delete t[Ae];
          } else
            t[Ae] = Fe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: He,
        position: ze,
        properties: et
      } = n;
      if (He.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(He, "] because the root node cannot be split."));
      var _e = ft.get(e, He), At = ft.parent(e, He), rt = He[He.length - 1], ot;
      if (hr.isText(_e)) {
        var at = _e.text.slice(0, ze), qt = _e.text.slice(ze);
        _e.text = at, ot = wl(wl({}, et), {}, {
          text: qt
        });
      } else {
        var lt = _e.children.slice(0, ze), Gt = _e.children.slice(ze);
        _e.children = lt, ot = wl(wl({}, et), {}, {
          children: Gt
        });
      }
      if (At.children.splice(rt + 1, 0, ot), t)
        for (var [Xe, bt] of Pt.points(t))
          t[bt] = In.transform(Xe, n);
      break;
    }
  }
  return t;
}, y7 = {
  transform(e, t) {
    e.children = ME(e.children);
    var n = e.selection && ME(e.selection);
    try {
      n = v7(e, n, t);
    } finally {
      e.children = TE(e.children), n ? e.selection = Pa(n) ? TE(n) : n : e.selection = null;
    }
  }
}, b7 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, w7 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, yF = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Fr(r) && Fr(o)) {
      if (!yF(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function C7(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Bu(e, t) {
  if (e == null) return {};
  var n = C7(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var O7 = ["anchor", "focus"];
function _E(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function x7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _E(Object(n), !0).forEach(function(r) {
      Qa(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _E(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Pt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Pt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Pt.edges(e);
    return t;
  },
  equals(e, t) {
    return In.equals(e.anchor, t.anchor) && In.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Pt.isRange(t)) {
      if (Pt.includes(e, t.anchor) || Pt.includes(e, t.focus))
        return !0;
      var [n, r] = Pt.edges(e), [o, i] = Pt.edges(t);
      return In.isBefore(n, o) && In.isAfter(r, i);
    }
    var [s, a] = Pt.edges(e), l = !1, u = !1;
    return In.isPoint(t) ? (l = In.compare(t, s) >= 0, u = In.compare(t, a) <= 0) : (l = De.compare(t, s.path) >= 0, u = De.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Bu(e, O7), [r, o] = Pt.edges(e), [i, s] = Pt.edges(t), a = In.isBefore(r, i) ? i : r, l = In.isBefore(o, s) ? o : s;
    return In.isBefore(l, a) ? null : x7({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return In.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return In.equals(t, n);
  },
  isExpanded(e) {
    return !Pt.isCollapsed(e);
  },
  isForward(e) {
    return !Pt.isBackward(e);
  },
  isRange(e) {
    return Fr(e) && In.isPoint(e.anchor) && In.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Pt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Aw(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = Pt.isCollapsed(r);
        Pt.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? Pt.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = In.transform(r.anchor, t, {
        affinity: i
      }), u = In.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, AE = (e) => Fr(e) && ft.isNodeList(e.children) && !xn.isEditor(e), Di = {
  isAncestor(e) {
    return Fr(e) && ft.isNodeList(e.children);
  },
  isElement: AE,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Di.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return AE(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, E7 = ["children"], L7 = ["text"], BE = /* @__PURE__ */ new WeakMap(), ft = {
  ancestor(e, t) {
    var n = ft.get(e, t);
    if (hr.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(ho.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of De.ancestors(t, n)) {
        var o = ft.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (hr.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(ho.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(ho.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = ft.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = ft.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = De.common(t, n), o = ft.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = ft.get(e, t);
    if (xn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(ho.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ft.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ft.nodes(e, t))
        Di.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Di.isAncestor(e)) {
      var t = Bu(e, E7);
      return t;
    } else {
      var t = Bu(e, L7);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = ft.get(e, n); r && !(hr.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (hr.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(ho.stringify(e)));
    var n = Aw({
      children: e.children
    }, (r) => {
      var [o, i] = Pt.edges(t), s = ft.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, m] = d;
          return !Pt.includes(t, m);
        }
      });
      for (var [, a] of s) {
        if (!Pt.includes(t, a)) {
          var l = ft.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (De.equals(a, i.path)) {
          var c = ft.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (De.equals(a, o.path)) {
          var p = ft.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      xn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (hr.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(ho.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (hr.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return hr.isText(e) || Di.isElement(e) || xn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = BE.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => ft.isNode(r));
    return BE.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = ft.get(e, n); r && !(hr.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = ft.get(e, t);
    if (!hr.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(ho.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of De.levels(t, n)) {
        var o = ft.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Di.isElement(e) && Di.isElementProps(t) && Di.matches(e, t) || hr.isText(e) && hr.isTextProps(t) && hr.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? De.isBefore(a, i) : De.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !hr.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          De.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = ft.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = De.next(a);
          if (ft.has(e, c)) {
            a = c, l = ft.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = De.previous(a);
          a = p, l = ft.get(e, a);
          continue;
        }
        a = De.parent(a), l = ft.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = De.parent(t), r = ft.get(e, n);
    if (hr.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return hr.isText(e) ? e.text : e.children.map(ft.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ft.nodes(e, t))
        hr.isText(n) && (yield [n, r]);
    }();
  }
};
function IE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IE(Object(n), !0).forEach(function(r) {
      Qa(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wl = {
  isNodeOperation(e) {
    return Wl.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Fr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return De.isPath(e.path) && ft.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && De.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && De.isPath(e.path) && Fr(e.properties);
      case "move_node":
        return De.isPath(e.path) && De.isPath(e.newPath);
      case "remove_node":
        return De.isPath(e.path) && ft.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && De.isPath(e.path);
      case "set_node":
        return De.isPath(e.path) && Fr(e.properties) && Fr(e.newProperties);
      case "set_selection":
        return e.properties === null && Pt.isRange(e.newProperties) || e.newProperties === null && Pt.isRange(e.properties) || Fr(e.properties) && Fr(e.newProperties);
      case "split_node":
        return De.isPath(e.path) && typeof e.position == "number" && Fr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Wl.isOperation(t));
  },
  isSelectionOperation(e) {
    return Wl.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Wl.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Vn(Vn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Vn(Vn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Vn(Vn({}, e), {}, {
          type: "split_node",
          path: De.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (De.equals(t, n))
          return e;
        if (De.isSibling(n, t))
          return Vn(Vn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = De.transform(n, e), o = De.transform(De.next(n), e);
        return Vn(Vn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Vn(Vn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Vn(Vn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return Vn(Vn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? Vn(Vn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Vn(Vn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : Vn(Vn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return Vn(Vn({}, e), {}, {
          type: "merge_node",
          path: De.next(e.path)
        });
    }
  }
}, NE = /* @__PURE__ */ new WeakMap(), P7 = (e) => {
  var t = NE.get(e);
  if (t !== void 0)
    return t;
  if (!Fr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Fr(e.marks)) && (e.selection === null || Pt.isRange(e.selection)) && ft.isNodeList(e.children) && Wl.isOperationList(e.operations);
  return NE.set(e, n), n;
}, xn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return P7(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function FE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function RE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FE(Object(n), !0).forEach(function(r) {
      Qa(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var In = {
  compare(e, t) {
    var n = De.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return In.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return In.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && De.equals(e.path, t.path);
  },
  isPoint(e) {
    return Fr(e) && typeof e.offset == "number" && De.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Aw(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = De.transform(i, t, n);
          break;
        }
        case "insert_text": {
          De.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          De.equals(t.path, i) && (r.offset += t.position), r.path = De.transform(i, t, n);
          break;
        }
        case "remove_text": {
          De.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (De.equals(t.path, i) || De.isAncestor(t.path, i))
            return null;
          r.path = De.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (De.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = De.transform(i, t, RE(RE({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = De.transform(i, t, n);
          break;
        }
      }
    });
  }
}, zE = void 0, ho = {
  setScrubber(e) {
    zE = e;
  },
  stringify(e) {
    return JSON.stringify(e, zE);
  }
}, k7 = ["text"], S7 = ["anchor", "focus"];
function UE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UE(Object(n), !0).forEach(function(r) {
      Qa(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hr = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = Bu(i, k7);
      return s;
    }
    return yF(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Fr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => hr.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [wi({}, e)];
    for (var r of t) {
      var o = Bu(r, S7), [i, s] = Pt.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, m = l;
        if (l += d, u <= m && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === m) || u > l || c < m || c === m && m !== 0) {
          a.push(p);
          continue;
        }
        var f = p, g = void 0, h = void 0;
        if (c < l) {
          var x = c - m;
          h = wi(wi({}, f), {}, {
            text: f.text.slice(x)
          }), f = wi(wi({}, f), {}, {
            text: f.text.slice(0, x)
          });
        }
        if (u > m) {
          var w = u - m;
          g = wi(wi({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = wi(wi({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), g && a.push(g), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, D7 = (e) => e.selection ? e.selection : e.children.length > 0 ? xn.end(e, []) : [0], jn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(jn || (jn = {}));
jn.L, jn.L | jn.V | jn.LV | jn.LVT, jn.LV | jn.V, jn.V | jn.T, jn.LVT | jn.T, jn.T, jn.Any, jn.Extend | jn.ZWJ, jn.Any, jn.SpacingMark, jn.Prepend, jn.Any, jn.ZWJ, jn.ExtPict, jn.RI, jn.RI;
var M7 = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    xn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = D7(e)
      } = n;
      if (De.isPath(o) && (o = xn.range(e, o)), Pt.isRange(o))
        if (Pt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Pt.end(o);
          if (!r && xn.void(e, {
            at: i
          }))
            return;
          var s = Pt.start(o), a = xn.pointRef(e, s), l = xn.pointRef(e, i);
          Yd.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Yd.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && xn.void(e, {
        at: o
      }) || xn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function $E(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function np(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $E(Object(n), !0).forEach(function(r) {
      Qa(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $E(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yd = np(np(np(np({}, y7), b7), w7), M7), bF = {}, Bw = {}, Iw = {};
Object.defineProperty(Iw, "__esModule", { value: !0 });
Iw.default = A7;
var VE = "html", HE = "head", rp = "body", T7 = /<([a-zA-Z]+[0-9]?)/, WE = /<head[^]*>/i, ZE = /<body[^]*>/i, Kd = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, bb = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, qE = typeof window == "object" && window.DOMParser;
if (typeof qE == "function") {
  var j7 = new qE(), _7 = "text/html";
  bb = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), j7.parseFromString(e, _7);
  }, Kd = bb;
}
if (typeof document == "object" && document.implementation) {
  var op = document.implementation.createHTMLDocument();
  Kd = function(e, t) {
    if (t) {
      var n = op.documentElement.querySelector(t);
      return n && (n.innerHTML = e), op;
    }
    return op.documentElement.innerHTML = e, op;
  };
}
var ip = typeof document == "object" && document.createElement("template"), wb;
ip && ip.content && (wb = function(e) {
  return ip.innerHTML = e, ip.content.childNodes;
});
function A7(e) {
  var t, n, r = e.match(T7), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case VE: {
      var i = bb(e);
      if (!WE.test(e)) {
        var s = i.querySelector(HE);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!ZE.test(e)) {
        var s = i.querySelector(rp);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(VE);
    }
    case HE:
    case rp: {
      var a = Kd(e).querySelectorAll(o);
      return ZE.test(e) && WE.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (wb)
        return wb(e);
      var s = Kd(e, rp).querySelector(rp);
      return s.childNodes;
    }
  }
}
var eg = {}, Nw = {}, Fw = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Fw);
var jt = {}, Ss = Sn && Sn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), nu = Sn && Sn.__assign || function() {
  return nu = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, nu.apply(this, arguments);
};
Object.defineProperty(jt, "__esModule", { value: !0 });
jt.cloneNode = jt.hasChildren = jt.isDocument = jt.isDirective = jt.isComment = jt.isText = jt.isCDATA = jt.isTag = jt.Element = jt.Document = jt.CDATA = jt.NodeWithChildren = jt.ProcessingInstruction = jt.Comment = jt.Text = jt.DataNode = jt.Node = void 0;
var lo = Fw, Rw = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), zw(this, t);
    }, e;
  }()
);
jt.Node = Rw;
var tg = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Rw)
);
jt.DataNode = tg;
var wF = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = lo.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(tg)
);
jt.Text = wF;
var CF = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = lo.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(tg)
);
jt.Comment = CF;
var OF = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = lo.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(tg)
);
jt.ProcessingInstruction = OF;
var ng = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Rw)
);
jt.NodeWithChildren = ng;
var xF = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = lo.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ng)
);
jt.CDATA = xF;
var EF = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = lo.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ng)
);
jt.Document = EF;
var LF = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? lo.ElementType.Script : n === "style" ? lo.ElementType.Style : lo.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ng)
);
jt.Element = LF;
function PF(e) {
  return (0, lo.isTag)(e);
}
jt.isTag = PF;
function kF(e) {
  return e.type === lo.ElementType.CDATA;
}
jt.isCDATA = kF;
function SF(e) {
  return e.type === lo.ElementType.Text;
}
jt.isText = SF;
function DF(e) {
  return e.type === lo.ElementType.Comment;
}
jt.isComment = DF;
function MF(e) {
  return e.type === lo.ElementType.Directive;
}
jt.isDirective = MF;
function TF(e) {
  return e.type === lo.ElementType.Root;
}
jt.isDocument = TF;
function B7(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
jt.hasChildren = B7;
function zw(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (SF(e))
    n = new wF(e.data);
  else if (DF(e))
    n = new CF(e.data);
  else if (PF(e)) {
    var r = t ? wm(e.children) : [], o = new LF(e.name, nu({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = nu({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = nu({}, e["x-attribsPrefix"])), n = o;
  } else if (kF(e)) {
    var r = t ? wm(e.children) : [], i = new xF(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (TF(e)) {
    var r = t ? wm(e.children) : [], s = new EF(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (MF(e)) {
    var a = new OF(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
jt.cloneNode = zw;
function wm(e) {
  for (var t = e.map(function(r) {
    return zw(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Sn && Sn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = Sn && Sn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Fw, o = jt;
  n(jt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(Nw);
var jF = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(jF);
Object.defineProperty(eg, "__esModule", { value: !0 });
eg.formatAttributes = _F;
eg.formatDOM = AF;
var sp = Nw, I7 = jF;
function N7(e) {
  return I7.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function _F(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function F7(e) {
  e = e.toLowerCase();
  var t = N7(e);
  return t || e;
}
function AF(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = F7(a.nodeName);
        o = new sp.Element(l, _F(a.attributes)), o.children = AF(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new sp.Text(a.nodeValue);
        break;
      case 8:
        o = new sp.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new sp.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var R7 = Sn && Sn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Bw, "__esModule", { value: !0 });
Bw.default = V7;
var z7 = R7(Iw), U7 = eg, $7 = /<(![a-zA-Z\s]+)>/;
function V7(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match($7), n = t ? t[1] : void 0;
  return (0, U7.formatDOM)((0, z7.default)(e), null, n);
}
var rg = {}, Vo = {}, og = {}, H7 = 0;
og.SAME = H7;
var W7 = 1;
og.CAMELCASE = W7;
og.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const BF = 0, Ds = 1, ig = 2, sg = 3, Uw = 4, IF = 5, NF = 6;
function Z7(e) {
  return _r.hasOwnProperty(e) ? _r[e] : null;
}
function Zr(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === ig || t === sg || t === Uw, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const _r = {}, q7 = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
q7.forEach((e) => {
  _r[e] = new Zr(
    e,
    BF,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  _r[e] = new Zr(
    e,
    Ds,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  _r[e] = new Zr(
    e,
    ig,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  _r[e] = new Zr(
    e,
    ig,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  _r[e] = new Zr(
    e,
    sg,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  _r[e] = new Zr(
    e,
    sg,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  _r[e] = new Zr(
    e,
    Uw,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  _r[e] = new Zr(
    e,
    NF,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  _r[e] = new Zr(
    e,
    IF,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const $w = /[\-\:]([a-z])/g, Vw = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace($w, Vw);
  _r[t] = new Zr(
    t,
    Ds,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace($w, Vw);
  _r[t] = new Zr(
    t,
    Ds,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace($w, Vw);
  _r[t] = new Zr(
    t,
    Ds,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  _r[e] = new Zr(
    e,
    Ds,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const G7 = "xlinkHref";
_r[G7] = new Zr(
  "xlinkHref",
  Ds,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  _r[e] = new Zr(
    e,
    Ds,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Y7,
  SAME: K7,
  possibleStandardNames: GE
} = og, J7 = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", X7 = J7 + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Q7 = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + X7 + "]*$")
), eZ = Object.keys(
  GE
).reduce((e, t) => {
  const n = GE[t];
  return n === K7 ? e[t] = t : n === Y7 ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Vo.BOOLEAN = sg;
Vo.BOOLEANISH_STRING = ig;
Vo.NUMERIC = IF;
Vo.OVERLOADED_BOOLEAN = Uw;
Vo.POSITIVE_NUMERIC = NF;
Vo.RESERVED = BF;
Vo.STRING = Ds;
Vo.getPropertyInfo = Z7;
Vo.isCustomAttribute = Q7;
Vo.possibleStandardNames = eZ;
var Hw = {}, Ww = {}, YE = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, tZ = /\n/g, nZ = /^\s*/, rZ = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, oZ = /^:\s*/, iZ = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, sZ = /^[;\s]*/, aZ = /^\s+|\s+$/g, lZ = `
`, KE = "/", JE = "*", ra = "", uZ = "comment", cZ = "declaration", pZ = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var g = f.match(tZ);
    g && (n += g.length);
    var h = f.lastIndexOf(lZ);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(g) {
      return g.position = new s(f), u(), g;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var g = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (g.reason = f, g.filename = t.source, g.line = n, g.column = r, g.source = e, !t.silent) throw g;
  }
  function l(f) {
    var g = f.exec(e);
    if (g) {
      var h = g[0];
      return o(h), e = e.slice(h.length), g;
    }
  }
  function u() {
    l(nZ);
  }
  function c(f) {
    var g;
    for (f = f || []; g = p(); )
      g !== !1 && f.push(g);
    return f;
  }
  function p() {
    var f = i();
    if (!(KE != e.charAt(0) || JE != e.charAt(1))) {
      for (var g = 2; ra != e.charAt(g) && (JE != e.charAt(g) || KE != e.charAt(g + 1)); )
        ++g;
      if (g += 2, ra === e.charAt(g - 1))
        return a("End of comment missing");
      var h = e.slice(2, g - 2);
      return r += 2, o(h), e = e.slice(g), r += 2, f({
        type: uZ,
        comment: h
      });
    }
  }
  function d() {
    var f = i(), g = l(rZ);
    if (g) {
      if (p(), !l(oZ)) return a("property missing ':'");
      var h = l(iZ), x = f({
        type: cZ,
        property: XE(g[0].replace(YE, ra)),
        value: h ? XE(h[0].replace(YE, ra)) : ra
      });
      return l(sZ), x;
    }
  }
  function m() {
    var f = [];
    c(f);
    for (var g; g = d(); )
      g !== !1 && (f.push(g), c(f));
    return f;
  }
  return u(), m();
};
function XE(e) {
  return e ? e.replace(aZ, ra) : ra;
}
var dZ = Sn && Sn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ww, "__esModule", { value: !0 });
Ww.default = hZ;
var fZ = dZ(pZ);
function hZ(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, fZ.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var ag = {};
Object.defineProperty(ag, "__esModule", { value: !0 });
ag.camelCase = void 0;
var gZ = /^--[a-zA-Z0-9_-]+$/, mZ = /-([a-z])/g, vZ = /^[^-]+$/, yZ = /^-(webkit|moz|ms|o|khtml)-/, bZ = /^-(ms)-/, wZ = function(e) {
  return !e || vZ.test(e) || gZ.test(e);
}, CZ = function(e, t) {
  return t.toUpperCase();
}, QE = function(e, t) {
  return "".concat(t, "-");
}, OZ = function(e, t) {
  return t === void 0 && (t = {}), wZ(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(bZ, QE) : e = e.replace(yZ, QE), e.replace(mZ, CZ));
};
ag.camelCase = OZ;
var xZ = Sn && Sn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, EZ = xZ(Ww), LZ = ag;
function Cb(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, EZ.default)(e, function(r, o) {
    r && o && (n[(0, LZ.camelCase)(r, t)] = o);
  }), n;
}
Cb.default = Cb;
var PZ = Cb;
(function(e) {
  var t = Sn && Sn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Ee, r = t(PZ), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Hw);
Object.defineProperty(rg, "__esModule", { value: !0 });
rg.default = MZ;
var Zl = Vo, eL = Hw, kZ = ["checked", "value"], SZ = ["input", "select", "textarea"], DZ = {
  reset: !0,
  submit: !0
};
function MZ(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && DZ[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Zl.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = tL(s);
    if (a) {
      var l = (0, Zl.getPropertyInfo)(a);
      switch (kZ.includes(a) && SZ.includes(t) && !r && (a = tL("default" + s)), n[a] = i, l && l.type) {
        case Zl.BOOLEAN:
          n[a] = !0;
          break;
        case Zl.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    eL.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, eL.setStyleProp)(e.style, n), n;
}
function tL(e) {
  return Zl.possibleStandardNames[e];
}
var Zw = {}, TZ = Sn && Sn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Zw, "__esModule", { value: !0 });
Zw.default = FF;
var Cm = Ee, jZ = TZ(rg), ru = Hw, _Z = {
  cloneElement: Cm.cloneElement,
  createElement: Cm.createElement,
  isValidElement: Cm.isValidElement
};
function FF(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || ru.returnFirstArg, i = t.library || _Z, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var m = !p.data.trim().length;
      if (m && p.parent && !(0, ru.canTextBeChildOfNode)(p.parent) || t.trim && m)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, g = {};
    AZ(f) ? ((0, ru.setStyleProp)(f.attribs.style, f.attribs), g = f.attribs) : f.attribs && (g = (0, jZ.default)(f.attribs, f.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (g.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? g.defaultValue = p.children[0].data : p.children && p.children.length && (h = FF(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), n.push(o(a(p.name, g, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function AZ(e) {
  return ru.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, ru.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Sn && Sn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(Bw);
  e.htmlToDOM = n.default;
  var r = t(rg);
  e.attributesToProps = r.default;
  var o = t(Zw);
  e.domToReact = o.default;
  var i = Nw;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(bF);
const BZ = /* @__PURE__ */ t7(bF);
BZ.default;
Ge({});
function IZ(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const NZ = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
IZ(NZ.CNPJ).length;
Da((e, t) => /* @__PURE__ */ ro.jsx("input", { ref: t, ...e }));
Ge({});
var Ni = {};
Object.defineProperty(Ni, "__esModule", {
  value: !0
});
var FZ = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Om = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, RF = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: FZ ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, qw = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var ap = 1; ap < 20; ap++)
  qw["f" + ap] = 111 + ap;
function lg(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return zF(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return UF(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function RZ(e, t) {
  return lg(e, t);
}
function zZ(e, t) {
  return lg(e, { byKey: !0 }, t);
}
function zF(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in Om)
    r[Om[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, m = d.endsWith("?") && d.length > 1;
      m && (d = d.slice(0, -1));
      var f = Gw(d), g = Om[f];
      if (d.length > 1 && !g && !RF[d] && !qw[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !g) && (n ? r.key = f : r.which = $F(d)), g && (r[g] = m ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function UF(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function $F(e) {
  e = Gw(e);
  var t = qw[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function Gw(e) {
  return e = e.toLowerCase(), e = RF[e] || e, e;
}
Ni.default = lg;
var xm = Ni.isHotkey = lg;
Ni.isCodeHotkey = RZ;
Ni.isKeyHotkey = zZ;
Ni.parseHotkey = zF;
Ni.compareHotkey = UF;
Ni.toKeyCode = $F;
Ni.toKeyName = Gw;
var UZ = typeof Sn == "object" && Sn && Sn.Object === Object && Sn, $Z = UZ, VZ = $Z, HZ = typeof self == "object" && self && self.Object === Object && self, WZ = VZ || HZ || Function("return this")(), ZZ = WZ, qZ = ZZ, GZ = qZ.Symbol, VF = GZ, nL = VF;
nL && nL.toStringTag;
var rL = VF;
rL && rL.toStringTag;
var oL;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(oL || (oL = {}));
var Yw = function(e) {
  return Object.freeze(e);
}, YZ = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Yw(this);
  }
  return e;
}(), KZ = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Yw(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), iL = typeof window < "u" ? window : {};
/msie|trident/i.test(iL.navigator && iL.navigator.userAgent);
var Em = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new YZ((n ? t : e) || 0, (n ? e : t) || 0);
};
Yw({
  devicePixelContentBoxSize: Em(),
  borderBoxSize: Em(),
  contentBoxSize: Em(),
  contentRect: new KZ(0, 0, 0, 0)
});
function Iu(e) {
  "@babel/helpers - typeof";
  return Iu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Iu(e);
}
function JZ(e, t) {
  if (Iu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Iu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function XZ(e) {
  var t = JZ(e, "string");
  return Iu(t) === "symbol" ? t : String(t);
}
function ou(e, t, n) {
  return t = XZ(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var QZ = /* @__PURE__ */ Ge(null), Lm, Pm;
parseInt(Ee.version.split(".")[0], 10);
var sL = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), km = typeof navigator < "u" && /Android/.test(navigator.userAgent), lp = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), eq = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Lm = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Lm !== void 0 && Lm[1] && parseInt((Pm = navigator.userAgent.match(/Version\/(\d+)/)) === null || Pm === void 0 ? void 0 : Pm[1], 10) < 17;
var tq = /* @__PURE__ */ new WeakMap(), nq = /* @__PURE__ */ new WeakMap(), rq = /* @__PURE__ */ new WeakMap(), oq = /* @__PURE__ */ new WeakMap(), iq = /* @__PURE__ */ new WeakMap(), aL = /* @__PURE__ */ new WeakMap(), sq = /* @__PURE__ */ new WeakMap(), lL = /* @__PURE__ */ new WeakMap(), up = /* @__PURE__ */ new WeakMap(), aq = /* @__PURE__ */ new WeakMap(), lq = /* @__PURE__ */ new WeakMap(), uq = /* @__PURE__ */ new WeakMap(), HF = globalThis.Node, cq = globalThis.Text, WF = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, pq = (e) => Jd(e) && e.nodeType === 8, Jo = (e) => Jd(e) && e.nodeType === 1, Jd = (e) => {
  var t = WF(e);
  return !!t && e instanceof t.Node;
}, uL = (e) => {
  var t = e && e.anchorNode && WF(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, dq = (e) => {
  var [t, n] = e;
  if (Jo(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = ZF(t, o, r ? "backward" : "forward"), r = o < n; Jo(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = hq(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, fq = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, ZF = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (pq(o) || Jo(o) && o.childNodes.length === 0 || Jo(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, hq = (e, t, n) => {
  var [r] = ZF(e, t, n);
  return r;
}, cL = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), qF = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Jo(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Bt.getWindow(e);
  if (o.contains(r))
    return Bt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : qF(e, i, n);
}, pL = (e, t) => !!(e.compareDocumentPosition(t) & HF.DOCUMENT_POSITION_PRECEDING), gq = (e, t) => !!(e.compareDocumentPosition(t) & HF.DOCUMENT_POSITION_FOLLOWING), mq = 0;
class vq {
  constructor() {
    ou(this, "id", void 0), this.id = "".concat(mq++);
  }
}
var Bt = {
  androidPendingDiffs: (e) => uq.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = lq.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Bt.toDOMNode(e, e), n = Bt.findDocumentOrShadowRoot(e);
    up.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Bt.findDocumentOrShadowRoot(e), r = cL(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Yd.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Bt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Bt.toSlateNode(e, t.target), s = Bt.findPath(e, i);
    if (Di.isElement(i) && xn.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = xn.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? xn.before(e, u) : xn.after(e, u);
      if (c) {
        var p = xn.range(e, c);
        return p;
      }
    }
    var d, {
      document: m
    } = Bt.getWindow(e);
    if (m.caretRangeFromPoint)
      d = m.caretRangeFromPoint(n, r);
    else {
      var f = m.caretPositionFromPoint(n, r);
      f && (d = m.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var g = Bt.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return g;
  },
  findKey: (e, t) => {
    var n = aL.get(t);
    return n || (n = new vq(), aL.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = nq.get(r);
      if (o == null) {
        if (xn.isEditor(r))
          return n;
        break;
      }
      var i = tq.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(ho.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!up.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Bt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Bt.toDOMNode(e, e), r = Bt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = cL(r), i = Bt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Yd.select(e, xn.start(e, [])), up.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = rq.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Bt.toDOMNode(e, e), i;
    try {
      i = Jo(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Jd(t) && Bt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return xn.hasPath(e, n.path) && xn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Bt.hasEditableTarget(e, t) || Bt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Jd(t) && Bt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!aq.get(e),
  isFocused: (e) => !!up.get(e),
  isReadOnly: (e) => !!lL.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (lL.get(e)) return !1;
    var n = Bt.hasTarget(e, t) && Bt.toSlateNode(e, t);
    return Di.isElement(n) && xn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = sq.get(e), r = xn.isEditor(t) ? oq.get(e) : n == null ? void 0 : n.get(Bt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(ho.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = xn.node(e, t.path), r = Bt.toDOMNode(e, n), o;
    xn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), m = d == null ? p : parseInt(d, 10), f = a + m, g = s[l + 1];
        if (t.offset === f && g !== null && g !== void 0 && g.hasAttribute("data-slate-mark-placeholder")) {
          var h, x = g.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            x instanceof cq ? x : g,
            (h = g.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(ho.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Pt.isBackward(t), i = Bt.toDOMPoint(e, n), s = Pt.isCollapsed(t) ? i : Bt.toDOMPoint(e, r), a = Bt.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, m = Jo(u) ? u : u.parentElement, f = !!m.getAttribute("data-slate-zero-width"), g = Jo(p) ? p : p.parentElement, h = !!g.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Jo(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? iq.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : dq(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, m = Bt.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), g = f && m.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), x = h && m.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = Bt.getWindow(e), y = O.document.createRange();
          y.setStart(u, 0), y.setEnd(s, a);
          var C = y.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (km && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (g) {
        for (var U = g.querySelectorAll("[data-slate-leaf]"), L = 0; L < U.length; L++) {
          var F = U[L];
          if (Bt.hasDOMNode(e, F)) {
            w = F;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (x) {
        var B = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = x.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...B($), ...B($ == null ? void 0 : $.nextElementSibling)];
          w = (V = z.find((M) => gq(x, M))) !== null && V !== void 0 ? V : null;
        } else {
          var q, X = [...B($ == null ? void 0 : $.previousElementSibling), ...B($)];
          w = (q = X.findLast((M) => pL(x, M))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      km && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      lp && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (km && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && Bt.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = Bt.toSlateNode(e, J), {
          path: ee,
          offset: k
        } = xn.start(e, Bt.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (k = a), {
          path: ee,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var j = Bt.toSlateNode(e, u), H = Bt.findPath(e, j);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = uL(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (uL(t)) {
        if (lp && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), m = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && m.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, g = m.startContainer, h = C(f.children[d.startOffset]), x = C(g.children[m.startOffset]);
            c = 0, x.childNodes.length > 0 ? a = x.childNodes[0] : a = x, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, x instanceof HTMLElement ? l = x.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = m.endContainer, l = m.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = m.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        eq && fq(a) || lp ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    lp && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Bt.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = pL(a, u) || a === u && c < l, O = p ? w : Bt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!O)
      return null;
    var y = {
      anchor: w,
      focus: O
    };
    return Pt.isExpanded(y) && Pt.isForward(y) && Jo(u) && xn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = xn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, yq = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, bq = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, wq = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Hn = (e) => {
  var t = yq[e], n = bq[e], r = wq[e], o = t && xm(t), i = n && xm(n), s = r && xm(r);
  return (a) => !!(o && o(a) || sL && i && i(a) || !sL && s && s(a));
};
Hn("bold"), Hn("compose"), Hn("moveBackward"), Hn("moveForward"), Hn("deleteBackward"), Hn("deleteForward"), Hn("deleteLineBackward"), Hn("deleteLineForward"), Hn("deleteWordBackward"), Hn("deleteWordForward"), Hn("extendBackward"), Hn("extendForward"), Hn("extendLineBackward"), Hn("extendLineForward"), Hn("italic"), Hn("moveLineBackward"), Hn("moveLineForward"), Hn("moveWordBackward"), Hn("moveWordForward"), Hn("redo"), Hn("insertSoftBreak"), Hn("splitBlock"), Hn("transposeCharacter"), Hn("undo");
var Cq = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => qF(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, Oq = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class xq extends Yu {
  constructor() {
    super(...arguments), ou(this, "context", null), ou(this, "manager", null), ou(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, Oq);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = Cq(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
ou(xq, "contextType", QZ);
Ge({});
Ge({});
Ge({});
var gr = {}, Kw = {}, Ku = {}, Ju = {}, GF = "Expected a function", dL = NaN, Eq = "[object Symbol]", Lq = /^\s+|\s+$/g, Pq = /^[-+]0x[0-9a-f]+$/i, kq = /^0b[01]+$/i, Sq = /^0o[0-7]+$/i, Dq = parseInt, Mq = typeof Sn == "object" && Sn && Sn.Object === Object && Sn, Tq = typeof self == "object" && self && self.Object === Object && self, jq = Mq || Tq || Function("return this")(), _q = Object.prototype, Aq = _q.toString, Bq = Math.max, Iq = Math.min, Sm = function() {
  return jq.Date.now();
};
function Nq(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(GF);
  t = fL(t) || 0, Xd(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Bq(fL(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function m(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, s = e.apply(U, S), s;
  }
  function f(C) {
    return u = C, a = setTimeout(x, t), c ? m(C) : s;
  }
  function g(C) {
    var S = C - l, U = C - u, L = t - S;
    return p ? Iq(L, i - U) : L;
  }
  function h(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function x() {
    var C = Sm();
    if (h(C))
      return w(C);
    a = setTimeout(x, g(C));
  }
  function w(C) {
    return a = void 0, d && r ? m(C) : (r = o = void 0, s);
  }
  function D() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function O() {
    return a === void 0 ? s : w(Sm());
  }
  function y() {
    var C = Sm(), S = h(C);
    if (r = arguments, o = this, l = C, S) {
      if (a === void 0)
        return f(l);
      if (p)
        return a = setTimeout(x, t), m(l);
    }
    return a === void 0 && (a = setTimeout(x, t)), s;
  }
  return y.cancel = D, y.flush = O, y;
}
function Fq(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(GF);
  return Xd(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Nq(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Xd(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Rq(e) {
  return !!e && typeof e == "object";
}
function zq(e) {
  return typeof e == "symbol" || Rq(e) && Aq.call(e) == Eq;
}
function fL(e) {
  if (typeof e == "number")
    return e;
  if (zq(e))
    return dL;
  if (Xd(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Xd(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Lq, "");
  var n = kq.test(e);
  return n || Sq.test(e) ? Dq(e.slice(2), n ? 2 : 8) : Pq.test(e) ? dL : +e;
}
var Uq = Fq, Xu = {};
Object.defineProperty(Xu, "__esModule", {
  value: !0
});
Xu.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), dd.has(t) || dd.set(t, /* @__PURE__ */ new Set());
  var o = dd.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Xu.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), dd.get(t).delete(n.name || t);
};
var dd = /* @__PURE__ */ new Map();
Object.defineProperty(Ju, "__esModule", {
  value: !0
});
var $q = Uq, Vq = Wq($q), Hq = Xu;
function Wq(e) {
  return e && e.__esModule ? e : { default: e };
}
var Zq = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Vq.default)(e, t);
}, tr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = Zq(function(r) {
        tr.scrollHandler(e);
      }, t);
      tr.scrollSpyContainers.push(e), (0, Hq.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return tr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = tr.scrollSpyContainers[tr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(tr.currentPositionX(e), tr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    tr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = tr.scrollSpyContainers[tr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(tr.currentPositionX(t), tr.currentPositionY(t));
  },
  updateStates: function() {
    tr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    tr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), tr.spySetState && tr.spySetState.length && tr.spySetState.indexOf(e) > -1 && tr.spySetState.splice(tr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", tr.scrollHandler);
  },
  update: function() {
    return tr.scrollSpyContainers.forEach(function(e) {
      return tr.scrollHandler(e);
    });
  }
};
Ju.default = tr;
var el = {}, Qu = {};
Object.defineProperty(Qu, "__esModule", {
  value: !0
});
var qq = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, Gq = function() {
  return window.location.hash.replace(/^#/, "");
}, Yq = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Kq = function(e) {
  return getComputedStyle(e).position !== "static";
}, Dm = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, Jq = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Kq(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Dm(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return Dm(t, a).offsetTop - Dm(e, a).offsetTop;
};
Qu.default = {
  updateHash: qq,
  getHash: Gq,
  filterElementInContainer: Yq,
  scrollOffset: Jq
};
var ug = {}, Jw = {};
Object.defineProperty(Jw, "__esModule", {
  value: !0
});
Jw.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Xw = {};
Object.defineProperty(Xw, "__esModule", {
  value: !0
});
var Xq = Xu, Qq = ["mousedown", "mousewheel", "touchmove", "keydown"];
Xw.default = {
  subscribe: function(e) {
    return typeof document < "u" && Qq.forEach(function(t) {
      return (0, Xq.addPassiveEventListener)(document, t, e);
    });
  }
};
var ec = {};
Object.defineProperty(ec, "__esModule", {
  value: !0
});
var Ob = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Ob.registered[e] = t;
    },
    remove: function(e) {
      Ob.registered[e] = null;
    }
  }
};
ec.default = Ob;
Object.defineProperty(ug, "__esModule", {
  value: !0
});
var eG = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, tG = Qu;
cg(tG);
var nG = Jw, hL = cg(nG), rG = Xw, oG = cg(rG), iG = ec, Zo = cg(iG);
function cg(e) {
  return e && e.__esModule ? e : { default: e };
}
var YF = function(e) {
  return hL.default[e.smooth] || hL.default.defaultEasing;
}, sG = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, aG = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, xb = function() {
  return aG() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), KF = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, JF = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, XF = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, lG = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, uG = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, cG = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Zo.default.registered.end && Zo.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    xb.call(window, i);
    return;
  }
  Zo.default.registered.end && Zo.default.registered.end(o.to, o.target, o.currentPosition);
}, Qw = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, tc = function(e, t, n, r) {
  t.data = t.data || KF(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (oG.default.subscribe(o), Qw(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? JF(t) : XF(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Zo.default.registered.end && Zo.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = sG(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = YF(t), s = cG.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Zo.default.registered.begin && Zo.default.registered.begin(t.data.to, t.data.target), xb.call(window, s);
    }, t.delay);
    return;
  }
  Zo.default.registered.begin && Zo.default.registered.begin(t.data.to, t.data.target), xb.call(window, s);
}, pg = function(e) {
  return e = eG({}, e), e.data = e.data || KF(), e.absolute = !0, e;
}, pG = function(e) {
  tc(0, pg(e));
}, dG = function(e, t) {
  tc(e, pg(t));
}, fG = function(e) {
  e = pg(e), Qw(e), tc(e.horizontal ? lG(e) : uG(e), e);
}, hG = function(e, t) {
  t = pg(t), Qw(t);
  var n = t.horizontal ? JF(t) : XF(t);
  tc(e + n, t);
};
ug.default = {
  animateTopScroll: tc,
  getAnimationType: YF,
  scrollToTop: pG,
  scrollToBottom: fG,
  scrollTo: dG,
  scrollMore: hG
};
Object.defineProperty(el, "__esModule", {
  value: !0
});
var gG = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, mG = Qu, vG = eC(mG), yG = ug, bG = eC(yG), wG = ec, cp = eC(wG);
function eC(e) {
  return e && e.__esModule ? e : { default: e };
}
var pp = {}, gL = void 0;
el.default = {
  unmount: function() {
    pp = {};
  },
  register: function(e, t) {
    pp[e] = t;
  },
  unregister: function(e) {
    delete pp[e];
  },
  get: function(e) {
    return pp[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return gL = e;
  },
  getActiveLink: function() {
    return gL;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = gG({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = vG.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      cp.default.registered.begin && cp.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, cp.default.registered.end && cp.default.registered.end(e, n);
      return;
    }
    bG.default.animateTopScroll(a, t, e, n);
  }
};
var Eb = { exports: {} }, Mm = { exports: {} }, on = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mL;
function CG() {
  if (mL) return on;
  mL = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case a:
                case c:
                case f:
                case m:
                case s:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function O(y) {
    return D(y) === u;
  }
  return on.AsyncMode = l, on.ConcurrentMode = u, on.ContextConsumer = a, on.ContextProvider = s, on.Element = t, on.ForwardRef = c, on.Fragment = r, on.Lazy = f, on.Memo = m, on.Portal = n, on.Profiler = i, on.StrictMode = o, on.Suspense = p, on.isAsyncMode = function(y) {
    return O(y) || D(y) === l;
  }, on.isConcurrentMode = O, on.isContextConsumer = function(y) {
    return D(y) === a;
  }, on.isContextProvider = function(y) {
    return D(y) === s;
  }, on.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, on.isForwardRef = function(y) {
    return D(y) === c;
  }, on.isFragment = function(y) {
    return D(y) === r;
  }, on.isLazy = function(y) {
    return D(y) === f;
  }, on.isMemo = function(y) {
    return D(y) === m;
  }, on.isPortal = function(y) {
    return D(y) === n;
  }, on.isProfiler = function(y) {
    return D(y) === i;
  }, on.isStrictMode = function(y) {
    return D(y) === o;
  }, on.isSuspense = function(y) {
    return D(y) === p;
  }, on.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === m || y.$$typeof === s || y.$$typeof === a || y.$$typeof === c || y.$$typeof === h || y.$$typeof === x || y.$$typeof === w || y.$$typeof === g);
  }, on.typeOf = D, on;
}
var gn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vL;
function OG() {
  return vL || (vL = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === m || N.$$typeof === s || N.$$typeof === a || N.$$typeof === c || N.$$typeof === h || N.$$typeof === x || N.$$typeof === w || N.$$typeof === g);
    }
    function O(N) {
      if (typeof N == "object" && N !== null) {
        var ue = N.$$typeof;
        switch (ue) {
          case t:
            var ye = N.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ye;
              default:
                var oe = ye && ye.$$typeof;
                switch (oe) {
                  case a:
                  case c:
                  case f:
                  case m:
                  case s:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, S = a, U = s, L = t, F = c, B = r, $ = f, V = m, z = n, q = i, X = o, J = p, te = !1;
    function ee(N) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(N) || O(N) === l;
    }
    function k(N) {
      return O(N) === u;
    }
    function j(N) {
      return O(N) === a;
    }
    function H(N) {
      return O(N) === s;
    }
    function M(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function Z(N) {
      return O(N) === c;
    }
    function E(N) {
      return O(N) === r;
    }
    function T(N) {
      return O(N) === f;
    }
    function R(N) {
      return O(N) === m;
    }
    function _(N) {
      return O(N) === n;
    }
    function W(N) {
      return O(N) === i;
    }
    function A(N) {
      return O(N) === o;
    }
    function Q(N) {
      return O(N) === p;
    }
    gn.AsyncMode = y, gn.ConcurrentMode = C, gn.ContextConsumer = S, gn.ContextProvider = U, gn.Element = L, gn.ForwardRef = F, gn.Fragment = B, gn.Lazy = $, gn.Memo = V, gn.Portal = z, gn.Profiler = q, gn.StrictMode = X, gn.Suspense = J, gn.isAsyncMode = ee, gn.isConcurrentMode = k, gn.isContextConsumer = j, gn.isContextProvider = H, gn.isElement = M, gn.isForwardRef = Z, gn.isFragment = E, gn.isLazy = T, gn.isMemo = R, gn.isPortal = _, gn.isProfiler = W, gn.isStrictMode = A, gn.isSuspense = Q, gn.isValidElementType = D, gn.typeOf = O;
  }()), gn;
}
var yL;
function QF() {
  return yL || (yL = 1, process.env.NODE_ENV === "production" ? Mm.exports = CG() : Mm.exports = OG()), Mm.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Tm, bL;
function xG() {
  if (bL) return Tm;
  bL = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Tm = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, Tm;
}
var jm, wL;
function tC() {
  if (wL) return jm;
  wL = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return jm = e, jm;
}
var CL, OL;
function eR() {
  return OL || (OL = 1, CL = Function.call.bind(Object.prototype.hasOwnProperty)), CL;
}
var _m, xL;
function EG() {
  if (xL) return _m;
  xL = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = tC(), n = {}, r = eR();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var m = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (m ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, _m = o, _m;
}
var Am, EL;
function LG() {
  if (EL) return Am;
  EL = 1;
  var e = QF(), t = xG(), n = tC(), r = eR(), o = EG(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return Am = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var j = k && (u && k[u] || k[c]);
      if (typeof j == "function")
        return j;
    }
    var d = "<<anonymous>>", m = {
      array: x("array"),
      bigint: x("bigint"),
      bool: x("boolean"),
      func: x("function"),
      number: x("number"),
      object: x("object"),
      string: x("string"),
      symbol: x("symbol"),
      any: w(),
      arrayOf: D,
      element: O(),
      elementType: y(),
      instanceOf: C,
      node: F(),
      objectOf: U,
      oneOf: S,
      oneOfType: L,
      shape: $,
      exact: V
    };
    function f(k, j) {
      return k === j ? k !== 0 || 1 / k === 1 / j : k !== k && j !== j;
    }
    function g(k, j) {
      this.message = k, this.data = j && typeof j == "object" ? j : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function h(k) {
      if (process.env.NODE_ENV !== "production")
        var j = {}, H = 0;
      function M(E, T, R, _, W, A, Q) {
        if (_ = _ || d, A = A || R, Q !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = _ + ":" + R;
            !j[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + _ + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), j[ue] = !0, H++);
          }
        }
        return T[R] == null ? E ? T[R] === null ? new g("The " + W + " `" + A + "` is marked as required " + ("in `" + _ + "`, but its value is `null`.")) : new g("The " + W + " `" + A + "` is marked as required in " + ("`" + _ + "`, but its value is `undefined`.")) : null : k(T, R, _, W, A);
      }
      var Z = M.bind(null, !1);
      return Z.isRequired = M.bind(null, !0), Z;
    }
    function x(k) {
      function j(H, M, Z, E, T, R) {
        var _ = H[M], W = X(_);
        if (W !== k) {
          var A = J(_);
          return new g(
            "Invalid " + E + " `" + T + "` of type " + ("`" + A + "` supplied to `" + Z + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return h(j);
    }
    function w() {
      return h(s);
    }
    function D(k) {
      function j(H, M, Z, E, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + Z + "` has invalid PropType notation inside arrayOf.");
        var R = H[M];
        if (!Array.isArray(R)) {
          var _ = X(R);
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected an array."));
        }
        for (var W = 0; W < R.length; W++) {
          var A = k(R, W, Z, E, T + "[" + W + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return h(j);
    }
    function O() {
      function k(j, H, M, Z, E) {
        var T = j[H];
        if (!a(T)) {
          var R = X(T);
          return new g("Invalid " + Z + " `" + E + "` of type " + ("`" + R + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(k);
    }
    function y() {
      function k(j, H, M, Z, E) {
        var T = j[H];
        if (!e.isValidElementType(T)) {
          var R = X(T);
          return new g("Invalid " + Z + " `" + E + "` of type " + ("`" + R + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(k);
    }
    function C(k) {
      function j(H, M, Z, E, T) {
        if (!(H[M] instanceof k)) {
          var R = k.name || d, _ = ee(H[M]);
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected ") + ("instance of `" + R + "`."));
        }
        return null;
      }
      return h(j);
    }
    function S(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function j(H, M, Z, E, T) {
        for (var R = H[M], _ = 0; _ < k.length; _++)
          if (f(R, k[_]))
            return null;
        var W = JSON.stringify(k, function(A, Q) {
          var N = J(Q);
          return N === "symbol" ? String(Q) : Q;
        });
        return new g("Invalid " + E + " `" + T + "` of value `" + String(R) + "` " + ("supplied to `" + Z + "`, expected one of " + W + "."));
      }
      return h(j);
    }
    function U(k) {
      function j(H, M, Z, E, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + Z + "` has invalid PropType notation inside objectOf.");
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected an object."));
        for (var W in R)
          if (r(R, W)) {
            var A = k(R, W, Z, E, T + "." + W, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return h(j);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var j = 0; j < k.length; j++) {
        var H = k[j];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(H) + " at index " + j + "."
          ), s;
      }
      function M(Z, E, T, R, _) {
        for (var W = [], A = 0; A < k.length; A++) {
          var Q = k[A], N = Q(Z, E, T, R, _, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && W.push(N.data.expectedType);
        }
        var ue = W.length > 0 ? ", expected one of type [" + W.join(", ") + "]" : "";
        return new g("Invalid " + R + " `" + _ + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return h(M);
    }
    function F() {
      function k(j, H, M, Z, E) {
        return z(j[H]) ? null : new g("Invalid " + Z + " `" + E + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return h(k);
    }
    function B(k, j, H, M, Z) {
      return new g(
        (k || "React class") + ": " + j + " type `" + H + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Z + "`."
      );
    }
    function $(k) {
      function j(H, M, Z, E, T) {
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type `" + _ + "` " + ("supplied to `" + Z + "`, expected `object`."));
        for (var W in k) {
          var A = k[W];
          if (typeof A != "function")
            return B(Z, E, T, W, J(A));
          var Q = A(R, W, Z, E, T + "." + W, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return h(j);
    }
    function V(k) {
      function j(H, M, Z, E, T) {
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type `" + _ + "` " + ("supplied to `" + Z + "`, expected `object`."));
        var W = t({}, H[M], k);
        for (var A in W) {
          var Q = k[A];
          if (r(k, A) && typeof Q != "function")
            return B(Z, E, T, A, J(Q));
          if (!Q)
            return new g(
              "Invalid " + E + " `" + T + "` key `" + A + "` supplied to `" + Z + "`.\nBad object: " + JSON.stringify(H[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var N = Q(R, A, Z, E, T + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return h(j);
    }
    function z(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every(z);
          if (k === null || a(k))
            return !0;
          var j = p(k);
          if (j) {
            var H = j.call(k), M;
            if (j !== k.entries) {
              for (; !(M = H.next()).done; )
                if (!z(M.value))
                  return !1;
            } else
              for (; !(M = H.next()).done; ) {
                var Z = M.value;
                if (Z && !z(Z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(k, j) {
      return k === "symbol" ? !0 : j ? j["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && j instanceof Symbol : !1;
    }
    function X(k) {
      var j = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : q(j, k) ? "symbol" : j;
    }
    function J(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var j = X(k);
      if (j === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return j;
    }
    function te(k) {
      var j = J(k);
      switch (j) {
        case "array":
        case "object":
          return "an " + j;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + j;
        default:
          return j;
      }
    }
    function ee(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return m.checkPropTypes = o, m.resetWarningCache = o.resetWarningCache, m.PropTypes = m, m;
  }, Am;
}
var Bm, LL;
function PG() {
  if (LL) return Bm;
  LL = 1;
  var e = tC();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Bm = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Bm;
}
if (process.env.NODE_ENV !== "production") {
  var kG = QF(), SG = !0;
  Eb.exports = LG()(kG.isElement, SG);
} else
  Eb.exports = PG()();
var dg = Eb.exports, fg = {};
Object.defineProperty(fg, "__esModule", {
  value: !0
});
var DG = Qu, Im = MG(DG);
function MG(e) {
  return e && e.__esModule ? e : { default: e };
}
var TG = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Im.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Im.default.getHash() !== e && Im.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
fg.default = TG;
Object.defineProperty(Ku, "__esModule", {
  value: !0
});
var dp = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, jG = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), _G = Ee, PL = nc(_G), AG = Ju, fp = nc(AG), BG = el, IG = nc(BG), NG = dg, Wn = nc(NG), FG = fg, $i = nc(FG);
function nc(e) {
  return e && e.__esModule ? e : { default: e };
}
function RG(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function zG(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function UG(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var kL = {
  to: Wn.default.string.isRequired,
  containerId: Wn.default.string,
  container: Wn.default.object,
  activeClass: Wn.default.string,
  activeStyle: Wn.default.object,
  spy: Wn.default.bool,
  horizontal: Wn.default.bool,
  smooth: Wn.default.oneOfType([Wn.default.bool, Wn.default.string]),
  offset: Wn.default.number,
  delay: Wn.default.number,
  isDynamic: Wn.default.bool,
  onClick: Wn.default.func,
  duration: Wn.default.oneOfType([Wn.default.number, Wn.default.func]),
  absolute: Wn.default.bool,
  onSetActive: Wn.default.func,
  onSetInactive: Wn.default.func,
  ignoreCancelEvents: Wn.default.bool,
  hashSpy: Wn.default.bool,
  saveHashHistory: Wn.default.bool,
  spyThrottle: Wn.default.number
};
Ku.default = function(e, t) {
  var n = t || IG.default, r = function(i) {
    UG(s, i);
    function s(a) {
      RG(this, s);
      var l = zG(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return jG(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          fp.default.isMounted(a) || fp.default.mount(a, this.props.spyThrottle), this.props.hashSpy && ($i.default.isMounted() || $i.default.mount(n), $i.default.mapContainer(this.props.to, a)), fp.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        fp.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = dp({}, this.props.style, this.props.activeStyle) : l = dp({}, this.props.style);
        var u = dp({}, this.props);
        for (var c in kL)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, PL.default.createElement(e, u);
      }
    }]), s;
  }(PL.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, dp({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!($i.default.isMounted() && !$i.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, m = void 0;
        if (u) {
          var f = 0, g = 0, h = 0;
          if (l.getBoundingClientRect) {
            var x = l.getBoundingClientRect();
            h = x.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - h + s, g = f + w.width;
          }
          var D = s - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(g), m = D < Math.floor(f) || D >= Math.floor(g);
        } else {
          var O = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            O = U.top - C + a, y = O + U.height;
          }
          var L = a - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(y), m = L < Math.floor(O) || L >= Math.floor(y);
        }
        var F = n.getActiveLink();
        if (m) {
          if (c === F && n.setActiveLink(void 0), i.props.hashSpy && $i.default.getHash() === c) {
            var B = i.props.saveHashHistory, $ = B === void 0 ? !1 : B;
            $i.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (F !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && $i.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = kL, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Kw, "__esModule", {
  value: !0
});
var $G = Ee, SL = tR($G), VG = Ku, HG = tR(VG);
function tR(e) {
  return e && e.__esModule ? e : { default: e };
}
function WG(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function DL(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ZG(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var qG = function(e) {
  ZG(t, e);
  function t() {
    var n, r, o, i;
    WG(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = DL(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return SL.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), DL(o, i);
  }
  return t;
}(SL.default.Component);
Kw.default = (0, HG.default)(qG);
var nC = {};
Object.defineProperty(nC, "__esModule", {
  value: !0
});
var GG = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), YG = Ee, ML = nR(YG), KG = Ku, JG = nR(KG);
function nR(e) {
  return e && e.__esModule ? e : { default: e };
}
function XG(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function QG(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function eY(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var tY = function(e) {
  eY(t, e);
  function t() {
    return XG(this, t), QG(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return GG(t, [{
    key: "render",
    value: function() {
      return ML.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(ML.default.Component);
nC.default = (0, JG.default)(tY);
var rC = {}, hg = {};
Object.defineProperty(hg, "__esModule", {
  value: !0
});
var nY = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, rY = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), oY = Ee, TL = gg(oY), iY = Ga;
gg(iY);
var sY = el, jL = gg(sY), aY = dg, _L = gg(aY);
function gg(e) {
  return e && e.__esModule ? e : { default: e };
}
function lY(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function uY(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function cY(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
hg.default = function(e) {
  var t = function(n) {
    cY(r, n);
    function r(o) {
      lY(this, r);
      var i = uY(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return rY(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        jL.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        jL.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return TL.default.createElement(e, nY({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(TL.default.Component);
  return t.propTypes = {
    name: _L.default.string,
    id: _L.default.string
  }, t;
};
Object.defineProperty(rC, "__esModule", {
  value: !0
});
var AL = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, pY = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), dY = Ee, BL = oC(dY), fY = hg, hY = oC(fY), gY = dg, IL = oC(gY);
function oC(e) {
  return e && e.__esModule ? e : { default: e };
}
function mY(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function vY(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function yY(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var rR = function(e) {
  yY(t, e);
  function t() {
    return mY(this, t), vY(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return pY(t, [{
    key: "render",
    value: function() {
      var n = this, r = AL({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, BL.default.createElement(
        "div",
        AL({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(BL.default.Component);
rR.propTypes = {
  name: IL.default.string,
  id: IL.default.string
};
rC.default = (0, hY.default)(rR);
var Nm = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, NL = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function FL(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function RL(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function zL(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var hp = Ee, Is = Ju, Fm = el, sr = dg, Vi = fg, UL = {
  to: sr.string.isRequired,
  containerId: sr.string,
  container: sr.object,
  activeClass: sr.string,
  spy: sr.bool,
  smooth: sr.oneOfType([sr.bool, sr.string]),
  offset: sr.number,
  delay: sr.number,
  isDynamic: sr.bool,
  onClick: sr.func,
  duration: sr.oneOfType([sr.number, sr.func]),
  absolute: sr.bool,
  onSetActive: sr.func,
  onSetInactive: sr.func,
  ignoreCancelEvents: sr.bool,
  hashSpy: sr.bool,
  spyThrottle: sr.number
}, bY = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Fm, r = function(i) {
      zL(s, i);
      function s(a) {
        FL(this, s);
        var l = RL(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return NL(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            Is.isMounted(a) || Is.mount(a, this.props.spyThrottle), this.props.hashSpy && (Vi.isMounted() || Vi.mount(n), Vi.mapContainer(this.props.to, a)), this.props.spy && Is.addStateHandler(this.stateHandler), Is.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Is.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = Nm({}, this.props);
          for (var u in UL)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, hp.createElement(e, l);
        }
      }]), s;
    }(hp.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, Nm({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(Vi.isMounted() && !Vi.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (a.getBoundingClientRect) {
            var m = a.getBoundingClientRect();
            d = m.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + s, p = c + f.height;
          }
          var g = s - i.props.offset, h = g >= Math.floor(c) && g < Math.floor(p), x = g < Math.floor(c) || g >= Math.floor(p), w = n.getActiveLink();
          if (x)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Vi.getHash() === l && Vi.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Is.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Vi.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Is.updateStates();
        }
      };
    };
    return r.propTypes = UL, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      zL(r, n);
      function r(o) {
        FL(this, r);
        var i = RL(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return NL(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Fm.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Fm.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return hp.createElement(e, Nm({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(hp.Component);
    return t.propTypes = {
      name: sr.string,
      id: sr.string
    }, t;
  }
}, wY = bY;
Object.defineProperty(gr, "__esModule", {
  value: !0
});
gr.Helpers = gr.ScrollElement = gr.ScrollLink = gr.animateScroll = gr.scrollSpy = gr.Events = gr.scroller = gr.Element = gr.Button = gr.Link = void 0;
var CY = Kw, oR = ii(CY), OY = nC, iR = ii(OY), xY = rC, sR = ii(xY), EY = el, aR = ii(EY), LY = ec, lR = ii(LY), PY = Ju, uR = ii(PY), kY = ug, cR = ii(kY), SY = Ku, pR = ii(SY), DY = hg, dR = ii(DY), MY = wY, fR = ii(MY);
function ii(e) {
  return e && e.__esModule ? e : { default: e };
}
gr.Link = oR.default;
gr.Button = iR.default;
gr.Element = sR.default;
gr.scroller = aR.default;
gr.Events = lR.default;
gr.scrollSpy = uR.default;
gr.animateScroll = cR.default;
gr.ScrollLink = pR.default;
gr.ScrollElement = dR.default;
gr.Helpers = fR.default;
gr.default = { Link: oR.default, Button: iR.default, Element: sR.default, scroller: aR.default, Events: lR.default, scrollSpy: uR.default, animateScroll: cR.default, ScrollLink: pR.default, ScrollElement: dR.default, Helpers: fR.default };
Ge({});
Ge({});
Ge({});
function Nu(e) {
  "@babel/helpers - typeof";
  return Nu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Nu(e);
}
function TY(e, t) {
  if (Nu(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Nu(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function jY(e) {
  var t = TY(e, "string");
  return Nu(t) == "symbol" ? t : t + "";
}
function he(e, t, n) {
  return (t = jY(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function hR(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Rm, $L;
function _Y() {
  if ($L) return Rm;
  $L = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, s, a, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, s, a, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Rm = t, Rm;
}
var AY = _Y(), xr = /* @__PURE__ */ hR(AY), gt = Ge(null);
function BY() {
  xr(!!xe, "useGoogleMap is React hook and requires React version 16.8+");
  var e = xe(gt);
  return xr(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function IY(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function NY(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function FY(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return NY(e, i), o;
}
function RY(e, t, n) {
  var r = IY(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function zY(e) {
  google.maps.event.removeListener(e);
}
function Vt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(zY);
}
function Rt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = RY(o, i, n);
  return FY(t, r, o, i), s;
}
function UY(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: m,
    onMouseOver: f,
    onMouseDown: g,
    onMouseUp: h,
    onRightClick: x,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: O
  } = e, [y, C] = P(null), S = Qe(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null), [A, Q] = P(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof s < "u" && y.setCenter(s);
  }, [y, s]), v(() => {
    y && l && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && g && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(y, "mousedown", g)));
  }, [g]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && m && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(y, "mouseout", m)));
  }, [m]), v(() => {
    y && f && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && h && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && x && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(y, "rightclick", x)));
  }, [x]), v(() => {
    y && a && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(y, "click", a)));
  }, [a]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [a]), v(() => {
    var N = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(N), N !== null && D && D(N), () => {
      N !== null && O && O(N);
    };
  }, []), ro.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: ro.jsx(gt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
Le(UY);
function VL(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function gR(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        VL(i, r, o, s, a, "next", l);
      }
      function a(l) {
        VL(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function mR(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return xr(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var oa = typeof document < "u";
function vR(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return oa ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, a.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function HL(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function yR() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return HL(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return HL(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Cl = !1;
function bR() {
  return ro.jsx("div", {
    children: "Loading..."
  });
}
var Lb = {
  id: "script-loader",
  version: "weekly"
};
class $Y extends be {
  constructor() {
    super(...arguments), he(this, "check", wr()), he(this, "state", {
      loaded: !1
    }), he(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), he(this, "isCleaningUp", /* @__PURE__ */ gR(function* () {
      function t(n) {
        if (!Cl)
          n();
        else if (oa)
          var r = window.setInterval(function() {
            Cl || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), he(this, "cleanup", () => {
      Cl = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), he(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && yR(), xr(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: mR(this.props)
      };
      vR(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (oa) {
      if (window.google && window.google.maps && !Cl) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), oa && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (oa) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Cl = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return ro.jsxs(ro.Fragment, {
      children: [ro.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || ro.jsx(bR, {})]
    });
  }
}
he($Y, "defaultProps", Lb);
function VY(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function iC(e, t) {
  if (e == null) return {};
  var n, r, o = VY(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var WL;
function HY(e) {
  var {
    id: t = Lb.id,
    version: n = Lb.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, m = Qe(!1), [f, g] = P(!1), [h, x] = P(void 0);
  v(function() {
    return m.current = !0, () => {
      m.current = !1;
    };
  }, []), v(function() {
    oa && u && yR();
  }, [u]), v(function() {
    f && xr(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = mR({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!oa)
      return;
    function O() {
      m.current && (g(!0), WL = w);
    }
    if (window.google && window.google.maps && WL === w) {
      O();
      return;
    }
    vR({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(y) {
      m.current && x(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var D = Qe();
  return v(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var WY = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], ZY = ro.jsx(bR, {});
function qY(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = iC(e, WY), {
    isLoaded: a,
    loadError: l
  } = HY(s);
  return v(function() {
    a && typeof n == "function" && n();
  }, [a, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || ZY;
}
Le(qY);
var ZL;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(ZL || (ZL = {}));
function qL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qL(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var GL = {}, YL = {
  options(e, t) {
    e.setOptions(t);
  }
};
function GY(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = xe(gt), [i, s] = P(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var a = new google.maps.TrafficLayer(Qd(Qd({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Le(GY);
class YY extends be {
  constructor() {
    super(...arguments), he(this, "state", {
      trafficLayer: null
    }), he(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), he(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Qd(Qd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Rt({
      updaterMap: YL,
      eventMap: GL,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: YL,
      eventMap: GL,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Vt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(YY, "contextType", gt);
function KY(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = xe(gt), [o, i] = P(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
Le(KY);
class JY extends be {
  constructor() {
    super(...arguments), he(this, "state", {
      bicyclingLayer: null
    }), he(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(JY, "contextType", gt);
function XY(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = xe(gt), [o, i] = P(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Le(XY);
class QY extends be {
  constructor() {
    super(...arguments), he(this, "state", {
      transitLayer: null
    }), he(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(QY, "contextType", gt);
function KL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ef(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KL(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var JL = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, XL = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function eK(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = xe(gt), [d, m] = P(null), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), g(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && s && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(d, "polygoncomplete", s)));
  }, [d, s]), v(() => {
    d && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", a)));
  }, [d, a]), v(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    xr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var F = new google.maps.drawing.DrawingManager(ef(ef({}, t), {}, {
      map: p
    }));
    return n && F.setDrawingMode(n), r && g(google.maps.event.addListener(F, "circlecomplete", r)), o && x(google.maps.event.addListener(F, "markercomplete", o)), i && D(google.maps.event.addListener(F, "overlaycomplete", i)), s && y(google.maps.event.addListener(F, "polygoncomplete", s)), a && S(google.maps.event.addListener(F, "polylinecomplete", a)), l && L(google.maps.event.addListener(F, "rectanglecomplete", l)), m(F), u && u(F), () => {
      d !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
Le(eK);
class tK extends be {
  constructor(t) {
    super(t), he(this, "registeredEvents", []), he(this, "state", {
      drawingManager: null
    }), he(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), xr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(ef(ef({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Rt({
      updaterMap: XL,
      eventMap: JL,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: XL,
      eventMap: JL,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Vt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
he(tK, "contextType", gt);
function QL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Aa(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QL(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var eP = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, tP = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, tf = {};
function nK(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: m,
    shape: f,
    title: g,
    zIndex: h,
    onClick: x,
    onDblClick: w,
    onDrag: D,
    onDragEnd: O,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: L,
    onRightClick: F,
    onClickableChanged: B,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: q,
    onIconChanged: X,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: k,
    onZindexChanged: j,
    onLoad: H,
    onUnmount: M
  } = e, Z = xe(gt), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null), [Q, N] = P(null), [ue, ye] = P(null), [oe, Ie] = P(null), [$e, Ve] = P(null), [Ne, Je] = P(null), [Ye, Te] = P(null), [Ke, nt] = P(null), [Me, Ae] = P(null), [Fe, He] = P(null), [ze, et] = P(null), [_e, At] = P(null), [rt, ot] = P(null), [at, qt] = P(null), [lt, Gt] = P(null), [Xe, bt] = P(null), [tt, Yt] = P(null), [ut, dn] = P(null), [Kt, fn] = P(null), [Jt, hn] = P(null);
  v(() => {
    E !== null && E.setMap(Z);
  }, [Z]), v(() => {
    typeof n < "u" && E !== null && E.setOptions(n);
  }, [E, n]), v(() => {
    typeof s < "u" && E !== null && E.setDraggable(s);
  }, [E, s]), v(() => {
    t && E !== null && E.setPosition(t);
  }, [E, t]), v(() => {
    typeof a < "u" && E !== null && E.setVisible(a);
  }, [E, a]), v(() => {
    E == null || E.setAnimation(l);
  }, [E, l]), v(() => {
    E && u !== void 0 && E.setClickable(u);
  }, [E, u]), v(() => {
    E && c !== void 0 && E.setCursor(c);
  }, [E, c]), v(() => {
    E && p !== void 0 && E.setIcon(p);
  }, [E, p]), v(() => {
    E && d !== void 0 && E.setLabel(d);
  }, [E, d]), v(() => {
    E && m !== void 0 && E.setOpacity(m);
  }, [E, m]), v(() => {
    E && f !== void 0 && E.setShape(f);
  }, [E, f]), v(() => {
    E && g !== void 0 && E.setTitle(g);
  }, [E, g]), v(() => {
    E && h !== void 0 && E.setZIndex(h);
  }, [E, h]), v(() => {
    E && w && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(E, "dblclick", w)));
  }, [w]), v(() => {
    E && O && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(E, "dragend", O)));
  }, [O]), v(() => {
    E && y && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(E, "dragstart", y)));
  }, [y]), v(() => {
    E && L && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(E, "mousedown", L)));
  }, [L]), v(() => {
    E && C && (oe !== null && google.maps.event.removeListener(oe), Ie(google.maps.event.addListener(E, "mouseout", C)));
  }, [C]), v(() => {
    E && S && ($e !== null && google.maps.event.removeListener($e), Ve(google.maps.event.addListener(E, "mouseover", S)));
  }, [S]), v(() => {
    E && U && (Ne !== null && google.maps.event.removeListener(Ne), Je(google.maps.event.addListener(E, "mouseup", U)));
  }, [U]), v(() => {
    E && F && (Ye !== null && google.maps.event.removeListener(Ye), Te(google.maps.event.addListener(E, "rightclick", F)));
  }, [F]), v(() => {
    E && x && (Ke !== null && google.maps.event.removeListener(Ke), nt(google.maps.event.addListener(E, "click", x)));
  }, [x]), v(() => {
    E && D && (Me !== null && google.maps.event.removeListener(Me), Ae(google.maps.event.addListener(E, "drag", D)));
  }, [D]), v(() => {
    E && B && (Fe !== null && google.maps.event.removeListener(Fe), He(google.maps.event.addListener(E, "clickable_changed", B)));
  }, [B]), v(() => {
    E && $ && (ze !== null && google.maps.event.removeListener(ze), et(google.maps.event.addListener(E, "cursor_changed", $)));
  }, [$]), v(() => {
    E && V && (_e !== null && google.maps.event.removeListener(_e), At(google.maps.event.addListener(E, "animation_changed", V)));
  }, [V]), v(() => {
    E && z && (rt !== null && google.maps.event.removeListener(rt), ot(google.maps.event.addListener(E, "draggable_changed", z)));
  }, [z]), v(() => {
    E && q && (at !== null && google.maps.event.removeListener(at), qt(google.maps.event.addListener(E, "flat_changed", q)));
  }, [q]), v(() => {
    E && X && (lt !== null && google.maps.event.removeListener(lt), Gt(google.maps.event.addListener(E, "icon_changed", X)));
  }, [X]), v(() => {
    E && J && (Xe !== null && google.maps.event.removeListener(Xe), bt(google.maps.event.addListener(E, "position_changed", J)));
  }, [J]), v(() => {
    E && te && (tt !== null && google.maps.event.removeListener(tt), Yt(google.maps.event.addListener(E, "shape_changed", te)));
  }, [te]), v(() => {
    E && ee && (ut !== null && google.maps.event.removeListener(ut), dn(google.maps.event.addListener(E, "title_changed", ee)));
  }, [ee]), v(() => {
    E && k && (Kt !== null && google.maps.event.removeListener(Kt), fn(google.maps.event.addListener(E, "visible_changed", k)));
  }, [k]), v(() => {
    E && j && (Jt !== null && google.maps.event.removeListener(Jt), hn(google.maps.event.addListener(E, "zindex_changed", j)));
  }, [j]), v(() => {
    var wt = Aa(Aa(Aa({}, n || tf), r ? tf : {
      map: Z
    }), {}, {
      position: t
    }), re = new google.maps.Marker(wt);
    return r ? r.addMarker(re, !!o) : re.setMap(Z), t && re.setPosition(t), typeof a < "u" && re.setVisible(a), typeof s < "u" && re.setDraggable(s), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof m < "u" && re.setOpacity(m), f && re.setShape(f), typeof g == "string" && re.setTitle(g), typeof h == "number" && re.setZIndex(h), w && _(google.maps.event.addListener(re, "dblclick", w)), O && A(google.maps.event.addListener(re, "dragend", O)), y && N(google.maps.event.addListener(re, "dragstart", y)), L && ye(google.maps.event.addListener(re, "mousedown", L)), C && Ie(google.maps.event.addListener(re, "mouseout", C)), S && Ve(google.maps.event.addListener(re, "mouseover", S)), U && Je(google.maps.event.addListener(re, "mouseup", U)), F && Te(google.maps.event.addListener(re, "rightclick", F)), x && nt(google.maps.event.addListener(re, "click", x)), D && Ae(google.maps.event.addListener(re, "drag", D)), B && He(google.maps.event.addListener(re, "clickable_changed", B)), $ && et(google.maps.event.addListener(re, "cursor_changed", $)), V && At(google.maps.event.addListener(re, "animation_changed", V)), z && ot(google.maps.event.addListener(re, "draggable_changed", z)), q && qt(google.maps.event.addListener(re, "flat_changed", q)), X && Gt(google.maps.event.addListener(re, "icon_changed", X)), J && bt(google.maps.event.addListener(re, "position_changed", J)), te && Yt(google.maps.event.addListener(re, "shape_changed", te)), ee && dn(google.maps.event.addListener(re, "title_changed", ee)), k && fn(google.maps.event.addListener(re, "visible_changed", k)), j && hn(google.maps.event.addListener(re, "zindex_changed", j)), T(re), H && H(re), () => {
      R !== null && google.maps.event.removeListener(R), W !== null && google.maps.event.removeListener(W), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), $e !== null && google.maps.event.removeListener($e), Ne !== null && google.maps.event.removeListener(Ne), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Fe !== null && google.maps.event.removeListener(Fe), ze !== null && google.maps.event.removeListener(ze), _e !== null && google.maps.event.removeListener(_e), rt !== null && google.maps.event.removeListener(rt), at !== null && google.maps.event.removeListener(at), lt !== null && google.maps.event.removeListener(lt), Xe !== null && google.maps.event.removeListener(Xe), ut !== null && google.maps.event.removeListener(ut), Kt !== null && google.maps.event.removeListener(Kt), Jt !== null && google.maps.event.removeListener(Jt), M && M(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Fn = Nn(() => i ? it.map(i, (wt) => {
    if (!ti(wt))
      return wt;
    var re = wt;
    return ni(re, {
      anchor: E
    });
  }) : null, [i, E]);
  return ro.jsx(ro.Fragment, {
    children: Fn
  }) || null;
}
Le(nK);
class rK extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return gR(function* () {
      var n = Aa(Aa(Aa({}, t.props.options || tf), t.props.clusterer ? tf : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Rt({
        updaterMap: tP,
        eventMap: eP,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: tP,
      eventMap: eP,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Vt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? it.map(this.props.children, (n) => {
      if (!ti(n))
        return n;
      var r = n;
      return ni(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
he(rK, "contextType", gt);
var oK = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var m = document.createElement("div");
        m.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (m.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (m.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(m), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), iK = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new oK(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function sK(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var aK = 2e3, lK = 500, uK = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", cK = "png", pK = [53, 56, 66, 78, 90], dK = "cluster", wR = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || uK, this.imageExtension = r.imageExtension || cK, this.imageSizes = r.imageSizes || pK, this.calculator = r.calculator || sK, this.batchSize = r.batchSize || aK, this.batchSizeIE = r.batchSizeIE || lK, this.clusterClass = r.clusterClass || dK, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new iK(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var m = d[p];
            m.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function nP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fK(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nP(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var To = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Qt = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, hK = {};
function gK(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: m,
    minimumClusterSize: f,
    styles: g,
    title: h,
    zoomOnClick: x,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: O,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [L, F] = P(null), B = xe(gt), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null);
  return v(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, To.onMouseOut, C)));
  }, [C]), v(() => {
    L && y && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(L, To.onMouseOver, y)));
  }, [y]), v(() => {
    L && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(L, To.onClick, w)));
  }, [w]), v(() => {
    L && D && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(L, To.onClusteringBegin, D)));
  }, [D]), v(() => {
    L && O && (X !== null && google.maps.event.removeListener(X), q(google.maps.event.addListener(L, To.onClusteringEnd, O)));
  }, [O]), v(() => {
    typeof r < "u" && L !== null && Qt.averageCenter(L, r);
  }, [L, r]), v(() => {
    typeof o < "u" && L !== null && Qt.batchSizeIE(L, o);
  }, [L, o]), v(() => {
    typeof i < "u" && L !== null && Qt.calculator(L, i);
  }, [L, i]), v(() => {
    typeof s < "u" && L !== null && Qt.clusterClass(L, s);
  }, [L, s]), v(() => {
    typeof a < "u" && L !== null && Qt.enableRetinaIcons(L, a);
  }, [L, a]), v(() => {
    typeof l < "u" && L !== null && Qt.gridSize(L, l);
  }, [L, l]), v(() => {
    typeof u < "u" && L !== null && Qt.ignoreHidden(L, u);
  }, [L, u]), v(() => {
    typeof c < "u" && L !== null && Qt.imageExtension(L, c);
  }, [L, c]), v(() => {
    typeof p < "u" && L !== null && Qt.imagePath(L, p);
  }, [L, p]), v(() => {
    typeof d < "u" && L !== null && Qt.imageSizes(L, d);
  }, [L, d]), v(() => {
    typeof m < "u" && L !== null && Qt.maxZoom(L, m);
  }, [L, m]), v(() => {
    typeof f < "u" && L !== null && Qt.minimumClusterSize(L, f);
  }, [L, f]), v(() => {
    typeof g < "u" && L !== null && Qt.styles(L, g);
  }, [L, g]), v(() => {
    typeof h < "u" && L !== null && Qt.title(L, h);
  }, [L, h]), v(() => {
    typeof x < "u" && L !== null && Qt.zoomOnClick(L, x);
  }, [L, x]), v(() => {
    if (B) {
      var H = fK({}, n || hK), M = new wR(B, [], H);
      return r && Qt.averageCenter(M, r), o && Qt.batchSizeIE(M, o), i && Qt.calculator(M, i), s && Qt.clusterClass(M, s), a && Qt.enableRetinaIcons(M, a), l && Qt.gridSize(M, l), u && Qt.ignoreHidden(M, u), c && Qt.imageExtension(M, c), p && Qt.imagePath(M, p), d && Qt.imageSizes(M, d), m && Qt.maxZoom(M, m), f && Qt.minimumClusterSize(M, f), g && Qt.styles(M, g), h && Qt.title(M, h), x && Qt.zoomOnClick(M, x), C && ee(google.maps.event.addListener(M, To.onMouseOut, C)), y && j(google.maps.event.addListener(M, To.onMouseOver, y)), w && V(google.maps.event.addListener(M, To.onClick, w)), D && q(google.maps.event.addListener(M, To.onClusteringBegin, D)), O && J(google.maps.event.addListener(M, To.onClusteringEnd, O)), F(M), S && S(M), () => {
        te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), U && U(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
Le(gK);
class mK extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      markerClusterer: null
    }), he(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new wR(this.context, [], this.props.options);
      this.registeredEvents = Rt({
        updaterMap: Qt,
        eventMap: To,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: Qt,
      eventMap: To,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Vt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
he(mK, "contextType", gt);
function rP(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var CR = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || rP(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, rP));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, m = this.infoBoxClearance.width, f = this.infoBoxClearance.height, g = this.getProjection(), h = g.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + m ? r = h.x + u - m : h.x + p + u + m > a && (r = h.x + p + u + m - a), this.alignBottom ? h.y < -c + f + d ? o = h.y + c - f - d : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + d + c + f > l && (o = h.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), vK = ["position"], yK = ["position"];
function oP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oP(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var iP = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, sP = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, bK = {};
function wK(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = xe(gt), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), F = Qe(null);
  return v(() => {
    m && f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (m) {
      var B = r || bK, {
        position: $
      } = B, V = iC(B, vK), z;
      $ && !($ instanceof google.maps.LatLng) && (z = new google.maps.LatLng($.lat, $.lng));
      var q = new CR(nf(nf({}, V), z ? {
        position: z
      } : {}));
      F.current = document.createElement("div"), g(q), s && x(google.maps.event.addListener(q, "closeclick", s)), a && D(google.maps.event.addListener(q, "domready", a)), l && y(google.maps.event.addListener(q, "content_changed", l)), u && S(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(F.current), n ? q.open(m, n) : q.getPosition() ? q.open(m) : xr(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), F.current ? Cr(it.only(t), F.current) : null;
}
Le(wK);
class CK extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", null), he(this, "state", {
      infoBox: null
    }), he(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : xr(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), he(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = iC(t, yK), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new CR(nf(nf({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Rt({
      updaterMap: sP,
      eventMap: iP,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: sP,
      eventMap: iP,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Vt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Cr(it.only(this.props.children), this.containerElement) : null;
  }
}
he(CK, "contextType", gt);
var aP, lP;
function OK() {
  return lP || (lP = 1, aP = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), aP;
}
var xK = OK(), uP = /* @__PURE__ */ hR(xK), cP = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], zm = 1, Ol = 8;
class sC {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== zm)
      throw new Error("Got v".concat(o, " data when expected v").concat(zm, "."));
    var i = cP[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new sC(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = cP.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Ol, t), this.coords = new this.ArrayType(this.data, Ol + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Ol + s + a + l), this.ids = new this.IndexArrayType(this.data, Ol, t), this.coords = new this.ArrayType(this.data, Ol + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (zm << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return Pb(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (var m = d; m <= p; m++) {
          var f = s[2 * m], g = s[2 * m + 1];
          f >= t && f <= r && g >= n && g <= o && u.push(i[m]);
        }
        continue;
      }
      var h = d + p >> 1, x = s[2 * h], w = s[2 * h + 1];
      x >= t && x <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= x : n <= w) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= x : o >= w) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (var m = d; m <= p; m++)
          pP(i[2 * m], i[2 * m + 1], t, n) <= u && l.push(o[m]);
        continue;
      }
      var f = d + p >> 1, g = i[2 * f], h = i[2 * f + 1];
      pP(g, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= g : n - r <= h) && (a.push(d), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= h) && (a.push(f + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function Pb(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    OR(e, t, s, r, o, i), Pb(e, t, n, r, s - 1, 1 - i), Pb(e, t, n, s + 1, o, 1 - i);
  }
}
function OR(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - a * u / s + c)), d = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      OR(e, t, n, p, d, i);
    }
    var m = t[2 * n + i], f = r, g = o;
    for (xl(e, t, r, n), t[2 * o + i] > m && xl(e, t, r, o); f < g; ) {
      for (xl(e, t, f, g), f++, g--; t[2 * f + i] < m; ) f++;
      for (; t[2 * g + i] > m; ) g--;
    }
    t[2 * r + i] === m ? xl(e, t, r, g) : (g++, xl(e, t, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1);
  }
}
function xl(e, t, n, r) {
  Um(e, n, r), Um(t, 2 * n, 2 * r), Um(t, 2 * n + 1, 2 * r + 1);
}
function Um(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function pP(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var EK = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, dP = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Ns = 2, os = 3, $m = 4, Qi = 5, xR = 6;
class LK {
  constructor(t) {
    this.options = Object.assign(Object.create(EK), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = dP(gp(u)), d = dP(mp(c));
        s.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var m = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var g = +Date.now();
      m = this.trees[f] = this._createTree(this._cluster(m, f)), n && console.log("z%d: %d clusters in %dms", f, m.numItems, +Date.now() - g);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(gp(r), mp(s), gp(i), mp(o)), p = u.data, d = [];
    for (var m of c) {
      var f = this.stride * m;
      d.push(p[f + Qi] > 1 ? fP(p, f, this.clusterProps) : this.points[p[f + os]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (var d of c) {
      var m = d * this.stride;
      s[m + $m] === t && p.push(s[m + Qi] > 1 ? fP(s, m, this.clusterProps) : this.points[s[m + os]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new sC(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + Qi] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = ER(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var m = this.points[n[l + os]];
        c = m.properties;
        var [f, g] = m.geometry.coordinates;
        p = gp(f), d = mp(g);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, x = void 0;
      u || this.options.generateId ? x = n[l + os] : x = this.points[n[l + os]].id, x !== void 0 && (h.id = x), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Ns] <= n)) {
        l[p + Ns] = n;
        var d = l[p], m = l[p + 1], f = t.within(l[p], l[p + 1], a), g = l[p + Qi], h = g;
        for (var x of f) {
          var w = x * c;
          l[w + Ns] > n && (h += l[w + Qi]);
        }
        if (h > g && h >= s) {
          var D = d * g, O = m * g, y = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var L = U * c;
            if (!(l[L + Ns] <= n)) {
              l[L + Ns] = n;
              var F = l[L + Qi];
              D += l[L] * F, O += l[L + 1] * F, l[L + $m] = S, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + $m] = S, u.push(D / h, O / h, 1 / 0, S, -1, h), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (h > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Ns] <= n)) {
                l[V + Ns] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Qi] > 1) {
      var o = this.clusterProps[t[n + xR]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + os]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function fP(e, t, n) {
  return {
    type: "Feature",
    id: e[t + os],
    properties: ER(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [PK(e[t]), kK(e[t + 1])]
    }
  };
}
function ER(e, t, n) {
  var r = e[t + Qi], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + xR], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + os],
    point_count: r,
    point_count_abbreviated: o
  });
}
function gp(e) {
  return e / 360 + 0.5;
}
function mp(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function PK(e) {
  return (e - 0.5) * 360;
}
function kK(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function SK(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class go {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class kb {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(go.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => go.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (go.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class DK {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return MK(n);
  }
}
var MK = (e) => {
  var t = e.map((n) => new kb({
    position: go.getPosition(n),
    markers: [n]
  }));
  return t;
};
class TK extends DK {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = SK(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new LK(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!uP(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = go.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !uP(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new kb({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new kb({
      markers: [i],
      position: go.getPosition(i)
    });
  }
}
class jK {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class _K {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (go.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(a, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var m = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(m);
  }
}
function AK(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class aC {
  constructor() {
    AK(aC, google.maps.OverlayView);
  }
}
var iu;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(iu || (iu = {}));
var BK = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class IK extends aC {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new TK(o),
      renderer: s = new _K(),
      onClusterClick: a = BK
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (go.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, iu.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || go.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => go.setMap(l, null)));
      }
      google.maps.event.trigger(this, iu.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => go.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new jK(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => go.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, iu.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), go.setMap(r.marker, n);
    });
  }
}
function hP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hP(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function NK(e) {
  var t = BY(), [n, r] = P(null);
  return v(() => {
    if (t && n === null) {
      var o = new IK(gP(gP({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function FK(e) {
  var {
    children: t,
    options: n
  } = e, r = NK(n);
  return r !== null ? t(r) : null;
}
Le(FK);
var mP = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, vP = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function RK(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = xe(gt), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), F = Qe(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var B = new google.maps.InfoWindow(r);
    return g(B), F.current = document.createElement("div"), s && x(google.maps.event.addListener(B, "closeclick", s)), a && D(google.maps.event.addListener(B, "domready", a)), l && y(google.maps.event.addListener(B, "content_changed", l)), u && S(google.maps.event.addListener(B, "position_changed", u)), c && L(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(F.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(m, n) : B.getPosition() ? B.open(m) : xr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      h && google.maps.event.removeListener(h), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(B), B.close();
    };
  }, []), F.current ? Cr(it.only(t), F.current) : null;
}
Le(RK);
class zK extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", null), he(this, "state", {
      infoWindow: null
    }), he(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : xr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), he(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Rt({
      updaterMap: vP,
      eventMap: mP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: vP,
      eventMap: mP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Vt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Cr(it.only(this.props.children), this.containerElement) : null;
  }
}
he(zK, "contextType", gt);
function yP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yP(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var bP = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, wP = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, UK = {};
function $K(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onLoad: x,
    onUnmount: w
  } = e, D = xe(gt), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null);
  return v(() => {
    O !== null && O.setMap(D);
  }, [D]), v(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), v(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), v(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), v(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), v(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), v(() => {
    O && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(O, "dblclick", s)));
  }, [s]), v(() => {
    O && a && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(O, "dragend", a)));
  }, [a]), v(() => {
    O && l && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), v(() => {
    O && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), v(() => {
    O && c && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), v(() => {
    O && p && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), v(() => {
    O && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), v(() => {
    O && m && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(O, "mouseup", m)));
  }, [m]), v(() => {
    O && f && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), v(() => {
    O && g && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(O, "click", g)));
  }, [g]), v(() => {
    O && h && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(O, "drag", h)));
  }, [h]), v(() => {
    var _ = new google.maps.Polyline(rf(rf({}, t || UK), {}, {
      map: D
    }));
    return i && _.setPath(i), typeof o < "u" && _.setVisible(o), typeof r < "u" && _.setEditable(r), typeof n < "u" && _.setDraggable(n), s && S(google.maps.event.addListener(_, "dblclick", s)), a && L(google.maps.event.addListener(_, "dragend", a)), l && B(google.maps.event.addListener(_, "dragstart", l)), u && V(google.maps.event.addListener(_, "mousedown", u)), c && q(google.maps.event.addListener(_, "mousemove", c)), p && J(google.maps.event.addListener(_, "mouseout", p)), d && ee(google.maps.event.addListener(_, "mouseover", d)), m && j(google.maps.event.addListener(_, "mouseup", m)), f && M(google.maps.event.addListener(_, "rightclick", f)), g && E(google.maps.event.addListener(_, "click", g)), h && R(google.maps.event.addListener(_, "drag", h)), y(_), x && x(_), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), w && w(_), _.setMap(null);
    };
  }, []), null;
}
Le($K);
class VK extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      polyline: null
    }), he(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(rf(rf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Rt({
      updaterMap: wP,
      eventMap: bP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: wP,
      eventMap: bP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Vt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
he(VK, "contextType", gt);
function CP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function OP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CP(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xP = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, EP = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function HK(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: x,
    onLoad: w,
    onUnmount: D,
    onEdit: O
  } = e, y = xe(gt), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof s < "u" && C !== null && C.setPaths(s);
  }, [C, s]), v(() => {
    C && typeof a == "function" && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(C, "dblclick", a)));
  }, [a]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      O == null || O(C);
    }));
  }, [C, O]), v(() => {
    C && typeof l == "function" && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof m == "function" && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(C, "mouseover", m)));
  }, [m]), v(() => {
    C && typeof f == "function" && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof g == "function" && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(C, "rightclick", g)));
  }, [g]), v(() => {
    C && typeof h == "function" && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(C, "click", h)));
  }, [h]), v(() => {
    C && typeof x == "function" && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(C, "drag", x)));
  }, [x]), v(() => {
    var A = new google.maps.Polygon(OP(OP({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), s && A.setPaths(s), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), a && L(google.maps.event.addListener(A, "dblclick", a)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), m && j(google.maps.event.addListener(A, "mouseover", m)), f && M(google.maps.event.addListener(A, "mouseup", f)), g && E(google.maps.event.addListener(A, "rightclick", g)), h && R(google.maps.event.addListener(A, "click", h)), x && W(google.maps.event.addListener(A, "drag", x)), S(A), w && w(A), () => {
      U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), T !== null && google.maps.event.removeListener(T), D && D(A), A.setMap(null);
    };
  }, []), null;
}
Le(HK);
class WK extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Rt({
      updaterMap: EP,
      eventMap: xP,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: EP,
      eventMap: xP,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Vt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
he(WK, "contextType", gt);
function LP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function of(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LP(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PP = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, kP = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function ZK(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onBoundsChanged: x,
    onLoad: w,
    onUnmount: D
  } = e, O = xe(gt), [y, C] = P(null), [S, U] = P(null), [L, F] = P(null), [B, $] = P(null), [V, z] = P(null), [q, X] = P(null), [J, te] = P(null), [ee, k] = P(null), [j, H] = P(null), [M, Z] = P(null), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null);
  return v(() => {
    y !== null && y.setMap(O);
  }, [O]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && s && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(y, "dblclick", s)));
  }, [s]), v(() => {
    y && a && (L !== null && google.maps.event.removeListener(L), F(google.maps.event.addListener(y, "dragend", a)));
  }, [a]), v(() => {
    y && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (q !== null && google.maps.event.removeListener(q), X(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && m && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(y, "mouseup", m)));
  }, [m]), v(() => {
    y && f && (M !== null && google.maps.event.removeListener(M), Z(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && g && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(y, "click", g)));
  }, [g]), v(() => {
    y && h && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(y, "drag", h)));
  }, [h]), v(() => {
    y && x && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(y, "bounds_changed", x)));
  }, [x]), v(() => {
    var Q = new google.maps.Rectangle(of(of({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), s && U(google.maps.event.addListener(Q, "dblclick", s)), a && F(google.maps.event.addListener(Q, "dragend", a)), l && $(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && X(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && k(google.maps.event.addListener(Q, "mouseover", d)), m && H(google.maps.event.addListener(Q, "mouseup", m)), f && Z(google.maps.event.addListener(Q, "rightclick", f)), g && T(google.maps.event.addListener(Q, "click", g)), h && _(google.maps.event.addListener(Q, "drag", h)), x && A(google.maps.event.addListener(Q, "bounds_changed", x)), C(Q), w && w(Q), () => {
      S !== null && google.maps.event.removeListener(S), L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), M !== null && google.maps.event.removeListener(M), E !== null && google.maps.event.removeListener(E), R !== null && google.maps.event.removeListener(R), W !== null && google.maps.event.removeListener(W), D && D(Q), Q.setMap(null);
    };
  }, []), null;
}
Le(ZK);
class qK extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      rectangle: null
    }), he(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(of(of({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Rt({
      updaterMap: kP,
      eventMap: PP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: kP,
      eventMap: PP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Vt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
he(qK, "contextType", gt);
function SP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SP(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var DP = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, MP = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, GK = {};
function YK(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: x,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: O,
    onUnmount: y
  } = e, C = xe(gt), [S, U] = P(null), [L, F] = P(null), [B, $] = P(null), [V, z] = P(null), [q, X] = P(null), [J, te] = P(null), [ee, k] = P(null), [j, H] = P(null), [M, Z] = P(null), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null), [Q, N] = P(null), [ue, ye] = P(null);
  return v(() => {
    S !== null && S.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), v(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), v(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), v(() => {
    typeof s < "u" && S !== null && S.setVisible(s);
  }, [S, s]), v(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), v(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), v(() => {
    S && a && (L !== null && google.maps.event.removeListener(L), F(google.maps.event.addListener(S, "dblclick", a)));
  }, [a]), v(() => {
    S && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), v(() => {
    S && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), v(() => {
    S && c && (q !== null && google.maps.event.removeListener(q), X(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), v(() => {
    S && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), v(() => {
    S && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), v(() => {
    S && m && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(S, "mouseover", m)));
  }, [m]), v(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), Z(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), v(() => {
    S && g && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(S, "rightclick", g)));
  }, [g]), v(() => {
    S && h && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(S, "click", h)));
  }, [h]), v(() => {
    S && x && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(S, "drag", x)));
  }, [x]), v(() => {
    S && w && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(S, "center_changed", w)));
  }, [h]), v(() => {
    S && D && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), v(() => {
    var oe = new google.maps.Circle(sf(sf({}, t || GK), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof s < "u" && oe.setVisible(s), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), a && F(google.maps.event.addListener(oe, "dblclick", a)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), m && H(google.maps.event.addListener(oe, "mouseover", m)), f && Z(google.maps.event.addListener(oe, "mouseup", f)), g && T(google.maps.event.addListener(oe, "rightclick", g)), h && _(google.maps.event.addListener(oe, "click", h)), x && A(google.maps.event.addListener(oe, "drag", x)), w && N(google.maps.event.addListener(oe, "center_changed", w)), D && ye(google.maps.event.addListener(oe, "radius_changed", D)), U(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), M !== null && google.maps.event.removeListener(M), E !== null && google.maps.event.removeListener(E), R !== null && google.maps.event.removeListener(R), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
Le(YK);
class KK extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      circle: null
    }), he(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(sf(sf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Rt({
      updaterMap: MP,
      eventMap: DP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: MP,
      eventMap: DP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Vt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
he(KK, "contextType", gt);
function TP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function af(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TP(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jP = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, _P = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function JK(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: m,
    onSetProperty: f,
    onLoad: g,
    onUnmount: h
  } = e, x = xe(gt), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null);
  return v(() => {
    w !== null && w.setMap(x);
  }, [x]), v(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && s && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), v(() => {
    w && a && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && m && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(w, "setgeometry", m)));
  }, [m]), v(() => {
    w && f && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (x !== null) {
      var A = new google.maps.Data(af(af({}, t), {}, {
        map: x
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), s && B(google.maps.event.addListener(A, "mouseout", s)), a && V(google.maps.event.addListener(A, "mouseover", a)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && j(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && E(google.maps.event.addListener(A, "removeproperty", d)), m && R(google.maps.event.addListener(A, "setgeometry", m)), f && W(google.maps.event.addListener(A, "setproperty", f)), D(A), g && g(A);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), T !== null && google.maps.event.removeListener(T), _ !== null && google.maps.event.removeListener(_), h && h(w), w.setMap(null));
    };
  }, []), null;
}
Le(JK);
class XK extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      data: null
    }), he(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(af(af({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Rt({
        updaterMap: _P,
        eventMap: jP,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: _P,
      eventMap: jP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Vt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
he(XK, "contextType", gt);
function AP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function BP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AP(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var IP = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, NP = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class QK extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      kmlLayer: null
    }), he(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(BP(BP({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Rt({
      updaterMap: NP,
      eventMap: IP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: NP,
      eventMap: IP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Vt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(QK, "contextType", gt);
function LR(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function eJ(e, t) {
  return new t(e.lat, e.lng);
}
function tJ(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function nJ(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function rJ(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function oJ(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function iJ(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function PR(e, t, n, r) {
  return n !== void 0 ? oJ(e, t, rJ(n, google.maps.LatLngBounds, tJ)) : iJ(e, t, nJ(r, google.maps.LatLng, eJ));
}
function sJ(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function FP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aJ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FP(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function lJ(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = aJ({}, this.container ? LR(this.container, o) : {
        x: 0,
        y: 0
      }), u = PR(a, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function RP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uJ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RP(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function zP(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function UP(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function cJ(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = xe(gt), c = Nn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Nn(() => lJ(c, r, t, n, a), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    s == null || s(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), oi.createPortal(l, c);
}
Le(cJ);
class tl extends be {
  constructor(t) {
    super(t), he(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), he(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      xr(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), he(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), he(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = uJ({
        x: 0,
        y: 0
      }, this.containerRef.current ? LR(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = PR(r, o, this.props.bounds, this.props.position);
      if (!sJ(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), he(this, "draw", () => {
      this.onPositionElement();
    }), he(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = wr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = zP(t.position), r = zP(this.props.position), o = UP(t.bounds), i = UP(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? oi.createPortal(ro.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: it.only(this.props.children)
    }), t) : null;
  }
}
he(tl, "FLOAT_PANE", "floatPane");
he(tl, "MAP_PANE", "mapPane");
he(tl, "MARKER_LAYER", "markerLayer");
he(tl, "OVERLAY_LAYER", "overlayLayer");
he(tl, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
he(tl, "contextType", gt);
function pJ() {
}
function $P(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function VP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $P(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $P(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var HP = {
  onDblClick: "dblclick",
  onClick: "click"
}, WP = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function dJ(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = xe(gt), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Nn(() => new google.maps.GroundOverlay(t, s, r), []);
  return v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), v(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Le(dJ);
class kR extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      groundOverlay: null
    }), he(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    xr(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, VP(VP({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Rt({
      updaterMap: WP,
      eventMap: HP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: WP,
      eventMap: HP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
he(kR, "defaultProps", {
  onLoad: pJ
});
he(kR, "contextType", gt);
function ZP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZP(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qP = {}, GP = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function fJ(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = xe(gt), [s, a] = P(null);
  return v(() => {
    google.maps.visualization || xr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    xr(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(lf(lf({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Le(fJ);
class hJ extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      heatmapLayer: null
    }), he(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    xr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), xr(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(lf(lf({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Rt({
      updaterMap: GP,
      eventMap: qP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: GP,
      eventMap: qP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Vt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(hJ, "contextType", gt);
var YP = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, KP = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class gJ extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      streetViewPanorama: null
    }), he(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Rt({
      updaterMap: KP,
      eventMap: YP,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: KP,
      eventMap: YP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Vt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
he(gJ, "contextType", gt);
class mJ extends be {
  constructor() {
    super(...arguments), he(this, "state", {
      streetViewService: null
    }), he(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
he(mJ, "contextType", gt);
var JP = {
  onDirectionsChanged: "directions_changed"
}, XP = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class vJ extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      directionsRenderer: null
    }), he(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Rt({
      updaterMap: XP,
      eventMap: JP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: XP,
      eventMap: JP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Vt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
he(vJ, "contextType", gt);
var QP = {
  onPlacesChanged: "places_changed"
}, ek = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class yJ extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", wr()), he(this, "state", {
      searchBox: null
    }), he(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (xr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Rt({
          updaterMap: ek,
          eventMap: QP,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: ek,
      eventMap: QP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Vt(this.registeredEvents));
  }
  render() {
    return ro.jsx("div", {
      ref: this.containerElement,
      children: it.only(this.props.children)
    });
  }
}
he(yJ, "contextType", gt);
var tk = {
  onPlaceChanged: "place_changed"
}, nk = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class SR extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", wr()), he(this, "state", {
      autocomplete: null
    }), he(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    xr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Rt({
        updaterMap: nk,
        eventMap: tk,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Vt(this.registeredEvents), this.registeredEvents = Rt({
      updaterMap: nk,
      eventMap: tk,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Vt(this.registeredEvents);
  }
  render() {
    return ro.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: it.only(this.props.children)
    });
  }
}
he(SR, "defaultProps", {
  className: ""
});
he(SR, "contextType", gt);
let bJ = { data: "" }, wJ = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || bJ, CJ = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, OJ = /\/\*[^]*?\*\/|  +/g, rk = /\n+/g, ps = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? ps(s, i) : i + "{" + ps(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += ps(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ps.p ? ps.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ci = {}, DR = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + DR(e[n]);
    return t;
  }
  return e;
}, xJ = (e, t, n, r, o) => {
  let i = DR(e), s = Ci[i] || (Ci[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ci[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = CJ.exec(u.replace(OJ, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(rk, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(rk, " ").trim();
      return d[0];
    })(e);
    Ci[s] = ps(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Ci.g ? Ci.g : null;
  return n && (Ci.g = Ci[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ci[s], t, r, a), s;
}, EJ = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : ps(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function mg(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return xJ(n.unshift ? n.raw ? EJ(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, wJ(t.target), t.g, t.o, t.k);
}
let MR, Sb, Db;
mg.bind({ g: 1 });
let ji = mg.bind({ k: 1 });
function LJ(e, t, n, r) {
  ps.p = t, MR = e, Sb = n, Db = r;
}
function Ms(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: Sb && Sb() }, a), n.o = / *go\d+/.test(l), a.className = mg.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), Db && u[0] && Db(a), MR(u, a);
    }
    return o;
  };
}
var PJ = (e) => typeof e == "function", kJ = (e, t) => PJ(e) ? e(t) : e, SJ = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), DJ = ji`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, MJ = ji`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, TJ = ji`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, jJ = Ms("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${DJ} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${MJ} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${TJ} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, _J = ji`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, AJ = Ms("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${_J} 1s linear infinite;
`, BJ = ji`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, IJ = ji`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, NJ = Ms("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${BJ} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${IJ} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, FJ = Ms("div")`
  position: absolute;
`, RJ = Ms("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, zJ = ji`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, UJ = Ms("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${zJ} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, $J = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ue.createElement(UJ, null, t) : t : n === "blank" ? null : Ue.createElement(RJ, null, Ue.createElement(AJ, { ...r }), n !== "loading" && Ue.createElement(FJ, null, n === "error" ? Ue.createElement(jJ, { ...r }) : Ue.createElement(NJ, { ...r })));
}, VJ = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, HJ = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, WJ = "0%{opacity:0;} 100%{opacity:1;}", ZJ = "0%{opacity:1;} 100%{opacity:0;}", qJ = Ms("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, GJ = Ms("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, YJ = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = SJ() ? [WJ, ZJ] : [VJ(n), HJ(n)];
  return { animation: t ? `${ji(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ji(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ue.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? YJ(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ue.createElement($J, { toast: e }), s = Ue.createElement(GJ, { ...e.ariaProps }, kJ(e.message, e));
  return Ue.createElement(qJ, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ue.createElement(Ue.Fragment, null, i, s));
});
LJ(Ue.createElement);
mg`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ge({});
function KJ(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const JJ = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
KJ(JJ.CNPJ).length;
Da((e, t) => /* @__PURE__ */ no.jsx("input", { ref: t, ...e }));
Ge({});
var Fi = {};
Object.defineProperty(Fi, "__esModule", {
  value: !0
});
var XJ = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Vm = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, TR = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: XJ ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, lC = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var vp = 1; vp < 20; vp++)
  lC["f" + vp] = 111 + vp;
function vg(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return jR(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return _R(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function QJ(e, t) {
  return vg(e, t);
}
function eX(e, t) {
  return vg(e, { byKey: !0 }, t);
}
function jR(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in Vm)
    r[Vm[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, m = d.endsWith("?") && d.length > 1;
      m && (d = d.slice(0, -1));
      var f = uC(d), g = Vm[f];
      if (d.length > 1 && !g && !TR[d] && !lC[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !g) && (n ? r.key = f : r.which = AR(d)), g && (r[g] = m ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function _R(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function AR(e) {
  e = uC(e);
  var t = lC[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function uC(e) {
  return e = e.toLowerCase(), e = TR[e] || e, e;
}
Fi.default = vg;
var Hm = Fi.isHotkey = vg;
Fi.isCodeHotkey = QJ;
Fi.isKeyHotkey = eX;
Fi.parseHotkey = jR;
Fi.compareHotkey = _R;
Fi.toKeyCode = AR;
Fi.toKeyName = uC;
var tX = typeof kn == "object" && kn && kn.Object === Object && kn, nX = tX, rX = nX, oX = typeof self == "object" && self && self.Object === Object && self, iX = rX || oX || Function("return this")(), sX = iX, aX = sX, lX = aX.Symbol, BR = lX, ok = BR;
ok && ok.toStringTag;
var ik = BR;
ik && ik.toStringTag;
var sk;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(sk || (sk = {}));
var cC = function(e) {
  return Object.freeze(e);
}, uX = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, cC(this);
  }
  return e;
}(), cX = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, cC(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), ak = typeof window < "u" ? window : {};
/msie|trident/i.test(ak.navigator && ak.navigator.userAgent);
var Wm = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new uX((n ? t : e) || 0, (n ? e : t) || 0);
};
cC({
  devicePixelContentBoxSize: Wm(),
  borderBoxSize: Wm(),
  contentBoxSize: Wm(),
  contentRect: new cX(0, 0, 0, 0)
});
function Fu(e) {
  "@babel/helpers - typeof";
  return Fu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Fu(e);
}
function pX(e, t) {
  if (Fu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Fu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function dX(e) {
  var t = pX(e, "string");
  return Fu(t) === "symbol" ? t : String(t);
}
function su(e, t, n) {
  return t = dX(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var fX = /* @__PURE__ */ Ge(null), Zm, qm;
parseInt(Ee.version.split(".")[0], 10);
var lk = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Gm = typeof navigator < "u" && /Android/.test(navigator.userAgent), yp = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), hX = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Zm = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Zm !== void 0 && Zm[1] && parseInt((qm = navigator.userAgent.match(/Version\/(\d+)/)) === null || qm === void 0 ? void 0 : qm[1], 10) < 17;
var gX = /* @__PURE__ */ new WeakMap(), mX = /* @__PURE__ */ new WeakMap(), vX = /* @__PURE__ */ new WeakMap(), yX = /* @__PURE__ */ new WeakMap(), bX = /* @__PURE__ */ new WeakMap(), uk = /* @__PURE__ */ new WeakMap(), wX = /* @__PURE__ */ new WeakMap(), ck = /* @__PURE__ */ new WeakMap(), bp = /* @__PURE__ */ new WeakMap(), CX = /* @__PURE__ */ new WeakMap(), OX = /* @__PURE__ */ new WeakMap(), xX = /* @__PURE__ */ new WeakMap(), IR = globalThis.Node, EX = globalThis.Text, NR = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, LX = (e) => uf(e) && e.nodeType === 8, Xo = (e) => uf(e) && e.nodeType === 1, uf = (e) => {
  var t = NR(e);
  return !!t && e instanceof t.Node;
}, pk = (e) => {
  var t = e && e.anchorNode && NR(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, PX = (e) => {
  var [t, n] = e;
  if (Xo(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = FR(t, o, r ? "backward" : "forward"), r = o < n; Xo(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = SX(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, kX = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, FR = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (LX(o) || Xo(o) && o.childNodes.length === 0 || Xo(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, SX = (e, t, n) => {
  var [r] = FR(e, t, n);
  return r;
}, dk = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), RR = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Xo(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = It.getWindow(e);
  if (o.contains(r))
    return It.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : RR(e, i, n);
}, fk = (e, t) => !!(e.compareDocumentPosition(t) & IR.DOCUMENT_POSITION_PRECEDING), DX = (e, t) => !!(e.compareDocumentPosition(t) & IR.DOCUMENT_POSITION_FOLLOWING), MX = 0;
class TX {
  constructor() {
    su(this, "id", void 0), this.id = "".concat(MX++);
  }
}
var It = {
  androidPendingDiffs: (e) => xX.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = OX.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = It.toDOMNode(e, e), n = It.findDocumentOrShadowRoot(e);
    bp.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = It.findDocumentOrShadowRoot(e), r = dk(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Hd.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = It.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = It.toSlateNode(e, t.target), s = It.findPath(e, i);
    if (Si.isElement(i) && On.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = On.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? On.before(e, u) : On.after(e, u);
      if (c) {
        var p = On.range(e, c);
        return p;
      }
    }
    var d, {
      document: m
    } = It.getWindow(e);
    if (m.caretRangeFromPoint)
      d = m.caretRangeFromPoint(n, r);
    else {
      var f = m.caretPositionFromPoint(n, r);
      f && (d = m.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var g = It.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return g;
  },
  findKey: (e, t) => {
    var n = uk.get(t);
    return n || (n = new TX(), uk.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = mX.get(r);
      if (o == null) {
        if (On.isEditor(r))
          return n;
        break;
      }
      var i = gX.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(fo.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!bp.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          It.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = It.toDOMNode(e, e), r = It.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = dk(r), i = It.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Hd.select(e, On.start(e, [])), bp.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = vX.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = It.toDOMNode(e, e), i;
    try {
      i = Xo(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => uf(t) && It.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return On.hasPath(e, n.path) && On.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => It.hasEditableTarget(e, t) || It.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => uf(t) && It.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!CX.get(e),
  isFocused: (e) => !!bp.get(e),
  isReadOnly: (e) => !!ck.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (ck.get(e)) return !1;
    var n = It.hasTarget(e, t) && It.toSlateNode(e, t);
    return Si.isElement(n) && On.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = wX.get(e), r = On.isEditor(t) ? yX.get(e) : n == null ? void 0 : n.get(It.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(fo.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = On.node(e, t.path), r = It.toDOMNode(e, n), o;
    On.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), m = d == null ? p : parseInt(d, 10), f = a + m, g = s[l + 1];
        if (t.offset === f && g !== null && g !== void 0 && g.hasAttribute("data-slate-mark-placeholder")) {
          var h, x = g.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            x instanceof EX ? x : g,
            (h = g.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(fo.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Lt.isBackward(t), i = It.toDOMPoint(e, n), s = Lt.isCollapsed(t) ? i : It.toDOMPoint(e, r), a = It.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, m = Xo(u) ? u : u.parentElement, f = !!m.getAttribute("data-slate-zero-width"), g = Xo(p) ? p : p.parentElement, h = !!g.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Xo(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? bX.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : PX(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, m = It.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), g = f && m.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), x = h && m.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = It.getWindow(e), y = O.document.createRange();
          y.setStart(u, 0), y.setEnd(s, a);
          var C = y.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (Gm && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (g) {
        for (var U = g.querySelectorAll("[data-slate-leaf]"), L = 0; L < U.length; L++) {
          var F = U[L];
          if (It.hasDOMNode(e, F)) {
            w = F;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (x) {
        var B = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = x.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...B($), ...B($ == null ? void 0 : $.nextElementSibling)];
          w = (V = z.find((M) => DX(x, M))) !== null && V !== void 0 ? V : null;
        } else {
          var q, X = [...B($ == null ? void 0 : $.previousElementSibling), ...B($)];
          w = (q = X.findLast((M) => fk(x, M))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Gm && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      yp && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Gm && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && It.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = It.toSlateNode(e, J), {
          path: ee,
          offset: k
        } = On.start(e, It.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (k = a), {
          path: ee,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var j = It.toSlateNode(e, u), H = It.findPath(e, j);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = pk(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (pk(t)) {
        if (yp && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), m = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && m.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, g = m.startContainer, h = C(f.children[d.startOffset]), x = C(g.children[m.startOffset]);
            c = 0, x.childNodes.length > 0 ? a = x.childNodes[0] : a = x, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, x instanceof HTMLElement ? l = x.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = m.endContainer, l = m.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = m.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        hX && kX(a) || yp ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    yp && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = It.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = fk(a, u) || a === u && c < l, O = p ? w : It.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!O)
      return null;
    var y = {
      anchor: w,
      focus: O
    };
    return Lt.isExpanded(y) && Lt.isForward(y) && Xo(u) && On.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = On.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, jX = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, _X = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, AX = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Zn = (e) => {
  var t = jX[e], n = _X[e], r = AX[e], o = t && Hm(t), i = n && Hm(n), s = r && Hm(r);
  return (a) => !!(o && o(a) || lk && i && i(a) || !lk && s && s(a));
};
Zn("bold"), Zn("compose"), Zn("moveBackward"), Zn("moveForward"), Zn("deleteBackward"), Zn("deleteForward"), Zn("deleteLineBackward"), Zn("deleteLineForward"), Zn("deleteWordBackward"), Zn("deleteWordForward"), Zn("extendBackward"), Zn("extendForward"), Zn("extendLineBackward"), Zn("extendLineForward"), Zn("italic"), Zn("moveLineBackward"), Zn("moveLineForward"), Zn("moveWordBackward"), Zn("moveWordForward"), Zn("redo"), Zn("insertSoftBreak"), Zn("splitBlock"), Zn("transposeCharacter"), Zn("undo");
var BX = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => RR(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, IX = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class NX extends Yu {
  constructor() {
    super(...arguments), su(this, "context", null), su(this, "manager", null), su(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, IX);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = BX(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
su(NX, "contextType", fX);
Ge({});
Ge({});
Ge({});
var mr = {}, pC = {}, rc = {}, oc = {}, zR = "Expected a function", hk = NaN, FX = "[object Symbol]", RX = /^\s+|\s+$/g, zX = /^[-+]0x[0-9a-f]+$/i, UX = /^0b[01]+$/i, $X = /^0o[0-7]+$/i, VX = parseInt, HX = typeof kn == "object" && kn && kn.Object === Object && kn, WX = typeof self == "object" && self && self.Object === Object && self, ZX = HX || WX || Function("return this")(), qX = Object.prototype, GX = qX.toString, YX = Math.max, KX = Math.min, Ym = function() {
  return ZX.Date.now();
};
function JX(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(zR);
  t = gk(t) || 0, cf(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? YX(gk(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function m(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, s = e.apply(U, S), s;
  }
  function f(C) {
    return u = C, a = setTimeout(x, t), c ? m(C) : s;
  }
  function g(C) {
    var S = C - l, U = C - u, L = t - S;
    return p ? KX(L, i - U) : L;
  }
  function h(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function x() {
    var C = Ym();
    if (h(C))
      return w(C);
    a = setTimeout(x, g(C));
  }
  function w(C) {
    return a = void 0, d && r ? m(C) : (r = o = void 0, s);
  }
  function D() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function O() {
    return a === void 0 ? s : w(Ym());
  }
  function y() {
    var C = Ym(), S = h(C);
    if (r = arguments, o = this, l = C, S) {
      if (a === void 0)
        return f(l);
      if (p)
        return a = setTimeout(x, t), m(l);
    }
    return a === void 0 && (a = setTimeout(x, t)), s;
  }
  return y.cancel = D, y.flush = O, y;
}
function XX(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(zR);
  return cf(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), JX(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function cf(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function QX(e) {
  return !!e && typeof e == "object";
}
function eQ(e) {
  return typeof e == "symbol" || QX(e) && GX.call(e) == FX;
}
function gk(e) {
  if (typeof e == "number")
    return e;
  if (eQ(e))
    return hk;
  if (cf(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = cf(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(RX, "");
  var n = UX.test(e);
  return n || $X.test(e) ? VX(e.slice(2), n ? 2 : 8) : zX.test(e) ? hk : +e;
}
var tQ = XX, ic = {};
Object.defineProperty(ic, "__esModule", {
  value: !0
});
ic.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), fd.has(t) || fd.set(t, /* @__PURE__ */ new Set());
  var o = fd.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
ic.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), fd.get(t).delete(n.name || t);
};
var fd = /* @__PURE__ */ new Map();
Object.defineProperty(oc, "__esModule", {
  value: !0
});
var nQ = tQ, rQ = iQ(nQ), oQ = ic;
function iQ(e) {
  return e && e.__esModule ? e : { default: e };
}
var sQ = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, rQ.default)(e, t);
}, nr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = sQ(function(r) {
        nr.scrollHandler(e);
      }, t);
      nr.scrollSpyContainers.push(e), (0, oQ.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return nr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = nr.scrollSpyContainers[nr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(nr.currentPositionX(e), nr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    nr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = nr.scrollSpyContainers[nr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(nr.currentPositionX(t), nr.currentPositionY(t));
  },
  updateStates: function() {
    nr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    nr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), nr.spySetState && nr.spySetState.length && nr.spySetState.indexOf(e) > -1 && nr.spySetState.splice(nr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", nr.scrollHandler);
  },
  update: function() {
    return nr.scrollSpyContainers.forEach(function(e) {
      return nr.scrollHandler(e);
    });
  }
};
oc.default = nr;
var nl = {}, sc = {};
Object.defineProperty(sc, "__esModule", {
  value: !0
});
var aQ = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, lQ = function() {
  return window.location.hash.replace(/^#/, "");
}, uQ = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, cQ = function(e) {
  return getComputedStyle(e).position !== "static";
}, Km = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, pQ = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (cQ(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Km(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return Km(t, a).offsetTop - Km(e, a).offsetTop;
};
sc.default = {
  updateHash: aQ,
  getHash: lQ,
  filterElementInContainer: uQ,
  scrollOffset: pQ
};
var yg = {}, dC = {};
Object.defineProperty(dC, "__esModule", {
  value: !0
});
dC.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var fC = {};
Object.defineProperty(fC, "__esModule", {
  value: !0
});
var dQ = ic, fQ = ["mousedown", "mousewheel", "touchmove", "keydown"];
fC.default = {
  subscribe: function(e) {
    return typeof document < "u" && fQ.forEach(function(t) {
      return (0, dQ.addPassiveEventListener)(document, t, e);
    });
  }
};
var ac = {};
Object.defineProperty(ac, "__esModule", {
  value: !0
});
var Mb = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Mb.registered[e] = t;
    },
    remove: function(e) {
      Mb.registered[e] = null;
    }
  }
};
ac.default = Mb;
Object.defineProperty(yg, "__esModule", {
  value: !0
});
var hQ = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, gQ = sc;
bg(gQ);
var mQ = dC, mk = bg(mQ), vQ = fC, yQ = bg(vQ), bQ = ac, qo = bg(bQ);
function bg(e) {
  return e && e.__esModule ? e : { default: e };
}
var UR = function(e) {
  return mk.default[e.smooth] || mk.default.defaultEasing;
}, wQ = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, CQ = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Tb = function() {
  return CQ() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), $R = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, VR = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, HR = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, OQ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, xQ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, EQ = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    qo.default.registered.end && qo.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Tb.call(window, i);
    return;
  }
  qo.default.registered.end && qo.default.registered.end(o.to, o.target, o.currentPosition);
}, hC = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, lc = function(e, t, n, r) {
  t.data = t.data || $R(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (yQ.default.subscribe(o), hC(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? VR(t) : HR(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    qo.default.registered.end && qo.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = wQ(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = UR(t), s = EQ.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      qo.default.registered.begin && qo.default.registered.begin(t.data.to, t.data.target), Tb.call(window, s);
    }, t.delay);
    return;
  }
  qo.default.registered.begin && qo.default.registered.begin(t.data.to, t.data.target), Tb.call(window, s);
}, wg = function(e) {
  return e = hQ({}, e), e.data = e.data || $R(), e.absolute = !0, e;
}, LQ = function(e) {
  lc(0, wg(e));
}, PQ = function(e, t) {
  lc(e, wg(t));
}, kQ = function(e) {
  e = wg(e), hC(e), lc(e.horizontal ? OQ(e) : xQ(e), e);
}, SQ = function(e, t) {
  t = wg(t), hC(t);
  var n = t.horizontal ? VR(t) : HR(t);
  lc(e + n, t);
};
yg.default = {
  animateTopScroll: lc,
  getAnimationType: UR,
  scrollToTop: LQ,
  scrollToBottom: kQ,
  scrollTo: PQ,
  scrollMore: SQ
};
Object.defineProperty(nl, "__esModule", {
  value: !0
});
var DQ = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, MQ = sc, TQ = gC(MQ), jQ = yg, _Q = gC(jQ), AQ = ac, wp = gC(AQ);
function gC(e) {
  return e && e.__esModule ? e : { default: e };
}
var Cp = {}, vk = void 0;
nl.default = {
  unmount: function() {
    Cp = {};
  },
  register: function(e, t) {
    Cp[e] = t;
  },
  unregister: function(e) {
    delete Cp[e];
  },
  get: function(e) {
    return Cp[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return vk = e;
  },
  getActiveLink: function() {
    return vk;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = DQ({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = TQ.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      wp.default.registered.begin && wp.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, wp.default.registered.end && wp.default.registered.end(e, n);
      return;
    }
    _Q.default.animateTopScroll(a, t, e, n);
  }
};
var jb = { exports: {} }, Jm = { exports: {} }, sn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yk;
function BQ() {
  if (yk) return sn;
  yk = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case a:
                case c:
                case f:
                case m:
                case s:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function O(y) {
    return D(y) === u;
  }
  return sn.AsyncMode = l, sn.ConcurrentMode = u, sn.ContextConsumer = a, sn.ContextProvider = s, sn.Element = t, sn.ForwardRef = c, sn.Fragment = r, sn.Lazy = f, sn.Memo = m, sn.Portal = n, sn.Profiler = i, sn.StrictMode = o, sn.Suspense = p, sn.isAsyncMode = function(y) {
    return O(y) || D(y) === l;
  }, sn.isConcurrentMode = O, sn.isContextConsumer = function(y) {
    return D(y) === a;
  }, sn.isContextProvider = function(y) {
    return D(y) === s;
  }, sn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, sn.isForwardRef = function(y) {
    return D(y) === c;
  }, sn.isFragment = function(y) {
    return D(y) === r;
  }, sn.isLazy = function(y) {
    return D(y) === f;
  }, sn.isMemo = function(y) {
    return D(y) === m;
  }, sn.isPortal = function(y) {
    return D(y) === n;
  }, sn.isProfiler = function(y) {
    return D(y) === i;
  }, sn.isStrictMode = function(y) {
    return D(y) === o;
  }, sn.isSuspense = function(y) {
    return D(y) === p;
  }, sn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === m || y.$$typeof === s || y.$$typeof === a || y.$$typeof === c || y.$$typeof === h || y.$$typeof === x || y.$$typeof === w || y.$$typeof === g);
  }, sn.typeOf = D, sn;
}
var mn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bk;
function IQ() {
  return bk || (bk = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === m || N.$$typeof === s || N.$$typeof === a || N.$$typeof === c || N.$$typeof === h || N.$$typeof === x || N.$$typeof === w || N.$$typeof === g);
    }
    function O(N) {
      if (typeof N == "object" && N !== null) {
        var ue = N.$$typeof;
        switch (ue) {
          case t:
            var ye = N.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ye;
              default:
                var oe = ye && ye.$$typeof;
                switch (oe) {
                  case a:
                  case c:
                  case f:
                  case m:
                  case s:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, S = a, U = s, L = t, F = c, B = r, $ = f, V = m, z = n, q = i, X = o, J = p, te = !1;
    function ee(N) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(N) || O(N) === l;
    }
    function k(N) {
      return O(N) === u;
    }
    function j(N) {
      return O(N) === a;
    }
    function H(N) {
      return O(N) === s;
    }
    function M(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function Z(N) {
      return O(N) === c;
    }
    function E(N) {
      return O(N) === r;
    }
    function T(N) {
      return O(N) === f;
    }
    function R(N) {
      return O(N) === m;
    }
    function _(N) {
      return O(N) === n;
    }
    function W(N) {
      return O(N) === i;
    }
    function A(N) {
      return O(N) === o;
    }
    function Q(N) {
      return O(N) === p;
    }
    mn.AsyncMode = y, mn.ConcurrentMode = C, mn.ContextConsumer = S, mn.ContextProvider = U, mn.Element = L, mn.ForwardRef = F, mn.Fragment = B, mn.Lazy = $, mn.Memo = V, mn.Portal = z, mn.Profiler = q, mn.StrictMode = X, mn.Suspense = J, mn.isAsyncMode = ee, mn.isConcurrentMode = k, mn.isContextConsumer = j, mn.isContextProvider = H, mn.isElement = M, mn.isForwardRef = Z, mn.isFragment = E, mn.isLazy = T, mn.isMemo = R, mn.isPortal = _, mn.isProfiler = W, mn.isStrictMode = A, mn.isSuspense = Q, mn.isValidElementType = D, mn.typeOf = O;
  }()), mn;
}
var wk;
function WR() {
  return wk || (wk = 1, process.env.NODE_ENV === "production" ? Jm.exports = BQ() : Jm.exports = IQ()), Jm.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Xm, Ck;
function NQ() {
  if (Ck) return Xm;
  Ck = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Xm = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, Xm;
}
var Qm, Ok;
function mC() {
  if (Ok) return Qm;
  Ok = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Qm = e, Qm;
}
var xk, Ek;
function ZR() {
  return Ek || (Ek = 1, xk = Function.call.bind(Object.prototype.hasOwnProperty)), xk;
}
var ev, Lk;
function FQ() {
  if (Lk) return ev;
  Lk = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = mC(), n = {}, r = ZR();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var m = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (m ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, ev = o, ev;
}
var tv, Pk;
function RQ() {
  if (Pk) return tv;
  Pk = 1;
  var e = WR(), t = NQ(), n = mC(), r = ZR(), o = FQ(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return tv = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var j = k && (u && k[u] || k[c]);
      if (typeof j == "function")
        return j;
    }
    var d = "<<anonymous>>", m = {
      array: x("array"),
      bigint: x("bigint"),
      bool: x("boolean"),
      func: x("function"),
      number: x("number"),
      object: x("object"),
      string: x("string"),
      symbol: x("symbol"),
      any: w(),
      arrayOf: D,
      element: O(),
      elementType: y(),
      instanceOf: C,
      node: F(),
      objectOf: U,
      oneOf: S,
      oneOfType: L,
      shape: $,
      exact: V
    };
    function f(k, j) {
      return k === j ? k !== 0 || 1 / k === 1 / j : k !== k && j !== j;
    }
    function g(k, j) {
      this.message = k, this.data = j && typeof j == "object" ? j : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function h(k) {
      if (process.env.NODE_ENV !== "production")
        var j = {}, H = 0;
      function M(E, T, R, _, W, A, Q) {
        if (_ = _ || d, A = A || R, Q !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = _ + ":" + R;
            !j[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + _ + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), j[ue] = !0, H++);
          }
        }
        return T[R] == null ? E ? T[R] === null ? new g("The " + W + " `" + A + "` is marked as required " + ("in `" + _ + "`, but its value is `null`.")) : new g("The " + W + " `" + A + "` is marked as required in " + ("`" + _ + "`, but its value is `undefined`.")) : null : k(T, R, _, W, A);
      }
      var Z = M.bind(null, !1);
      return Z.isRequired = M.bind(null, !0), Z;
    }
    function x(k) {
      function j(H, M, Z, E, T, R) {
        var _ = H[M], W = X(_);
        if (W !== k) {
          var A = J(_);
          return new g(
            "Invalid " + E + " `" + T + "` of type " + ("`" + A + "` supplied to `" + Z + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return h(j);
    }
    function w() {
      return h(s);
    }
    function D(k) {
      function j(H, M, Z, E, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + Z + "` has invalid PropType notation inside arrayOf.");
        var R = H[M];
        if (!Array.isArray(R)) {
          var _ = X(R);
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected an array."));
        }
        for (var W = 0; W < R.length; W++) {
          var A = k(R, W, Z, E, T + "[" + W + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return h(j);
    }
    function O() {
      function k(j, H, M, Z, E) {
        var T = j[H];
        if (!a(T)) {
          var R = X(T);
          return new g("Invalid " + Z + " `" + E + "` of type " + ("`" + R + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(k);
    }
    function y() {
      function k(j, H, M, Z, E) {
        var T = j[H];
        if (!e.isValidElementType(T)) {
          var R = X(T);
          return new g("Invalid " + Z + " `" + E + "` of type " + ("`" + R + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(k);
    }
    function C(k) {
      function j(H, M, Z, E, T) {
        if (!(H[M] instanceof k)) {
          var R = k.name || d, _ = ee(H[M]);
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected ") + ("instance of `" + R + "`."));
        }
        return null;
      }
      return h(j);
    }
    function S(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function j(H, M, Z, E, T) {
        for (var R = H[M], _ = 0; _ < k.length; _++)
          if (f(R, k[_]))
            return null;
        var W = JSON.stringify(k, function(A, Q) {
          var N = J(Q);
          return N === "symbol" ? String(Q) : Q;
        });
        return new g("Invalid " + E + " `" + T + "` of value `" + String(R) + "` " + ("supplied to `" + Z + "`, expected one of " + W + "."));
      }
      return h(j);
    }
    function U(k) {
      function j(H, M, Z, E, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + Z + "` has invalid PropType notation inside objectOf.");
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected an object."));
        for (var W in R)
          if (r(R, W)) {
            var A = k(R, W, Z, E, T + "." + W, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return h(j);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var j = 0; j < k.length; j++) {
        var H = k[j];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(H) + " at index " + j + "."
          ), s;
      }
      function M(Z, E, T, R, _) {
        for (var W = [], A = 0; A < k.length; A++) {
          var Q = k[A], N = Q(Z, E, T, R, _, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && W.push(N.data.expectedType);
        }
        var ue = W.length > 0 ? ", expected one of type [" + W.join(", ") + "]" : "";
        return new g("Invalid " + R + " `" + _ + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return h(M);
    }
    function F() {
      function k(j, H, M, Z, E) {
        return z(j[H]) ? null : new g("Invalid " + Z + " `" + E + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return h(k);
    }
    function B(k, j, H, M, Z) {
      return new g(
        (k || "React class") + ": " + j + " type `" + H + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Z + "`."
      );
    }
    function $(k) {
      function j(H, M, Z, E, T) {
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type `" + _ + "` " + ("supplied to `" + Z + "`, expected `object`."));
        for (var W in k) {
          var A = k[W];
          if (typeof A != "function")
            return B(Z, E, T, W, J(A));
          var Q = A(R, W, Z, E, T + "." + W, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return h(j);
    }
    function V(k) {
      function j(H, M, Z, E, T) {
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type `" + _ + "` " + ("supplied to `" + Z + "`, expected `object`."));
        var W = t({}, H[M], k);
        for (var A in W) {
          var Q = k[A];
          if (r(k, A) && typeof Q != "function")
            return B(Z, E, T, A, J(Q));
          if (!Q)
            return new g(
              "Invalid " + E + " `" + T + "` key `" + A + "` supplied to `" + Z + "`.\nBad object: " + JSON.stringify(H[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var N = Q(R, A, Z, E, T + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return h(j);
    }
    function z(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every(z);
          if (k === null || a(k))
            return !0;
          var j = p(k);
          if (j) {
            var H = j.call(k), M;
            if (j !== k.entries) {
              for (; !(M = H.next()).done; )
                if (!z(M.value))
                  return !1;
            } else
              for (; !(M = H.next()).done; ) {
                var Z = M.value;
                if (Z && !z(Z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(k, j) {
      return k === "symbol" ? !0 : j ? j["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && j instanceof Symbol : !1;
    }
    function X(k) {
      var j = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : q(j, k) ? "symbol" : j;
    }
    function J(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var j = X(k);
      if (j === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return j;
    }
    function te(k) {
      var j = J(k);
      switch (j) {
        case "array":
        case "object":
          return "an " + j;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + j;
        default:
          return j;
      }
    }
    function ee(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return m.checkPropTypes = o, m.resetWarningCache = o.resetWarningCache, m.PropTypes = m, m;
  }, tv;
}
var nv, kk;
function zQ() {
  if (kk) return nv;
  kk = 1;
  var e = mC();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, nv = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, nv;
}
if (process.env.NODE_ENV !== "production") {
  var UQ = WR(), $Q = !0;
  jb.exports = RQ()(UQ.isElement, $Q);
} else
  jb.exports = zQ()();
var Cg = jb.exports, Og = {};
Object.defineProperty(Og, "__esModule", {
  value: !0
});
var VQ = sc, rv = HQ(VQ);
function HQ(e) {
  return e && e.__esModule ? e : { default: e };
}
var WQ = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return rv.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && rv.default.getHash() !== e && rv.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Og.default = WQ;
Object.defineProperty(rc, "__esModule", {
  value: !0
});
var Op = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, ZQ = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), qQ = Ee, Sk = uc(qQ), GQ = oc, xp = uc(GQ), YQ = nl, KQ = uc(YQ), JQ = Cg, qn = uc(JQ), XQ = Og, Hi = uc(XQ);
function uc(e) {
  return e && e.__esModule ? e : { default: e };
}
function QQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function eee(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function tee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Dk = {
  to: qn.default.string.isRequired,
  containerId: qn.default.string,
  container: qn.default.object,
  activeClass: qn.default.string,
  activeStyle: qn.default.object,
  spy: qn.default.bool,
  horizontal: qn.default.bool,
  smooth: qn.default.oneOfType([qn.default.bool, qn.default.string]),
  offset: qn.default.number,
  delay: qn.default.number,
  isDynamic: qn.default.bool,
  onClick: qn.default.func,
  duration: qn.default.oneOfType([qn.default.number, qn.default.func]),
  absolute: qn.default.bool,
  onSetActive: qn.default.func,
  onSetInactive: qn.default.func,
  ignoreCancelEvents: qn.default.bool,
  hashSpy: qn.default.bool,
  saveHashHistory: qn.default.bool,
  spyThrottle: qn.default.number
};
rc.default = function(e, t) {
  var n = t || KQ.default, r = function(i) {
    tee(s, i);
    function s(a) {
      QQ(this, s);
      var l = eee(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return ZQ(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          xp.default.isMounted(a) || xp.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (Hi.default.isMounted() || Hi.default.mount(n), Hi.default.mapContainer(this.props.to, a)), xp.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        xp.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Op({}, this.props.style, this.props.activeStyle) : l = Op({}, this.props.style);
        var u = Op({}, this.props);
        for (var c in Dk)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, Sk.default.createElement(e, u);
      }
    }]), s;
  }(Sk.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, Op({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(Hi.default.isMounted() && !Hi.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, m = void 0;
        if (u) {
          var f = 0, g = 0, h = 0;
          if (l.getBoundingClientRect) {
            var x = l.getBoundingClientRect();
            h = x.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - h + s, g = f + w.width;
          }
          var D = s - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(g), m = D < Math.floor(f) || D >= Math.floor(g);
        } else {
          var O = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            O = U.top - C + a, y = O + U.height;
          }
          var L = a - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(y), m = L < Math.floor(O) || L >= Math.floor(y);
        }
        var F = n.getActiveLink();
        if (m) {
          if (c === F && n.setActiveLink(void 0), i.props.hashSpy && Hi.default.getHash() === c) {
            var B = i.props.saveHashHistory, $ = B === void 0 ? !1 : B;
            Hi.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (F !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && Hi.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = Dk, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(pC, "__esModule", {
  value: !0
});
var nee = Ee, Mk = qR(nee), ree = rc, oee = qR(ree);
function qR(e) {
  return e && e.__esModule ? e : { default: e };
}
function iee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Tk(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function see(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var aee = function(e) {
  see(t, e);
  function t() {
    var n, r, o, i;
    iee(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = Tk(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return Mk.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), Tk(o, i);
  }
  return t;
}(Mk.default.Component);
pC.default = (0, oee.default)(aee);
var vC = {};
Object.defineProperty(vC, "__esModule", {
  value: !0
});
var lee = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), uee = Ee, jk = GR(uee), cee = rc, pee = GR(cee);
function GR(e) {
  return e && e.__esModule ? e : { default: e };
}
function dee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function fee(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function hee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var gee = function(e) {
  hee(t, e);
  function t() {
    return dee(this, t), fee(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return lee(t, [{
    key: "render",
    value: function() {
      return jk.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(jk.default.Component);
vC.default = (0, pee.default)(gee);
var yC = {}, xg = {};
Object.defineProperty(xg, "__esModule", {
  value: !0
});
var mee = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, vee = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), yee = Ee, _k = Eg(yee), bee = Ga;
Eg(bee);
var wee = nl, Ak = Eg(wee), Cee = Cg, Bk = Eg(Cee);
function Eg(e) {
  return e && e.__esModule ? e : { default: e };
}
function Oee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function xee(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Eee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
xg.default = function(e) {
  var t = function(n) {
    Eee(r, n);
    function r(o) {
      Oee(this, r);
      var i = xee(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return vee(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        Ak.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        Ak.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return _k.default.createElement(e, mee({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(_k.default.Component);
  return t.propTypes = {
    name: Bk.default.string,
    id: Bk.default.string
  }, t;
};
Object.defineProperty(yC, "__esModule", {
  value: !0
});
var Ik = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Lee = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Pee = Ee, Nk = bC(Pee), kee = xg, See = bC(kee), Dee = Cg, Fk = bC(Dee);
function bC(e) {
  return e && e.__esModule ? e : { default: e };
}
function Mee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Tee(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function jee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var YR = function(e) {
  jee(t, e);
  function t() {
    return Mee(this, t), Tee(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Lee(t, [{
    key: "render",
    value: function() {
      var n = this, r = Ik({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, Nk.default.createElement(
        "div",
        Ik({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(Nk.default.Component);
YR.propTypes = {
  name: Fk.default.string,
  id: Fk.default.string
};
yC.default = (0, See.default)(YR);
var ov = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Rk = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function zk(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Uk(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function $k(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Ep = Ee, Fs = oc, iv = nl, ar = Cg, Wi = Og, Vk = {
  to: ar.string.isRequired,
  containerId: ar.string,
  container: ar.object,
  activeClass: ar.string,
  spy: ar.bool,
  smooth: ar.oneOfType([ar.bool, ar.string]),
  offset: ar.number,
  delay: ar.number,
  isDynamic: ar.bool,
  onClick: ar.func,
  duration: ar.oneOfType([ar.number, ar.func]),
  absolute: ar.bool,
  onSetActive: ar.func,
  onSetInactive: ar.func,
  ignoreCancelEvents: ar.bool,
  hashSpy: ar.bool,
  spyThrottle: ar.number
}, _ee = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || iv, r = function(i) {
      $k(s, i);
      function s(a) {
        zk(this, s);
        var l = Uk(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return Rk(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            Fs.isMounted(a) || Fs.mount(a, this.props.spyThrottle), this.props.hashSpy && (Wi.isMounted() || Wi.mount(n), Wi.mapContainer(this.props.to, a)), this.props.spy && Fs.addStateHandler(this.stateHandler), Fs.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Fs.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = ov({}, this.props);
          for (var u in Vk)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, Ep.createElement(e, l);
        }
      }]), s;
    }(Ep.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, ov({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(Wi.isMounted() && !Wi.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (a.getBoundingClientRect) {
            var m = a.getBoundingClientRect();
            d = m.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + s, p = c + f.height;
          }
          var g = s - i.props.offset, h = g >= Math.floor(c) && g < Math.floor(p), x = g < Math.floor(c) || g >= Math.floor(p), w = n.getActiveLink();
          if (x)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Wi.getHash() === l && Wi.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Fs.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Wi.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Fs.updateStates();
        }
      };
    };
    return r.propTypes = Vk, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      $k(r, n);
      function r(o) {
        zk(this, r);
        var i = Uk(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return Rk(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          iv.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          iv.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Ep.createElement(e, ov({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Ep.Component);
    return t.propTypes = {
      name: ar.string,
      id: ar.string
    }, t;
  }
}, Aee = _ee;
Object.defineProperty(mr, "__esModule", {
  value: !0
});
mr.Helpers = mr.ScrollElement = mr.ScrollLink = mr.animateScroll = mr.scrollSpy = mr.Events = mr.scroller = mr.Element = mr.Button = mr.Link = void 0;
var Bee = pC, KR = si(Bee), Iee = vC, JR = si(Iee), Nee = yC, XR = si(Nee), Fee = nl, QR = si(Fee), Ree = ac, e2 = si(Ree), zee = oc, t2 = si(zee), Uee = yg, n2 = si(Uee), $ee = rc, r2 = si($ee), Vee = xg, o2 = si(Vee), Hee = Aee, i2 = si(Hee);
function si(e) {
  return e && e.__esModule ? e : { default: e };
}
mr.Link = KR.default;
mr.Button = JR.default;
mr.Element = XR.default;
mr.scroller = QR.default;
mr.Events = e2.default;
mr.scrollSpy = t2.default;
mr.animateScroll = n2.default;
mr.ScrollLink = r2.default;
mr.ScrollElement = o2.default;
mr.Helpers = i2.default;
mr.default = { Link: KR.default, Button: JR.default, Element: XR.default, scroller: QR.default, Events: e2.default, scrollSpy: t2.default, animateScroll: n2.default, ScrollLink: r2.default, ScrollElement: o2.default, Helpers: i2.default };
Ge({});
Ge({});
Ge({});
function Ru(e) {
  "@babel/helpers - typeof";
  return Ru = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ru(e);
}
function Wee(e, t) {
  if (Ru(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ru(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Zee(e) {
  var t = Wee(e, "string");
  return Ru(t) == "symbol" ? t : t + "";
}
function ge(e, t, n) {
  return (t = Zee(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function s2(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var sv, Hk;
function qee() {
  if (Hk) return sv;
  Hk = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, s, a, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, s, a, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return sv = t, sv;
}
var Gee = qee(), Er = /* @__PURE__ */ s2(Gee), mt = Ge(null);
function Yee() {
  Er(!!xe, "useGoogleMap is React hook and requires React version 16.8+");
  var e = xe(mt);
  return Er(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Kee(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function Jee(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Xee(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return Jee(e, i), o;
}
function Qee(e, t, n) {
  var r = Kee(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function ete(e) {
  google.maps.event.removeListener(e);
}
function Ht() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(ete);
}
function zt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = Qee(o, i, n);
  return Xee(t, r, o, i), s;
}
function tte(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: m,
    onMouseOver: f,
    onMouseDown: g,
    onMouseUp: h,
    onRightClick: x,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: O
  } = e, [y, C] = P(null), S = Qe(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null), [A, Q] = P(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof s < "u" && y.setCenter(s);
  }, [y, s]), v(() => {
    y && l && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && g && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(y, "mousedown", g)));
  }, [g]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && m && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(y, "mouseout", m)));
  }, [m]), v(() => {
    y && f && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && h && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && x && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(y, "rightclick", x)));
  }, [x]), v(() => {
    y && a && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(y, "click", a)));
  }, [a]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [a]), v(() => {
    var N = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(N), N !== null && D && D(N), () => {
      N !== null && O && O(N);
    };
  }, []), no.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: no.jsx(mt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
Le(tte);
function Wk(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function a2(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        Wk(i, r, o, s, a, "next", l);
      }
      function a(l) {
        Wk(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function l2(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Er(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var ia = typeof document < "u";
function u2(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return ia ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, a.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function Zk(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function c2() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return Zk(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return Zk(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var El = !1;
function p2() {
  return no.jsx("div", {
    children: "Loading..."
  });
}
var _b = {
  id: "script-loader",
  version: "weekly"
};
class nte extends be {
  constructor() {
    super(...arguments), ge(this, "check", wr()), ge(this, "state", {
      loaded: !1
    }), ge(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ge(this, "isCleaningUp", /* @__PURE__ */ a2(function* () {
      function t(n) {
        if (!El)
          n();
        else if (ia)
          var r = window.setInterval(function() {
            El || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ge(this, "cleanup", () => {
      El = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), ge(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && c2(), Er(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: l2(this.props)
      };
      u2(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (ia) {
      if (window.google && window.google.maps && !El) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), ia && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (ia) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, El = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return no.jsxs(no.Fragment, {
      children: [no.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || no.jsx(p2, {})]
    });
  }
}
ge(nte, "defaultProps", _b);
function rte(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function wC(e, t) {
  if (e == null) return {};
  var n, r, o = rte(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var qk;
function ote(e) {
  var {
    id: t = _b.id,
    version: n = _b.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, m = Qe(!1), [f, g] = P(!1), [h, x] = P(void 0);
  v(function() {
    return m.current = !0, () => {
      m.current = !1;
    };
  }, []), v(function() {
    ia && u && c2();
  }, [u]), v(function() {
    f && Er(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = l2({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!ia)
      return;
    function O() {
      m.current && (g(!0), qk = w);
    }
    if (window.google && window.google.maps && qk === w) {
      O();
      return;
    }
    u2({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(y) {
      m.current && x(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var D = Qe();
  return v(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var ite = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], ste = no.jsx(p2, {});
function ate(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = wC(e, ite), {
    isLoaded: a,
    loadError: l
  } = ote(s);
  return v(function() {
    a && typeof n == "function" && n();
  }, [a, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || ste;
}
Le(ate);
var Gk;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Gk || (Gk = {}));
function Yk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Yk(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Yk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Kk = {}, Jk = {
  options(e, t) {
    e.setOptions(t);
  }
};
function lte(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = xe(mt), [i, s] = P(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var a = new google.maps.TrafficLayer(pf(pf({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Le(lte);
class ute extends be {
  constructor() {
    super(...arguments), ge(this, "state", {
      trafficLayer: null
    }), ge(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ge(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(pf(pf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = zt({
      updaterMap: Jk,
      eventMap: Kk,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: Jk,
      eventMap: Kk,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Ht(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(ute, "contextType", mt);
function cte(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = xe(mt), [o, i] = P(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
Le(cte);
class pte extends be {
  constructor() {
    super(...arguments), ge(this, "state", {
      bicyclingLayer: null
    }), ge(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(pte, "contextType", mt);
function dte(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = xe(mt), [o, i] = P(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Le(dte);
class fte extends be {
  constructor() {
    super(...arguments), ge(this, "state", {
      transitLayer: null
    }), ge(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(fte, "contextType", mt);
function Xk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function df(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Xk(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Xk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qk = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, eS = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function hte(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = xe(mt), [d, m] = P(null), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), g(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && s && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(d, "polygoncomplete", s)));
  }, [d, s]), v(() => {
    d && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", a)));
  }, [d, a]), v(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    Er(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var F = new google.maps.drawing.DrawingManager(df(df({}, t), {}, {
      map: p
    }));
    return n && F.setDrawingMode(n), r && g(google.maps.event.addListener(F, "circlecomplete", r)), o && x(google.maps.event.addListener(F, "markercomplete", o)), i && D(google.maps.event.addListener(F, "overlaycomplete", i)), s && y(google.maps.event.addListener(F, "polygoncomplete", s)), a && S(google.maps.event.addListener(F, "polylinecomplete", a)), l && L(google.maps.event.addListener(F, "rectanglecomplete", l)), m(F), u && u(F), () => {
      d !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
Le(hte);
class gte extends be {
  constructor(t) {
    super(t), ge(this, "registeredEvents", []), ge(this, "state", {
      drawingManager: null
    }), ge(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Er(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(df(df({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = zt({
      updaterMap: eS,
      eventMap: Qk,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: eS,
      eventMap: Qk,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Ht(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ge(gte, "contextType", mt);
function tS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ba(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nS = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, rS = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, ff = {};
function mte(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: m,
    shape: f,
    title: g,
    zIndex: h,
    onClick: x,
    onDblClick: w,
    onDrag: D,
    onDragEnd: O,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: L,
    onRightClick: F,
    onClickableChanged: B,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: q,
    onIconChanged: X,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: k,
    onZindexChanged: j,
    onLoad: H,
    onUnmount: M
  } = e, Z = xe(mt), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null), [Q, N] = P(null), [ue, ye] = P(null), [oe, Ie] = P(null), [$e, Ve] = P(null), [Ne, Je] = P(null), [Ye, Te] = P(null), [Ke, nt] = P(null), [Me, Ae] = P(null), [Fe, He] = P(null), [ze, et] = P(null), [_e, At] = P(null), [rt, ot] = P(null), [at, qt] = P(null), [lt, Gt] = P(null), [Xe, bt] = P(null), [tt, Yt] = P(null), [ut, dn] = P(null), [Kt, fn] = P(null), [Jt, hn] = P(null);
  v(() => {
    E !== null && E.setMap(Z);
  }, [Z]), v(() => {
    typeof n < "u" && E !== null && E.setOptions(n);
  }, [E, n]), v(() => {
    typeof s < "u" && E !== null && E.setDraggable(s);
  }, [E, s]), v(() => {
    t && E !== null && E.setPosition(t);
  }, [E, t]), v(() => {
    typeof a < "u" && E !== null && E.setVisible(a);
  }, [E, a]), v(() => {
    E == null || E.setAnimation(l);
  }, [E, l]), v(() => {
    E && u !== void 0 && E.setClickable(u);
  }, [E, u]), v(() => {
    E && c !== void 0 && E.setCursor(c);
  }, [E, c]), v(() => {
    E && p !== void 0 && E.setIcon(p);
  }, [E, p]), v(() => {
    E && d !== void 0 && E.setLabel(d);
  }, [E, d]), v(() => {
    E && m !== void 0 && E.setOpacity(m);
  }, [E, m]), v(() => {
    E && f !== void 0 && E.setShape(f);
  }, [E, f]), v(() => {
    E && g !== void 0 && E.setTitle(g);
  }, [E, g]), v(() => {
    E && h !== void 0 && E.setZIndex(h);
  }, [E, h]), v(() => {
    E && w && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(E, "dblclick", w)));
  }, [w]), v(() => {
    E && O && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(E, "dragend", O)));
  }, [O]), v(() => {
    E && y && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(E, "dragstart", y)));
  }, [y]), v(() => {
    E && L && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(E, "mousedown", L)));
  }, [L]), v(() => {
    E && C && (oe !== null && google.maps.event.removeListener(oe), Ie(google.maps.event.addListener(E, "mouseout", C)));
  }, [C]), v(() => {
    E && S && ($e !== null && google.maps.event.removeListener($e), Ve(google.maps.event.addListener(E, "mouseover", S)));
  }, [S]), v(() => {
    E && U && (Ne !== null && google.maps.event.removeListener(Ne), Je(google.maps.event.addListener(E, "mouseup", U)));
  }, [U]), v(() => {
    E && F && (Ye !== null && google.maps.event.removeListener(Ye), Te(google.maps.event.addListener(E, "rightclick", F)));
  }, [F]), v(() => {
    E && x && (Ke !== null && google.maps.event.removeListener(Ke), nt(google.maps.event.addListener(E, "click", x)));
  }, [x]), v(() => {
    E && D && (Me !== null && google.maps.event.removeListener(Me), Ae(google.maps.event.addListener(E, "drag", D)));
  }, [D]), v(() => {
    E && B && (Fe !== null && google.maps.event.removeListener(Fe), He(google.maps.event.addListener(E, "clickable_changed", B)));
  }, [B]), v(() => {
    E && $ && (ze !== null && google.maps.event.removeListener(ze), et(google.maps.event.addListener(E, "cursor_changed", $)));
  }, [$]), v(() => {
    E && V && (_e !== null && google.maps.event.removeListener(_e), At(google.maps.event.addListener(E, "animation_changed", V)));
  }, [V]), v(() => {
    E && z && (rt !== null && google.maps.event.removeListener(rt), ot(google.maps.event.addListener(E, "draggable_changed", z)));
  }, [z]), v(() => {
    E && q && (at !== null && google.maps.event.removeListener(at), qt(google.maps.event.addListener(E, "flat_changed", q)));
  }, [q]), v(() => {
    E && X && (lt !== null && google.maps.event.removeListener(lt), Gt(google.maps.event.addListener(E, "icon_changed", X)));
  }, [X]), v(() => {
    E && J && (Xe !== null && google.maps.event.removeListener(Xe), bt(google.maps.event.addListener(E, "position_changed", J)));
  }, [J]), v(() => {
    E && te && (tt !== null && google.maps.event.removeListener(tt), Yt(google.maps.event.addListener(E, "shape_changed", te)));
  }, [te]), v(() => {
    E && ee && (ut !== null && google.maps.event.removeListener(ut), dn(google.maps.event.addListener(E, "title_changed", ee)));
  }, [ee]), v(() => {
    E && k && (Kt !== null && google.maps.event.removeListener(Kt), fn(google.maps.event.addListener(E, "visible_changed", k)));
  }, [k]), v(() => {
    E && j && (Jt !== null && google.maps.event.removeListener(Jt), hn(google.maps.event.addListener(E, "zindex_changed", j)));
  }, [j]), v(() => {
    var wt = Ba(Ba(Ba({}, n || ff), r ? ff : {
      map: Z
    }), {}, {
      position: t
    }), re = new google.maps.Marker(wt);
    return r ? r.addMarker(re, !!o) : re.setMap(Z), t && re.setPosition(t), typeof a < "u" && re.setVisible(a), typeof s < "u" && re.setDraggable(s), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof m < "u" && re.setOpacity(m), f && re.setShape(f), typeof g == "string" && re.setTitle(g), typeof h == "number" && re.setZIndex(h), w && _(google.maps.event.addListener(re, "dblclick", w)), O && A(google.maps.event.addListener(re, "dragend", O)), y && N(google.maps.event.addListener(re, "dragstart", y)), L && ye(google.maps.event.addListener(re, "mousedown", L)), C && Ie(google.maps.event.addListener(re, "mouseout", C)), S && Ve(google.maps.event.addListener(re, "mouseover", S)), U && Je(google.maps.event.addListener(re, "mouseup", U)), F && Te(google.maps.event.addListener(re, "rightclick", F)), x && nt(google.maps.event.addListener(re, "click", x)), D && Ae(google.maps.event.addListener(re, "drag", D)), B && He(google.maps.event.addListener(re, "clickable_changed", B)), $ && et(google.maps.event.addListener(re, "cursor_changed", $)), V && At(google.maps.event.addListener(re, "animation_changed", V)), z && ot(google.maps.event.addListener(re, "draggable_changed", z)), q && qt(google.maps.event.addListener(re, "flat_changed", q)), X && Gt(google.maps.event.addListener(re, "icon_changed", X)), J && bt(google.maps.event.addListener(re, "position_changed", J)), te && Yt(google.maps.event.addListener(re, "shape_changed", te)), ee && dn(google.maps.event.addListener(re, "title_changed", ee)), k && fn(google.maps.event.addListener(re, "visible_changed", k)), j && hn(google.maps.event.addListener(re, "zindex_changed", j)), T(re), H && H(re), () => {
      R !== null && google.maps.event.removeListener(R), W !== null && google.maps.event.removeListener(W), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), $e !== null && google.maps.event.removeListener($e), Ne !== null && google.maps.event.removeListener(Ne), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Fe !== null && google.maps.event.removeListener(Fe), ze !== null && google.maps.event.removeListener(ze), _e !== null && google.maps.event.removeListener(_e), rt !== null && google.maps.event.removeListener(rt), at !== null && google.maps.event.removeListener(at), lt !== null && google.maps.event.removeListener(lt), Xe !== null && google.maps.event.removeListener(Xe), ut !== null && google.maps.event.removeListener(ut), Kt !== null && google.maps.event.removeListener(Kt), Jt !== null && google.maps.event.removeListener(Jt), M && M(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Fn = Nn(() => i ? it.map(i, (wt) => {
    if (!ti(wt))
      return wt;
    var re = wt;
    return ni(re, {
      anchor: E
    });
  }) : null, [i, E]);
  return no.jsx(no.Fragment, {
    children: Fn
  }) || null;
}
Le(mte);
class vte extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return a2(function* () {
      var n = Ba(Ba(Ba({}, t.props.options || ff), t.props.clusterer ? ff : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = zt({
        updaterMap: rS,
        eventMap: nS,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: rS,
      eventMap: nS,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Ht(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? it.map(this.props.children, (n) => {
      if (!ti(n))
        return n;
      var r = n;
      return ni(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ge(vte, "contextType", mt);
var yte = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var m = document.createElement("div");
        m.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (m.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (m.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(m), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), bte = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new yte(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function wte(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Cte = 2e3, Ote = 500, xte = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Ete = "png", Lte = [53, 56, 66, 78, 90], Pte = "cluster", d2 = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || xte, this.imageExtension = r.imageExtension || Ete, this.imageSizes = r.imageSizes || Lte, this.calculator = r.calculator || wte, this.batchSize = r.batchSize || Cte, this.batchSizeIE = r.batchSizeIE || Ote, this.clusterClass = r.clusterClass || Pte, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new bte(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var m = d[p];
            m.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function oS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kte(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jo = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, en = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Ste = {};
function Dte(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: m,
    minimumClusterSize: f,
    styles: g,
    title: h,
    zoomOnClick: x,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: O,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [L, F] = P(null), B = xe(mt), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null);
  return v(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, jo.onMouseOut, C)));
  }, [C]), v(() => {
    L && y && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(L, jo.onMouseOver, y)));
  }, [y]), v(() => {
    L && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(L, jo.onClick, w)));
  }, [w]), v(() => {
    L && D && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(L, jo.onClusteringBegin, D)));
  }, [D]), v(() => {
    L && O && (X !== null && google.maps.event.removeListener(X), q(google.maps.event.addListener(L, jo.onClusteringEnd, O)));
  }, [O]), v(() => {
    typeof r < "u" && L !== null && en.averageCenter(L, r);
  }, [L, r]), v(() => {
    typeof o < "u" && L !== null && en.batchSizeIE(L, o);
  }, [L, o]), v(() => {
    typeof i < "u" && L !== null && en.calculator(L, i);
  }, [L, i]), v(() => {
    typeof s < "u" && L !== null && en.clusterClass(L, s);
  }, [L, s]), v(() => {
    typeof a < "u" && L !== null && en.enableRetinaIcons(L, a);
  }, [L, a]), v(() => {
    typeof l < "u" && L !== null && en.gridSize(L, l);
  }, [L, l]), v(() => {
    typeof u < "u" && L !== null && en.ignoreHidden(L, u);
  }, [L, u]), v(() => {
    typeof c < "u" && L !== null && en.imageExtension(L, c);
  }, [L, c]), v(() => {
    typeof p < "u" && L !== null && en.imagePath(L, p);
  }, [L, p]), v(() => {
    typeof d < "u" && L !== null && en.imageSizes(L, d);
  }, [L, d]), v(() => {
    typeof m < "u" && L !== null && en.maxZoom(L, m);
  }, [L, m]), v(() => {
    typeof f < "u" && L !== null && en.minimumClusterSize(L, f);
  }, [L, f]), v(() => {
    typeof g < "u" && L !== null && en.styles(L, g);
  }, [L, g]), v(() => {
    typeof h < "u" && L !== null && en.title(L, h);
  }, [L, h]), v(() => {
    typeof x < "u" && L !== null && en.zoomOnClick(L, x);
  }, [L, x]), v(() => {
    if (B) {
      var H = kte({}, n || Ste), M = new d2(B, [], H);
      return r && en.averageCenter(M, r), o && en.batchSizeIE(M, o), i && en.calculator(M, i), s && en.clusterClass(M, s), a && en.enableRetinaIcons(M, a), l && en.gridSize(M, l), u && en.ignoreHidden(M, u), c && en.imageExtension(M, c), p && en.imagePath(M, p), d && en.imageSizes(M, d), m && en.maxZoom(M, m), f && en.minimumClusterSize(M, f), g && en.styles(M, g), h && en.title(M, h), x && en.zoomOnClick(M, x), C && ee(google.maps.event.addListener(M, jo.onMouseOut, C)), y && j(google.maps.event.addListener(M, jo.onMouseOver, y)), w && V(google.maps.event.addListener(M, jo.onClick, w)), D && q(google.maps.event.addListener(M, jo.onClusteringBegin, D)), O && J(google.maps.event.addListener(M, jo.onClusteringEnd, O)), F(M), S && S(M), () => {
        te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), U && U(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
Le(Dte);
class Mte extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      markerClusterer: null
    }), ge(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new d2(this.context, [], this.props.options);
      this.registeredEvents = zt({
        updaterMap: en,
        eventMap: jo,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: en,
      eventMap: jo,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Ht(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ge(Mte, "contextType", mt);
function iS(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var f2 = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || iS(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, iS));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, m = this.infoBoxClearance.width, f = this.infoBoxClearance.height, g = this.getProjection(), h = g.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + m ? r = h.x + u - m : h.x + p + u + m > a && (r = h.x + p + u + m - a), this.alignBottom ? h.y < -c + f + d ? o = h.y + c - f - d : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + d + c + f > l && (o = h.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Tte = ["position"], jte = ["position"];
function sS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aS = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, lS = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, _te = {};
function Ate(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = xe(mt), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), F = Qe(null);
  return v(() => {
    m && f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (m) {
      var B = r || _te, {
        position: $
      } = B, V = wC(B, Tte), z;
      $ && !($ instanceof google.maps.LatLng) && (z = new google.maps.LatLng($.lat, $.lng));
      var q = new f2(hf(hf({}, V), z ? {
        position: z
      } : {}));
      F.current = document.createElement("div"), g(q), s && x(google.maps.event.addListener(q, "closeclick", s)), a && D(google.maps.event.addListener(q, "domready", a)), l && y(google.maps.event.addListener(q, "content_changed", l)), u && S(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(F.current), n ? q.open(m, n) : q.getPosition() ? q.open(m) : Er(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), F.current ? Cr(it.only(t), F.current) : null;
}
Le(Ate);
class Bte extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", null), ge(this, "state", {
      infoBox: null
    }), ge(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Er(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ge(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = wC(t, jte), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new f2(hf(hf({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = zt({
      updaterMap: lS,
      eventMap: aS,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: lS,
      eventMap: aS,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Ht(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Cr(it.only(this.props.children), this.containerElement) : null;
  }
}
ge(Bte, "contextType", mt);
var uS, cS;
function Ite() {
  return cS || (cS = 1, uS = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), uS;
}
var Nte = Ite(), pS = /* @__PURE__ */ s2(Nte), dS = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], av = 1, Ll = 8;
class CC {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== av)
      throw new Error("Got v".concat(o, " data when expected v").concat(av, "."));
    var i = dS[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new CC(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = dS.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Ll, t), this.coords = new this.ArrayType(this.data, Ll + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Ll + s + a + l), this.ids = new this.IndexArrayType(this.data, Ll, t), this.coords = new this.ArrayType(this.data, Ll + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (av << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return Ab(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (var m = d; m <= p; m++) {
          var f = s[2 * m], g = s[2 * m + 1];
          f >= t && f <= r && g >= n && g <= o && u.push(i[m]);
        }
        continue;
      }
      var h = d + p >> 1, x = s[2 * h], w = s[2 * h + 1];
      x >= t && x <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= x : n <= w) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= x : o >= w) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (var m = d; m <= p; m++)
          fS(i[2 * m], i[2 * m + 1], t, n) <= u && l.push(o[m]);
        continue;
      }
      var f = d + p >> 1, g = i[2 * f], h = i[2 * f + 1];
      fS(g, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= g : n - r <= h) && (a.push(d), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= h) && (a.push(f + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function Ab(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    h2(e, t, s, r, o, i), Ab(e, t, n, r, s - 1, 1 - i), Ab(e, t, n, s + 1, o, 1 - i);
  }
}
function h2(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - a * u / s + c)), d = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      h2(e, t, n, p, d, i);
    }
    var m = t[2 * n + i], f = r, g = o;
    for (Pl(e, t, r, n), t[2 * o + i] > m && Pl(e, t, r, o); f < g; ) {
      for (Pl(e, t, f, g), f++, g--; t[2 * f + i] < m; ) f++;
      for (; t[2 * g + i] > m; ) g--;
    }
    t[2 * r + i] === m ? Pl(e, t, r, g) : (g++, Pl(e, t, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1);
  }
}
function Pl(e, t, n, r) {
  lv(e, n, r), lv(t, 2 * n, 2 * r), lv(t, 2 * n + 1, 2 * r + 1);
}
function lv(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function fS(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Fte = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, hS = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Rs = 2, is = 3, uv = 4, es = 5, g2 = 6;
class Rte {
  constructor(t) {
    this.options = Object.assign(Object.create(Fte), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = hS(Lp(u)), d = hS(Pp(c));
        s.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var m = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var g = +Date.now();
      m = this.trees[f] = this._createTree(this._cluster(m, f)), n && console.log("z%d: %d clusters in %dms", f, m.numItems, +Date.now() - g);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Lp(r), Pp(s), Lp(i), Pp(o)), p = u.data, d = [];
    for (var m of c) {
      var f = this.stride * m;
      d.push(p[f + es] > 1 ? gS(p, f, this.clusterProps) : this.points[p[f + is]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (var d of c) {
      var m = d * this.stride;
      s[m + uv] === t && p.push(s[m + es] > 1 ? gS(s, m, this.clusterProps) : this.points[s[m + is]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new CC(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + es] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = m2(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var m = this.points[n[l + is]];
        c = m.properties;
        var [f, g] = m.geometry.coordinates;
        p = Lp(f), d = Pp(g);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, x = void 0;
      u || this.options.generateId ? x = n[l + is] : x = this.points[n[l + is]].id, x !== void 0 && (h.id = x), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Rs] <= n)) {
        l[p + Rs] = n;
        var d = l[p], m = l[p + 1], f = t.within(l[p], l[p + 1], a), g = l[p + es], h = g;
        for (var x of f) {
          var w = x * c;
          l[w + Rs] > n && (h += l[w + es]);
        }
        if (h > g && h >= s) {
          var D = d * g, O = m * g, y = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var L = U * c;
            if (!(l[L + Rs] <= n)) {
              l[L + Rs] = n;
              var F = l[L + es];
              D += l[L] * F, O += l[L + 1] * F, l[L + uv] = S, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + uv] = S, u.push(D / h, O / h, 1 / 0, S, -1, h), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (h > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Rs] <= n)) {
                l[V + Rs] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + es] > 1) {
      var o = this.clusterProps[t[n + g2]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + is]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function gS(e, t, n) {
  return {
    type: "Feature",
    id: e[t + is],
    properties: m2(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [zte(e[t]), Ute(e[t + 1])]
    }
  };
}
function m2(e, t, n) {
  var r = e[t + es], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + g2], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + is],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Lp(e) {
  return e / 360 + 0.5;
}
function Pp(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function zte(e) {
  return (e - 0.5) * 360;
}
function Ute(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function $te(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class mo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Bb {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(mo.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => mo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (mo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Vte {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return Hte(n);
  }
}
var Hte = (e) => {
  var t = e.map((n) => new Bb({
    position: mo.getPosition(n),
    markers: [n]
  }));
  return t;
};
class Wte extends Vte {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = $te(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Rte(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!pS(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = mo.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !pS(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Bb({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Bb({
      markers: [i],
      position: mo.getPosition(i)
    });
  }
}
class Zte {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class qte {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (mo.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(a, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var m = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(m);
  }
}
function Gte(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class OC {
  constructor() {
    Gte(OC, google.maps.OverlayView);
  }
}
var au;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(au || (au = {}));
var Yte = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Kte extends OC {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new Wte(o),
      renderer: s = new qte(),
      onClusterClick: a = Yte
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (mo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, au.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || mo.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => mo.setMap(l, null)));
      }
      google.maps.event.trigger(this, au.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => mo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Zte(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => mo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, au.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), mo.setMap(r.marker, n);
    });
  }
}
function mS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Jte(e) {
  var t = Yee(), [n, r] = P(null);
  return v(() => {
    if (t && n === null) {
      var o = new Kte(vS(vS({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Xte(e) {
  var {
    children: t,
    options: n
  } = e, r = Jte(n);
  return r !== null ? t(r) : null;
}
Le(Xte);
var yS = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, bS = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Qte(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = xe(mt), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), F = Qe(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var B = new google.maps.InfoWindow(r);
    return g(B), F.current = document.createElement("div"), s && x(google.maps.event.addListener(B, "closeclick", s)), a && D(google.maps.event.addListener(B, "domready", a)), l && y(google.maps.event.addListener(B, "content_changed", l)), u && S(google.maps.event.addListener(B, "position_changed", u)), c && L(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(F.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(m, n) : B.getPosition() ? B.open(m) : Er(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      h && google.maps.event.removeListener(h), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(B), B.close();
    };
  }, []), F.current ? Cr(it.only(t), F.current) : null;
}
Le(Qte);
class ene extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", null), ge(this, "state", {
      infoWindow: null
    }), ge(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Er(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ge(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = zt({
      updaterMap: bS,
      eventMap: yS,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: bS,
      eventMap: yS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Ht(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Cr(it.only(this.props.children), this.containerElement) : null;
  }
}
ge(ene, "contextType", mt);
function wS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var CS = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, OS = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, tne = {};
function nne(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onLoad: x,
    onUnmount: w
  } = e, D = xe(mt), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null);
  return v(() => {
    O !== null && O.setMap(D);
  }, [D]), v(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), v(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), v(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), v(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), v(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), v(() => {
    O && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(O, "dblclick", s)));
  }, [s]), v(() => {
    O && a && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(O, "dragend", a)));
  }, [a]), v(() => {
    O && l && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), v(() => {
    O && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), v(() => {
    O && c && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), v(() => {
    O && p && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), v(() => {
    O && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), v(() => {
    O && m && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(O, "mouseup", m)));
  }, [m]), v(() => {
    O && f && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), v(() => {
    O && g && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(O, "click", g)));
  }, [g]), v(() => {
    O && h && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(O, "drag", h)));
  }, [h]), v(() => {
    var _ = new google.maps.Polyline(gf(gf({}, t || tne), {}, {
      map: D
    }));
    return i && _.setPath(i), typeof o < "u" && _.setVisible(o), typeof r < "u" && _.setEditable(r), typeof n < "u" && _.setDraggable(n), s && S(google.maps.event.addListener(_, "dblclick", s)), a && L(google.maps.event.addListener(_, "dragend", a)), l && B(google.maps.event.addListener(_, "dragstart", l)), u && V(google.maps.event.addListener(_, "mousedown", u)), c && q(google.maps.event.addListener(_, "mousemove", c)), p && J(google.maps.event.addListener(_, "mouseout", p)), d && ee(google.maps.event.addListener(_, "mouseover", d)), m && j(google.maps.event.addListener(_, "mouseup", m)), f && M(google.maps.event.addListener(_, "rightclick", f)), g && E(google.maps.event.addListener(_, "click", g)), h && R(google.maps.event.addListener(_, "drag", h)), y(_), x && x(_), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), w && w(_), _.setMap(null);
    };
  }, []), null;
}
Le(nne);
class rne extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      polyline: null
    }), ge(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(gf(gf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = zt({
      updaterMap: OS,
      eventMap: CS,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: OS,
      eventMap: CS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Ht(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ge(rne, "contextType", mt);
function xS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ES(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var LS = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, PS = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function one(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: x,
    onLoad: w,
    onUnmount: D,
    onEdit: O
  } = e, y = xe(mt), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof s < "u" && C !== null && C.setPaths(s);
  }, [C, s]), v(() => {
    C && typeof a == "function" && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(C, "dblclick", a)));
  }, [a]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      O == null || O(C);
    }));
  }, [C, O]), v(() => {
    C && typeof l == "function" && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof m == "function" && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(C, "mouseover", m)));
  }, [m]), v(() => {
    C && typeof f == "function" && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof g == "function" && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(C, "rightclick", g)));
  }, [g]), v(() => {
    C && typeof h == "function" && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(C, "click", h)));
  }, [h]), v(() => {
    C && typeof x == "function" && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(C, "drag", x)));
  }, [x]), v(() => {
    var A = new google.maps.Polygon(ES(ES({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), s && A.setPaths(s), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), a && L(google.maps.event.addListener(A, "dblclick", a)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), m && j(google.maps.event.addListener(A, "mouseover", m)), f && M(google.maps.event.addListener(A, "mouseup", f)), g && E(google.maps.event.addListener(A, "rightclick", g)), h && R(google.maps.event.addListener(A, "click", h)), x && W(google.maps.event.addListener(A, "drag", x)), S(A), w && w(A), () => {
      U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), T !== null && google.maps.event.removeListener(T), D && D(A), A.setMap(null);
    };
  }, []), null;
}
Le(one);
class ine extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = zt({
      updaterMap: PS,
      eventMap: LS,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: PS,
      eventMap: LS,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Ht(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ge(ine, "contextType", mt);
function kS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var SS = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, DS = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function sne(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onBoundsChanged: x,
    onLoad: w,
    onUnmount: D
  } = e, O = xe(mt), [y, C] = P(null), [S, U] = P(null), [L, F] = P(null), [B, $] = P(null), [V, z] = P(null), [q, X] = P(null), [J, te] = P(null), [ee, k] = P(null), [j, H] = P(null), [M, Z] = P(null), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null);
  return v(() => {
    y !== null && y.setMap(O);
  }, [O]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && s && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(y, "dblclick", s)));
  }, [s]), v(() => {
    y && a && (L !== null && google.maps.event.removeListener(L), F(google.maps.event.addListener(y, "dragend", a)));
  }, [a]), v(() => {
    y && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (q !== null && google.maps.event.removeListener(q), X(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && m && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(y, "mouseup", m)));
  }, [m]), v(() => {
    y && f && (M !== null && google.maps.event.removeListener(M), Z(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && g && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(y, "click", g)));
  }, [g]), v(() => {
    y && h && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(y, "drag", h)));
  }, [h]), v(() => {
    y && x && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(y, "bounds_changed", x)));
  }, [x]), v(() => {
    var Q = new google.maps.Rectangle(mf(mf({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), s && U(google.maps.event.addListener(Q, "dblclick", s)), a && F(google.maps.event.addListener(Q, "dragend", a)), l && $(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && X(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && k(google.maps.event.addListener(Q, "mouseover", d)), m && H(google.maps.event.addListener(Q, "mouseup", m)), f && Z(google.maps.event.addListener(Q, "rightclick", f)), g && T(google.maps.event.addListener(Q, "click", g)), h && _(google.maps.event.addListener(Q, "drag", h)), x && A(google.maps.event.addListener(Q, "bounds_changed", x)), C(Q), w && w(Q), () => {
      S !== null && google.maps.event.removeListener(S), L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), M !== null && google.maps.event.removeListener(M), E !== null && google.maps.event.removeListener(E), R !== null && google.maps.event.removeListener(R), W !== null && google.maps.event.removeListener(W), D && D(Q), Q.setMap(null);
    };
  }, []), null;
}
Le(sne);
class ane extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      rectangle: null
    }), ge(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(mf(mf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = zt({
      updaterMap: DS,
      eventMap: SS,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: DS,
      eventMap: SS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Ht(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ge(ane, "contextType", mt);
function MS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? MS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var TS = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, jS = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, lne = {};
function une(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: x,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: O,
    onUnmount: y
  } = e, C = xe(mt), [S, U] = P(null), [L, F] = P(null), [B, $] = P(null), [V, z] = P(null), [q, X] = P(null), [J, te] = P(null), [ee, k] = P(null), [j, H] = P(null), [M, Z] = P(null), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null), [Q, N] = P(null), [ue, ye] = P(null);
  return v(() => {
    S !== null && S.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), v(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), v(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), v(() => {
    typeof s < "u" && S !== null && S.setVisible(s);
  }, [S, s]), v(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), v(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), v(() => {
    S && a && (L !== null && google.maps.event.removeListener(L), F(google.maps.event.addListener(S, "dblclick", a)));
  }, [a]), v(() => {
    S && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), v(() => {
    S && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), v(() => {
    S && c && (q !== null && google.maps.event.removeListener(q), X(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), v(() => {
    S && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), v(() => {
    S && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), v(() => {
    S && m && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(S, "mouseover", m)));
  }, [m]), v(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), Z(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), v(() => {
    S && g && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(S, "rightclick", g)));
  }, [g]), v(() => {
    S && h && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(S, "click", h)));
  }, [h]), v(() => {
    S && x && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(S, "drag", x)));
  }, [x]), v(() => {
    S && w && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(S, "center_changed", w)));
  }, [h]), v(() => {
    S && D && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), v(() => {
    var oe = new google.maps.Circle(vf(vf({}, t || lne), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof s < "u" && oe.setVisible(s), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), a && F(google.maps.event.addListener(oe, "dblclick", a)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), m && H(google.maps.event.addListener(oe, "mouseover", m)), f && Z(google.maps.event.addListener(oe, "mouseup", f)), g && T(google.maps.event.addListener(oe, "rightclick", g)), h && _(google.maps.event.addListener(oe, "click", h)), x && A(google.maps.event.addListener(oe, "drag", x)), w && N(google.maps.event.addListener(oe, "center_changed", w)), D && ye(google.maps.event.addListener(oe, "radius_changed", D)), U(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), M !== null && google.maps.event.removeListener(M), E !== null && google.maps.event.removeListener(E), R !== null && google.maps.event.removeListener(R), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
Le(une);
class cne extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      circle: null
    }), ge(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(vf(vf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = zt({
      updaterMap: jS,
      eventMap: TS,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: jS,
      eventMap: TS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Ht(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ge(cne, "contextType", mt);
function _S(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _S(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _S(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var AS = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, BS = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function pne(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: m,
    onSetProperty: f,
    onLoad: g,
    onUnmount: h
  } = e, x = xe(mt), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null);
  return v(() => {
    w !== null && w.setMap(x);
  }, [x]), v(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && s && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), v(() => {
    w && a && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && m && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(w, "setgeometry", m)));
  }, [m]), v(() => {
    w && f && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (x !== null) {
      var A = new google.maps.Data(yf(yf({}, t), {}, {
        map: x
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), s && B(google.maps.event.addListener(A, "mouseout", s)), a && V(google.maps.event.addListener(A, "mouseover", a)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && j(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && E(google.maps.event.addListener(A, "removeproperty", d)), m && R(google.maps.event.addListener(A, "setgeometry", m)), f && W(google.maps.event.addListener(A, "setproperty", f)), D(A), g && g(A);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), T !== null && google.maps.event.removeListener(T), _ !== null && google.maps.event.removeListener(_), h && h(w), w.setMap(null));
    };
  }, []), null;
}
Le(pne);
class dne extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      data: null
    }), ge(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(yf(yf({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = zt({
        updaterMap: BS,
        eventMap: AS,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: BS,
      eventMap: AS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Ht(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ge(dne, "contextType", mt);
function IS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function NS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var FS = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, RS = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class fne extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      kmlLayer: null
    }), ge(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(NS(NS({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = zt({
      updaterMap: RS,
      eventMap: FS,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: RS,
      eventMap: FS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Ht(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(fne, "contextType", mt);
function v2(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function hne(e, t) {
  return new t(e.lat, e.lng);
}
function gne(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function mne(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function vne(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function yne(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function bne(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function y2(e, t, n, r) {
  return n !== void 0 ? yne(e, t, vne(n, google.maps.LatLngBounds, gne)) : bne(e, t, mne(r, google.maps.LatLng, hne));
}
function wne(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function zS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cne(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function One(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = Cne({}, this.container ? v2(this.container, o) : {
        x: 0,
        y: 0
      }), u = y2(a, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function US(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xne(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? US(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : US(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function $S(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function VS(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Ene(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = xe(mt), c = Nn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Nn(() => One(c, r, t, n, a), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    s == null || s(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), oi.createPortal(l, c);
}
Le(Ene);
class rl extends be {
  constructor(t) {
    super(t), ge(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ge(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Er(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ge(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ge(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = xne({
        x: 0,
        y: 0
      }, this.containerRef.current ? v2(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = y2(r, o, this.props.bounds, this.props.position);
      if (!wne(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ge(this, "draw", () => {
      this.onPositionElement();
    }), ge(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = wr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = $S(t.position), r = $S(this.props.position), o = VS(t.bounds), i = VS(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? oi.createPortal(no.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: it.only(this.props.children)
    }), t) : null;
  }
}
ge(rl, "FLOAT_PANE", "floatPane");
ge(rl, "MAP_PANE", "mapPane");
ge(rl, "MARKER_LAYER", "markerLayer");
ge(rl, "OVERLAY_LAYER", "overlayLayer");
ge(rl, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ge(rl, "contextType", mt);
function Lne() {
}
function HS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function WS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ZS = {
  onDblClick: "dblclick",
  onClick: "click"
}, qS = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Pne(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = xe(mt), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Nn(() => new google.maps.GroundOverlay(t, s, r), []);
  return v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), v(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Le(Pne);
class b2 extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      groundOverlay: null
    }), ge(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Er(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, WS(WS({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = zt({
      updaterMap: qS,
      eventMap: ZS,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: qS,
      eventMap: ZS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ge(b2, "defaultProps", {
  onLoad: Lne
});
ge(b2, "contextType", mt);
function GS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var YS = {}, KS = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function kne(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = xe(mt), [s, a] = P(null);
  return v(() => {
    google.maps.visualization || Er(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    Er(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(bf(bf({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Le(kne);
class Sne extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      heatmapLayer: null
    }), ge(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Er(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Er(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(bf(bf({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = zt({
      updaterMap: KS,
      eventMap: YS,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: KS,
      eventMap: YS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Ht(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(Sne, "contextType", mt);
var JS = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, XS = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Dne extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      streetViewPanorama: null
    }), ge(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = zt({
      updaterMap: XS,
      eventMap: JS,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: XS,
      eventMap: JS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Ht(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ge(Dne, "contextType", mt);
class Mne extends be {
  constructor() {
    super(...arguments), ge(this, "state", {
      streetViewService: null
    }), ge(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ge(Mne, "contextType", mt);
var QS = {
  onDirectionsChanged: "directions_changed"
}, eD = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Tne extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      directionsRenderer: null
    }), ge(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = zt({
      updaterMap: eD,
      eventMap: QS,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: eD,
      eventMap: QS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Ht(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(Tne, "contextType", mt);
var tD = {
  onPlacesChanged: "places_changed"
}, nD = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class jne extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", wr()), ge(this, "state", {
      searchBox: null
    }), ge(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Er(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = zt({
          updaterMap: nD,
          eventMap: tD,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: nD,
      eventMap: tD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Ht(this.registeredEvents));
  }
  render() {
    return no.jsx("div", {
      ref: this.containerElement,
      children: it.only(this.props.children)
    });
  }
}
ge(jne, "contextType", mt);
var rD = {
  onPlaceChanged: "place_changed"
}, oD = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class w2 extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", wr()), ge(this, "state", {
      autocomplete: null
    }), ge(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Er(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = zt({
        updaterMap: oD,
        eventMap: rD,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Ht(this.registeredEvents), this.registeredEvents = zt({
      updaterMap: oD,
      eventMap: rD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Ht(this.registeredEvents);
  }
  render() {
    return no.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: it.only(this.props.children)
    });
  }
}
ge(w2, "defaultProps", {
  className: ""
});
ge(w2, "contextType", mt);
let _ne = { data: "" }, Ane = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || _ne, Bne = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Ine = /\/\*[^]*?\*\/|  +/g, iD = /\n+/g, ds = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? ds(s, i) : i + "{" + ds(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += ds(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ds.p ? ds.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Oi = {}, C2 = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + C2(e[n]);
    return t;
  }
  return e;
}, Nne = (e, t, n, r, o) => {
  let i = C2(e), s = Oi[i] || (Oi[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Oi[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Bne.exec(u.replace(Ine, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(iD, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(iD, " ").trim();
      return d[0];
    })(e);
    Oi[s] = ds(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Oi.g ? Oi.g : null;
  return n && (Oi.g = Oi[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Oi[s], t, r, a), s;
}, Fne = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : ds(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function Lg(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Nne(n.unshift ? n.raw ? Fne(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Ane(t.target), t.g, t.o, t.k);
}
let O2, Ib, Nb;
Lg.bind({ g: 1 });
let _i = Lg.bind({ k: 1 });
function Rne(e, t, n, r) {
  ds.p = t, O2 = e, Ib = n, Nb = r;
}
function Ts(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: Ib && Ib() }, a), n.o = / *go\d+/.test(l), a.className = Lg.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), Nb && u[0] && Nb(a), O2(u, a);
    }
    return o;
  };
}
var zne = (e) => typeof e == "function", Une = (e, t) => zne(e) ? e(t) : e, $ne = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Vne = _i`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Hne = _i`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Wne = _i`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Zne = Ts("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Vne} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Hne} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Wne} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, qne = _i`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Gne = Ts("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${qne} 1s linear infinite;
`, Yne = _i`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Kne = _i`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, Jne = Ts("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Yne} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Kne} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Xne = Ts("div")`
  position: absolute;
`, Qne = Ts("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, ere = _i`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, tre = Ts("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${ere} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, nre = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ue.createElement(tre, null, t) : t : n === "blank" ? null : Ue.createElement(Qne, null, Ue.createElement(Gne, { ...r }), n !== "loading" && Ue.createElement(Xne, null, n === "error" ? Ue.createElement(Zne, { ...r }) : Ue.createElement(Jne, { ...r })));
}, rre = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ore = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, ire = "0%{opacity:0;} 100%{opacity:1;}", sre = "0%{opacity:1;} 100%{opacity:0;}", are = Ts("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, lre = Ts("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, ure = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = $ne() ? [ire, sre] : [rre(n), ore(n)];
  return { animation: t ? `${_i(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${_i(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ue.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? ure(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ue.createElement(nre, { toast: e }), s = Ue.createElement(lre, { ...e.ariaProps }, Une(e.message, e));
  return Ue.createElement(are, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ue.createElement(Ue.Fragment, null, i, s));
});
Rne(Ue.createElement);
Lg`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ge({});
function cre(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const pre = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
cre(pre.CNPJ).length;
Da((e, t) => /* @__PURE__ */ to.jsx("input", { ref: t, ...e }));
Ge({});
var Ri = {};
Object.defineProperty(Ri, "__esModule", {
  value: !0
});
var dre = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), cv = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, x2 = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: dre ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, xC = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var kp = 1; kp < 20; kp++)
  xC["f" + kp] = 111 + kp;
function Pg(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return E2(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return L2(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function fre(e, t) {
  return Pg(e, t);
}
function hre(e, t) {
  return Pg(e, { byKey: !0 }, t);
}
function E2(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in cv)
    r[cv[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, m = d.endsWith("?") && d.length > 1;
      m && (d = d.slice(0, -1));
      var f = EC(d), g = cv[f];
      if (d.length > 1 && !g && !x2[d] && !xC[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !g) && (n ? r.key = f : r.which = P2(d)), g && (r[g] = m ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function L2(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function P2(e) {
  e = EC(e);
  var t = xC[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function EC(e) {
  return e = e.toLowerCase(), e = x2[e] || e, e;
}
Ri.default = Pg;
var pv = Ri.isHotkey = Pg;
Ri.isCodeHotkey = fre;
Ri.isKeyHotkey = hre;
Ri.parseHotkey = E2;
Ri.compareHotkey = L2;
Ri.toKeyCode = P2;
Ri.toKeyName = EC;
var gre = typeof Pn == "object" && Pn && Pn.Object === Object && Pn, mre = gre, vre = mre, yre = typeof self == "object" && self && self.Object === Object && self, bre = vre || yre || Function("return this")(), wre = bre, Cre = wre, Ore = Cre.Symbol, k2 = Ore, sD = k2;
sD && sD.toStringTag;
var aD = k2;
aD && aD.toStringTag;
var lD;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(lD || (lD = {}));
var LC = function(e) {
  return Object.freeze(e);
}, xre = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, LC(this);
  }
  return e;
}(), Ere = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, LC(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), uD = typeof window < "u" ? window : {};
/msie|trident/i.test(uD.navigator && uD.navigator.userAgent);
var dv = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new xre((n ? t : e) || 0, (n ? e : t) || 0);
};
LC({
  devicePixelContentBoxSize: dv(),
  borderBoxSize: dv(),
  contentBoxSize: dv(),
  contentRect: new Ere(0, 0, 0, 0)
});
function zu(e) {
  "@babel/helpers - typeof";
  return zu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zu(e);
}
function Lre(e, t) {
  if (zu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (zu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Pre(e) {
  var t = Lre(e, "string");
  return zu(t) === "symbol" ? t : String(t);
}
function lu(e, t, n) {
  return t = Pre(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var kre = /* @__PURE__ */ Ge(null), fv, hv;
parseInt(Ee.version.split(".")[0], 10);
var cD = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), gv = typeof navigator < "u" && /Android/.test(navigator.userAgent), Sp = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Sre = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (fv = navigator.userAgent.match(/Version\/(\d+)/)) !== null && fv !== void 0 && fv[1] && parseInt((hv = navigator.userAgent.match(/Version\/(\d+)/)) === null || hv === void 0 ? void 0 : hv[1], 10) < 17;
var Dre = /* @__PURE__ */ new WeakMap(), Mre = /* @__PURE__ */ new WeakMap(), Tre = /* @__PURE__ */ new WeakMap(), jre = /* @__PURE__ */ new WeakMap(), _re = /* @__PURE__ */ new WeakMap(), pD = /* @__PURE__ */ new WeakMap(), Are = /* @__PURE__ */ new WeakMap(), dD = /* @__PURE__ */ new WeakMap(), Dp = /* @__PURE__ */ new WeakMap(), Bre = /* @__PURE__ */ new WeakMap(), Ire = /* @__PURE__ */ new WeakMap(), Nre = /* @__PURE__ */ new WeakMap(), S2 = globalThis.Node, Fre = globalThis.Text, D2 = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, Rre = (e) => wf(e) && e.nodeType === 8, Qo = (e) => wf(e) && e.nodeType === 1, wf = (e) => {
  var t = D2(e);
  return !!t && e instanceof t.Node;
}, fD = (e) => {
  var t = e && e.anchorNode && D2(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, zre = (e) => {
  var [t, n] = e;
  if (Qo(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = M2(t, o, r ? "backward" : "forward"), r = o < n; Qo(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = $re(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, Ure = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, M2 = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (Rre(o) || Qo(o) && o.childNodes.length === 0 || Qo(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, $re = (e, t, n) => {
  var [r] = M2(e, t, n);
  return r;
}, hD = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), T2 = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Qo(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Nt.getWindow(e);
  if (o.contains(r))
    return Nt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : T2(e, i, n);
}, gD = (e, t) => !!(e.compareDocumentPosition(t) & S2.DOCUMENT_POSITION_PRECEDING), Vre = (e, t) => !!(e.compareDocumentPosition(t) & S2.DOCUMENT_POSITION_FOLLOWING), Hre = 0;
class Wre {
  constructor() {
    lu(this, "id", void 0), this.id = "".concat(Hre++);
  }
}
var Nt = {
  androidPendingDiffs: (e) => Nre.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = Ire.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Nt.toDOMNode(e, e), n = Nt.findDocumentOrShadowRoot(e);
    Dp.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Nt.findDocumentOrShadowRoot(e), r = hD(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Rd.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Nt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Nt.toSlateNode(e, t.target), s = Nt.findPath(e, i);
    if (ki.isElement(i) && Cn.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = Cn.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? Cn.before(e, u) : Cn.after(e, u);
      if (c) {
        var p = Cn.range(e, c);
        return p;
      }
    }
    var d, {
      document: m
    } = Nt.getWindow(e);
    if (m.caretRangeFromPoint)
      d = m.caretRangeFromPoint(n, r);
    else {
      var f = m.caretPositionFromPoint(n, r);
      f && (d = m.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var g = Nt.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return g;
  },
  findKey: (e, t) => {
    var n = pD.get(t);
    return n || (n = new Wre(), pD.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = Mre.get(r);
      if (o == null) {
        if (Cn.isEditor(r))
          return n;
        break;
      }
      var i = Dre.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(po.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Dp.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Nt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Nt.toDOMNode(e, e), r = Nt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = hD(r), i = Nt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Rd.select(e, Cn.start(e, [])), Dp.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Tre.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Nt.toDOMNode(e, e), i;
    try {
      i = Qo(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => wf(t) && Nt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Cn.hasPath(e, n.path) && Cn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Nt.hasEditableTarget(e, t) || Nt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => wf(t) && Nt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Bre.get(e),
  isFocused: (e) => !!Dp.get(e),
  isReadOnly: (e) => !!dD.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (dD.get(e)) return !1;
    var n = Nt.hasTarget(e, t) && Nt.toSlateNode(e, t);
    return ki.isElement(n) && Cn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Are.get(e), r = Cn.isEditor(t) ? jre.get(e) : n == null ? void 0 : n.get(Nt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(po.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Cn.node(e, t.path), r = Nt.toDOMNode(e, n), o;
    Cn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), m = d == null ? p : parseInt(d, 10), f = a + m, g = s[l + 1];
        if (t.offset === f && g !== null && g !== void 0 && g.hasAttribute("data-slate-mark-placeholder")) {
          var h, x = g.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            x instanceof Fre ? x : g,
            (h = g.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(po.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Et.isBackward(t), i = Nt.toDOMPoint(e, n), s = Et.isCollapsed(t) ? i : Nt.toDOMPoint(e, r), a = Nt.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, m = Qo(u) ? u : u.parentElement, f = !!m.getAttribute("data-slate-zero-width"), g = Qo(p) ? p : p.parentElement, h = !!g.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Qo(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? _re.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : zre(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, m = Nt.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), g = f && m.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), x = h && m.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = Nt.getWindow(e), y = O.document.createRange();
          y.setStart(u, 0), y.setEnd(s, a);
          var C = y.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (gv && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (g) {
        for (var U = g.querySelectorAll("[data-slate-leaf]"), L = 0; L < U.length; L++) {
          var F = U[L];
          if (Nt.hasDOMNode(e, F)) {
            w = F;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (x) {
        var B = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = x.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...B($), ...B($ == null ? void 0 : $.nextElementSibling)];
          w = (V = z.find((M) => Vre(x, M))) !== null && V !== void 0 ? V : null;
        } else {
          var q, X = [...B($ == null ? void 0 : $.previousElementSibling), ...B($)];
          w = (q = X.findLast((M) => gD(x, M))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      gv && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Sp && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (gv && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && Nt.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = Nt.toSlateNode(e, J), {
          path: ee,
          offset: k
        } = Cn.start(e, Nt.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (k = a), {
          path: ee,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var j = Nt.toSlateNode(e, u), H = Nt.findPath(e, j);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = fD(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (fD(t)) {
        if (Sp && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), m = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && m.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, g = m.startContainer, h = C(f.children[d.startOffset]), x = C(g.children[m.startOffset]);
            c = 0, x.childNodes.length > 0 ? a = x.childNodes[0] : a = x, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, x instanceof HTMLElement ? l = x.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = m.endContainer, l = m.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = m.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Sre && Ure(a) || Sp ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Sp && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Nt.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = gD(a, u) || a === u && c < l, O = p ? w : Nt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!O)
      return null;
    var y = {
      anchor: w,
      focus: O
    };
    return Et.isExpanded(y) && Et.isForward(y) && Qo(u) && Cn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = Cn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, Zre = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, qre = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, Gre = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Gn = (e) => {
  var t = Zre[e], n = qre[e], r = Gre[e], o = t && pv(t), i = n && pv(n), s = r && pv(r);
  return (a) => !!(o && o(a) || cD && i && i(a) || !cD && s && s(a));
};
Gn("bold"), Gn("compose"), Gn("moveBackward"), Gn("moveForward"), Gn("deleteBackward"), Gn("deleteForward"), Gn("deleteLineBackward"), Gn("deleteLineForward"), Gn("deleteWordBackward"), Gn("deleteWordForward"), Gn("extendBackward"), Gn("extendForward"), Gn("extendLineBackward"), Gn("extendLineForward"), Gn("italic"), Gn("moveLineBackward"), Gn("moveLineForward"), Gn("moveWordBackward"), Gn("moveWordForward"), Gn("redo"), Gn("insertSoftBreak"), Gn("splitBlock"), Gn("transposeCharacter"), Gn("undo");
var Yre = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => T2(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, Kre = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class Jre extends Yu {
  constructor() {
    super(...arguments), lu(this, "context", null), lu(this, "manager", null), lu(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, Kre);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = Yre(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
lu(Jre, "contextType", kre);
Ge({});
Ge({});
Ge({});
var vr = {}, PC = {}, cc = {}, pc = {}, j2 = "Expected a function", mD = NaN, Xre = "[object Symbol]", Qre = /^\s+|\s+$/g, eoe = /^[-+]0x[0-9a-f]+$/i, toe = /^0b[01]+$/i, noe = /^0o[0-7]+$/i, roe = parseInt, ooe = typeof Pn == "object" && Pn && Pn.Object === Object && Pn, ioe = typeof self == "object" && self && self.Object === Object && self, soe = ooe || ioe || Function("return this")(), aoe = Object.prototype, loe = aoe.toString, uoe = Math.max, coe = Math.min, mv = function() {
  return soe.Date.now();
};
function poe(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(j2);
  t = vD(t) || 0, Cf(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? uoe(vD(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function m(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, s = e.apply(U, S), s;
  }
  function f(C) {
    return u = C, a = setTimeout(x, t), c ? m(C) : s;
  }
  function g(C) {
    var S = C - l, U = C - u, L = t - S;
    return p ? coe(L, i - U) : L;
  }
  function h(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function x() {
    var C = mv();
    if (h(C))
      return w(C);
    a = setTimeout(x, g(C));
  }
  function w(C) {
    return a = void 0, d && r ? m(C) : (r = o = void 0, s);
  }
  function D() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function O() {
    return a === void 0 ? s : w(mv());
  }
  function y() {
    var C = mv(), S = h(C);
    if (r = arguments, o = this, l = C, S) {
      if (a === void 0)
        return f(l);
      if (p)
        return a = setTimeout(x, t), m(l);
    }
    return a === void 0 && (a = setTimeout(x, t)), s;
  }
  return y.cancel = D, y.flush = O, y;
}
function doe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(j2);
  return Cf(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), poe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Cf(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function foe(e) {
  return !!e && typeof e == "object";
}
function hoe(e) {
  return typeof e == "symbol" || foe(e) && loe.call(e) == Xre;
}
function vD(e) {
  if (typeof e == "number")
    return e;
  if (hoe(e))
    return mD;
  if (Cf(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Cf(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Qre, "");
  var n = toe.test(e);
  return n || noe.test(e) ? roe(e.slice(2), n ? 2 : 8) : eoe.test(e) ? mD : +e;
}
var goe = doe, dc = {};
Object.defineProperty(dc, "__esModule", {
  value: !0
});
dc.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), hd.has(t) || hd.set(t, /* @__PURE__ */ new Set());
  var o = hd.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
dc.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), hd.get(t).delete(n.name || t);
};
var hd = /* @__PURE__ */ new Map();
Object.defineProperty(pc, "__esModule", {
  value: !0
});
var moe = goe, voe = boe(moe), yoe = dc;
function boe(e) {
  return e && e.__esModule ? e : { default: e };
}
var woe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, voe.default)(e, t);
}, rr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = woe(function(r) {
        rr.scrollHandler(e);
      }, t);
      rr.scrollSpyContainers.push(e), (0, yoe.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return rr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = rr.scrollSpyContainers[rr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(rr.currentPositionX(e), rr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    rr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = rr.scrollSpyContainers[rr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(rr.currentPositionX(t), rr.currentPositionY(t));
  },
  updateStates: function() {
    rr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    rr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), rr.spySetState && rr.spySetState.length && rr.spySetState.indexOf(e) > -1 && rr.spySetState.splice(rr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", rr.scrollHandler);
  },
  update: function() {
    return rr.scrollSpyContainers.forEach(function(e) {
      return rr.scrollHandler(e);
    });
  }
};
pc.default = rr;
var ol = {}, fc = {};
Object.defineProperty(fc, "__esModule", {
  value: !0
});
var Coe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, Ooe = function() {
  return window.location.hash.replace(/^#/, "");
}, xoe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Eoe = function(e) {
  return getComputedStyle(e).position !== "static";
}, vv = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, Loe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Eoe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = vv(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return vv(t, a).offsetTop - vv(e, a).offsetTop;
};
fc.default = {
  updateHash: Coe,
  getHash: Ooe,
  filterElementInContainer: xoe,
  scrollOffset: Loe
};
var kg = {}, kC = {};
Object.defineProperty(kC, "__esModule", {
  value: !0
});
kC.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var SC = {};
Object.defineProperty(SC, "__esModule", {
  value: !0
});
var Poe = dc, koe = ["mousedown", "mousewheel", "touchmove", "keydown"];
SC.default = {
  subscribe: function(e) {
    return typeof document < "u" && koe.forEach(function(t) {
      return (0, Poe.addPassiveEventListener)(document, t, e);
    });
  }
};
var hc = {};
Object.defineProperty(hc, "__esModule", {
  value: !0
});
var Fb = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Fb.registered[e] = t;
    },
    remove: function(e) {
      Fb.registered[e] = null;
    }
  }
};
hc.default = Fb;
Object.defineProperty(kg, "__esModule", {
  value: !0
});
var Soe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Doe = fc;
Sg(Doe);
var Moe = kC, yD = Sg(Moe), Toe = SC, joe = Sg(Toe), _oe = hc, Go = Sg(_oe);
function Sg(e) {
  return e && e.__esModule ? e : { default: e };
}
var _2 = function(e) {
  return yD.default[e.smooth] || yD.default.defaultEasing;
}, Aoe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Boe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Rb = function() {
  return Boe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), A2 = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, B2 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, I2 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, Ioe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, Noe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, Foe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Go.default.registered.end && Go.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Rb.call(window, i);
    return;
  }
  Go.default.registered.end && Go.default.registered.end(o.to, o.target, o.currentPosition);
}, DC = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, gc = function(e, t, n, r) {
  t.data = t.data || A2(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (joe.default.subscribe(o), DC(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? B2(t) : I2(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Go.default.registered.end && Go.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = Aoe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = _2(t), s = Foe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Go.default.registered.begin && Go.default.registered.begin(t.data.to, t.data.target), Rb.call(window, s);
    }, t.delay);
    return;
  }
  Go.default.registered.begin && Go.default.registered.begin(t.data.to, t.data.target), Rb.call(window, s);
}, Dg = function(e) {
  return e = Soe({}, e), e.data = e.data || A2(), e.absolute = !0, e;
}, Roe = function(e) {
  gc(0, Dg(e));
}, zoe = function(e, t) {
  gc(e, Dg(t));
}, Uoe = function(e) {
  e = Dg(e), DC(e), gc(e.horizontal ? Ioe(e) : Noe(e), e);
}, $oe = function(e, t) {
  t = Dg(t), DC(t);
  var n = t.horizontal ? B2(t) : I2(t);
  gc(e + n, t);
};
kg.default = {
  animateTopScroll: gc,
  getAnimationType: _2,
  scrollToTop: Roe,
  scrollToBottom: Uoe,
  scrollTo: zoe,
  scrollMore: $oe
};
Object.defineProperty(ol, "__esModule", {
  value: !0
});
var Voe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Hoe = fc, Woe = MC(Hoe), Zoe = kg, qoe = MC(Zoe), Goe = hc, Mp = MC(Goe);
function MC(e) {
  return e && e.__esModule ? e : { default: e };
}
var Tp = {}, bD = void 0;
ol.default = {
  unmount: function() {
    Tp = {};
  },
  register: function(e, t) {
    Tp[e] = t;
  },
  unregister: function(e) {
    delete Tp[e];
  },
  get: function(e) {
    return Tp[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return bD = e;
  },
  getActiveLink: function() {
    return bD;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Voe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = Woe.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      Mp.default.registered.begin && Mp.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, Mp.default.registered.end && Mp.default.registered.end(e, n);
      return;
    }
    qoe.default.animateTopScroll(a, t, e, n);
  }
};
var zb = { exports: {} }, yv = { exports: {} }, an = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wD;
function Yoe() {
  if (wD) return an;
  wD = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case a:
                case c:
                case f:
                case m:
                case s:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function O(y) {
    return D(y) === u;
  }
  return an.AsyncMode = l, an.ConcurrentMode = u, an.ContextConsumer = a, an.ContextProvider = s, an.Element = t, an.ForwardRef = c, an.Fragment = r, an.Lazy = f, an.Memo = m, an.Portal = n, an.Profiler = i, an.StrictMode = o, an.Suspense = p, an.isAsyncMode = function(y) {
    return O(y) || D(y) === l;
  }, an.isConcurrentMode = O, an.isContextConsumer = function(y) {
    return D(y) === a;
  }, an.isContextProvider = function(y) {
    return D(y) === s;
  }, an.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, an.isForwardRef = function(y) {
    return D(y) === c;
  }, an.isFragment = function(y) {
    return D(y) === r;
  }, an.isLazy = function(y) {
    return D(y) === f;
  }, an.isMemo = function(y) {
    return D(y) === m;
  }, an.isPortal = function(y) {
    return D(y) === n;
  }, an.isProfiler = function(y) {
    return D(y) === i;
  }, an.isStrictMode = function(y) {
    return D(y) === o;
  }, an.isSuspense = function(y) {
    return D(y) === p;
  }, an.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === m || y.$$typeof === s || y.$$typeof === a || y.$$typeof === c || y.$$typeof === h || y.$$typeof === x || y.$$typeof === w || y.$$typeof === g);
  }, an.typeOf = D, an;
}
var vn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var CD;
function Koe() {
  return CD || (CD = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === m || N.$$typeof === s || N.$$typeof === a || N.$$typeof === c || N.$$typeof === h || N.$$typeof === x || N.$$typeof === w || N.$$typeof === g);
    }
    function O(N) {
      if (typeof N == "object" && N !== null) {
        var ue = N.$$typeof;
        switch (ue) {
          case t:
            var ye = N.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ye;
              default:
                var oe = ye && ye.$$typeof;
                switch (oe) {
                  case a:
                  case c:
                  case f:
                  case m:
                  case s:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, S = a, U = s, L = t, F = c, B = r, $ = f, V = m, z = n, q = i, X = o, J = p, te = !1;
    function ee(N) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(N) || O(N) === l;
    }
    function k(N) {
      return O(N) === u;
    }
    function j(N) {
      return O(N) === a;
    }
    function H(N) {
      return O(N) === s;
    }
    function M(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function Z(N) {
      return O(N) === c;
    }
    function E(N) {
      return O(N) === r;
    }
    function T(N) {
      return O(N) === f;
    }
    function R(N) {
      return O(N) === m;
    }
    function _(N) {
      return O(N) === n;
    }
    function W(N) {
      return O(N) === i;
    }
    function A(N) {
      return O(N) === o;
    }
    function Q(N) {
      return O(N) === p;
    }
    vn.AsyncMode = y, vn.ConcurrentMode = C, vn.ContextConsumer = S, vn.ContextProvider = U, vn.Element = L, vn.ForwardRef = F, vn.Fragment = B, vn.Lazy = $, vn.Memo = V, vn.Portal = z, vn.Profiler = q, vn.StrictMode = X, vn.Suspense = J, vn.isAsyncMode = ee, vn.isConcurrentMode = k, vn.isContextConsumer = j, vn.isContextProvider = H, vn.isElement = M, vn.isForwardRef = Z, vn.isFragment = E, vn.isLazy = T, vn.isMemo = R, vn.isPortal = _, vn.isProfiler = W, vn.isStrictMode = A, vn.isSuspense = Q, vn.isValidElementType = D, vn.typeOf = O;
  }()), vn;
}
var OD;
function N2() {
  return OD || (OD = 1, process.env.NODE_ENV === "production" ? yv.exports = Yoe() : yv.exports = Koe()), yv.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var bv, xD;
function Joe() {
  if (xD) return bv;
  xD = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return bv = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, bv;
}
var wv, ED;
function TC() {
  if (ED) return wv;
  ED = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return wv = e, wv;
}
var LD, PD;
function F2() {
  return PD || (PD = 1, LD = Function.call.bind(Object.prototype.hasOwnProperty)), LD;
}
var Cv, kD;
function Xoe() {
  if (kD) return Cv;
  kD = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = TC(), n = {}, r = F2();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var m = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (m ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Cv = o, Cv;
}
var Ov, SD;
function Qoe() {
  if (SD) return Ov;
  SD = 1;
  var e = N2(), t = Joe(), n = TC(), r = F2(), o = Xoe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return Ov = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var j = k && (u && k[u] || k[c]);
      if (typeof j == "function")
        return j;
    }
    var d = "<<anonymous>>", m = {
      array: x("array"),
      bigint: x("bigint"),
      bool: x("boolean"),
      func: x("function"),
      number: x("number"),
      object: x("object"),
      string: x("string"),
      symbol: x("symbol"),
      any: w(),
      arrayOf: D,
      element: O(),
      elementType: y(),
      instanceOf: C,
      node: F(),
      objectOf: U,
      oneOf: S,
      oneOfType: L,
      shape: $,
      exact: V
    };
    function f(k, j) {
      return k === j ? k !== 0 || 1 / k === 1 / j : k !== k && j !== j;
    }
    function g(k, j) {
      this.message = k, this.data = j && typeof j == "object" ? j : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function h(k) {
      if (process.env.NODE_ENV !== "production")
        var j = {}, H = 0;
      function M(E, T, R, _, W, A, Q) {
        if (_ = _ || d, A = A || R, Q !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = _ + ":" + R;
            !j[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + _ + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), j[ue] = !0, H++);
          }
        }
        return T[R] == null ? E ? T[R] === null ? new g("The " + W + " `" + A + "` is marked as required " + ("in `" + _ + "`, but its value is `null`.")) : new g("The " + W + " `" + A + "` is marked as required in " + ("`" + _ + "`, but its value is `undefined`.")) : null : k(T, R, _, W, A);
      }
      var Z = M.bind(null, !1);
      return Z.isRequired = M.bind(null, !0), Z;
    }
    function x(k) {
      function j(H, M, Z, E, T, R) {
        var _ = H[M], W = X(_);
        if (W !== k) {
          var A = J(_);
          return new g(
            "Invalid " + E + " `" + T + "` of type " + ("`" + A + "` supplied to `" + Z + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return h(j);
    }
    function w() {
      return h(s);
    }
    function D(k) {
      function j(H, M, Z, E, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + Z + "` has invalid PropType notation inside arrayOf.");
        var R = H[M];
        if (!Array.isArray(R)) {
          var _ = X(R);
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected an array."));
        }
        for (var W = 0; W < R.length; W++) {
          var A = k(R, W, Z, E, T + "[" + W + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return h(j);
    }
    function O() {
      function k(j, H, M, Z, E) {
        var T = j[H];
        if (!a(T)) {
          var R = X(T);
          return new g("Invalid " + Z + " `" + E + "` of type " + ("`" + R + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(k);
    }
    function y() {
      function k(j, H, M, Z, E) {
        var T = j[H];
        if (!e.isValidElementType(T)) {
          var R = X(T);
          return new g("Invalid " + Z + " `" + E + "` of type " + ("`" + R + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(k);
    }
    function C(k) {
      function j(H, M, Z, E, T) {
        if (!(H[M] instanceof k)) {
          var R = k.name || d, _ = ee(H[M]);
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected ") + ("instance of `" + R + "`."));
        }
        return null;
      }
      return h(j);
    }
    function S(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function j(H, M, Z, E, T) {
        for (var R = H[M], _ = 0; _ < k.length; _++)
          if (f(R, k[_]))
            return null;
        var W = JSON.stringify(k, function(A, Q) {
          var N = J(Q);
          return N === "symbol" ? String(Q) : Q;
        });
        return new g("Invalid " + E + " `" + T + "` of value `" + String(R) + "` " + ("supplied to `" + Z + "`, expected one of " + W + "."));
      }
      return h(j);
    }
    function U(k) {
      function j(H, M, Z, E, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + Z + "` has invalid PropType notation inside objectOf.");
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected an object."));
        for (var W in R)
          if (r(R, W)) {
            var A = k(R, W, Z, E, T + "." + W, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return h(j);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var j = 0; j < k.length; j++) {
        var H = k[j];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(H) + " at index " + j + "."
          ), s;
      }
      function M(Z, E, T, R, _) {
        for (var W = [], A = 0; A < k.length; A++) {
          var Q = k[A], N = Q(Z, E, T, R, _, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && W.push(N.data.expectedType);
        }
        var ue = W.length > 0 ? ", expected one of type [" + W.join(", ") + "]" : "";
        return new g("Invalid " + R + " `" + _ + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return h(M);
    }
    function F() {
      function k(j, H, M, Z, E) {
        return z(j[H]) ? null : new g("Invalid " + Z + " `" + E + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return h(k);
    }
    function B(k, j, H, M, Z) {
      return new g(
        (k || "React class") + ": " + j + " type `" + H + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Z + "`."
      );
    }
    function $(k) {
      function j(H, M, Z, E, T) {
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type `" + _ + "` " + ("supplied to `" + Z + "`, expected `object`."));
        for (var W in k) {
          var A = k[W];
          if (typeof A != "function")
            return B(Z, E, T, W, J(A));
          var Q = A(R, W, Z, E, T + "." + W, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return h(j);
    }
    function V(k) {
      function j(H, M, Z, E, T) {
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type `" + _ + "` " + ("supplied to `" + Z + "`, expected `object`."));
        var W = t({}, H[M], k);
        for (var A in W) {
          var Q = k[A];
          if (r(k, A) && typeof Q != "function")
            return B(Z, E, T, A, J(Q));
          if (!Q)
            return new g(
              "Invalid " + E + " `" + T + "` key `" + A + "` supplied to `" + Z + "`.\nBad object: " + JSON.stringify(H[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var N = Q(R, A, Z, E, T + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return h(j);
    }
    function z(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every(z);
          if (k === null || a(k))
            return !0;
          var j = p(k);
          if (j) {
            var H = j.call(k), M;
            if (j !== k.entries) {
              for (; !(M = H.next()).done; )
                if (!z(M.value))
                  return !1;
            } else
              for (; !(M = H.next()).done; ) {
                var Z = M.value;
                if (Z && !z(Z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(k, j) {
      return k === "symbol" ? !0 : j ? j["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && j instanceof Symbol : !1;
    }
    function X(k) {
      var j = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : q(j, k) ? "symbol" : j;
    }
    function J(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var j = X(k);
      if (j === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return j;
    }
    function te(k) {
      var j = J(k);
      switch (j) {
        case "array":
        case "object":
          return "an " + j;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + j;
        default:
          return j;
      }
    }
    function ee(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return m.checkPropTypes = o, m.resetWarningCache = o.resetWarningCache, m.PropTypes = m, m;
  }, Ov;
}
var xv, DD;
function eie() {
  if (DD) return xv;
  DD = 1;
  var e = TC();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, xv = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, xv;
}
if (process.env.NODE_ENV !== "production") {
  var tie = N2(), nie = !0;
  zb.exports = Qoe()(tie.isElement, nie);
} else
  zb.exports = eie()();
var Mg = zb.exports, Tg = {};
Object.defineProperty(Tg, "__esModule", {
  value: !0
});
var rie = fc, Ev = oie(rie);
function oie(e) {
  return e && e.__esModule ? e : { default: e };
}
var iie = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Ev.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Ev.default.getHash() !== e && Ev.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Tg.default = iie;
Object.defineProperty(cc, "__esModule", {
  value: !0
});
var jp = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, sie = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), aie = Ee, MD = mc(aie), lie = pc, _p = mc(lie), uie = ol, cie = mc(uie), pie = Mg, Yn = mc(pie), die = Tg, Zi = mc(die);
function mc(e) {
  return e && e.__esModule ? e : { default: e };
}
function fie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function hie(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function gie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var TD = {
  to: Yn.default.string.isRequired,
  containerId: Yn.default.string,
  container: Yn.default.object,
  activeClass: Yn.default.string,
  activeStyle: Yn.default.object,
  spy: Yn.default.bool,
  horizontal: Yn.default.bool,
  smooth: Yn.default.oneOfType([Yn.default.bool, Yn.default.string]),
  offset: Yn.default.number,
  delay: Yn.default.number,
  isDynamic: Yn.default.bool,
  onClick: Yn.default.func,
  duration: Yn.default.oneOfType([Yn.default.number, Yn.default.func]),
  absolute: Yn.default.bool,
  onSetActive: Yn.default.func,
  onSetInactive: Yn.default.func,
  ignoreCancelEvents: Yn.default.bool,
  hashSpy: Yn.default.bool,
  saveHashHistory: Yn.default.bool,
  spyThrottle: Yn.default.number
};
cc.default = function(e, t) {
  var n = t || cie.default, r = function(i) {
    gie(s, i);
    function s(a) {
      fie(this, s);
      var l = hie(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return sie(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          _p.default.isMounted(a) || _p.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (Zi.default.isMounted() || Zi.default.mount(n), Zi.default.mapContainer(this.props.to, a)), _p.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        _p.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = jp({}, this.props.style, this.props.activeStyle) : l = jp({}, this.props.style);
        var u = jp({}, this.props);
        for (var c in TD)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, MD.default.createElement(e, u);
      }
    }]), s;
  }(MD.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, jp({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(Zi.default.isMounted() && !Zi.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, m = void 0;
        if (u) {
          var f = 0, g = 0, h = 0;
          if (l.getBoundingClientRect) {
            var x = l.getBoundingClientRect();
            h = x.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - h + s, g = f + w.width;
          }
          var D = s - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(g), m = D < Math.floor(f) || D >= Math.floor(g);
        } else {
          var O = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            O = U.top - C + a, y = O + U.height;
          }
          var L = a - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(y), m = L < Math.floor(O) || L >= Math.floor(y);
        }
        var F = n.getActiveLink();
        if (m) {
          if (c === F && n.setActiveLink(void 0), i.props.hashSpy && Zi.default.getHash() === c) {
            var B = i.props.saveHashHistory, $ = B === void 0 ? !1 : B;
            Zi.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (F !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && Zi.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = TD, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(PC, "__esModule", {
  value: !0
});
var mie = Ee, jD = R2(mie), vie = cc, yie = R2(vie);
function R2(e) {
  return e && e.__esModule ? e : { default: e };
}
function bie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function _D(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function wie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Cie = function(e) {
  wie(t, e);
  function t() {
    var n, r, o, i;
    bie(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = _D(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return jD.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), _D(o, i);
  }
  return t;
}(jD.default.Component);
PC.default = (0, yie.default)(Cie);
var jC = {};
Object.defineProperty(jC, "__esModule", {
  value: !0
});
var Oie = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), xie = Ee, AD = z2(xie), Eie = cc, Lie = z2(Eie);
function z2(e) {
  return e && e.__esModule ? e : { default: e };
}
function Pie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function kie(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Sie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Die = function(e) {
  Sie(t, e);
  function t() {
    return Pie(this, t), kie(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Oie(t, [{
    key: "render",
    value: function() {
      return AD.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(AD.default.Component);
jC.default = (0, Lie.default)(Die);
var _C = {}, jg = {};
Object.defineProperty(jg, "__esModule", {
  value: !0
});
var Mie = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Tie = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), jie = Ee, BD = _g(jie), _ie = Ga;
_g(_ie);
var Aie = ol, ID = _g(Aie), Bie = Mg, ND = _g(Bie);
function _g(e) {
  return e && e.__esModule ? e : { default: e };
}
function Iie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Nie(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Fie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
jg.default = function(e) {
  var t = function(n) {
    Fie(r, n);
    function r(o) {
      Iie(this, r);
      var i = Nie(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Tie(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        ID.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        ID.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return BD.default.createElement(e, Mie({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(BD.default.Component);
  return t.propTypes = {
    name: ND.default.string,
    id: ND.default.string
  }, t;
};
Object.defineProperty(_C, "__esModule", {
  value: !0
});
var FD = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Rie = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), zie = Ee, RD = AC(zie), Uie = jg, $ie = AC(Uie), Vie = Mg, zD = AC(Vie);
function AC(e) {
  return e && e.__esModule ? e : { default: e };
}
function Hie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Wie(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Zie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var U2 = function(e) {
  Zie(t, e);
  function t() {
    return Hie(this, t), Wie(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Rie(t, [{
    key: "render",
    value: function() {
      var n = this, r = FD({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, RD.default.createElement(
        "div",
        FD({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(RD.default.Component);
U2.propTypes = {
  name: zD.default.string,
  id: zD.default.string
};
_C.default = (0, $ie.default)(U2);
var Lv = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, UD = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function $D(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function VD(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function HD(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Ap = Ee, zs = pc, Pv = ol, lr = Mg, qi = Tg, WD = {
  to: lr.string.isRequired,
  containerId: lr.string,
  container: lr.object,
  activeClass: lr.string,
  spy: lr.bool,
  smooth: lr.oneOfType([lr.bool, lr.string]),
  offset: lr.number,
  delay: lr.number,
  isDynamic: lr.bool,
  onClick: lr.func,
  duration: lr.oneOfType([lr.number, lr.func]),
  absolute: lr.bool,
  onSetActive: lr.func,
  onSetInactive: lr.func,
  ignoreCancelEvents: lr.bool,
  hashSpy: lr.bool,
  spyThrottle: lr.number
}, qie = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Pv, r = function(i) {
      HD(s, i);
      function s(a) {
        $D(this, s);
        var l = VD(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return UD(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            zs.isMounted(a) || zs.mount(a, this.props.spyThrottle), this.props.hashSpy && (qi.isMounted() || qi.mount(n), qi.mapContainer(this.props.to, a)), this.props.spy && zs.addStateHandler(this.stateHandler), zs.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          zs.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = Lv({}, this.props);
          for (var u in WD)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, Ap.createElement(e, l);
        }
      }]), s;
    }(Ap.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, Lv({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(qi.isMounted() && !qi.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (a.getBoundingClientRect) {
            var m = a.getBoundingClientRect();
            d = m.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + s, p = c + f.height;
          }
          var g = s - i.props.offset, h = g >= Math.floor(c) && g < Math.floor(p), x = g < Math.floor(c) || g >= Math.floor(p), w = n.getActiveLink();
          if (x)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && qi.getHash() === l && qi.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), zs.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && qi.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), zs.updateStates();
        }
      };
    };
    return r.propTypes = WD, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      HD(r, n);
      function r(o) {
        $D(this, r);
        var i = VD(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return UD(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Pv.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Pv.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Ap.createElement(e, Lv({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Ap.Component);
    return t.propTypes = {
      name: lr.string,
      id: lr.string
    }, t;
  }
}, Gie = qie;
Object.defineProperty(vr, "__esModule", {
  value: !0
});
vr.Helpers = vr.ScrollElement = vr.ScrollLink = vr.animateScroll = vr.scrollSpy = vr.Events = vr.scroller = vr.Element = vr.Button = vr.Link = void 0;
var Yie = PC, $2 = ai(Yie), Kie = jC, V2 = ai(Kie), Jie = _C, H2 = ai(Jie), Xie = ol, W2 = ai(Xie), Qie = hc, Z2 = ai(Qie), ese = pc, q2 = ai(ese), tse = kg, G2 = ai(tse), nse = cc, Y2 = ai(nse), rse = jg, K2 = ai(rse), ose = Gie, J2 = ai(ose);
function ai(e) {
  return e && e.__esModule ? e : { default: e };
}
vr.Link = $2.default;
vr.Button = V2.default;
vr.Element = H2.default;
vr.scroller = W2.default;
vr.Events = Z2.default;
vr.scrollSpy = q2.default;
vr.animateScroll = G2.default;
vr.ScrollLink = Y2.default;
vr.ScrollElement = K2.default;
vr.Helpers = J2.default;
vr.default = { Link: $2.default, Button: V2.default, Element: H2.default, scroller: W2.default, Events: Z2.default, scrollSpy: q2.default, animateScroll: G2.default, ScrollLink: Y2.default, ScrollElement: K2.default, Helpers: J2.default };
Ge({});
Ge({});
Ge({});
function Uu(e) {
  "@babel/helpers - typeof";
  return Uu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Uu(e);
}
function ise(e, t) {
  if (Uu(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Uu(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function sse(e) {
  var t = ise(e, "string");
  return Uu(t) == "symbol" ? t : t + "";
}
function me(e, t, n) {
  return (t = sse(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function X2(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var kv, ZD;
function ase() {
  if (ZD) return kv;
  ZD = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, s, a, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, s, a, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return kv = t, kv;
}
var lse = ase(), Lr = /* @__PURE__ */ X2(lse), vt = Ge(null);
function use() {
  Lr(!!xe, "useGoogleMap is React hook and requires React version 16.8+");
  var e = xe(vt);
  return Lr(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function cse(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function pse(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function dse(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return pse(e, i), o;
}
function fse(e, t, n) {
  var r = cse(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function hse(e) {
  google.maps.event.removeListener(e);
}
function Wt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(hse);
}
function Ut(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = fse(o, i, n);
  return dse(t, r, o, i), s;
}
function gse(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: m,
    onMouseOver: f,
    onMouseDown: g,
    onMouseUp: h,
    onRightClick: x,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: O
  } = e, [y, C] = P(null), S = Qe(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null), [A, Q] = P(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof s < "u" && y.setCenter(s);
  }, [y, s]), v(() => {
    y && l && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && g && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(y, "mousedown", g)));
  }, [g]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && m && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(y, "mouseout", m)));
  }, [m]), v(() => {
    y && f && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && h && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && x && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(y, "rightclick", x)));
  }, [x]), v(() => {
    y && a && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(y, "click", a)));
  }, [a]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [a]), v(() => {
    var N = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(N), N !== null && D && D(N), () => {
      N !== null && O && O(N);
    };
  }, []), to.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: to.jsx(vt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
Le(gse);
function qD(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Q2(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        qD(i, r, o, s, a, "next", l);
      }
      function a(l) {
        qD(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function ez(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Lr(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var sa = typeof document < "u";
function tz(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return sa ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, a.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function GD(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function nz() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return GD(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return GD(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var kl = !1;
function rz() {
  return to.jsx("div", {
    children: "Loading..."
  });
}
var Ub = {
  id: "script-loader",
  version: "weekly"
};
class mse extends be {
  constructor() {
    super(...arguments), me(this, "check", wr()), me(this, "state", {
      loaded: !1
    }), me(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), me(this, "isCleaningUp", /* @__PURE__ */ Q2(function* () {
      function t(n) {
        if (!kl)
          n();
        else if (sa)
          var r = window.setInterval(function() {
            kl || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), me(this, "cleanup", () => {
      kl = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), me(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && nz(), Lr(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: ez(this.props)
      };
      tz(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (sa) {
      if (window.google && window.google.maps && !kl) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), sa && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (sa) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, kl = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return to.jsxs(to.Fragment, {
      children: [to.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || to.jsx(rz, {})]
    });
  }
}
me(mse, "defaultProps", Ub);
function vse(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function BC(e, t) {
  if (e == null) return {};
  var n, r, o = vse(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var YD;
function yse(e) {
  var {
    id: t = Ub.id,
    version: n = Ub.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, m = Qe(!1), [f, g] = P(!1), [h, x] = P(void 0);
  v(function() {
    return m.current = !0, () => {
      m.current = !1;
    };
  }, []), v(function() {
    sa && u && nz();
  }, [u]), v(function() {
    f && Lr(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = ez({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!sa)
      return;
    function O() {
      m.current && (g(!0), YD = w);
    }
    if (window.google && window.google.maps && YD === w) {
      O();
      return;
    }
    tz({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(y) {
      m.current && x(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var D = Qe();
  return v(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var bse = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], wse = to.jsx(rz, {});
function Cse(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = BC(e, bse), {
    isLoaded: a,
    loadError: l
  } = yse(s);
  return v(function() {
    a && typeof n == "function" && n();
  }, [a, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || wse;
}
Le(Cse);
var KD;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(KD || (KD = {}));
function JD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Of(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JD(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var XD = {}, QD = {
  options(e, t) {
    e.setOptions(t);
  }
};
function Ose(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = xe(vt), [i, s] = P(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var a = new google.maps.TrafficLayer(Of(Of({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Le(Ose);
class xse extends be {
  constructor() {
    super(...arguments), me(this, "state", {
      trafficLayer: null
    }), me(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), me(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Of(Of({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: QD,
      eventMap: XD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: QD,
      eventMap: XD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Wt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
me(xse, "contextType", vt);
function Ese(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = xe(vt), [o, i] = P(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
Le(Ese);
class Lse extends be {
  constructor() {
    super(...arguments), me(this, "state", {
      bicyclingLayer: null
    }), me(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
me(Lse, "contextType", vt);
function Pse(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = xe(vt), [o, i] = P(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Le(Pse);
class kse extends be {
  constructor() {
    super(...arguments), me(this, "state", {
      transitLayer: null
    }), me(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
me(kse, "contextType", vt);
function eM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tM = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, nM = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Sse(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = xe(vt), [d, m] = P(null), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), g(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && s && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(d, "polygoncomplete", s)));
  }, [d, s]), v(() => {
    d && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", a)));
  }, [d, a]), v(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    Lr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var F = new google.maps.drawing.DrawingManager(xf(xf({}, t), {}, {
      map: p
    }));
    return n && F.setDrawingMode(n), r && g(google.maps.event.addListener(F, "circlecomplete", r)), o && x(google.maps.event.addListener(F, "markercomplete", o)), i && D(google.maps.event.addListener(F, "overlaycomplete", i)), s && y(google.maps.event.addListener(F, "polygoncomplete", s)), a && S(google.maps.event.addListener(F, "polylinecomplete", a)), l && L(google.maps.event.addListener(F, "rectanglecomplete", l)), m(F), u && u(F), () => {
      d !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
Le(Sse);
class Dse extends be {
  constructor(t) {
    super(t), me(this, "registeredEvents", []), me(this, "state", {
      drawingManager: null
    }), me(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Lr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(xf(xf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: nM,
      eventMap: tM,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: nM,
      eventMap: tM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Wt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
me(Dse, "contextType", vt);
function rM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ia(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oM = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, iM = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Ef = {};
function Mse(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: m,
    shape: f,
    title: g,
    zIndex: h,
    onClick: x,
    onDblClick: w,
    onDrag: D,
    onDragEnd: O,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: L,
    onRightClick: F,
    onClickableChanged: B,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: q,
    onIconChanged: X,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: k,
    onZindexChanged: j,
    onLoad: H,
    onUnmount: M
  } = e, Z = xe(vt), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null), [Q, N] = P(null), [ue, ye] = P(null), [oe, Ie] = P(null), [$e, Ve] = P(null), [Ne, Je] = P(null), [Ye, Te] = P(null), [Ke, nt] = P(null), [Me, Ae] = P(null), [Fe, He] = P(null), [ze, et] = P(null), [_e, At] = P(null), [rt, ot] = P(null), [at, qt] = P(null), [lt, Gt] = P(null), [Xe, bt] = P(null), [tt, Yt] = P(null), [ut, dn] = P(null), [Kt, fn] = P(null), [Jt, hn] = P(null);
  v(() => {
    E !== null && E.setMap(Z);
  }, [Z]), v(() => {
    typeof n < "u" && E !== null && E.setOptions(n);
  }, [E, n]), v(() => {
    typeof s < "u" && E !== null && E.setDraggable(s);
  }, [E, s]), v(() => {
    t && E !== null && E.setPosition(t);
  }, [E, t]), v(() => {
    typeof a < "u" && E !== null && E.setVisible(a);
  }, [E, a]), v(() => {
    E == null || E.setAnimation(l);
  }, [E, l]), v(() => {
    E && u !== void 0 && E.setClickable(u);
  }, [E, u]), v(() => {
    E && c !== void 0 && E.setCursor(c);
  }, [E, c]), v(() => {
    E && p !== void 0 && E.setIcon(p);
  }, [E, p]), v(() => {
    E && d !== void 0 && E.setLabel(d);
  }, [E, d]), v(() => {
    E && m !== void 0 && E.setOpacity(m);
  }, [E, m]), v(() => {
    E && f !== void 0 && E.setShape(f);
  }, [E, f]), v(() => {
    E && g !== void 0 && E.setTitle(g);
  }, [E, g]), v(() => {
    E && h !== void 0 && E.setZIndex(h);
  }, [E, h]), v(() => {
    E && w && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(E, "dblclick", w)));
  }, [w]), v(() => {
    E && O && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(E, "dragend", O)));
  }, [O]), v(() => {
    E && y && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(E, "dragstart", y)));
  }, [y]), v(() => {
    E && L && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(E, "mousedown", L)));
  }, [L]), v(() => {
    E && C && (oe !== null && google.maps.event.removeListener(oe), Ie(google.maps.event.addListener(E, "mouseout", C)));
  }, [C]), v(() => {
    E && S && ($e !== null && google.maps.event.removeListener($e), Ve(google.maps.event.addListener(E, "mouseover", S)));
  }, [S]), v(() => {
    E && U && (Ne !== null && google.maps.event.removeListener(Ne), Je(google.maps.event.addListener(E, "mouseup", U)));
  }, [U]), v(() => {
    E && F && (Ye !== null && google.maps.event.removeListener(Ye), Te(google.maps.event.addListener(E, "rightclick", F)));
  }, [F]), v(() => {
    E && x && (Ke !== null && google.maps.event.removeListener(Ke), nt(google.maps.event.addListener(E, "click", x)));
  }, [x]), v(() => {
    E && D && (Me !== null && google.maps.event.removeListener(Me), Ae(google.maps.event.addListener(E, "drag", D)));
  }, [D]), v(() => {
    E && B && (Fe !== null && google.maps.event.removeListener(Fe), He(google.maps.event.addListener(E, "clickable_changed", B)));
  }, [B]), v(() => {
    E && $ && (ze !== null && google.maps.event.removeListener(ze), et(google.maps.event.addListener(E, "cursor_changed", $)));
  }, [$]), v(() => {
    E && V && (_e !== null && google.maps.event.removeListener(_e), At(google.maps.event.addListener(E, "animation_changed", V)));
  }, [V]), v(() => {
    E && z && (rt !== null && google.maps.event.removeListener(rt), ot(google.maps.event.addListener(E, "draggable_changed", z)));
  }, [z]), v(() => {
    E && q && (at !== null && google.maps.event.removeListener(at), qt(google.maps.event.addListener(E, "flat_changed", q)));
  }, [q]), v(() => {
    E && X && (lt !== null && google.maps.event.removeListener(lt), Gt(google.maps.event.addListener(E, "icon_changed", X)));
  }, [X]), v(() => {
    E && J && (Xe !== null && google.maps.event.removeListener(Xe), bt(google.maps.event.addListener(E, "position_changed", J)));
  }, [J]), v(() => {
    E && te && (tt !== null && google.maps.event.removeListener(tt), Yt(google.maps.event.addListener(E, "shape_changed", te)));
  }, [te]), v(() => {
    E && ee && (ut !== null && google.maps.event.removeListener(ut), dn(google.maps.event.addListener(E, "title_changed", ee)));
  }, [ee]), v(() => {
    E && k && (Kt !== null && google.maps.event.removeListener(Kt), fn(google.maps.event.addListener(E, "visible_changed", k)));
  }, [k]), v(() => {
    E && j && (Jt !== null && google.maps.event.removeListener(Jt), hn(google.maps.event.addListener(E, "zindex_changed", j)));
  }, [j]), v(() => {
    var wt = Ia(Ia(Ia({}, n || Ef), r ? Ef : {
      map: Z
    }), {}, {
      position: t
    }), re = new google.maps.Marker(wt);
    return r ? r.addMarker(re, !!o) : re.setMap(Z), t && re.setPosition(t), typeof a < "u" && re.setVisible(a), typeof s < "u" && re.setDraggable(s), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof m < "u" && re.setOpacity(m), f && re.setShape(f), typeof g == "string" && re.setTitle(g), typeof h == "number" && re.setZIndex(h), w && _(google.maps.event.addListener(re, "dblclick", w)), O && A(google.maps.event.addListener(re, "dragend", O)), y && N(google.maps.event.addListener(re, "dragstart", y)), L && ye(google.maps.event.addListener(re, "mousedown", L)), C && Ie(google.maps.event.addListener(re, "mouseout", C)), S && Ve(google.maps.event.addListener(re, "mouseover", S)), U && Je(google.maps.event.addListener(re, "mouseup", U)), F && Te(google.maps.event.addListener(re, "rightclick", F)), x && nt(google.maps.event.addListener(re, "click", x)), D && Ae(google.maps.event.addListener(re, "drag", D)), B && He(google.maps.event.addListener(re, "clickable_changed", B)), $ && et(google.maps.event.addListener(re, "cursor_changed", $)), V && At(google.maps.event.addListener(re, "animation_changed", V)), z && ot(google.maps.event.addListener(re, "draggable_changed", z)), q && qt(google.maps.event.addListener(re, "flat_changed", q)), X && Gt(google.maps.event.addListener(re, "icon_changed", X)), J && bt(google.maps.event.addListener(re, "position_changed", J)), te && Yt(google.maps.event.addListener(re, "shape_changed", te)), ee && dn(google.maps.event.addListener(re, "title_changed", ee)), k && fn(google.maps.event.addListener(re, "visible_changed", k)), j && hn(google.maps.event.addListener(re, "zindex_changed", j)), T(re), H && H(re), () => {
      R !== null && google.maps.event.removeListener(R), W !== null && google.maps.event.removeListener(W), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), $e !== null && google.maps.event.removeListener($e), Ne !== null && google.maps.event.removeListener(Ne), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Fe !== null && google.maps.event.removeListener(Fe), ze !== null && google.maps.event.removeListener(ze), _e !== null && google.maps.event.removeListener(_e), rt !== null && google.maps.event.removeListener(rt), at !== null && google.maps.event.removeListener(at), lt !== null && google.maps.event.removeListener(lt), Xe !== null && google.maps.event.removeListener(Xe), ut !== null && google.maps.event.removeListener(ut), Kt !== null && google.maps.event.removeListener(Kt), Jt !== null && google.maps.event.removeListener(Jt), M && M(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Fn = Nn(() => i ? it.map(i, (wt) => {
    if (!ti(wt))
      return wt;
    var re = wt;
    return ni(re, {
      anchor: E
    });
  }) : null, [i, E]);
  return to.jsx(to.Fragment, {
    children: Fn
  }) || null;
}
Le(Mse);
class Tse extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Q2(function* () {
      var n = Ia(Ia(Ia({}, t.props.options || Ef), t.props.clusterer ? Ef : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Ut({
        updaterMap: iM,
        eventMap: oM,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: iM,
      eventMap: oM,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Wt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? it.map(this.props.children, (n) => {
      if (!ti(n))
        return n;
      var r = n;
      return ni(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
me(Tse, "contextType", vt);
var jse = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var m = document.createElement("div");
        m.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (m.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (m.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(m), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), _se = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new jse(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function Ase(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Bse = 2e3, Ise = 500, Nse = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Fse = "png", Rse = [53, 56, 66, 78, 90], zse = "cluster", oz = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Nse, this.imageExtension = r.imageExtension || Fse, this.imageSizes = r.imageSizes || Rse, this.calculator = r.calculator || Ase, this.batchSize = r.batchSize || Bse, this.batchSizeIE = r.batchSizeIE || Ise, this.clusterClass = r.clusterClass || zse, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new _se(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var m = d[p];
            m.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function sM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Use(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _o = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, tn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, $se = {};
function Vse(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: m,
    minimumClusterSize: f,
    styles: g,
    title: h,
    zoomOnClick: x,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: O,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [L, F] = P(null), B = xe(vt), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null);
  return v(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, _o.onMouseOut, C)));
  }, [C]), v(() => {
    L && y && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(L, _o.onMouseOver, y)));
  }, [y]), v(() => {
    L && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(L, _o.onClick, w)));
  }, [w]), v(() => {
    L && D && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(L, _o.onClusteringBegin, D)));
  }, [D]), v(() => {
    L && O && (X !== null && google.maps.event.removeListener(X), q(google.maps.event.addListener(L, _o.onClusteringEnd, O)));
  }, [O]), v(() => {
    typeof r < "u" && L !== null && tn.averageCenter(L, r);
  }, [L, r]), v(() => {
    typeof o < "u" && L !== null && tn.batchSizeIE(L, o);
  }, [L, o]), v(() => {
    typeof i < "u" && L !== null && tn.calculator(L, i);
  }, [L, i]), v(() => {
    typeof s < "u" && L !== null && tn.clusterClass(L, s);
  }, [L, s]), v(() => {
    typeof a < "u" && L !== null && tn.enableRetinaIcons(L, a);
  }, [L, a]), v(() => {
    typeof l < "u" && L !== null && tn.gridSize(L, l);
  }, [L, l]), v(() => {
    typeof u < "u" && L !== null && tn.ignoreHidden(L, u);
  }, [L, u]), v(() => {
    typeof c < "u" && L !== null && tn.imageExtension(L, c);
  }, [L, c]), v(() => {
    typeof p < "u" && L !== null && tn.imagePath(L, p);
  }, [L, p]), v(() => {
    typeof d < "u" && L !== null && tn.imageSizes(L, d);
  }, [L, d]), v(() => {
    typeof m < "u" && L !== null && tn.maxZoom(L, m);
  }, [L, m]), v(() => {
    typeof f < "u" && L !== null && tn.minimumClusterSize(L, f);
  }, [L, f]), v(() => {
    typeof g < "u" && L !== null && tn.styles(L, g);
  }, [L, g]), v(() => {
    typeof h < "u" && L !== null && tn.title(L, h);
  }, [L, h]), v(() => {
    typeof x < "u" && L !== null && tn.zoomOnClick(L, x);
  }, [L, x]), v(() => {
    if (B) {
      var H = Use({}, n || $se), M = new oz(B, [], H);
      return r && tn.averageCenter(M, r), o && tn.batchSizeIE(M, o), i && tn.calculator(M, i), s && tn.clusterClass(M, s), a && tn.enableRetinaIcons(M, a), l && tn.gridSize(M, l), u && tn.ignoreHidden(M, u), c && tn.imageExtension(M, c), p && tn.imagePath(M, p), d && tn.imageSizes(M, d), m && tn.maxZoom(M, m), f && tn.minimumClusterSize(M, f), g && tn.styles(M, g), h && tn.title(M, h), x && tn.zoomOnClick(M, x), C && ee(google.maps.event.addListener(M, _o.onMouseOut, C)), y && j(google.maps.event.addListener(M, _o.onMouseOver, y)), w && V(google.maps.event.addListener(M, _o.onClick, w)), D && q(google.maps.event.addListener(M, _o.onClusteringBegin, D)), O && J(google.maps.event.addListener(M, _o.onClusteringEnd, O)), F(M), S && S(M), () => {
        te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), U && U(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
Le(Vse);
class Hse extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      markerClusterer: null
    }), me(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new oz(this.context, [], this.props.options);
      this.registeredEvents = Ut({
        updaterMap: tn,
        eventMap: _o,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: tn,
      eventMap: _o,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Wt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
me(Hse, "contextType", vt);
function aM(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var iz = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || aM(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, aM));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, m = this.infoBoxClearance.width, f = this.infoBoxClearance.height, g = this.getProjection(), h = g.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + m ? r = h.x + u - m : h.x + p + u + m > a && (r = h.x + p + u + m - a), this.alignBottom ? h.y < -c + f + d ? o = h.y + c - f - d : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + d + c + f > l && (o = h.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Wse = ["position"], Zse = ["position"];
function lM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var uM = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, cM = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, qse = {};
function Gse(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = xe(vt), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), F = Qe(null);
  return v(() => {
    m && f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (m) {
      var B = r || qse, {
        position: $
      } = B, V = BC(B, Wse), z;
      $ && !($ instanceof google.maps.LatLng) && (z = new google.maps.LatLng($.lat, $.lng));
      var q = new iz(Lf(Lf({}, V), z ? {
        position: z
      } : {}));
      F.current = document.createElement("div"), g(q), s && x(google.maps.event.addListener(q, "closeclick", s)), a && D(google.maps.event.addListener(q, "domready", a)), l && y(google.maps.event.addListener(q, "content_changed", l)), u && S(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(F.current), n ? q.open(m, n) : q.getPosition() ? q.open(m) : Lr(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), F.current ? Cr(it.only(t), F.current) : null;
}
Le(Gse);
class Yse extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "containerElement", null), me(this, "state", {
      infoBox: null
    }), me(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Lr(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), me(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = BC(t, Zse), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new iz(Lf(Lf({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Ut({
      updaterMap: cM,
      eventMap: uM,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: cM,
      eventMap: uM,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Wt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Cr(it.only(this.props.children), this.containerElement) : null;
  }
}
me(Yse, "contextType", vt);
var pM, dM;
function Kse() {
  return dM || (dM = 1, pM = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), pM;
}
var Jse = Kse(), fM = /* @__PURE__ */ X2(Jse), hM = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Sv = 1, Sl = 8;
class IC {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Sv)
      throw new Error("Got v".concat(o, " data when expected v").concat(Sv, "."));
    var i = hM[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new IC(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = hM.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Sl, t), this.coords = new this.ArrayType(this.data, Sl + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Sl + s + a + l), this.ids = new this.IndexArrayType(this.data, Sl, t), this.coords = new this.ArrayType(this.data, Sl + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Sv << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return $b(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (var m = d; m <= p; m++) {
          var f = s[2 * m], g = s[2 * m + 1];
          f >= t && f <= r && g >= n && g <= o && u.push(i[m]);
        }
        continue;
      }
      var h = d + p >> 1, x = s[2 * h], w = s[2 * h + 1];
      x >= t && x <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= x : n <= w) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= x : o >= w) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (var m = d; m <= p; m++)
          gM(i[2 * m], i[2 * m + 1], t, n) <= u && l.push(o[m]);
        continue;
      }
      var f = d + p >> 1, g = i[2 * f], h = i[2 * f + 1];
      gM(g, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= g : n - r <= h) && (a.push(d), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= h) && (a.push(f + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function $b(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    sz(e, t, s, r, o, i), $b(e, t, n, r, s - 1, 1 - i), $b(e, t, n, s + 1, o, 1 - i);
  }
}
function sz(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - a * u / s + c)), d = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      sz(e, t, n, p, d, i);
    }
    var m = t[2 * n + i], f = r, g = o;
    for (Dl(e, t, r, n), t[2 * o + i] > m && Dl(e, t, r, o); f < g; ) {
      for (Dl(e, t, f, g), f++, g--; t[2 * f + i] < m; ) f++;
      for (; t[2 * g + i] > m; ) g--;
    }
    t[2 * r + i] === m ? Dl(e, t, r, g) : (g++, Dl(e, t, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1);
  }
}
function Dl(e, t, n, r) {
  Dv(e, n, r), Dv(t, 2 * n, 2 * r), Dv(t, 2 * n + 1, 2 * r + 1);
}
function Dv(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function gM(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Xse = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, mM = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Us = 2, ss = 3, Mv = 4, ts = 5, az = 6;
class Qse {
  constructor(t) {
    this.options = Object.assign(Object.create(Xse), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = mM(Bp(u)), d = mM(Ip(c));
        s.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var m = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var g = +Date.now();
      m = this.trees[f] = this._createTree(this._cluster(m, f)), n && console.log("z%d: %d clusters in %dms", f, m.numItems, +Date.now() - g);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Bp(r), Ip(s), Bp(i), Ip(o)), p = u.data, d = [];
    for (var m of c) {
      var f = this.stride * m;
      d.push(p[f + ts] > 1 ? vM(p, f, this.clusterProps) : this.points[p[f + ss]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (var d of c) {
      var m = d * this.stride;
      s[m + Mv] === t && p.push(s[m + ts] > 1 ? vM(s, m, this.clusterProps) : this.points[s[m + ss]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new IC(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + ts] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = lz(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var m = this.points[n[l + ss]];
        c = m.properties;
        var [f, g] = m.geometry.coordinates;
        p = Bp(f), d = Ip(g);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, x = void 0;
      u || this.options.generateId ? x = n[l + ss] : x = this.points[n[l + ss]].id, x !== void 0 && (h.id = x), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Us] <= n)) {
        l[p + Us] = n;
        var d = l[p], m = l[p + 1], f = t.within(l[p], l[p + 1], a), g = l[p + ts], h = g;
        for (var x of f) {
          var w = x * c;
          l[w + Us] > n && (h += l[w + ts]);
        }
        if (h > g && h >= s) {
          var D = d * g, O = m * g, y = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var L = U * c;
            if (!(l[L + Us] <= n)) {
              l[L + Us] = n;
              var F = l[L + ts];
              D += l[L] * F, O += l[L + 1] * F, l[L + Mv] = S, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + Mv] = S, u.push(D / h, O / h, 1 / 0, S, -1, h), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (h > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Us] <= n)) {
                l[V + Us] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ts] > 1) {
      var o = this.clusterProps[t[n + az]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + ss]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function vM(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ss],
    properties: lz(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [eae(e[t]), tae(e[t + 1])]
    }
  };
}
function lz(e, t, n) {
  var r = e[t + ts], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + az], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + ss],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Bp(e) {
  return e / 360 + 0.5;
}
function Ip(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function eae(e) {
  return (e - 0.5) * 360;
}
function tae(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function nae(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class vo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Vb {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(vo.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => vo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (vo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class rae {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return oae(n);
  }
}
var oae = (e) => {
  var t = e.map((n) => new Vb({
    position: vo.getPosition(n),
    markers: [n]
  }));
  return t;
};
class iae extends rae {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = nae(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Qse(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!fM(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = vo.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !fM(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Vb({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Vb({
      markers: [i],
      position: vo.getPosition(i)
    });
  }
}
class sae {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class aae {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (vo.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(a, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var m = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(m);
  }
}
function lae(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class NC {
  constructor() {
    lae(NC, google.maps.OverlayView);
  }
}
var uu;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(uu || (uu = {}));
var uae = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class cae extends NC {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new iae(o),
      renderer: s = new aae(),
      onClusterClick: a = uae
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (vo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, uu.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || vo.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => vo.setMap(l, null)));
      }
      google.maps.event.trigger(this, uu.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => vo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new sae(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => vo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, uu.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), vo.setMap(r.marker, n);
    });
  }
}
function yM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function pae(e) {
  var t = use(), [n, r] = P(null);
  return v(() => {
    if (t && n === null) {
      var o = new cae(bM(bM({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function dae(e) {
  var {
    children: t,
    options: n
  } = e, r = pae(n);
  return r !== null ? t(r) : null;
}
Le(dae);
var wM = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, CM = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function fae(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = xe(vt), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), F = Qe(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var B = new google.maps.InfoWindow(r);
    return g(B), F.current = document.createElement("div"), s && x(google.maps.event.addListener(B, "closeclick", s)), a && D(google.maps.event.addListener(B, "domready", a)), l && y(google.maps.event.addListener(B, "content_changed", l)), u && S(google.maps.event.addListener(B, "position_changed", u)), c && L(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(F.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(m, n) : B.getPosition() ? B.open(m) : Lr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      h && google.maps.event.removeListener(h), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(B), B.close();
    };
  }, []), F.current ? Cr(it.only(t), F.current) : null;
}
Le(fae);
class hae extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "containerElement", null), me(this, "state", {
      infoWindow: null
    }), me(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Lr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), me(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Ut({
      updaterMap: CM,
      eventMap: wM,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: CM,
      eventMap: wM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Wt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Cr(it.only(this.props.children), this.containerElement) : null;
  }
}
me(hae, "contextType", vt);
function OM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xM = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, EM = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, gae = {};
function mae(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onLoad: x,
    onUnmount: w
  } = e, D = xe(vt), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null);
  return v(() => {
    O !== null && O.setMap(D);
  }, [D]), v(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), v(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), v(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), v(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), v(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), v(() => {
    O && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(O, "dblclick", s)));
  }, [s]), v(() => {
    O && a && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(O, "dragend", a)));
  }, [a]), v(() => {
    O && l && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), v(() => {
    O && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), v(() => {
    O && c && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), v(() => {
    O && p && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), v(() => {
    O && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), v(() => {
    O && m && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(O, "mouseup", m)));
  }, [m]), v(() => {
    O && f && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), v(() => {
    O && g && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(O, "click", g)));
  }, [g]), v(() => {
    O && h && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(O, "drag", h)));
  }, [h]), v(() => {
    var _ = new google.maps.Polyline(Pf(Pf({}, t || gae), {}, {
      map: D
    }));
    return i && _.setPath(i), typeof o < "u" && _.setVisible(o), typeof r < "u" && _.setEditable(r), typeof n < "u" && _.setDraggable(n), s && S(google.maps.event.addListener(_, "dblclick", s)), a && L(google.maps.event.addListener(_, "dragend", a)), l && B(google.maps.event.addListener(_, "dragstart", l)), u && V(google.maps.event.addListener(_, "mousedown", u)), c && q(google.maps.event.addListener(_, "mousemove", c)), p && J(google.maps.event.addListener(_, "mouseout", p)), d && ee(google.maps.event.addListener(_, "mouseover", d)), m && j(google.maps.event.addListener(_, "mouseup", m)), f && M(google.maps.event.addListener(_, "rightclick", f)), g && E(google.maps.event.addListener(_, "click", g)), h && R(google.maps.event.addListener(_, "drag", h)), y(_), x && x(_), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), w && w(_), _.setMap(null);
    };
  }, []), null;
}
Le(mae);
class vae extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      polyline: null
    }), me(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Pf(Pf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: EM,
      eventMap: xM,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: EM,
      eventMap: xM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Wt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
me(vae, "contextType", vt);
function LM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function PM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kM = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, SM = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function yae(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: x,
    onLoad: w,
    onUnmount: D,
    onEdit: O
  } = e, y = xe(vt), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof s < "u" && C !== null && C.setPaths(s);
  }, [C, s]), v(() => {
    C && typeof a == "function" && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(C, "dblclick", a)));
  }, [a]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      O == null || O(C);
    }));
  }, [C, O]), v(() => {
    C && typeof l == "function" && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof m == "function" && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(C, "mouseover", m)));
  }, [m]), v(() => {
    C && typeof f == "function" && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof g == "function" && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(C, "rightclick", g)));
  }, [g]), v(() => {
    C && typeof h == "function" && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(C, "click", h)));
  }, [h]), v(() => {
    C && typeof x == "function" && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(C, "drag", x)));
  }, [x]), v(() => {
    var A = new google.maps.Polygon(PM(PM({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), s && A.setPaths(s), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), a && L(google.maps.event.addListener(A, "dblclick", a)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), m && j(google.maps.event.addListener(A, "mouseover", m)), f && M(google.maps.event.addListener(A, "mouseup", f)), g && E(google.maps.event.addListener(A, "rightclick", g)), h && R(google.maps.event.addListener(A, "click", h)), x && W(google.maps.event.addListener(A, "drag", x)), S(A), w && w(A), () => {
      U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), T !== null && google.maps.event.removeListener(T), D && D(A), A.setMap(null);
    };
  }, []), null;
}
Le(yae);
class bae extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Ut({
      updaterMap: SM,
      eventMap: kM,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: SM,
      eventMap: kM,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Wt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
me(bae, "contextType", vt);
function DM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var MM = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, TM = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function wae(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onBoundsChanged: x,
    onLoad: w,
    onUnmount: D
  } = e, O = xe(vt), [y, C] = P(null), [S, U] = P(null), [L, F] = P(null), [B, $] = P(null), [V, z] = P(null), [q, X] = P(null), [J, te] = P(null), [ee, k] = P(null), [j, H] = P(null), [M, Z] = P(null), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null);
  return v(() => {
    y !== null && y.setMap(O);
  }, [O]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && s && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(y, "dblclick", s)));
  }, [s]), v(() => {
    y && a && (L !== null && google.maps.event.removeListener(L), F(google.maps.event.addListener(y, "dragend", a)));
  }, [a]), v(() => {
    y && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (q !== null && google.maps.event.removeListener(q), X(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && m && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(y, "mouseup", m)));
  }, [m]), v(() => {
    y && f && (M !== null && google.maps.event.removeListener(M), Z(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && g && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(y, "click", g)));
  }, [g]), v(() => {
    y && h && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(y, "drag", h)));
  }, [h]), v(() => {
    y && x && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(y, "bounds_changed", x)));
  }, [x]), v(() => {
    var Q = new google.maps.Rectangle(kf(kf({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), s && U(google.maps.event.addListener(Q, "dblclick", s)), a && F(google.maps.event.addListener(Q, "dragend", a)), l && $(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && X(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && k(google.maps.event.addListener(Q, "mouseover", d)), m && H(google.maps.event.addListener(Q, "mouseup", m)), f && Z(google.maps.event.addListener(Q, "rightclick", f)), g && T(google.maps.event.addListener(Q, "click", g)), h && _(google.maps.event.addListener(Q, "drag", h)), x && A(google.maps.event.addListener(Q, "bounds_changed", x)), C(Q), w && w(Q), () => {
      S !== null && google.maps.event.removeListener(S), L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), M !== null && google.maps.event.removeListener(M), E !== null && google.maps.event.removeListener(E), R !== null && google.maps.event.removeListener(R), W !== null && google.maps.event.removeListener(W), D && D(Q), Q.setMap(null);
    };
  }, []), null;
}
Le(wae);
class Cae extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      rectangle: null
    }), me(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(kf(kf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: TM,
      eventMap: MM,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: TM,
      eventMap: MM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Wt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
me(Cae, "contextType", vt);
function jM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _M = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, AM = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Oae = {};
function xae(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: x,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: O,
    onUnmount: y
  } = e, C = xe(vt), [S, U] = P(null), [L, F] = P(null), [B, $] = P(null), [V, z] = P(null), [q, X] = P(null), [J, te] = P(null), [ee, k] = P(null), [j, H] = P(null), [M, Z] = P(null), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null), [Q, N] = P(null), [ue, ye] = P(null);
  return v(() => {
    S !== null && S.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), v(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), v(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), v(() => {
    typeof s < "u" && S !== null && S.setVisible(s);
  }, [S, s]), v(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), v(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), v(() => {
    S && a && (L !== null && google.maps.event.removeListener(L), F(google.maps.event.addListener(S, "dblclick", a)));
  }, [a]), v(() => {
    S && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), v(() => {
    S && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), v(() => {
    S && c && (q !== null && google.maps.event.removeListener(q), X(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), v(() => {
    S && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), v(() => {
    S && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), v(() => {
    S && m && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(S, "mouseover", m)));
  }, [m]), v(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), Z(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), v(() => {
    S && g && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(S, "rightclick", g)));
  }, [g]), v(() => {
    S && h && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(S, "click", h)));
  }, [h]), v(() => {
    S && x && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(S, "drag", x)));
  }, [x]), v(() => {
    S && w && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(S, "center_changed", w)));
  }, [h]), v(() => {
    S && D && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), v(() => {
    var oe = new google.maps.Circle(Sf(Sf({}, t || Oae), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof s < "u" && oe.setVisible(s), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), a && F(google.maps.event.addListener(oe, "dblclick", a)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), m && H(google.maps.event.addListener(oe, "mouseover", m)), f && Z(google.maps.event.addListener(oe, "mouseup", f)), g && T(google.maps.event.addListener(oe, "rightclick", g)), h && _(google.maps.event.addListener(oe, "click", h)), x && A(google.maps.event.addListener(oe, "drag", x)), w && N(google.maps.event.addListener(oe, "center_changed", w)), D && ye(google.maps.event.addListener(oe, "radius_changed", D)), U(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), M !== null && google.maps.event.removeListener(M), E !== null && google.maps.event.removeListener(E), R !== null && google.maps.event.removeListener(R), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
Le(xae);
class Eae extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      circle: null
    }), me(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Sf(Sf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: AM,
      eventMap: _M,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: AM,
      eventMap: _M,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Wt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
me(Eae, "contextType", vt);
function BM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Df(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var IM = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, NM = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Lae(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: m,
    onSetProperty: f,
    onLoad: g,
    onUnmount: h
  } = e, x = xe(vt), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null);
  return v(() => {
    w !== null && w.setMap(x);
  }, [x]), v(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && s && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), v(() => {
    w && a && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && m && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(w, "setgeometry", m)));
  }, [m]), v(() => {
    w && f && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (x !== null) {
      var A = new google.maps.Data(Df(Df({}, t), {}, {
        map: x
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), s && B(google.maps.event.addListener(A, "mouseout", s)), a && V(google.maps.event.addListener(A, "mouseover", a)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && j(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && E(google.maps.event.addListener(A, "removeproperty", d)), m && R(google.maps.event.addListener(A, "setgeometry", m)), f && W(google.maps.event.addListener(A, "setproperty", f)), D(A), g && g(A);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), T !== null && google.maps.event.removeListener(T), _ !== null && google.maps.event.removeListener(_), h && h(w), w.setMap(null));
    };
  }, []), null;
}
Le(Lae);
class Pae extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      data: null
    }), me(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Df(Df({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Ut({
        updaterMap: NM,
        eventMap: IM,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: NM,
      eventMap: IM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Wt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
me(Pae, "contextType", vt);
function FM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function RM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zM = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, UM = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class kae extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      kmlLayer: null
    }), me(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(RM(RM({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: UM,
      eventMap: zM,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: UM,
      eventMap: zM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Wt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
me(kae, "contextType", vt);
function uz(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Sae(e, t) {
  return new t(e.lat, e.lng);
}
function Dae(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Mae(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Tae(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function jae(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function _ae(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function cz(e, t, n, r) {
  return n !== void 0 ? jae(e, t, Tae(n, google.maps.LatLngBounds, Dae)) : _ae(e, t, Mae(r, google.maps.LatLng, Sae));
}
function Aae(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function $M(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Bae(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $M(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $M(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Iae(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = Bae({}, this.container ? uz(this.container, o) : {
        x: 0,
        y: 0
      }), u = cz(a, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function VM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nae(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function HM(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function WM(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Fae(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = xe(vt), c = Nn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Nn(() => Iae(c, r, t, n, a), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    s == null || s(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), oi.createPortal(l, c);
}
Le(Fae);
class il extends be {
  constructor(t) {
    super(t), me(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), me(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Lr(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), me(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), me(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Nae({
        x: 0,
        y: 0
      }, this.containerRef.current ? uz(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = cz(r, o, this.props.bounds, this.props.position);
      if (!Aae(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), me(this, "draw", () => {
      this.onPositionElement();
    }), me(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = wr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = HM(t.position), r = HM(this.props.position), o = WM(t.bounds), i = WM(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? oi.createPortal(to.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: it.only(this.props.children)
    }), t) : null;
  }
}
me(il, "FLOAT_PANE", "floatPane");
me(il, "MAP_PANE", "mapPane");
me(il, "MARKER_LAYER", "markerLayer");
me(il, "OVERLAY_LAYER", "overlayLayer");
me(il, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
me(il, "contextType", vt);
function Rae() {
}
function ZM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var GM = {
  onDblClick: "dblclick",
  onClick: "click"
}, YM = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function zae(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = xe(vt), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Nn(() => new google.maps.GroundOverlay(t, s, r), []);
  return v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), v(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Le(zae);
class pz extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      groundOverlay: null
    }), me(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Lr(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, qM(qM({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: YM,
      eventMap: GM,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: YM,
      eventMap: GM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
me(pz, "defaultProps", {
  onLoad: Rae
});
me(pz, "contextType", vt);
function KM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var JM = {}, XM = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Uae(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = xe(vt), [s, a] = P(null);
  return v(() => {
    google.maps.visualization || Lr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    Lr(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(Mf(Mf({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Le(Uae);
class $ae extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      heatmapLayer: null
    }), me(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Lr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Lr(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Mf(Mf({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: XM,
      eventMap: JM,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: XM,
      eventMap: JM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Wt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
me($ae, "contextType", vt);
var QM = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, eT = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Vae extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      streetViewPanorama: null
    }), me(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Ut({
      updaterMap: eT,
      eventMap: QM,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: eT,
      eventMap: QM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Wt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
me(Vae, "contextType", vt);
class Hae extends be {
  constructor() {
    super(...arguments), me(this, "state", {
      streetViewService: null
    }), me(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
me(Hae, "contextType", vt);
var tT = {
  onDirectionsChanged: "directions_changed"
}, nT = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Wae extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      directionsRenderer: null
    }), me(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Ut({
      updaterMap: nT,
      eventMap: tT,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: nT,
      eventMap: tT,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Wt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
me(Wae, "contextType", vt);
var rT = {
  onPlacesChanged: "places_changed"
}, oT = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Zae extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "containerElement", wr()), me(this, "state", {
      searchBox: null
    }), me(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Lr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Ut({
          updaterMap: oT,
          eventMap: rT,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: oT,
      eventMap: rT,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Wt(this.registeredEvents));
  }
  render() {
    return to.jsx("div", {
      ref: this.containerElement,
      children: it.only(this.props.children)
    });
  }
}
me(Zae, "contextType", vt);
var iT = {
  onPlaceChanged: "place_changed"
}, sT = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class dz extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "containerElement", wr()), me(this, "state", {
      autocomplete: null
    }), me(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Lr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Ut({
        updaterMap: sT,
        eventMap: iT,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Wt(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: sT,
      eventMap: iT,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Wt(this.registeredEvents);
  }
  render() {
    return to.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: it.only(this.props.children)
    });
  }
}
me(dz, "defaultProps", {
  className: ""
});
me(dz, "contextType", vt);
let qae = { data: "" }, Gae = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || qae, Yae = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Kae = /\/\*[^]*?\*\/|  +/g, aT = /\n+/g, fs = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? fs(s, i) : i + "{" + fs(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += fs(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += fs.p ? fs.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, xi = {}, fz = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + fz(e[n]);
    return t;
  }
  return e;
}, Jae = (e, t, n, r, o) => {
  let i = fz(e), s = xi[i] || (xi[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!xi[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Yae.exec(u.replace(Kae, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(aT, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(aT, " ").trim();
      return d[0];
    })(e);
    xi[s] = fs(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && xi.g ? xi.g : null;
  return n && (xi.g = xi[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(xi[s], t, r, a), s;
}, Xae = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : fs(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function Ag(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Jae(n.unshift ? n.raw ? Xae(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Gae(t.target), t.g, t.o, t.k);
}
let hz, Hb, Wb;
Ag.bind({ g: 1 });
let Ai = Ag.bind({ k: 1 });
function Qae(e, t, n, r) {
  fs.p = t, hz = e, Hb = n, Wb = r;
}
function js(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: Hb && Hb() }, a), n.o = / *go\d+/.test(l), a.className = Ag.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), Wb && u[0] && Wb(a), hz(u, a);
    }
    return o;
  };
}
var ele = (e) => typeof e == "function", tle = (e, t) => ele(e) ? e(t) : e, nle = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), rle = Ai`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, ole = Ai`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, ile = Ai`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, sle = js("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${rle} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${ole} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${ile} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, ale = Ai`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, lle = js("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${ale} 1s linear infinite;
`, ule = Ai`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, cle = Ai`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, ple = js("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${ule} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${cle} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, dle = js("div")`
  position: absolute;
`, fle = js("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, hle = Ai`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, gle = js("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${hle} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, mle = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ue.createElement(gle, null, t) : t : n === "blank" ? null : Ue.createElement(fle, null, Ue.createElement(lle, { ...r }), n !== "loading" && Ue.createElement(dle, null, n === "error" ? Ue.createElement(sle, { ...r }) : Ue.createElement(ple, { ...r })));
}, vle = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, yle = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, ble = "0%{opacity:0;} 100%{opacity:1;}", wle = "0%{opacity:1;} 100%{opacity:0;}", Cle = js("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Ole = js("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, xle = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = nle() ? [ble, wle] : [vle(n), yle(n)];
  return { animation: t ? `${Ai(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ai(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ue.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? xle(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ue.createElement(mle, { toast: e }), s = Ue.createElement(Ole, { ...e.ariaProps }, tle(e.message, e));
  return Ue.createElement(Cle, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ue.createElement(Ue.Fragment, null, i, s));
});
Qae(Ue.createElement);
Ag`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function gz(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: s,
    rightIcon: a,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, d = { xs: 12, sm: 16, md: 20, lg: 24 }[i], m = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ bn.jsxs("button", { className: m, disabled: l || t, ...p, children: [
    /* @__PURE__ */ bn.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ bn.jsx(ri, { size: d, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ bn.jsxs("div", { className: "arkynButtonContent", children: [
      SO(d, s),
      c,
      SO(d, a)
    ] })
  ] });
}
function Ele() {
  const e = C0(), t = nI(), n = rI(), [r, o] = P(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function s() {
    r && o(null);
  }
  v(() => {
    var u, c;
    let p = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, p) || Object.entries(p).length !== 0 && o(p);
  }, [n, e]), v(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && s();
  }, [n, t]);
  const a = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(a || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
Ge({});
function Lle(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: s,
    className: a = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${a}`;
  return /* @__PURE__ */ bn.jsxs(
    "button",
    {
      disabled: s || t,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ bn.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ bn.jsx(ri, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ bn.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ bn.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function Ple(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...s
  } = e, a = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ bn.jsxs("div", { className: a.trim(), ...s, children: [
    r,
    /* @__PURE__ */ bn.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function kle(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Sle = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
kle(Sle.CNPJ).length;
Da((e, t) => /* @__PURE__ */ bn.jsx("input", { ref: t, ...e }));
Ge({});
var zi = {};
Object.defineProperty(zi, "__esModule", {
  value: !0
});
var Dle = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Tv = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, mz = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: Dle ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, FC = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Np = 1; Np < 20; Np++)
  FC["f" + Np] = 111 + Np;
function Bg(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return vz(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return yz(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function Mle(e, t) {
  return Bg(e, t);
}
function Tle(e, t) {
  return Bg(e, { byKey: !0 }, t);
}
function vz(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in Tv)
    r[Tv[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, m = d.endsWith("?") && d.length > 1;
      m && (d = d.slice(0, -1));
      var f = RC(d), g = Tv[f];
      if (d.length > 1 && !g && !mz[d] && !FC[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !g) && (n ? r.key = f : r.which = bz(d)), g && (r[g] = m ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function yz(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function bz(e) {
  e = RC(e);
  var t = FC[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function RC(e) {
  return e = e.toLowerCase(), e = mz[e] || e, e;
}
zi.default = Bg;
var jv = zi.isHotkey = Bg;
zi.isCodeHotkey = Mle;
zi.isKeyHotkey = Tle;
zi.parseHotkey = vz;
zi.compareHotkey = yz;
zi.toKeyCode = bz;
zi.toKeyName = RC;
var jle = typeof Ln == "object" && Ln && Ln.Object === Object && Ln, _le = jle, Ale = _le, Ble = typeof self == "object" && self && self.Object === Object && self, Ile = Ale || Ble || Function("return this")(), Nle = Ile, Fle = Nle, Rle = Fle.Symbol, wz = Rle, lT = wz;
lT && lT.toStringTag;
var uT = wz;
uT && uT.toStringTag;
var cT;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(cT || (cT = {}));
var zC = function(e) {
  return Object.freeze(e);
}, zle = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, zC(this);
  }
  return e;
}(), Ule = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, zC(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), pT = typeof window < "u" ? window : {};
/msie|trident/i.test(pT.navigator && pT.navigator.userAgent);
var _v = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new zle((n ? t : e) || 0, (n ? e : t) || 0);
};
zC({
  devicePixelContentBoxSize: _v(),
  borderBoxSize: _v(),
  contentBoxSize: _v(),
  contentRect: new Ule(0, 0, 0, 0)
});
function $u(e) {
  "@babel/helpers - typeof";
  return $u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, $u(e);
}
function $le(e, t) {
  if ($u(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if ($u(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Vle(e) {
  var t = $le(e, "string");
  return $u(t) === "symbol" ? t : String(t);
}
function cu(e, t, n) {
  return t = Vle(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Hle = /* @__PURE__ */ Ge(null), Av, Bv;
parseInt(Ee.version.split(".")[0], 10);
var dT = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Iv = typeof navigator < "u" && /Android/.test(navigator.userAgent), Fp = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Wle = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Av = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Av !== void 0 && Av[1] && parseInt((Bv = navigator.userAgent.match(/Version\/(\d+)/)) === null || Bv === void 0 ? void 0 : Bv[1], 10) < 17;
var Zle = /* @__PURE__ */ new WeakMap(), qle = /* @__PURE__ */ new WeakMap(), Gle = /* @__PURE__ */ new WeakMap(), Yle = /* @__PURE__ */ new WeakMap(), Kle = /* @__PURE__ */ new WeakMap(), fT = /* @__PURE__ */ new WeakMap(), Jle = /* @__PURE__ */ new WeakMap(), hT = /* @__PURE__ */ new WeakMap(), Rp = /* @__PURE__ */ new WeakMap(), Xle = /* @__PURE__ */ new WeakMap(), Qle = /* @__PURE__ */ new WeakMap(), eue = /* @__PURE__ */ new WeakMap(), Cz = globalThis.Node, tue = globalThis.Text, Oz = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, nue = (e) => Tf(e) && e.nodeType === 8, ei = (e) => Tf(e) && e.nodeType === 1, Tf = (e) => {
  var t = Oz(e);
  return !!t && e instanceof t.Node;
}, gT = (e) => {
  var t = e && e.anchorNode && Oz(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, rue = (e) => {
  var [t, n] = e;
  if (ei(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = xz(t, o, r ? "backward" : "forward"), r = o < n; ei(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = iue(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, oue = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, xz = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (nue(o) || ei(o) && o.childNodes.length === 0 || ei(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, iue = (e, t, n) => {
  var [r] = xz(e, t, n);
  return r;
}, mT = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Ez = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ei(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Ft.getWindow(e);
  if (o.contains(r))
    return Ft.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Ez(e, i, n);
}, vT = (e, t) => !!(e.compareDocumentPosition(t) & Cz.DOCUMENT_POSITION_PRECEDING), sue = (e, t) => !!(e.compareDocumentPosition(t) & Cz.DOCUMENT_POSITION_FOLLOWING), aue = 0;
class lue {
  constructor() {
    cu(this, "id", void 0), this.id = "".concat(aue++);
  }
}
var Ft = {
  androidPendingDiffs: (e) => eue.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = Qle.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Ft.toDOMNode(e, e), n = Ft.findDocumentOrShadowRoot(e);
    Rp.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Ft.findDocumentOrShadowRoot(e), r = mT(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Ad.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Ft.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Ft.toSlateNode(e, t.target), s = Ft.findPath(e, i);
    if (Pi.isElement(i) && wn.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = wn.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? wn.before(e, u) : wn.after(e, u);
      if (c) {
        var p = wn.range(e, c);
        return p;
      }
    }
    var d, {
      document: m
    } = Ft.getWindow(e);
    if (m.caretRangeFromPoint)
      d = m.caretRangeFromPoint(n, r);
    else {
      var f = m.caretPositionFromPoint(n, r);
      f && (d = m.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var g = Ft.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return g;
  },
  findKey: (e, t) => {
    var n = fT.get(t);
    return n || (n = new lue(), fT.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = qle.get(r);
      if (o == null) {
        if (wn.isEditor(r))
          return n;
        break;
      }
      var i = Zle.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(co.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Rp.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Ft.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Ft.toDOMNode(e, e), r = Ft.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = mT(r), i = Ft.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Ad.select(e, wn.start(e, [])), Rp.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Gle.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Ft.toDOMNode(e, e), i;
    try {
      i = ei(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Tf(t) && Ft.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return wn.hasPath(e, n.path) && wn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Ft.hasEditableTarget(e, t) || Ft.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Tf(t) && Ft.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Xle.get(e),
  isFocused: (e) => !!Rp.get(e),
  isReadOnly: (e) => !!hT.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (hT.get(e)) return !1;
    var n = Ft.hasTarget(e, t) && Ft.toSlateNode(e, t);
    return Pi.isElement(n) && wn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Jle.get(e), r = wn.isEditor(t) ? Yle.get(e) : n == null ? void 0 : n.get(Ft.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(co.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = wn.node(e, t.path), r = Ft.toDOMNode(e, n), o;
    wn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), m = d == null ? p : parseInt(d, 10), f = a + m, g = s[l + 1];
        if (t.offset === f && g !== null && g !== void 0 && g.hasAttribute("data-slate-mark-placeholder")) {
          var h, x = g.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            x instanceof tue ? x : g,
            (h = g.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(co.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = xt.isBackward(t), i = Ft.toDOMPoint(e, n), s = xt.isCollapsed(t) ? i : Ft.toDOMPoint(e, r), a = Ft.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, m = ei(u) ? u : u.parentElement, f = !!m.getAttribute("data-slate-zero-width"), g = ei(p) ? p : p.parentElement, h = !!g.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = ei(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Kle.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : rue(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, m = Ft.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), g = f && m.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), x = h && m.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = Ft.getWindow(e), y = O.document.createRange();
          y.setStart(u, 0), y.setEnd(s, a);
          var C = y.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (Iv && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (g) {
        for (var U = g.querySelectorAll("[data-slate-leaf]"), L = 0; L < U.length; L++) {
          var F = U[L];
          if (Ft.hasDOMNode(e, F)) {
            w = F;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (x) {
        var B = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = x.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...B($), ...B($ == null ? void 0 : $.nextElementSibling)];
          w = (V = z.find((M) => sue(x, M))) !== null && V !== void 0 ? V : null;
        } else {
          var q, X = [...B($ == null ? void 0 : $.previousElementSibling), ...B($)];
          w = (q = X.findLast((M) => vT(x, M))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Iv && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Fp && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Iv && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && Ft.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = Ft.toSlateNode(e, J), {
          path: ee,
          offset: k
        } = wn.start(e, Ft.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (k = a), {
          path: ee,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var j = Ft.toSlateNode(e, u), H = Ft.findPath(e, j);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = gT(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (gT(t)) {
        if (Fp && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), m = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && m.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, g = m.startContainer, h = C(f.children[d.startOffset]), x = C(g.children[m.startOffset]);
            c = 0, x.childNodes.length > 0 ? a = x.childNodes[0] : a = x, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, x instanceof HTMLElement ? l = x.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = m.endContainer, l = m.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = m.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Wle && oue(a) || Fp ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Fp && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Ft.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = vT(a, u) || a === u && c < l, O = p ? w : Ft.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!O)
      return null;
    var y = {
      anchor: w,
      focus: O
    };
    return xt.isExpanded(y) && xt.isForward(y) && ei(u) && wn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = wn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, uue = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, cue = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, pue = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Kn = (e) => {
  var t = uue[e], n = cue[e], r = pue[e], o = t && jv(t), i = n && jv(n), s = r && jv(r);
  return (a) => !!(o && o(a) || dT && i && i(a) || !dT && s && s(a));
};
Kn("bold"), Kn("compose"), Kn("moveBackward"), Kn("moveForward"), Kn("deleteBackward"), Kn("deleteForward"), Kn("deleteLineBackward"), Kn("deleteLineForward"), Kn("deleteWordBackward"), Kn("deleteWordForward"), Kn("extendBackward"), Kn("extendForward"), Kn("extendLineBackward"), Kn("extendLineForward"), Kn("italic"), Kn("moveLineBackward"), Kn("moveLineForward"), Kn("moveWordBackward"), Kn("moveWordForward"), Kn("redo"), Kn("insertSoftBreak"), Kn("splitBlock"), Kn("transposeCharacter"), Kn("undo");
var due = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => Ez(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, fue = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class hue extends Yu {
  constructor() {
    super(...arguments), cu(this, "context", null), cu(this, "manager", null), cu(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, fue);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = due(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
cu(hue, "contextType", Hle);
Ge({});
Ge({});
Ge({});
var yr = {}, UC = {}, vc = {}, yc = {}, Lz = "Expected a function", yT = NaN, gue = "[object Symbol]", mue = /^\s+|\s+$/g, vue = /^[-+]0x[0-9a-f]+$/i, yue = /^0b[01]+$/i, bue = /^0o[0-7]+$/i, wue = parseInt, Cue = typeof Ln == "object" && Ln && Ln.Object === Object && Ln, Oue = typeof self == "object" && self && self.Object === Object && self, xue = Cue || Oue || Function("return this")(), Eue = Object.prototype, Lue = Eue.toString, Pue = Math.max, kue = Math.min, Nv = function() {
  return xue.Date.now();
};
function Sue(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Lz);
  t = bT(t) || 0, jf(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Pue(bT(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function m(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, s = e.apply(U, S), s;
  }
  function f(C) {
    return u = C, a = setTimeout(x, t), c ? m(C) : s;
  }
  function g(C) {
    var S = C - l, U = C - u, L = t - S;
    return p ? kue(L, i - U) : L;
  }
  function h(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function x() {
    var C = Nv();
    if (h(C))
      return w(C);
    a = setTimeout(x, g(C));
  }
  function w(C) {
    return a = void 0, d && r ? m(C) : (r = o = void 0, s);
  }
  function D() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function O() {
    return a === void 0 ? s : w(Nv());
  }
  function y() {
    var C = Nv(), S = h(C);
    if (r = arguments, o = this, l = C, S) {
      if (a === void 0)
        return f(l);
      if (p)
        return a = setTimeout(x, t), m(l);
    }
    return a === void 0 && (a = setTimeout(x, t)), s;
  }
  return y.cancel = D, y.flush = O, y;
}
function Due(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Lz);
  return jf(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Sue(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function jf(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Mue(e) {
  return !!e && typeof e == "object";
}
function Tue(e) {
  return typeof e == "symbol" || Mue(e) && Lue.call(e) == gue;
}
function bT(e) {
  if (typeof e == "number")
    return e;
  if (Tue(e))
    return yT;
  if (jf(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = jf(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(mue, "");
  var n = yue.test(e);
  return n || bue.test(e) ? wue(e.slice(2), n ? 2 : 8) : vue.test(e) ? yT : +e;
}
var jue = Due, bc = {};
Object.defineProperty(bc, "__esModule", {
  value: !0
});
bc.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), gd.has(t) || gd.set(t, /* @__PURE__ */ new Set());
  var o = gd.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
bc.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), gd.get(t).delete(n.name || t);
};
var gd = /* @__PURE__ */ new Map();
Object.defineProperty(yc, "__esModule", {
  value: !0
});
var _ue = jue, Aue = Iue(_ue), Bue = bc;
function Iue(e) {
  return e && e.__esModule ? e : { default: e };
}
var Nue = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Aue.default)(e, t);
}, or = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = Nue(function(r) {
        or.scrollHandler(e);
      }, t);
      or.scrollSpyContainers.push(e), (0, Bue.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return or.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = or.scrollSpyContainers[or.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(or.currentPositionX(e), or.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    or.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = or.scrollSpyContainers[or.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(or.currentPositionX(t), or.currentPositionY(t));
  },
  updateStates: function() {
    or.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    or.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), or.spySetState && or.spySetState.length && or.spySetState.indexOf(e) > -1 && or.spySetState.splice(or.spySetState.indexOf(e), 1), document.removeEventListener("scroll", or.scrollHandler);
  },
  update: function() {
    return or.scrollSpyContainers.forEach(function(e) {
      return or.scrollHandler(e);
    });
  }
};
yc.default = or;
var sl = {}, wc = {};
Object.defineProperty(wc, "__esModule", {
  value: !0
});
var Fue = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, Rue = function() {
  return window.location.hash.replace(/^#/, "");
}, zue = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Uue = function(e) {
  return getComputedStyle(e).position !== "static";
}, Fv = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, $ue = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Uue(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Fv(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return Fv(t, a).offsetTop - Fv(e, a).offsetTop;
};
wc.default = {
  updateHash: Fue,
  getHash: Rue,
  filterElementInContainer: zue,
  scrollOffset: $ue
};
var Ig = {}, $C = {};
Object.defineProperty($C, "__esModule", {
  value: !0
});
$C.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var VC = {};
Object.defineProperty(VC, "__esModule", {
  value: !0
});
var Vue = bc, Hue = ["mousedown", "mousewheel", "touchmove", "keydown"];
VC.default = {
  subscribe: function(e) {
    return typeof document < "u" && Hue.forEach(function(t) {
      return (0, Vue.addPassiveEventListener)(document, t, e);
    });
  }
};
var Cc = {};
Object.defineProperty(Cc, "__esModule", {
  value: !0
});
var Zb = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Zb.registered[e] = t;
    },
    remove: function(e) {
      Zb.registered[e] = null;
    }
  }
};
Cc.default = Zb;
Object.defineProperty(Ig, "__esModule", {
  value: !0
});
var Wue = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Zue = wc;
Ng(Zue);
var que = $C, wT = Ng(que), Gue = VC, Yue = Ng(Gue), Kue = Cc, Yo = Ng(Kue);
function Ng(e) {
  return e && e.__esModule ? e : { default: e };
}
var Pz = function(e) {
  return wT.default[e.smooth] || wT.default.defaultEasing;
}, Jue = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Xue = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, qb = function() {
  return Xue() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), kz = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Sz = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Dz = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, Que = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, ece = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, tce = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Yo.default.registered.end && Yo.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    qb.call(window, i);
    return;
  }
  Yo.default.registered.end && Yo.default.registered.end(o.to, o.target, o.currentPosition);
}, HC = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Oc = function(e, t, n, r) {
  t.data = t.data || kz(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (Yue.default.subscribe(o), HC(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Sz(t) : Dz(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Yo.default.registered.end && Yo.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = Jue(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Pz(t), s = tce.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Yo.default.registered.begin && Yo.default.registered.begin(t.data.to, t.data.target), qb.call(window, s);
    }, t.delay);
    return;
  }
  Yo.default.registered.begin && Yo.default.registered.begin(t.data.to, t.data.target), qb.call(window, s);
}, Fg = function(e) {
  return e = Wue({}, e), e.data = e.data || kz(), e.absolute = !0, e;
}, nce = function(e) {
  Oc(0, Fg(e));
}, rce = function(e, t) {
  Oc(e, Fg(t));
}, oce = function(e) {
  e = Fg(e), HC(e), Oc(e.horizontal ? Que(e) : ece(e), e);
}, ice = function(e, t) {
  t = Fg(t), HC(t);
  var n = t.horizontal ? Sz(t) : Dz(t);
  Oc(e + n, t);
};
Ig.default = {
  animateTopScroll: Oc,
  getAnimationType: Pz,
  scrollToTop: nce,
  scrollToBottom: oce,
  scrollTo: rce,
  scrollMore: ice
};
Object.defineProperty(sl, "__esModule", {
  value: !0
});
var sce = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, ace = wc, lce = WC(ace), uce = Ig, cce = WC(uce), pce = Cc, zp = WC(pce);
function WC(e) {
  return e && e.__esModule ? e : { default: e };
}
var Up = {}, CT = void 0;
sl.default = {
  unmount: function() {
    Up = {};
  },
  register: function(e, t) {
    Up[e] = t;
  },
  unregister: function(e) {
    delete Up[e];
  },
  get: function(e) {
    return Up[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return CT = e;
  },
  getActiveLink: function() {
    return CT;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = sce({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = lce.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      zp.default.registered.begin && zp.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, zp.default.registered.end && zp.default.registered.end(e, n);
      return;
    }
    cce.default.animateTopScroll(a, t, e, n);
  }
};
var Gb = { exports: {} }, Rv = { exports: {} }, ln = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var OT;
function dce() {
  if (OT) return ln;
  OT = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case a:
                case c:
                case f:
                case m:
                case s:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function O(y) {
    return D(y) === u;
  }
  return ln.AsyncMode = l, ln.ConcurrentMode = u, ln.ContextConsumer = a, ln.ContextProvider = s, ln.Element = t, ln.ForwardRef = c, ln.Fragment = r, ln.Lazy = f, ln.Memo = m, ln.Portal = n, ln.Profiler = i, ln.StrictMode = o, ln.Suspense = p, ln.isAsyncMode = function(y) {
    return O(y) || D(y) === l;
  }, ln.isConcurrentMode = O, ln.isContextConsumer = function(y) {
    return D(y) === a;
  }, ln.isContextProvider = function(y) {
    return D(y) === s;
  }, ln.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, ln.isForwardRef = function(y) {
    return D(y) === c;
  }, ln.isFragment = function(y) {
    return D(y) === r;
  }, ln.isLazy = function(y) {
    return D(y) === f;
  }, ln.isMemo = function(y) {
    return D(y) === m;
  }, ln.isPortal = function(y) {
    return D(y) === n;
  }, ln.isProfiler = function(y) {
    return D(y) === i;
  }, ln.isStrictMode = function(y) {
    return D(y) === o;
  }, ln.isSuspense = function(y) {
    return D(y) === p;
  }, ln.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === m || y.$$typeof === s || y.$$typeof === a || y.$$typeof === c || y.$$typeof === h || y.$$typeof === x || y.$$typeof === w || y.$$typeof === g);
  }, ln.typeOf = D, ln;
}
var yn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xT;
function fce() {
  return xT || (xT = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === m || N.$$typeof === s || N.$$typeof === a || N.$$typeof === c || N.$$typeof === h || N.$$typeof === x || N.$$typeof === w || N.$$typeof === g);
    }
    function O(N) {
      if (typeof N == "object" && N !== null) {
        var ue = N.$$typeof;
        switch (ue) {
          case t:
            var ye = N.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ye;
              default:
                var oe = ye && ye.$$typeof;
                switch (oe) {
                  case a:
                  case c:
                  case f:
                  case m:
                  case s:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, S = a, U = s, L = t, F = c, B = r, $ = f, V = m, z = n, q = i, X = o, J = p, te = !1;
    function ee(N) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(N) || O(N) === l;
    }
    function k(N) {
      return O(N) === u;
    }
    function j(N) {
      return O(N) === a;
    }
    function H(N) {
      return O(N) === s;
    }
    function M(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function Z(N) {
      return O(N) === c;
    }
    function E(N) {
      return O(N) === r;
    }
    function T(N) {
      return O(N) === f;
    }
    function R(N) {
      return O(N) === m;
    }
    function _(N) {
      return O(N) === n;
    }
    function W(N) {
      return O(N) === i;
    }
    function A(N) {
      return O(N) === o;
    }
    function Q(N) {
      return O(N) === p;
    }
    yn.AsyncMode = y, yn.ConcurrentMode = C, yn.ContextConsumer = S, yn.ContextProvider = U, yn.Element = L, yn.ForwardRef = F, yn.Fragment = B, yn.Lazy = $, yn.Memo = V, yn.Portal = z, yn.Profiler = q, yn.StrictMode = X, yn.Suspense = J, yn.isAsyncMode = ee, yn.isConcurrentMode = k, yn.isContextConsumer = j, yn.isContextProvider = H, yn.isElement = M, yn.isForwardRef = Z, yn.isFragment = E, yn.isLazy = T, yn.isMemo = R, yn.isPortal = _, yn.isProfiler = W, yn.isStrictMode = A, yn.isSuspense = Q, yn.isValidElementType = D, yn.typeOf = O;
  }()), yn;
}
var ET;
function Mz() {
  return ET || (ET = 1, process.env.NODE_ENV === "production" ? Rv.exports = dce() : Rv.exports = fce()), Rv.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var zv, LT;
function hce() {
  if (LT) return zv;
  LT = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return zv = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, zv;
}
var Uv, PT;
function ZC() {
  if (PT) return Uv;
  PT = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Uv = e, Uv;
}
var kT, ST;
function Tz() {
  return ST || (ST = 1, kT = Function.call.bind(Object.prototype.hasOwnProperty)), kT;
}
var $v, DT;
function gce() {
  if (DT) return $v;
  DT = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = ZC(), n = {}, r = Tz();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var m = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (m ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, $v = o, $v;
}
var Vv, MT;
function mce() {
  if (MT) return Vv;
  MT = 1;
  var e = Mz(), t = hce(), n = ZC(), r = Tz(), o = gce(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return Vv = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var j = k && (u && k[u] || k[c]);
      if (typeof j == "function")
        return j;
    }
    var d = "<<anonymous>>", m = {
      array: x("array"),
      bigint: x("bigint"),
      bool: x("boolean"),
      func: x("function"),
      number: x("number"),
      object: x("object"),
      string: x("string"),
      symbol: x("symbol"),
      any: w(),
      arrayOf: D,
      element: O(),
      elementType: y(),
      instanceOf: C,
      node: F(),
      objectOf: U,
      oneOf: S,
      oneOfType: L,
      shape: $,
      exact: V
    };
    function f(k, j) {
      return k === j ? k !== 0 || 1 / k === 1 / j : k !== k && j !== j;
    }
    function g(k, j) {
      this.message = k, this.data = j && typeof j == "object" ? j : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function h(k) {
      if (process.env.NODE_ENV !== "production")
        var j = {}, H = 0;
      function M(E, T, R, _, W, A, Q) {
        if (_ = _ || d, A = A || R, Q !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = _ + ":" + R;
            !j[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + _ + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), j[ue] = !0, H++);
          }
        }
        return T[R] == null ? E ? T[R] === null ? new g("The " + W + " `" + A + "` is marked as required " + ("in `" + _ + "`, but its value is `null`.")) : new g("The " + W + " `" + A + "` is marked as required in " + ("`" + _ + "`, but its value is `undefined`.")) : null : k(T, R, _, W, A);
      }
      var Z = M.bind(null, !1);
      return Z.isRequired = M.bind(null, !0), Z;
    }
    function x(k) {
      function j(H, M, Z, E, T, R) {
        var _ = H[M], W = X(_);
        if (W !== k) {
          var A = J(_);
          return new g(
            "Invalid " + E + " `" + T + "` of type " + ("`" + A + "` supplied to `" + Z + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return h(j);
    }
    function w() {
      return h(s);
    }
    function D(k) {
      function j(H, M, Z, E, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + Z + "` has invalid PropType notation inside arrayOf.");
        var R = H[M];
        if (!Array.isArray(R)) {
          var _ = X(R);
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected an array."));
        }
        for (var W = 0; W < R.length; W++) {
          var A = k(R, W, Z, E, T + "[" + W + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return h(j);
    }
    function O() {
      function k(j, H, M, Z, E) {
        var T = j[H];
        if (!a(T)) {
          var R = X(T);
          return new g("Invalid " + Z + " `" + E + "` of type " + ("`" + R + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(k);
    }
    function y() {
      function k(j, H, M, Z, E) {
        var T = j[H];
        if (!e.isValidElementType(T)) {
          var R = X(T);
          return new g("Invalid " + Z + " `" + E + "` of type " + ("`" + R + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(k);
    }
    function C(k) {
      function j(H, M, Z, E, T) {
        if (!(H[M] instanceof k)) {
          var R = k.name || d, _ = ee(H[M]);
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected ") + ("instance of `" + R + "`."));
        }
        return null;
      }
      return h(j);
    }
    function S(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function j(H, M, Z, E, T) {
        for (var R = H[M], _ = 0; _ < k.length; _++)
          if (f(R, k[_]))
            return null;
        var W = JSON.stringify(k, function(A, Q) {
          var N = J(Q);
          return N === "symbol" ? String(Q) : Q;
        });
        return new g("Invalid " + E + " `" + T + "` of value `" + String(R) + "` " + ("supplied to `" + Z + "`, expected one of " + W + "."));
      }
      return h(j);
    }
    function U(k) {
      function j(H, M, Z, E, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + Z + "` has invalid PropType notation inside objectOf.");
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected an object."));
        for (var W in R)
          if (r(R, W)) {
            var A = k(R, W, Z, E, T + "." + W, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return h(j);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var j = 0; j < k.length; j++) {
        var H = k[j];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(H) + " at index " + j + "."
          ), s;
      }
      function M(Z, E, T, R, _) {
        for (var W = [], A = 0; A < k.length; A++) {
          var Q = k[A], N = Q(Z, E, T, R, _, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && W.push(N.data.expectedType);
        }
        var ue = W.length > 0 ? ", expected one of type [" + W.join(", ") + "]" : "";
        return new g("Invalid " + R + " `" + _ + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return h(M);
    }
    function F() {
      function k(j, H, M, Z, E) {
        return z(j[H]) ? null : new g("Invalid " + Z + " `" + E + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return h(k);
    }
    function B(k, j, H, M, Z) {
      return new g(
        (k || "React class") + ": " + j + " type `" + H + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Z + "`."
      );
    }
    function $(k) {
      function j(H, M, Z, E, T) {
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type `" + _ + "` " + ("supplied to `" + Z + "`, expected `object`."));
        for (var W in k) {
          var A = k[W];
          if (typeof A != "function")
            return B(Z, E, T, W, J(A));
          var Q = A(R, W, Z, E, T + "." + W, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return h(j);
    }
    function V(k) {
      function j(H, M, Z, E, T) {
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type `" + _ + "` " + ("supplied to `" + Z + "`, expected `object`."));
        var W = t({}, H[M], k);
        for (var A in W) {
          var Q = k[A];
          if (r(k, A) && typeof Q != "function")
            return B(Z, E, T, A, J(Q));
          if (!Q)
            return new g(
              "Invalid " + E + " `" + T + "` key `" + A + "` supplied to `" + Z + "`.\nBad object: " + JSON.stringify(H[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var N = Q(R, A, Z, E, T + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return h(j);
    }
    function z(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every(z);
          if (k === null || a(k))
            return !0;
          var j = p(k);
          if (j) {
            var H = j.call(k), M;
            if (j !== k.entries) {
              for (; !(M = H.next()).done; )
                if (!z(M.value))
                  return !1;
            } else
              for (; !(M = H.next()).done; ) {
                var Z = M.value;
                if (Z && !z(Z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(k, j) {
      return k === "symbol" ? !0 : j ? j["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && j instanceof Symbol : !1;
    }
    function X(k) {
      var j = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : q(j, k) ? "symbol" : j;
    }
    function J(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var j = X(k);
      if (j === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return j;
    }
    function te(k) {
      var j = J(k);
      switch (j) {
        case "array":
        case "object":
          return "an " + j;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + j;
        default:
          return j;
      }
    }
    function ee(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return m.checkPropTypes = o, m.resetWarningCache = o.resetWarningCache, m.PropTypes = m, m;
  }, Vv;
}
var Hv, TT;
function vce() {
  if (TT) return Hv;
  TT = 1;
  var e = ZC();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Hv = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Hv;
}
if (process.env.NODE_ENV !== "production") {
  var yce = Mz(), bce = !0;
  Gb.exports = mce()(yce.isElement, bce);
} else
  Gb.exports = vce()();
var Rg = Gb.exports, zg = {};
Object.defineProperty(zg, "__esModule", {
  value: !0
});
var wce = wc, Wv = Cce(wce);
function Cce(e) {
  return e && e.__esModule ? e : { default: e };
}
var Oce = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Wv.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Wv.default.getHash() !== e && Wv.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
zg.default = Oce;
Object.defineProperty(vc, "__esModule", {
  value: !0
});
var $p = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, xce = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Ece = Ee, jT = xc(Ece), Lce = yc, Vp = xc(Lce), Pce = sl, kce = xc(Pce), Sce = Rg, Jn = xc(Sce), Dce = zg, Gi = xc(Dce);
function xc(e) {
  return e && e.__esModule ? e : { default: e };
}
function Mce(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Tce(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function jce(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var _T = {
  to: Jn.default.string.isRequired,
  containerId: Jn.default.string,
  container: Jn.default.object,
  activeClass: Jn.default.string,
  activeStyle: Jn.default.object,
  spy: Jn.default.bool,
  horizontal: Jn.default.bool,
  smooth: Jn.default.oneOfType([Jn.default.bool, Jn.default.string]),
  offset: Jn.default.number,
  delay: Jn.default.number,
  isDynamic: Jn.default.bool,
  onClick: Jn.default.func,
  duration: Jn.default.oneOfType([Jn.default.number, Jn.default.func]),
  absolute: Jn.default.bool,
  onSetActive: Jn.default.func,
  onSetInactive: Jn.default.func,
  ignoreCancelEvents: Jn.default.bool,
  hashSpy: Jn.default.bool,
  saveHashHistory: Jn.default.bool,
  spyThrottle: Jn.default.number
};
vc.default = function(e, t) {
  var n = t || kce.default, r = function(i) {
    jce(s, i);
    function s(a) {
      Mce(this, s);
      var l = Tce(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return xce(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          Vp.default.isMounted(a) || Vp.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (Gi.default.isMounted() || Gi.default.mount(n), Gi.default.mapContainer(this.props.to, a)), Vp.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Vp.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = $p({}, this.props.style, this.props.activeStyle) : l = $p({}, this.props.style);
        var u = $p({}, this.props);
        for (var c in _T)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, jT.default.createElement(e, u);
      }
    }]), s;
  }(jT.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, $p({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(Gi.default.isMounted() && !Gi.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, m = void 0;
        if (u) {
          var f = 0, g = 0, h = 0;
          if (l.getBoundingClientRect) {
            var x = l.getBoundingClientRect();
            h = x.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - h + s, g = f + w.width;
          }
          var D = s - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(g), m = D < Math.floor(f) || D >= Math.floor(g);
        } else {
          var O = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            O = U.top - C + a, y = O + U.height;
          }
          var L = a - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(y), m = L < Math.floor(O) || L >= Math.floor(y);
        }
        var F = n.getActiveLink();
        if (m) {
          if (c === F && n.setActiveLink(void 0), i.props.hashSpy && Gi.default.getHash() === c) {
            var B = i.props.saveHashHistory, $ = B === void 0 ? !1 : B;
            Gi.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (F !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && Gi.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = _T, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(UC, "__esModule", {
  value: !0
});
var _ce = Ee, AT = jz(_ce), Ace = vc, Bce = jz(Ace);
function jz(e) {
  return e && e.__esModule ? e : { default: e };
}
function Ice(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function BT(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Nce(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Fce = function(e) {
  Nce(t, e);
  function t() {
    var n, r, o, i;
    Ice(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = BT(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return AT.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), BT(o, i);
  }
  return t;
}(AT.default.Component);
UC.default = (0, Bce.default)(Fce);
var qC = {};
Object.defineProperty(qC, "__esModule", {
  value: !0
});
var Rce = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), zce = Ee, IT = _z(zce), Uce = vc, $ce = _z(Uce);
function _z(e) {
  return e && e.__esModule ? e : { default: e };
}
function Vce(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Hce(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Wce(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Zce = function(e) {
  Wce(t, e);
  function t() {
    return Vce(this, t), Hce(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Rce(t, [{
    key: "render",
    value: function() {
      return IT.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(IT.default.Component);
qC.default = (0, $ce.default)(Zce);
var GC = {}, Ug = {};
Object.defineProperty(Ug, "__esModule", {
  value: !0
});
var qce = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Gce = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Yce = Ee, NT = $g(Yce), Kce = Ga;
$g(Kce);
var Jce = sl, FT = $g(Jce), Xce = Rg, RT = $g(Xce);
function $g(e) {
  return e && e.__esModule ? e : { default: e };
}
function Qce(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function epe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function tpe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Ug.default = function(e) {
  var t = function(n) {
    tpe(r, n);
    function r(o) {
      Qce(this, r);
      var i = epe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Gce(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        FT.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        FT.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return NT.default.createElement(e, qce({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(NT.default.Component);
  return t.propTypes = {
    name: RT.default.string,
    id: RT.default.string
  }, t;
};
Object.defineProperty(GC, "__esModule", {
  value: !0
});
var zT = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, npe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), rpe = Ee, UT = YC(rpe), ope = Ug, ipe = YC(ope), spe = Rg, $T = YC(spe);
function YC(e) {
  return e && e.__esModule ? e : { default: e };
}
function ape(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lpe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function upe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Az = function(e) {
  upe(t, e);
  function t() {
    return ape(this, t), lpe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return npe(t, [{
    key: "render",
    value: function() {
      var n = this, r = zT({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, UT.default.createElement(
        "div",
        zT({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(UT.default.Component);
Az.propTypes = {
  name: $T.default.string,
  id: $T.default.string
};
GC.default = (0, ipe.default)(Az);
var Zv = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, VT = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function HT(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function WT(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ZT(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Hp = Ee, $s = yc, qv = sl, ur = Rg, Yi = zg, qT = {
  to: ur.string.isRequired,
  containerId: ur.string,
  container: ur.object,
  activeClass: ur.string,
  spy: ur.bool,
  smooth: ur.oneOfType([ur.bool, ur.string]),
  offset: ur.number,
  delay: ur.number,
  isDynamic: ur.bool,
  onClick: ur.func,
  duration: ur.oneOfType([ur.number, ur.func]),
  absolute: ur.bool,
  onSetActive: ur.func,
  onSetInactive: ur.func,
  ignoreCancelEvents: ur.bool,
  hashSpy: ur.bool,
  spyThrottle: ur.number
}, cpe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || qv, r = function(i) {
      ZT(s, i);
      function s(a) {
        HT(this, s);
        var l = WT(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return VT(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            $s.isMounted(a) || $s.mount(a, this.props.spyThrottle), this.props.hashSpy && (Yi.isMounted() || Yi.mount(n), Yi.mapContainer(this.props.to, a)), this.props.spy && $s.addStateHandler(this.stateHandler), $s.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          $s.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = Zv({}, this.props);
          for (var u in qT)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, Hp.createElement(e, l);
        }
      }]), s;
    }(Hp.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, Zv({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(Yi.isMounted() && !Yi.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (a.getBoundingClientRect) {
            var m = a.getBoundingClientRect();
            d = m.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + s, p = c + f.height;
          }
          var g = s - i.props.offset, h = g >= Math.floor(c) && g < Math.floor(p), x = g < Math.floor(c) || g >= Math.floor(p), w = n.getActiveLink();
          if (x)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Yi.getHash() === l && Yi.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), $s.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Yi.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), $s.updateStates();
        }
      };
    };
    return r.propTypes = qT, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      ZT(r, n);
      function r(o) {
        HT(this, r);
        var i = WT(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return VT(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          qv.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          qv.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Hp.createElement(e, Zv({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Hp.Component);
    return t.propTypes = {
      name: ur.string,
      id: ur.string
    }, t;
  }
}, ppe = cpe;
Object.defineProperty(yr, "__esModule", {
  value: !0
});
yr.Helpers = yr.ScrollElement = yr.ScrollLink = yr.animateScroll = yr.scrollSpy = yr.Events = yr.scroller = yr.Element = yr.Button = yr.Link = void 0;
var dpe = UC, Bz = li(dpe), fpe = qC, Iz = li(fpe), hpe = GC, Nz = li(hpe), gpe = sl, Fz = li(gpe), mpe = Cc, Rz = li(mpe), vpe = yc, zz = li(vpe), ype = Ig, Uz = li(ype), bpe = vc, $z = li(bpe), wpe = Ug, Vz = li(wpe), Cpe = ppe, Hz = li(Cpe);
function li(e) {
  return e && e.__esModule ? e : { default: e };
}
yr.Link = Bz.default;
yr.Button = Iz.default;
yr.Element = Nz.default;
yr.scroller = Fz.default;
yr.Events = Rz.default;
yr.scrollSpy = zz.default;
yr.animateScroll = Uz.default;
yr.ScrollLink = $z.default;
yr.ScrollElement = Vz.default;
yr.Helpers = Hz.default;
yr.default = { Link: Bz.default, Button: Iz.default, Element: Nz.default, scroller: Fz.default, Events: Rz.default, scrollSpy: zz.default, animateScroll: Uz.default, ScrollLink: $z.default, ScrollElement: Vz.default, Helpers: Hz.default };
Ge({});
Ge({});
Ge({});
function Vu(e) {
  "@babel/helpers - typeof";
  return Vu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Vu(e);
}
function Ope(e, t) {
  if (Vu(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Vu(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function xpe(e) {
  var t = Ope(e, "string");
  return Vu(t) == "symbol" ? t : t + "";
}
function ve(e, t, n) {
  return (t = xpe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Wz(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Gv, GT;
function Epe() {
  if (GT) return Gv;
  GT = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, s, a, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, s, a, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Gv = t, Gv;
}
var Lpe = Epe(), Pr = /* @__PURE__ */ Wz(Lpe), yt = Ge(null);
function Ppe() {
  Pr(!!xe, "useGoogleMap is React hook and requires React version 16.8+");
  var e = xe(yt);
  return Pr(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function kpe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function Spe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Dpe(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return Spe(e, i), o;
}
function Mpe(e, t, n) {
  var r = kpe(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function Tpe(e) {
  google.maps.event.removeListener(e);
}
function Zt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(Tpe);
}
function $t(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = Mpe(o, i, n);
  return Dpe(t, r, o, i), s;
}
function jpe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: m,
    onMouseOver: f,
    onMouseDown: g,
    onMouseUp: h,
    onRightClick: x,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: O
  } = e, [y, C] = P(null), S = Qe(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null), [A, Q] = P(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof s < "u" && y.setCenter(s);
  }, [y, s]), v(() => {
    y && l && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && g && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(y, "mousedown", g)));
  }, [g]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && m && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(y, "mouseout", m)));
  }, [m]), v(() => {
    y && f && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && h && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && x && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(y, "rightclick", x)));
  }, [x]), v(() => {
    y && a && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(y, "click", a)));
  }, [a]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [a]), v(() => {
    var N = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(N), N !== null && D && D(N), () => {
      N !== null && O && O(N);
    };
  }, []), bn.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: bn.jsx(yt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
Le(jpe);
function YT(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Zz(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        YT(i, r, o, s, a, "next", l);
      }
      function a(l) {
        YT(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function qz(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Pr(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var aa = typeof document < "u";
function Gz(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return aa ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, a.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function KT(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Yz() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return KT(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return KT(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Ml = !1;
function Kz() {
  return bn.jsx("div", {
    children: "Loading..."
  });
}
var Yb = {
  id: "script-loader",
  version: "weekly"
};
class _pe extends be {
  constructor() {
    super(...arguments), ve(this, "check", wr()), ve(this, "state", {
      loaded: !1
    }), ve(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ve(this, "isCleaningUp", /* @__PURE__ */ Zz(function* () {
      function t(n) {
        if (!Ml)
          n();
        else if (aa)
          var r = window.setInterval(function() {
            Ml || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ve(this, "cleanup", () => {
      Ml = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), ve(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Yz(), Pr(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: qz(this.props)
      };
      Gz(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (aa) {
      if (window.google && window.google.maps && !Ml) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), aa && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (aa) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Ml = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return bn.jsxs(bn.Fragment, {
      children: [bn.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || bn.jsx(Kz, {})]
    });
  }
}
ve(_pe, "defaultProps", Yb);
function Ape(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function KC(e, t) {
  if (e == null) return {};
  var n, r, o = Ape(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var JT;
function Bpe(e) {
  var {
    id: t = Yb.id,
    version: n = Yb.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, m = Qe(!1), [f, g] = P(!1), [h, x] = P(void 0);
  v(function() {
    return m.current = !0, () => {
      m.current = !1;
    };
  }, []), v(function() {
    aa && u && Yz();
  }, [u]), v(function() {
    f && Pr(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = qz({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!aa)
      return;
    function O() {
      m.current && (g(!0), JT = w);
    }
    if (window.google && window.google.maps && JT === w) {
      O();
      return;
    }
    Gz({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(y) {
      m.current && x(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var D = Qe();
  return v(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var Ipe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], Npe = bn.jsx(Kz, {});
function Fpe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = KC(e, Ipe), {
    isLoaded: a,
    loadError: l
  } = Bpe(s);
  return v(function() {
    a && typeof n == "function" && n();
  }, [a, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || Npe;
}
Le(Fpe);
var XT;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(XT || (XT = {}));
function QT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _f(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QT(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ej = {}, tj = {
  options(e, t) {
    e.setOptions(t);
  }
};
function Rpe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = xe(yt), [i, s] = P(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var a = new google.maps.TrafficLayer(_f(_f({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Le(Rpe);
class zpe extends be {
  constructor() {
    super(...arguments), ve(this, "state", {
      trafficLayer: null
    }), ve(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ve(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(_f(_f({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: tj,
      eventMap: ej,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: tj,
      eventMap: ej,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Zt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ve(zpe, "contextType", yt);
function Upe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = xe(yt), [o, i] = P(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
Le(Upe);
class $pe extends be {
  constructor() {
    super(...arguments), ve(this, "state", {
      bicyclingLayer: null
    }), ve(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ve($pe, "contextType", yt);
function Vpe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = xe(yt), [o, i] = P(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Le(Vpe);
class Hpe extends be {
  constructor() {
    super(...arguments), ve(this, "state", {
      transitLayer: null
    }), ve(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Hpe, "contextType", yt);
function nj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Af(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rj = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, oj = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Wpe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = xe(yt), [d, m] = P(null), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), g(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && s && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(d, "polygoncomplete", s)));
  }, [d, s]), v(() => {
    d && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", a)));
  }, [d, a]), v(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    Pr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var F = new google.maps.drawing.DrawingManager(Af(Af({}, t), {}, {
      map: p
    }));
    return n && F.setDrawingMode(n), r && g(google.maps.event.addListener(F, "circlecomplete", r)), o && x(google.maps.event.addListener(F, "markercomplete", o)), i && D(google.maps.event.addListener(F, "overlaycomplete", i)), s && y(google.maps.event.addListener(F, "polygoncomplete", s)), a && S(google.maps.event.addListener(F, "polylinecomplete", a)), l && L(google.maps.event.addListener(F, "rectanglecomplete", l)), m(F), u && u(F), () => {
      d !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
Le(Wpe);
class Zpe extends be {
  constructor(t) {
    super(t), ve(this, "registeredEvents", []), ve(this, "state", {
      drawingManager: null
    }), ve(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Pr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Af(Af({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: oj,
      eventMap: rj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: oj,
      eventMap: rj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Zt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Zpe, "contextType", yt);
function ij(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Na(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ij(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ij(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sj = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, aj = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Bf = {};
function qpe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: m,
    shape: f,
    title: g,
    zIndex: h,
    onClick: x,
    onDblClick: w,
    onDrag: D,
    onDragEnd: O,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: L,
    onRightClick: F,
    onClickableChanged: B,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: q,
    onIconChanged: X,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: k,
    onZindexChanged: j,
    onLoad: H,
    onUnmount: M
  } = e, Z = xe(yt), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null), [Q, N] = P(null), [ue, ye] = P(null), [oe, Ie] = P(null), [$e, Ve] = P(null), [Ne, Je] = P(null), [Ye, Te] = P(null), [Ke, nt] = P(null), [Me, Ae] = P(null), [Fe, He] = P(null), [ze, et] = P(null), [_e, At] = P(null), [rt, ot] = P(null), [at, qt] = P(null), [lt, Gt] = P(null), [Xe, bt] = P(null), [tt, Yt] = P(null), [ut, dn] = P(null), [Kt, fn] = P(null), [Jt, hn] = P(null);
  v(() => {
    E !== null && E.setMap(Z);
  }, [Z]), v(() => {
    typeof n < "u" && E !== null && E.setOptions(n);
  }, [E, n]), v(() => {
    typeof s < "u" && E !== null && E.setDraggable(s);
  }, [E, s]), v(() => {
    t && E !== null && E.setPosition(t);
  }, [E, t]), v(() => {
    typeof a < "u" && E !== null && E.setVisible(a);
  }, [E, a]), v(() => {
    E == null || E.setAnimation(l);
  }, [E, l]), v(() => {
    E && u !== void 0 && E.setClickable(u);
  }, [E, u]), v(() => {
    E && c !== void 0 && E.setCursor(c);
  }, [E, c]), v(() => {
    E && p !== void 0 && E.setIcon(p);
  }, [E, p]), v(() => {
    E && d !== void 0 && E.setLabel(d);
  }, [E, d]), v(() => {
    E && m !== void 0 && E.setOpacity(m);
  }, [E, m]), v(() => {
    E && f !== void 0 && E.setShape(f);
  }, [E, f]), v(() => {
    E && g !== void 0 && E.setTitle(g);
  }, [E, g]), v(() => {
    E && h !== void 0 && E.setZIndex(h);
  }, [E, h]), v(() => {
    E && w && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(E, "dblclick", w)));
  }, [w]), v(() => {
    E && O && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(E, "dragend", O)));
  }, [O]), v(() => {
    E && y && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(E, "dragstart", y)));
  }, [y]), v(() => {
    E && L && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(E, "mousedown", L)));
  }, [L]), v(() => {
    E && C && (oe !== null && google.maps.event.removeListener(oe), Ie(google.maps.event.addListener(E, "mouseout", C)));
  }, [C]), v(() => {
    E && S && ($e !== null && google.maps.event.removeListener($e), Ve(google.maps.event.addListener(E, "mouseover", S)));
  }, [S]), v(() => {
    E && U && (Ne !== null && google.maps.event.removeListener(Ne), Je(google.maps.event.addListener(E, "mouseup", U)));
  }, [U]), v(() => {
    E && F && (Ye !== null && google.maps.event.removeListener(Ye), Te(google.maps.event.addListener(E, "rightclick", F)));
  }, [F]), v(() => {
    E && x && (Ke !== null && google.maps.event.removeListener(Ke), nt(google.maps.event.addListener(E, "click", x)));
  }, [x]), v(() => {
    E && D && (Me !== null && google.maps.event.removeListener(Me), Ae(google.maps.event.addListener(E, "drag", D)));
  }, [D]), v(() => {
    E && B && (Fe !== null && google.maps.event.removeListener(Fe), He(google.maps.event.addListener(E, "clickable_changed", B)));
  }, [B]), v(() => {
    E && $ && (ze !== null && google.maps.event.removeListener(ze), et(google.maps.event.addListener(E, "cursor_changed", $)));
  }, [$]), v(() => {
    E && V && (_e !== null && google.maps.event.removeListener(_e), At(google.maps.event.addListener(E, "animation_changed", V)));
  }, [V]), v(() => {
    E && z && (rt !== null && google.maps.event.removeListener(rt), ot(google.maps.event.addListener(E, "draggable_changed", z)));
  }, [z]), v(() => {
    E && q && (at !== null && google.maps.event.removeListener(at), qt(google.maps.event.addListener(E, "flat_changed", q)));
  }, [q]), v(() => {
    E && X && (lt !== null && google.maps.event.removeListener(lt), Gt(google.maps.event.addListener(E, "icon_changed", X)));
  }, [X]), v(() => {
    E && J && (Xe !== null && google.maps.event.removeListener(Xe), bt(google.maps.event.addListener(E, "position_changed", J)));
  }, [J]), v(() => {
    E && te && (tt !== null && google.maps.event.removeListener(tt), Yt(google.maps.event.addListener(E, "shape_changed", te)));
  }, [te]), v(() => {
    E && ee && (ut !== null && google.maps.event.removeListener(ut), dn(google.maps.event.addListener(E, "title_changed", ee)));
  }, [ee]), v(() => {
    E && k && (Kt !== null && google.maps.event.removeListener(Kt), fn(google.maps.event.addListener(E, "visible_changed", k)));
  }, [k]), v(() => {
    E && j && (Jt !== null && google.maps.event.removeListener(Jt), hn(google.maps.event.addListener(E, "zindex_changed", j)));
  }, [j]), v(() => {
    var wt = Na(Na(Na({}, n || Bf), r ? Bf : {
      map: Z
    }), {}, {
      position: t
    }), re = new google.maps.Marker(wt);
    return r ? r.addMarker(re, !!o) : re.setMap(Z), t && re.setPosition(t), typeof a < "u" && re.setVisible(a), typeof s < "u" && re.setDraggable(s), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof m < "u" && re.setOpacity(m), f && re.setShape(f), typeof g == "string" && re.setTitle(g), typeof h == "number" && re.setZIndex(h), w && _(google.maps.event.addListener(re, "dblclick", w)), O && A(google.maps.event.addListener(re, "dragend", O)), y && N(google.maps.event.addListener(re, "dragstart", y)), L && ye(google.maps.event.addListener(re, "mousedown", L)), C && Ie(google.maps.event.addListener(re, "mouseout", C)), S && Ve(google.maps.event.addListener(re, "mouseover", S)), U && Je(google.maps.event.addListener(re, "mouseup", U)), F && Te(google.maps.event.addListener(re, "rightclick", F)), x && nt(google.maps.event.addListener(re, "click", x)), D && Ae(google.maps.event.addListener(re, "drag", D)), B && He(google.maps.event.addListener(re, "clickable_changed", B)), $ && et(google.maps.event.addListener(re, "cursor_changed", $)), V && At(google.maps.event.addListener(re, "animation_changed", V)), z && ot(google.maps.event.addListener(re, "draggable_changed", z)), q && qt(google.maps.event.addListener(re, "flat_changed", q)), X && Gt(google.maps.event.addListener(re, "icon_changed", X)), J && bt(google.maps.event.addListener(re, "position_changed", J)), te && Yt(google.maps.event.addListener(re, "shape_changed", te)), ee && dn(google.maps.event.addListener(re, "title_changed", ee)), k && fn(google.maps.event.addListener(re, "visible_changed", k)), j && hn(google.maps.event.addListener(re, "zindex_changed", j)), T(re), H && H(re), () => {
      R !== null && google.maps.event.removeListener(R), W !== null && google.maps.event.removeListener(W), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), $e !== null && google.maps.event.removeListener($e), Ne !== null && google.maps.event.removeListener(Ne), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Fe !== null && google.maps.event.removeListener(Fe), ze !== null && google.maps.event.removeListener(ze), _e !== null && google.maps.event.removeListener(_e), rt !== null && google.maps.event.removeListener(rt), at !== null && google.maps.event.removeListener(at), lt !== null && google.maps.event.removeListener(lt), Xe !== null && google.maps.event.removeListener(Xe), ut !== null && google.maps.event.removeListener(ut), Kt !== null && google.maps.event.removeListener(Kt), Jt !== null && google.maps.event.removeListener(Jt), M && M(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Fn = Nn(() => i ? it.map(i, (wt) => {
    if (!ti(wt))
      return wt;
    var re = wt;
    return ni(re, {
      anchor: E
    });
  }) : null, [i, E]);
  return bn.jsx(bn.Fragment, {
    children: Fn
  }) || null;
}
Le(qpe);
class Gpe extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Zz(function* () {
      var n = Na(Na(Na({}, t.props.options || Bf), t.props.clusterer ? Bf : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = $t({
        updaterMap: aj,
        eventMap: sj,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: aj,
      eventMap: sj,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Zt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? it.map(this.props.children, (n) => {
      if (!ti(n))
        return n;
      var r = n;
      return ni(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ve(Gpe, "contextType", yt);
var Ype = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var m = document.createElement("div");
        m.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (m.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (m.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(m), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), Kpe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new Ype(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function Jpe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Xpe = 2e3, Qpe = 500, ede = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", tde = "png", nde = [53, 56, 66, 78, 90], rde = "cluster", Jz = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || ede, this.imageExtension = r.imageExtension || tde, this.imageSizes = r.imageSizes || nde, this.calculator = r.calculator || Jpe, this.batchSize = r.batchSize || Xpe, this.batchSizeIE = r.batchSizeIE || Qpe, this.clusterClass = r.clusterClass || rde, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new Kpe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var m = d[p];
            m.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function lj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ode(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ao = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, nn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, ide = {};
function sde(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: m,
    minimumClusterSize: f,
    styles: g,
    title: h,
    zoomOnClick: x,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: O,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [L, F] = P(null), B = xe(yt), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null);
  return v(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, Ao.onMouseOut, C)));
  }, [C]), v(() => {
    L && y && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(L, Ao.onMouseOver, y)));
  }, [y]), v(() => {
    L && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(L, Ao.onClick, w)));
  }, [w]), v(() => {
    L && D && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(L, Ao.onClusteringBegin, D)));
  }, [D]), v(() => {
    L && O && (X !== null && google.maps.event.removeListener(X), q(google.maps.event.addListener(L, Ao.onClusteringEnd, O)));
  }, [O]), v(() => {
    typeof r < "u" && L !== null && nn.averageCenter(L, r);
  }, [L, r]), v(() => {
    typeof o < "u" && L !== null && nn.batchSizeIE(L, o);
  }, [L, o]), v(() => {
    typeof i < "u" && L !== null && nn.calculator(L, i);
  }, [L, i]), v(() => {
    typeof s < "u" && L !== null && nn.clusterClass(L, s);
  }, [L, s]), v(() => {
    typeof a < "u" && L !== null && nn.enableRetinaIcons(L, a);
  }, [L, a]), v(() => {
    typeof l < "u" && L !== null && nn.gridSize(L, l);
  }, [L, l]), v(() => {
    typeof u < "u" && L !== null && nn.ignoreHidden(L, u);
  }, [L, u]), v(() => {
    typeof c < "u" && L !== null && nn.imageExtension(L, c);
  }, [L, c]), v(() => {
    typeof p < "u" && L !== null && nn.imagePath(L, p);
  }, [L, p]), v(() => {
    typeof d < "u" && L !== null && nn.imageSizes(L, d);
  }, [L, d]), v(() => {
    typeof m < "u" && L !== null && nn.maxZoom(L, m);
  }, [L, m]), v(() => {
    typeof f < "u" && L !== null && nn.minimumClusterSize(L, f);
  }, [L, f]), v(() => {
    typeof g < "u" && L !== null && nn.styles(L, g);
  }, [L, g]), v(() => {
    typeof h < "u" && L !== null && nn.title(L, h);
  }, [L, h]), v(() => {
    typeof x < "u" && L !== null && nn.zoomOnClick(L, x);
  }, [L, x]), v(() => {
    if (B) {
      var H = ode({}, n || ide), M = new Jz(B, [], H);
      return r && nn.averageCenter(M, r), o && nn.batchSizeIE(M, o), i && nn.calculator(M, i), s && nn.clusterClass(M, s), a && nn.enableRetinaIcons(M, a), l && nn.gridSize(M, l), u && nn.ignoreHidden(M, u), c && nn.imageExtension(M, c), p && nn.imagePath(M, p), d && nn.imageSizes(M, d), m && nn.maxZoom(M, m), f && nn.minimumClusterSize(M, f), g && nn.styles(M, g), h && nn.title(M, h), x && nn.zoomOnClick(M, x), C && ee(google.maps.event.addListener(M, Ao.onMouseOut, C)), y && j(google.maps.event.addListener(M, Ao.onMouseOver, y)), w && V(google.maps.event.addListener(M, Ao.onClick, w)), D && q(google.maps.event.addListener(M, Ao.onClusteringBegin, D)), O && J(google.maps.event.addListener(M, Ao.onClusteringEnd, O)), F(M), S && S(M), () => {
        te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), U && U(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
Le(sde);
class ade extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      markerClusterer: null
    }), ve(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Jz(this.context, [], this.props.options);
      this.registeredEvents = $t({
        updaterMap: nn,
        eventMap: Ao,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: nn,
      eventMap: Ao,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Zt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ve(ade, "contextType", yt);
function uj(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Xz = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || uj(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, uj));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, m = this.infoBoxClearance.width, f = this.infoBoxClearance.height, g = this.getProjection(), h = g.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + m ? r = h.x + u - m : h.x + p + u + m > a && (r = h.x + p + u + m - a), this.alignBottom ? h.y < -c + f + d ? o = h.y + c - f - d : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + d + c + f > l && (o = h.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), lde = ["position"], ude = ["position"];
function cj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function If(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pj = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, dj = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, cde = {};
function pde(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = xe(yt), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), F = Qe(null);
  return v(() => {
    m && f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (m) {
      var B = r || cde, {
        position: $
      } = B, V = KC(B, lde), z;
      $ && !($ instanceof google.maps.LatLng) && (z = new google.maps.LatLng($.lat, $.lng));
      var q = new Xz(If(If({}, V), z ? {
        position: z
      } : {}));
      F.current = document.createElement("div"), g(q), s && x(google.maps.event.addListener(q, "closeclick", s)), a && D(google.maps.event.addListener(q, "domready", a)), l && y(google.maps.event.addListener(q, "content_changed", l)), u && S(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(F.current), n ? q.open(m, n) : q.getPosition() ? q.open(m) : Pr(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), F.current ? Cr(it.only(t), F.current) : null;
}
Le(pde);
class dde extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "containerElement", null), ve(this, "state", {
      infoBox: null
    }), ve(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Pr(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ve(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = KC(t, ude), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Xz(If(If({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = $t({
      updaterMap: dj,
      eventMap: pj,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: dj,
      eventMap: pj,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Zt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Cr(it.only(this.props.children), this.containerElement) : null;
  }
}
ve(dde, "contextType", yt);
var fj, hj;
function fde() {
  return hj || (hj = 1, fj = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), fj;
}
var hde = fde(), gj = /* @__PURE__ */ Wz(hde), mj = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Yv = 1, Tl = 8;
class JC {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Yv)
      throw new Error("Got v".concat(o, " data when expected v").concat(Yv, "."));
    var i = mj[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new JC(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = mj.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Tl, t), this.coords = new this.ArrayType(this.data, Tl + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Tl + s + a + l), this.ids = new this.IndexArrayType(this.data, Tl, t), this.coords = new this.ArrayType(this.data, Tl + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Yv << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return Kb(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (var m = d; m <= p; m++) {
          var f = s[2 * m], g = s[2 * m + 1];
          f >= t && f <= r && g >= n && g <= o && u.push(i[m]);
        }
        continue;
      }
      var h = d + p >> 1, x = s[2 * h], w = s[2 * h + 1];
      x >= t && x <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= x : n <= w) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= x : o >= w) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (var m = d; m <= p; m++)
          vj(i[2 * m], i[2 * m + 1], t, n) <= u && l.push(o[m]);
        continue;
      }
      var f = d + p >> 1, g = i[2 * f], h = i[2 * f + 1];
      vj(g, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= g : n - r <= h) && (a.push(d), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= h) && (a.push(f + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function Kb(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    Qz(e, t, s, r, o, i), Kb(e, t, n, r, s - 1, 1 - i), Kb(e, t, n, s + 1, o, 1 - i);
  }
}
function Qz(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - a * u / s + c)), d = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      Qz(e, t, n, p, d, i);
    }
    var m = t[2 * n + i], f = r, g = o;
    for (jl(e, t, r, n), t[2 * o + i] > m && jl(e, t, r, o); f < g; ) {
      for (jl(e, t, f, g), f++, g--; t[2 * f + i] < m; ) f++;
      for (; t[2 * g + i] > m; ) g--;
    }
    t[2 * r + i] === m ? jl(e, t, r, g) : (g++, jl(e, t, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1);
  }
}
function jl(e, t, n, r) {
  Kv(e, n, r), Kv(t, 2 * n, 2 * r), Kv(t, 2 * n + 1, 2 * r + 1);
}
function Kv(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function vj(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var gde = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, yj = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Vs = 2, as = 3, Jv = 4, ns = 5, eU = 6;
class mde {
  constructor(t) {
    this.options = Object.assign(Object.create(gde), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = yj(Wp(u)), d = yj(Zp(c));
        s.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var m = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var g = +Date.now();
      m = this.trees[f] = this._createTree(this._cluster(m, f)), n && console.log("z%d: %d clusters in %dms", f, m.numItems, +Date.now() - g);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Wp(r), Zp(s), Wp(i), Zp(o)), p = u.data, d = [];
    for (var m of c) {
      var f = this.stride * m;
      d.push(p[f + ns] > 1 ? bj(p, f, this.clusterProps) : this.points[p[f + as]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (var d of c) {
      var m = d * this.stride;
      s[m + Jv] === t && p.push(s[m + ns] > 1 ? bj(s, m, this.clusterProps) : this.points[s[m + as]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new JC(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + ns] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = tU(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var m = this.points[n[l + as]];
        c = m.properties;
        var [f, g] = m.geometry.coordinates;
        p = Wp(f), d = Zp(g);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, x = void 0;
      u || this.options.generateId ? x = n[l + as] : x = this.points[n[l + as]].id, x !== void 0 && (h.id = x), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Vs] <= n)) {
        l[p + Vs] = n;
        var d = l[p], m = l[p + 1], f = t.within(l[p], l[p + 1], a), g = l[p + ns], h = g;
        for (var x of f) {
          var w = x * c;
          l[w + Vs] > n && (h += l[w + ns]);
        }
        if (h > g && h >= s) {
          var D = d * g, O = m * g, y = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var L = U * c;
            if (!(l[L + Vs] <= n)) {
              l[L + Vs] = n;
              var F = l[L + ns];
              D += l[L] * F, O += l[L + 1] * F, l[L + Jv] = S, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + Jv] = S, u.push(D / h, O / h, 1 / 0, S, -1, h), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (h > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Vs] <= n)) {
                l[V + Vs] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ns] > 1) {
      var o = this.clusterProps[t[n + eU]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + as]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function bj(e, t, n) {
  return {
    type: "Feature",
    id: e[t + as],
    properties: tU(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [vde(e[t]), yde(e[t + 1])]
    }
  };
}
function tU(e, t, n) {
  var r = e[t + ns], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + eU], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + as],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Wp(e) {
  return e / 360 + 0.5;
}
function Zp(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function vde(e) {
  return (e - 0.5) * 360;
}
function yde(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function bde(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class yo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Jb {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(yo.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => yo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (yo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class wde {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return Cde(n);
  }
}
var Cde = (e) => {
  var t = e.map((n) => new Jb({
    position: yo.getPosition(n),
    markers: [n]
  }));
  return t;
};
class Ode extends wde {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = bde(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new mde(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!gj(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = yo.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !gj(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Jb({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Jb({
      markers: [i],
      position: yo.getPosition(i)
    });
  }
}
class xde {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Ede {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (yo.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(a, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var m = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(m);
  }
}
function Lde(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class XC {
  constructor() {
    Lde(XC, google.maps.OverlayView);
  }
}
var pu;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(pu || (pu = {}));
var Pde = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class kde extends XC {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new Ode(o),
      renderer: s = new Ede(),
      onClusterClick: a = Pde
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (yo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, pu.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || yo.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => yo.setMap(l, null)));
      }
      google.maps.event.trigger(this, pu.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => yo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new xde(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => yo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, pu.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), yo.setMap(r.marker, n);
    });
  }
}
function wj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Sde(e) {
  var t = Ppe(), [n, r] = P(null);
  return v(() => {
    if (t && n === null) {
      var o = new kde(Cj(Cj({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Dde(e) {
  var {
    children: t,
    options: n
  } = e, r = Sde(n);
  return r !== null ? t(r) : null;
}
Le(Dde);
var Oj = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, xj = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Mde(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = xe(yt), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), F = Qe(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var B = new google.maps.InfoWindow(r);
    return g(B), F.current = document.createElement("div"), s && x(google.maps.event.addListener(B, "closeclick", s)), a && D(google.maps.event.addListener(B, "domready", a)), l && y(google.maps.event.addListener(B, "content_changed", l)), u && S(google.maps.event.addListener(B, "position_changed", u)), c && L(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(F.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(m, n) : B.getPosition() ? B.open(m) : Pr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      h && google.maps.event.removeListener(h), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(B), B.close();
    };
  }, []), F.current ? Cr(it.only(t), F.current) : null;
}
Le(Mde);
class Tde extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "containerElement", null), ve(this, "state", {
      infoWindow: null
    }), ve(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Pr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ve(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = $t({
      updaterMap: xj,
      eventMap: Oj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: xj,
      eventMap: Oj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Zt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Cr(it.only(this.props.children), this.containerElement) : null;
  }
}
ve(Tde, "contextType", yt);
function Ej(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ej(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ej(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Lj = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Pj = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, jde = {};
function _de(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onLoad: x,
    onUnmount: w
  } = e, D = xe(yt), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null);
  return v(() => {
    O !== null && O.setMap(D);
  }, [D]), v(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), v(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), v(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), v(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), v(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), v(() => {
    O && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(O, "dblclick", s)));
  }, [s]), v(() => {
    O && a && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(O, "dragend", a)));
  }, [a]), v(() => {
    O && l && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), v(() => {
    O && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), v(() => {
    O && c && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), v(() => {
    O && p && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), v(() => {
    O && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), v(() => {
    O && m && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(O, "mouseup", m)));
  }, [m]), v(() => {
    O && f && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), v(() => {
    O && g && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(O, "click", g)));
  }, [g]), v(() => {
    O && h && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(O, "drag", h)));
  }, [h]), v(() => {
    var _ = new google.maps.Polyline(Nf(Nf({}, t || jde), {}, {
      map: D
    }));
    return i && _.setPath(i), typeof o < "u" && _.setVisible(o), typeof r < "u" && _.setEditable(r), typeof n < "u" && _.setDraggable(n), s && S(google.maps.event.addListener(_, "dblclick", s)), a && L(google.maps.event.addListener(_, "dragend", a)), l && B(google.maps.event.addListener(_, "dragstart", l)), u && V(google.maps.event.addListener(_, "mousedown", u)), c && q(google.maps.event.addListener(_, "mousemove", c)), p && J(google.maps.event.addListener(_, "mouseout", p)), d && ee(google.maps.event.addListener(_, "mouseover", d)), m && j(google.maps.event.addListener(_, "mouseup", m)), f && M(google.maps.event.addListener(_, "rightclick", f)), g && E(google.maps.event.addListener(_, "click", g)), h && R(google.maps.event.addListener(_, "drag", h)), y(_), x && x(_), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), w && w(_), _.setMap(null);
    };
  }, []), null;
}
Le(_de);
class Ade extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      polyline: null
    }), ve(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Nf(Nf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: Pj,
      eventMap: Lj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: Pj,
      eventMap: Lj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Zt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Ade, "contextType", yt);
function kj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Dj = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Mj = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Bde(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: x,
    onLoad: w,
    onUnmount: D,
    onEdit: O
  } = e, y = xe(yt), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof s < "u" && C !== null && C.setPaths(s);
  }, [C, s]), v(() => {
    C && typeof a == "function" && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(C, "dblclick", a)));
  }, [a]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      O == null || O(C);
    }));
  }, [C, O]), v(() => {
    C && typeof l == "function" && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof m == "function" && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(C, "mouseover", m)));
  }, [m]), v(() => {
    C && typeof f == "function" && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof g == "function" && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(C, "rightclick", g)));
  }, [g]), v(() => {
    C && typeof h == "function" && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(C, "click", h)));
  }, [h]), v(() => {
    C && typeof x == "function" && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(C, "drag", x)));
  }, [x]), v(() => {
    var A = new google.maps.Polygon(Sj(Sj({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), s && A.setPaths(s), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), a && L(google.maps.event.addListener(A, "dblclick", a)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), m && j(google.maps.event.addListener(A, "mouseover", m)), f && M(google.maps.event.addListener(A, "mouseup", f)), g && E(google.maps.event.addListener(A, "rightclick", g)), h && R(google.maps.event.addListener(A, "click", h)), x && W(google.maps.event.addListener(A, "drag", x)), S(A), w && w(A), () => {
      U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), T !== null && google.maps.event.removeListener(T), D && D(A), A.setMap(null);
    };
  }, []), null;
}
Le(Bde);
class Ide extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = $t({
      updaterMap: Mj,
      eventMap: Dj,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: Mj,
      eventMap: Dj,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Zt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Ide, "contextType", yt);
function Tj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ff(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Tj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jj = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, _j = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Nde(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onBoundsChanged: x,
    onLoad: w,
    onUnmount: D
  } = e, O = xe(yt), [y, C] = P(null), [S, U] = P(null), [L, F] = P(null), [B, $] = P(null), [V, z] = P(null), [q, X] = P(null), [J, te] = P(null), [ee, k] = P(null), [j, H] = P(null), [M, Z] = P(null), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null);
  return v(() => {
    y !== null && y.setMap(O);
  }, [O]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && s && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(y, "dblclick", s)));
  }, [s]), v(() => {
    y && a && (L !== null && google.maps.event.removeListener(L), F(google.maps.event.addListener(y, "dragend", a)));
  }, [a]), v(() => {
    y && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (q !== null && google.maps.event.removeListener(q), X(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && m && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(y, "mouseup", m)));
  }, [m]), v(() => {
    y && f && (M !== null && google.maps.event.removeListener(M), Z(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && g && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(y, "click", g)));
  }, [g]), v(() => {
    y && h && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(y, "drag", h)));
  }, [h]), v(() => {
    y && x && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(y, "bounds_changed", x)));
  }, [x]), v(() => {
    var Q = new google.maps.Rectangle(Ff(Ff({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), s && U(google.maps.event.addListener(Q, "dblclick", s)), a && F(google.maps.event.addListener(Q, "dragend", a)), l && $(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && X(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && k(google.maps.event.addListener(Q, "mouseover", d)), m && H(google.maps.event.addListener(Q, "mouseup", m)), f && Z(google.maps.event.addListener(Q, "rightclick", f)), g && T(google.maps.event.addListener(Q, "click", g)), h && _(google.maps.event.addListener(Q, "drag", h)), x && A(google.maps.event.addListener(Q, "bounds_changed", x)), C(Q), w && w(Q), () => {
      S !== null && google.maps.event.removeListener(S), L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), M !== null && google.maps.event.removeListener(M), E !== null && google.maps.event.removeListener(E), R !== null && google.maps.event.removeListener(R), W !== null && google.maps.event.removeListener(W), D && D(Q), Q.setMap(null);
    };
  }, []), null;
}
Le(Nde);
class Fde extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      rectangle: null
    }), ve(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Ff(Ff({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: _j,
      eventMap: jj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: _j,
      eventMap: jj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Zt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Fde, "contextType", yt);
function Aj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Aj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Aj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Bj = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Ij = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Rde = {};
function zde(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: x,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: O,
    onUnmount: y
  } = e, C = xe(yt), [S, U] = P(null), [L, F] = P(null), [B, $] = P(null), [V, z] = P(null), [q, X] = P(null), [J, te] = P(null), [ee, k] = P(null), [j, H] = P(null), [M, Z] = P(null), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null), [Q, N] = P(null), [ue, ye] = P(null);
  return v(() => {
    S !== null && S.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), v(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), v(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), v(() => {
    typeof s < "u" && S !== null && S.setVisible(s);
  }, [S, s]), v(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), v(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), v(() => {
    S && a && (L !== null && google.maps.event.removeListener(L), F(google.maps.event.addListener(S, "dblclick", a)));
  }, [a]), v(() => {
    S && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), v(() => {
    S && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), v(() => {
    S && c && (q !== null && google.maps.event.removeListener(q), X(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), v(() => {
    S && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), v(() => {
    S && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), v(() => {
    S && m && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(S, "mouseover", m)));
  }, [m]), v(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), Z(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), v(() => {
    S && g && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(S, "rightclick", g)));
  }, [g]), v(() => {
    S && h && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(S, "click", h)));
  }, [h]), v(() => {
    S && x && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(S, "drag", x)));
  }, [x]), v(() => {
    S && w && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(S, "center_changed", w)));
  }, [h]), v(() => {
    S && D && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), v(() => {
    var oe = new google.maps.Circle(Rf(Rf({}, t || Rde), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof s < "u" && oe.setVisible(s), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), a && F(google.maps.event.addListener(oe, "dblclick", a)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), m && H(google.maps.event.addListener(oe, "mouseover", m)), f && Z(google.maps.event.addListener(oe, "mouseup", f)), g && T(google.maps.event.addListener(oe, "rightclick", g)), h && _(google.maps.event.addListener(oe, "click", h)), x && A(google.maps.event.addListener(oe, "drag", x)), w && N(google.maps.event.addListener(oe, "center_changed", w)), D && ye(google.maps.event.addListener(oe, "radius_changed", D)), U(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), M !== null && google.maps.event.removeListener(M), E !== null && google.maps.event.removeListener(E), R !== null && google.maps.event.removeListener(R), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
Le(zde);
class Ude extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      circle: null
    }), ve(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Rf(Rf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: Ij,
      eventMap: Bj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: Ij,
      eventMap: Bj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Zt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ve(Ude, "contextType", yt);
function Nj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Nj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Nj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fj = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, Rj = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function $de(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: m,
    onSetProperty: f,
    onLoad: g,
    onUnmount: h
  } = e, x = xe(yt), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null);
  return v(() => {
    w !== null && w.setMap(x);
  }, [x]), v(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && s && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), v(() => {
    w && a && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && m && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(w, "setgeometry", m)));
  }, [m]), v(() => {
    w && f && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (x !== null) {
      var A = new google.maps.Data(zf(zf({}, t), {}, {
        map: x
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), s && B(google.maps.event.addListener(A, "mouseout", s)), a && V(google.maps.event.addListener(A, "mouseover", a)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && j(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && E(google.maps.event.addListener(A, "removeproperty", d)), m && R(google.maps.event.addListener(A, "setgeometry", m)), f && W(google.maps.event.addListener(A, "setproperty", f)), D(A), g && g(A);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), T !== null && google.maps.event.removeListener(T), _ !== null && google.maps.event.removeListener(_), h && h(w), w.setMap(null));
    };
  }, []), null;
}
Le($de);
class Vde extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      data: null
    }), ve(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(zf(zf({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = $t({
        updaterMap: Rj,
        eventMap: Fj,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: Rj,
      eventMap: Fj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Zt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Vde, "contextType", yt);
function zj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $j = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Vj = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class Hde extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      kmlLayer: null
    }), ve(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(Uj(Uj({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: Vj,
      eventMap: $j,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: Vj,
      eventMap: $j,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Zt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Hde, "contextType", yt);
function nU(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Wde(e, t) {
  return new t(e.lat, e.lng);
}
function Zde(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function qde(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Gde(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Yde(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Kde(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function rU(e, t, n, r) {
  return n !== void 0 ? Yde(e, t, Gde(n, google.maps.LatLngBounds, Zde)) : Kde(e, t, qde(r, google.maps.LatLng, Wde));
}
function Jde(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function Hj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xde(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Hj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Hj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Qde(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = Xde({}, this.container ? nU(this.container, o) : {
        x: 0,
        y: 0
      }), u = rU(a, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function Wj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function efe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Wj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Wj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Zj(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function qj(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function tfe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = xe(yt), c = Nn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Nn(() => Qde(c, r, t, n, a), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    s == null || s(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), oi.createPortal(l, c);
}
Le(tfe);
class al extends be {
  constructor(t) {
    super(t), ve(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ve(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Pr(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ve(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ve(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = efe({
        x: 0,
        y: 0
      }, this.containerRef.current ? nU(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = rU(r, o, this.props.bounds, this.props.position);
      if (!Jde(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ve(this, "draw", () => {
      this.onPositionElement();
    }), ve(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = wr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = Zj(t.position), r = Zj(this.props.position), o = qj(t.bounds), i = qj(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? oi.createPortal(bn.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: it.only(this.props.children)
    }), t) : null;
  }
}
ve(al, "FLOAT_PANE", "floatPane");
ve(al, "MAP_PANE", "mapPane");
ve(al, "MARKER_LAYER", "markerLayer");
ve(al, "OVERLAY_LAYER", "overlayLayer");
ve(al, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ve(al, "contextType", yt);
function nfe() {
}
function Gj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Gj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Gj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Kj = {
  onDblClick: "dblclick",
  onClick: "click"
}, Jj = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function rfe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = xe(yt), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Nn(() => new google.maps.GroundOverlay(t, s, r), []);
  return v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), v(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Le(rfe);
class oU extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      groundOverlay: null
    }), ve(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Pr(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Yj(Yj({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: Jj,
      eventMap: Kj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: Jj,
      eventMap: Kj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ve(oU, "defaultProps", {
  onLoad: nfe
});
ve(oU, "contextType", yt);
function Xj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Xj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Xj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qj = {}, e_ = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function ofe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = xe(yt), [s, a] = P(null);
  return v(() => {
    google.maps.visualization || Pr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    Pr(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(Uf(Uf({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Le(ofe);
class ife extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      heatmapLayer: null
    }), ve(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Pr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Pr(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Uf(Uf({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: e_,
      eventMap: Qj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: e_,
      eventMap: Qj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Zt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ve(ife, "contextType", yt);
var t_ = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, n_ = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class sfe extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      streetViewPanorama: null
    }), ve(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = $t({
      updaterMap: n_,
      eventMap: t_,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: n_,
      eventMap: t_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Zt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ve(sfe, "contextType", yt);
class afe extends be {
  constructor() {
    super(...arguments), ve(this, "state", {
      streetViewService: null
    }), ve(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ve(afe, "contextType", yt);
var r_ = {
  onDirectionsChanged: "directions_changed"
}, o_ = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class lfe extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      directionsRenderer: null
    }), ve(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = $t({
      updaterMap: o_,
      eventMap: r_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: o_,
      eventMap: r_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Zt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ve(lfe, "contextType", yt);
var i_ = {
  onPlacesChanged: "places_changed"
}, s_ = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class ufe extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "containerElement", wr()), ve(this, "state", {
      searchBox: null
    }), ve(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Pr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = $t({
          updaterMap: s_,
          eventMap: i_,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: s_,
      eventMap: i_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Zt(this.registeredEvents));
  }
  render() {
    return bn.jsx("div", {
      ref: this.containerElement,
      children: it.only(this.props.children)
    });
  }
}
ve(ufe, "contextType", yt);
var a_ = {
  onPlaceChanged: "place_changed"
}, l_ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class iU extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "containerElement", wr()), ve(this, "state", {
      autocomplete: null
    }), ve(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Pr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = $t({
        updaterMap: l_,
        eventMap: a_,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Zt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: l_,
      eventMap: a_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Zt(this.registeredEvents);
  }
  render() {
    return bn.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: it.only(this.props.children)
    });
  }
}
ve(iU, "defaultProps", {
  className: ""
});
ve(iU, "contextType", yt);
let cfe = { data: "" }, pfe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || cfe, dfe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, ffe = /\/\*[^]*?\*\/|  +/g, u_ = /\n+/g, hs = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? hs(s, i) : i + "{" + hs(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += hs(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += hs.p ? hs.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ei = {}, sU = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + sU(e[n]);
    return t;
  }
  return e;
}, hfe = (e, t, n, r, o) => {
  let i = sU(e), s = Ei[i] || (Ei[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ei[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = dfe.exec(u.replace(ffe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(u_, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(u_, " ").trim();
      return d[0];
    })(e);
    Ei[s] = hs(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Ei.g ? Ei.g : null;
  return n && (Ei.g = Ei[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ei[s], t, r, a), s;
}, gfe = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : hs(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function Vg(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return hfe(n.unshift ? n.raw ? gfe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, pfe(t.target), t.g, t.o, t.k);
}
let aU, Xb, Qb;
Vg.bind({ g: 1 });
let Bi = Vg.bind({ k: 1 });
function mfe(e, t, n, r) {
  hs.p = t, aU = e, Xb = n, Qb = r;
}
function _s(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: Xb && Xb() }, a), n.o = / *go\d+/.test(l), a.className = Vg.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), Qb && u[0] && Qb(a), aU(u, a);
    }
    return o;
  };
}
var vfe = (e) => typeof e == "function", yfe = (e, t) => vfe(e) ? e(t) : e, bfe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), wfe = Bi`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Cfe = Bi`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Ofe = Bi`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, xfe = _s("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${wfe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Cfe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Ofe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Efe = Bi`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Lfe = _s("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Efe} 1s linear infinite;
`, Pfe = Bi`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, kfe = Bi`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, Sfe = _s("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Pfe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${kfe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Dfe = _s("div")`
  position: absolute;
`, Mfe = _s("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Tfe = Bi`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, jfe = _s("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Tfe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, _fe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ue.createElement(jfe, null, t) : t : n === "blank" ? null : Ue.createElement(Mfe, null, Ue.createElement(Lfe, { ...r }), n !== "loading" && Ue.createElement(Dfe, null, n === "error" ? Ue.createElement(xfe, { ...r }) : Ue.createElement(Sfe, { ...r })));
}, Afe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Bfe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, Ife = "0%{opacity:0;} 100%{opacity:1;}", Nfe = "0%{opacity:1;} 100%{opacity:0;}", Ffe = _s("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Rfe = _s("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, zfe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = bfe() ? [Ife, Nfe] : [Afe(n), Bfe(n)];
  return { animation: t ? `${Bi(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Bi(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ue.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? zfe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ue.createElement(_fe, { toast: e }), s = Ue.createElement(Rfe, { ...e.ariaProps }, yfe(e.message, e));
  return Ue.createElement(Ffe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ue.createElement(Ue.Fragment, null, i, s));
});
mfe(Ue.createElement);
Vg`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function Ufe(e) {
  const { error: t } = e, n = "arkynAudioUploadError";
  return t ? /* @__PURE__ */ K.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ K.jsx(K.Fragment, {});
}
function $fe(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynAudioUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ K.jsx("strong", { className: o.trim(), children: t });
}
function Vfe(e) {
  const { onChange: t, value: n, disableDrag: r = !1, onDragging: o } = e, [i, s] = P(!1), a = Qe(null), l = () => {
    s(!0);
  }, u = () => {
    s(!1);
  }, c = (f) => {
    if (r || !i || !a.current) return;
    const g = a.current.getBoundingClientRect(), h = f.clientX - g.left, x = Math.min(Math.max(h / g.width * 100, 0), 100);
    t(x);
  }, p = (f) => {
    if (!a.current) return;
    const g = a.current.getBoundingClientRect(), h = f.clientX - g.left, x = Math.min(Math.max(h / g.width * 100, 0), 100);
    t(x);
  };
  v(() => (i ? (o && o(!0), document.addEventListener("mousemove", c), document.addEventListener("mouseup", u)) : (o && o(!1), document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u)), () => {
    document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
  }), [i]);
  const m = `arkynSliderTrack ${i ? "isDragging" : "isNotDragging"}`;
  return /* @__PURE__ */ K.jsxs(
    "div",
    {
      className: m,
      ref: a,
      onMouseDown: l,
      onClick: p,
      children: [
        /* @__PURE__ */ K.jsx("div", { className: "arkynSliderFill", style: { width: `${n}%` } }),
        /* @__PURE__ */ K.jsx("div", { className: "arkynSliderThumb", style: { left: `${n}%` } })
      ]
    }
  );
}
function Hfe(e) {
  var S, U, L, F;
  const {
    filePath: t,
    disabled: n,
    acceptAudio: r,
    handleSelectFile: o,
    isLoading: i,
    reSendAudio: s,
    changeAudioButtonText: a
  } = e, [l, u] = P(0), c = Qe(null), [p, d] = P(!1), [m, f] = P(!1);
  v(() => {
    const B = c.current;
    if (!B) return;
    const $ = () => {
      const V = B.duration, q = B.currentTime / V * 100;
      u(q);
    };
    return B.addEventListener("timeupdate", $), () => {
      B.removeEventListener("timeupdate", $);
    };
  }, []);
  function g(B) {
    const $ = c.current;
    if (!$) return;
    const V = $.duration, z = B / 100 * V;
    $.currentTime = z;
  }
  function h() {
    var B;
    (B = c.current) == null || B.play(), f(!0);
  }
  function x() {
    var B;
    (B = c.current) == null || B.pause(), f(!1);
  }
  function w() {
    m ? x() : h();
  }
  const D = (S = c.current) == null ? void 0 : S.currentTime, O = (U = c.current) == null ? void 0 : U.duration;
  function y(B) {
    if (!B) return "00:00";
    const $ = Math.floor(B / 60), V = Math.floor(B % 60), z = String($).padStart(2, "0"), q = String(V).padStart(2, "0");
    return `${z}:${q}`;
  }
  p || !m ? (L = c.current) == null || L.pause() : m && ((F = c.current) == null || F.play());
  function C() {
    if (n) return;
    const B = document.createElement("input");
    B.type = "file", B.accept = r, B.onchange = ($) => {
      var z;
      const V = (z = $.target.files) == null ? void 0 : z[0];
      V && o(V);
    }, B.click();
  }
  return /* @__PURE__ */ K.jsxs("div", { className: "arkynAudioUploadHasFileContentContainer", children: [
    /* @__PURE__ */ K.jsx("audio", { ref: c, src: t, onEnded: x }),
    /* @__PURE__ */ K.jsxs("div", { className: "arkynAudioUploadAudioPlayer", children: [
      /* @__PURE__ */ K.jsxs("button", { type: "button", onClick: w, children: [
        m && /* @__PURE__ */ K.jsx(Q$, {}),
        !m && /* @__PURE__ */ K.jsx(e3, {})
      ] }),
      /* @__PURE__ */ K.jsx("p", { children: y(D) }),
      /* @__PURE__ */ K.jsx(
        Vfe,
        {
          value: l,
          onChange: g,
          onDragging: d
        }
      ),
      /* @__PURE__ */ K.jsx("p", { children: y(O) })
    ] }),
    /* @__PURE__ */ K.jsx(F6, {}),
    /* @__PURE__ */ K.jsxs("div", { className: "arkynAudioUploadButtonsContainer", children: [
      !!s && /* @__PURE__ */ K.jsx(Ple, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ K.jsx(
        Lle,
        {
          type: "button",
          "aria-label": "resend image",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: i,
          onClick: s,
          icon: QB,
          disabled: n
        }
      ) }),
      /* @__PURE__ */ K.jsx(
        gz,
        {
          isLoading: i,
          onClick: C,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: n,
          children: a
        }
      )
    ] })
  ] });
}
function Wfe(e) {
  const {
    dropAudioText: t,
    isLoading: n,
    acceptAudio: r,
    handleSelectFile: o,
    selectAudioButtonText: i,
    disabled: s
  } = e;
  function a(u) {
    if (s) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (s) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ K.jsxs("div", { onDrop: a, className: "arkynAudioUploadNoFileContent", children: [
    /* @__PURE__ */ K.jsx(
      gz,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: s,
        children: i
      }
    ),
    /* @__PURE__ */ K.jsx("p", { children: t })
  ] });
}
function o1e(e) {
  const {
    name: t,
    label: n,
    fileName: r = "file",
    method: o = "POST",
    onUpload: i,
    fileResponseName: s = "url",
    selectAudioButtonText: a = "Selecionar arquivo de áudio",
    dropAudioText: l = "Ou arraste e solte um arquivo de áudio aqui",
    changeAudioButtonText: u = "Trocar arquivo de áudio",
    acceptAudio: c = "audio/*",
    action: p,
    defaultValue: d = "",
    showAsterisk: m = !1,
    disabled: f = !1
  } = e, h = Ele()[t], [x, w] = P(d), [D, O] = P(""), [y, C] = P(null), [S, U] = P(d), [L, F] = P(!1);
  async function B(J) {
    if (f) return;
    F(!0), C(J), O("");
    const te = new FormData();
    te.append(r, J), await fetch(p, { method: o, body: te }).then(async (ee) => await ee.json()).then((ee) => {
      ee != null && ee.error ? O(ee.error) : w(ee == null ? void 0 : ee[s]), i && i(ee == null ? void 0 : ee[s]);
    }).catch((ee) => {
      console.error(ee), O("Erro ao enviar audio");
    }).finally(() => F(!1));
  }
  function $(J) {
    if (!f) {
      if (console.log(J.type), J.type.indexOf("audio") === -1) {
        O("O arquivo selecionado não é um arquivo de áudio");
        return;
      }
      U(URL.createObjectURL(J)), B(J);
    }
  }
  const V = h || D, X = `arkynAudioUpload ${V ? "hasError" : "noHasError"} ${S ? "hasAudio" : "noHasAudio"}`;
  return /* @__PURE__ */ K.jsxs("div", { className: "arkynAudioUploadContainer", children: [
    n && /* @__PURE__ */ K.jsx($fe, { label: n, showAsterisk: m }),
    /* @__PURE__ */ K.jsxs("div", { className: X, children: [
      /* @__PURE__ */ K.jsx("input", { type: "hidden", name: t, value: x || "" }),
      !S && /* @__PURE__ */ K.jsx(
        Wfe,
        {
          disabled: f,
          isLoading: L,
          acceptAudio: c,
          dropAudioText: l,
          handleSelectFile: $,
          selectAudioButtonText: a
        }
      ),
      S && /* @__PURE__ */ K.jsx(
        Hfe,
        {
          filePath: S,
          acceptAudio: c,
          changeAudioButtonText: u,
          disabled: f,
          handleSelectFile: $,
          isLoading: L,
          reSendAudio: V && y ? () => B(y) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ K.jsx(Ufe, { error: V })
  ] });
}
function $f(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: s,
    rightIcon: a,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, m = { xs: 12, sm: 16, md: 20, lg: 24 }[i], h = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ K.jsxs("button", { className: h, disabled: l || t, ...p, children: [
    /* @__PURE__ */ K.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ K.jsx(ri, { size: m, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ K.jsxs("div", { className: "arkynButtonContent", children: [
      Ed(m, s),
      c,
      Ed(m, a)
    ] })
  ] });
}
function lU() {
  const e = C0(), t = nI(), n = rI(), [r, o] = P(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function s() {
    r && o(null);
  }
  v(() => {
    var c, p;
    let u = ((p = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : p.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, e]), v(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && s();
  }, [n, t]);
  const a = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(a || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const uU = Ge({});
function c_(e) {
  var p;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = lU(), s = Qe(null), a = ((p = s.current) == null ? void 0 : p.name) || "", l = (i == null ? void 0 : i[a]) || null, u = G$(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ K.jsx(uU.Provider, { value: { error: l, id: u, inputRef: s }, children: /* @__PURE__ */ K.jsx(
    "section",
    {
      id: r || a || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function uo() {
  return xe(uU);
}
function i1e(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: s = null,
    onCheck: a,
    value: l,
    ...u
  } = e, { id: c, inputRef: p, error: d } = uo(), m = o || !!d, [f, g] = P(i || !1), h = typeof s == "boolean" ? s : f, D = `arkynCheckbox ${r} ${m ? "errorTrue" : "errorFalse"} ${h ? "checkedTrue" : "checkedFalse"} ${n}`;
  function O() {
    const y = f;
    g(!y), a && a(y ? "" : l || "checked");
  }
  return /* @__PURE__ */ K.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: D,
      onClick: O,
      ...u,
      children: [
        /* @__PURE__ */ K.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: p,
            value: h ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ K.jsx(b0, {})
      ]
    }
  );
}
function s1e(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = uo();
  return t ? /* @__PURE__ */ K.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ K.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ K.jsx(K.Fragment, {});
}
function p_(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = uo(), s = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ K.jsx("label", { className: s.trim(), htmlFor: o, ...r });
}
function Zfe(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: s,
    className: a = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, p = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${a}`;
  return /* @__PURE__ */ K.jsxs(
    "button",
    {
      disabled: s || t,
      className: p.trim(),
      ...l,
      children: [
        /* @__PURE__ */ K.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ K.jsx(ri, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ K.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ K.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function qfe(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...s
  } = e, a = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ K.jsxs("div", { className: a.trim(), ...s, children: [
    r,
    /* @__PURE__ */ K.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function Gfe(e) {
  const {
    disabled: t,
    filePath: n,
    isLoading: r,
    acceptImage: o,
    changeImageButtonText: i,
    handleSelectFile: s,
    reSendImage: a
  } = e;
  function l() {
    if (t) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = o, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && s(p);
    }, u.click();
  }
  return /* @__PURE__ */ K.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${n}")` },
      children: [
        a && /* @__PURE__ */ K.jsx(qfe, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ K.jsx(
          Zfe,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: r,
            onClick: a,
            icon: QB,
            disabled: t
          }
        ) }),
        /* @__PURE__ */ K.jsx(
          $f,
          {
            isLoading: r,
            onClick: l,
            variant: "outline",
            size: "sm",
            type: "button",
            disabled: t,
            children: i
          }
        )
      ]
    }
  );
}
function Yfe(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ K.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ K.jsx(K.Fragment, {});
}
function Kfe(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ K.jsx("strong", { className: o.trim(), children: t });
}
function Jfe(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i,
    disabled: s
  } = e;
  function a(u) {
    if (s) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (s) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ K.jsxs("div", { onDrop: a, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ K.jsx(
      $f,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: s,
        children: i
      }
    ),
    /* @__PURE__ */ K.jsx("p", { children: t })
  ] });
}
function Xfe(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: s = "file",
    method: a = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: p = "Selecionar imagem",
    dropImageText: d = "Ou arraste e solte a imagem aqui",
    onUpload: m,
    disabled: f = !1
  } = e, h = lU()[t], [x, w] = P(n), [D, O] = P(""), [y, C] = P(null), [S, U] = P(n), [L, F] = P(!1);
  async function B(J) {
    if (f) return;
    F(!0), C(J), O("");
    const te = new FormData();
    te.append(s, J), await fetch(i, { method: a, body: te }).then(async (ee) => await ee.json()).then((ee) => {
      ee != null && ee.error ? O(ee.error) : w(ee == null ? void 0 : ee[u]), m && m(ee == null ? void 0 : ee[u]);
    }).catch((ee) => {
      console.error(ee), O("Erro ao enviar imagem");
    }).finally(() => F(!1));
  }
  function $(J) {
    f || (U(URL.createObjectURL(J)), B(J));
  }
  const V = h || D, X = `arkynImageUpload ${V ? "hasError" : "noHasError"} ${S ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ K.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ K.jsx(Kfe, { label: r, showAsterisk: o }),
    /* @__PURE__ */ K.jsxs("div", { className: X, children: [
      /* @__PURE__ */ K.jsx("input", { type: "hidden", name: t, value: x || "" }),
      !S && /* @__PURE__ */ K.jsx(
        Jfe,
        {
          disabled: f,
          isLoading: L,
          acceptImage: l,
          dropImageText: d,
          handleSelectFile: $,
          selectImageButtonText: p
        }
      ),
      S && /* @__PURE__ */ K.jsx(
        Gfe,
        {
          disabled: f,
          isLoading: L,
          acceptImage: l,
          filePath: S,
          handleSelectFile: $,
          changeImageButtonText: c,
          reSendImage: V && y ? () => B(y) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ K.jsx(Yfe, { error: V })
  ] });
}
function ys(e, t, n) {
  if (!e) return /* @__PURE__ */ K.jsx(K.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ K.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ K.jsx("p", { className: n, children: /* @__PURE__ */ K.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function QC(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function cU(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function pU(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const e1 = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, dU = QC(e1.CNPJ).length;
function Qfe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    defaultValue: d,
    readOnly: m,
    onFocus: f,
    onBlur: g,
    title: h,
    style: x,
    onChange: w,
    ...D
  } = e;
  function O(z) {
    let q = QC(z);
    const X = pU(q);
    if (!(q.length > dU))
      return q = cU(q, e1[X]), q;
  }
  const y = c ? "right" : "left", B = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || m || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: B,
    prefix: ys(a, V, "prefix"),
    sufix: ys(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: O(d || ""),
    disabled: p,
    readOnly: m,
    onFocus: f,
    onBlur: g,
    title: h,
    style: x,
    onChange: w,
    loadingPosition: y,
    iconSize: V,
    Spinner: /* @__PURE__ */ K.jsx(ri, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...D
  };
}
function ehe(e) {
  const [t, n] = P(!1), r = Qe(null), { inputRef: o, id: i, error: s } = uo(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: m,
    sufix: f,
    iconSize: g,
    loadingPosition: h,
    isLoading: x,
    LeftIcon: w,
    readOnly: D,
    onFocus: O,
    onBlur: y,
    RightIcon: C,
    Spinner: S,
    onChange: U,
    value: L,
    defaultValue: F,
    ...B
  } = Qfe({ ...e, id: i, isError: l }, t), [$, V] = P(F), z = w && !x, q = C && !x, X = h === "left" && x, J = h === "right" && x;
  function te() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function ee(H) {
    let M = QC(H.target.value);
    const Z = pU(M);
    M.length > dU || (M = cU(M, e1[Z]), H.target.value = M, V(M), U && U(H));
  }
  function k(H) {
    n(!0), O && O(H);
  }
  function j(H) {
    n(!1), y && y(H);
  }
  return /* @__PURE__ */ K.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: te,
      className: d,
      children: [
        m,
        X && S,
        z && /* @__PURE__ */ K.jsx(w, { size: g, strokeWidth: 2.5 }),
        /* @__PURE__ */ K.jsx(
          "input",
          {
            disabled: u || x,
            readOnly: D,
            ref: a,
            value: L || $,
            onFocus: k,
            onChange: ee,
            onBlur: j,
            ...B
          }
        ),
        q && /* @__PURE__ */ K.jsx(C, { size: g, strokeWidth: 2.5 }),
        J && S,
        f
      ]
    }
  );
}
const the = 3, nhe = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? the : 0), qp = 2, d_ = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), e0 = (e) => {
  let t = e;
  return typeof e == "string" ? (t = d_(e), t % 1 !== 0 && (t = t.toFixed(qp))) : t = Number.isInteger(e) ? Number(e) * 10 ** qp : e.toFixed(qp), d_(t) / 10 ** qp;
}, f_ = (e, t, n) => {
  if (!t) return [0, ""];
  const r = e0(t), o = nhe(e, r, n);
  return [r, o];
};
function rhe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    // showCents = false,
    max: x = 1e9,
    locale: w = "pt-BR",
    currency: D = "BRL",
    ...O
  } = e, y = c ? "right" : "left", B = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: B,
    prefix: ys(a, V, "prefix"),
    sufix: ys(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    locale: w,
    currency: D,
    readOnly: d,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    max: x,
    // showCents,
    loadingPosition: y,
    iconSize: V,
    Spinner: /* @__PURE__ */ K.jsx(ri, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...O
  };
}
function ohe(e) {
  const [t, n] = P(!1), [r, o] = P("0"), i = Qe(null), { inputRef: s, id: a, error: l } = uo(), u = s || i, c = e.isError || !!l, {
    disabled: p,
    title: d,
    style: m,
    className: f,
    prefix: g,
    sufix: h,
    iconSize: x,
    loadingPosition: w,
    isLoading: D,
    LeftIcon: O,
    readOnly: y,
    onFocus: C,
    onBlur: S,
    RightIcon: U,
    Spinner: L,
    value: F,
    max: B,
    onChangeValue: $,
    onKeyPress: V,
    currency: z,
    locale: q,
    name: X,
    defaultValue: J,
    ...te
  } = rhe({ ...e, id: a, isError: c }, t), ee = O && !D, k = U && !D, j = w === "left" && D, H = w === "right" && D;
  function M() {
    p || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function Z(W) {
    n(!0), C && C(W);
  }
  function E(W) {
    n(!1), S && S(W);
  }
  const T = (W) => {
    const [A, Q] = f_(
      q,
      W,
      z
    );
    return !B || A <= B ? (o(Q), [A, Q]) : [e0(r), r];
  }, R = (W) => {
    W.preventDefault();
    const [A, Q] = T(W.target.value);
    $ && $(W, String(A), String(Q));
  }, _ = (W) => V && V(W, W.key, W.key);
  return v(() => {
    const W = F || +J || void 0, [, A] = f_(q, W, z);
    o(A);
  }, [z, J, F]), /* @__PURE__ */ K.jsxs(
    "section",
    {
      title: d,
      style: m,
      onClick: M,
      className: f,
      children: [
        g,
        j && L,
        ee && /* @__PURE__ */ K.jsx(O, { size: x, strokeWidth: 2.5 }),
        /* @__PURE__ */ K.jsx(
          "input",
          {
            value: r,
            onChange: R,
            onBlur: E,
            onFocus: Z,
            onKeyUp: _,
            disabled: p || D,
            readOnly: y,
            ...te
          }
        ),
        /* @__PURE__ */ K.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: X,
            value: e0(r)
          }
        ),
        H && L,
        k && /* @__PURE__ */ K.jsx(U, { size: x, strokeWidth: 2.5 }),
        h
      ]
    }
  );
}
function ihe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    onChange: x,
    showMask: w = !1,
    type: D,
    ...O
  } = e, y = c ? "right" : "left", B = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: B,
    prefix: ys(a, V, "prefix"),
    sufix: ys(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    onChange: x,
    loadingPosition: y,
    iconSize: V,
    showMask: w,
    Spinner: /* @__PURE__ */ K.jsx(ri, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...O
  };
}
const she = Da((e, t) => /* @__PURE__ */ K.jsx("input", { ref: t, ...e }));
function ahe(e) {
  const [t, n] = P(!1), r = Qe(null), { inputRef: o, id: i, error: s } = uo(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: m,
    sufix: f,
    iconSize: g,
    loadingPosition: h,
    isLoading: x,
    LeftIcon: w,
    readOnly: D,
    onFocus: O,
    onBlur: y,
    RightIcon: C,
    Spinner: S,
    ...U
  } = ihe({ ...e, id: i, isError: l }, t), L = w && !x, F = C && !x, B = h === "left" && x, $ = h === "right" && x;
  function V() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function z(X) {
    n(!0), O && O(X);
  }
  function q(X) {
    n(!1), y && y(X);
  }
  return /* @__PURE__ */ K.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: V,
      className: d,
      children: [
        m,
        B && S,
        L && /* @__PURE__ */ K.jsx(w, { size: g, strokeWidth: 2.5 }),
        /* @__PURE__ */ K.jsx(
          m3,
          {
            component: she,
            ref: a,
            onFocus: z,
            onBlur: q,
            disabled: u,
            ...U
          }
        ),
        F && /* @__PURE__ */ K.jsx(C, { size: g, strokeWidth: 2.5 }),
        $ && S,
        f
      ]
    }
  );
}
function lhe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    onChange: x,
    ...w
  } = e, D = c ? "right" : "left", L = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, B = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: L,
    prefix: ys(a, B, "prefix"),
    sufix: ys(l, B, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    onChange: x,
    loadingPosition: D,
    iconSize: B,
    Spinner: /* @__PURE__ */ K.jsx(ri, { className: "spinner", size: B, strokeWidth: 2.5 }),
    ...w
  };
}
function uhe(e) {
  const [t, n] = P(!1), r = Qe(null), { inputRef: o, id: i, error: s } = uo(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: m,
    sufix: f,
    iconSize: g,
    loadingPosition: h,
    isLoading: x,
    LeftIcon: w,
    readOnly: D,
    onFocus: O,
    onBlur: y,
    RightIcon: C,
    type: S,
    Spinner: U,
    ...L
  } = lhe({ ...e, id: i, isError: l }, t), F = w && !x, B = C && !x, $ = h === "left" && x, V = h === "right" && x;
  function z() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function q(J) {
    n(!0), O && O(J);
  }
  function X(J) {
    n(!1), y && y(J);
  }
  return S === "hidden" ? /* @__PURE__ */ K.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: a,
      ...L
    }
  ) : /* @__PURE__ */ K.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: z,
      className: d,
      children: [
        m,
        $ && U,
        F && /* @__PURE__ */ K.jsx(w, { size: g, strokeWidth: 2.5 }),
        /* @__PURE__ */ K.jsx(
          "input",
          {
            disabled: u || x,
            readOnly: D,
            ref: a,
            onFocus: q,
            onBlur: X,
            type: S,
            ...L
          }
        ),
        B && /* @__PURE__ */ K.jsx(C, { size: g, strokeWidth: 2.5 }),
        V && U,
        f
      ]
    }
  );
}
function Hg(e) {
  return e.type === "currency" ? /* @__PURE__ */ K.jsx(ohe, { ...e }) : e.type === "masked" ? /* @__PURE__ */ K.jsx(ahe, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ K.jsx(ehe, { ...e }) : /* @__PURE__ */ K.jsx(uhe, { ...e });
}
function che(e) {
  const { iconSize: t, isLoading: n, disabled: r, readOnly: o, isFocused: i } = e, l = `arkynMultiSelectChevron ${r || o ? "notAnimate" : ""} ${i ? "focused" : ""}`;
  return n ? /* @__PURE__ */ K.jsx(K.Fragment, {}) : /* @__PURE__ */ K.jsx(eI, { className: l, size: t, strokeWidth: 2.5 });
}
function phe(e) {
  const {
    children: t,
    handleContainerFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: s,
    className: a,
    readOnly: l,
    variant: u,
    size: c,
    id: p,
    prefixExists: d
  } = e, m = d ? "hasPrefix" : "", f = o ? "errored" : "", g = r || l || i ? "opacity" : "", h = s ? "focused" : "";
  return /* @__PURE__ */ K.jsx(
    "section",
    {
      onClick: n,
      id: p,
      className: `arkynMultiSelectContainer ${m} ${u} ${c} ${g} ${f} ${h} ${a}`,
      children: t
    }
  );
}
function dhe(e) {
  const { children: t, size: n } = e, r = `arkynMultiSelectContent ${n}`;
  return /* @__PURE__ */ K.jsx("div", { className: r, children: t });
}
function fhe(e) {
  const { label: t, value: n, handleChangeValue: r } = e;
  return /* @__PURE__ */ K.jsxs("div", { className: "arkynMultiSelectMark", children: [
    t,
    /* @__PURE__ */ K.jsx(
      "button",
      {
        type: "button",
        onClick: (o) => {
          o.stopPropagation(), r(n);
        },
        children: /* @__PURE__ */ K.jsx(w0, {})
      }
    )
  ] });
}
function hhe(e) {
  const { label: t, optionHasSelected: n, handleChangeValue: r, value: o, size: i } = e, s = n(o) ? "active" : "", a = `arkynMultiSelectOption ${i} ${s}`;
  return /* @__PURE__ */ K.jsxs("div", { onClick: () => r(o), className: a, children: [
    t,
    " ",
    /* @__PURE__ */ K.jsx(b0, {})
  ] });
}
function ghe(e) {
  const { children: t, isFocused: n, isSearchable: r, onSearch: o } = e;
  function i(s) {
    r && o(s.target.value);
  }
  return n ? /* @__PURE__ */ K.jsxs("div", { className: "arkynMultiSelectOptionsContainer", children: [
    r && /* @__PURE__ */ K.jsx(
      Hg,
      {
        type: "search",
        name: "search-select",
        variant: "underline",
        leftIcon: tI,
        onChange: i
      }
    ),
    t
  ] }) : /* @__PURE__ */ K.jsx(K.Fragment, {});
}
function mhe(e) {
  const { isFocused: t, handleBlur: n } = e;
  return t ? /* @__PURE__ */ K.jsx("aside", { className: "arkynMultiSelectOverlay", onClick: n }) : /* @__PURE__ */ K.jsx(K.Fragment, {});
}
function vhe(e) {
  const { iconSize: t, isLoading: n } = e;
  return n ? /* @__PURE__ */ K.jsx(
    ri,
    {
      className: "arkynMultiSelectSpinner",
      size: t,
      strokeWidth: 2.5
    }
  ) : /* @__PURE__ */ K.jsx(K.Fragment, {});
}
function a1e(e) {
  const {
    name: t,
    options: n,
    className: r = "",
    placeholder: o = "Selecione...",
    closeOnSelect: i = !1,
    defaultValue: s = [],
    isError: a,
    isLoading: l = !1,
    readOnly: u = !1,
    isSearchable: c = !1,
    leftIcon: p,
    onSearch: d,
    onSelect: m,
    onBlur: f,
    notFoundText: g = "Sem opções disponíveis",
    onFocus: h,
    disabled: x = !1,
    prefix: w,
    size: D = "md",
    value: O,
    variant: y = "solid"
  } = e, C = uo(), S = Qe(null), U = C.inputRef || S, L = C.id, F = a || !!C.error, $ = { md: 20, lg: 20 }[D], V = FI(w, $, "prefix"), [z, q] = P(""), [X, J] = P(!1), [te, ee] = P(s), k = O || te;
  function j(_) {
    return k.includes(_);
  }
  function H(_) {
    const W = n.find((A) => A.value === _);
    return (W == null ? void 0 : W.label) || "";
  }
  function M() {
    x || !(U != null && U.current) || X || (J(!0), U.current.focus(), h && h());
  }
  function Z() {
    J(!1), f && U.current && U.current.blur();
  }
  function E(_) {
    q(_), d && d(_);
  }
  function T(_) {
    j(_) ? ee(te.filter((W) => W !== _)) : ee([...te, _]), m && m(te), i && Z();
  }
  const R = n.filter((_) => !!(e.onSearch || !e.isSearchable || _.label.toLowerCase().includes(z.toLowerCase())));
  return /* @__PURE__ */ K.jsxs(
    phe,
    {
      handleContainerFocus: M,
      disabled: x,
      isError: F,
      isFocused: X,
      isLoading: l,
      readOnly: u,
      size: D,
      variant: y,
      className: r,
      prefixExists: !!w,
      id: L,
      children: [
        /* @__PURE__ */ K.jsx(
          "input",
          {
            ref: U,
            name: t,
            value: JSON.stringify(k),
            type: "hidden"
          }
        ),
        V,
        p && /* @__PURE__ */ K.jsx(p, { size: $, strokeWidth: 2.5 }),
        /* @__PURE__ */ K.jsxs(dhe, { size: D, children: [
          k.map((_) => /* @__PURE__ */ K.jsx(
            fhe,
            {
              label: H(_),
              value: _,
              handleChangeValue: T
            },
            _
          )),
          k.length <= 0 && /* @__PURE__ */ K.jsx("p", { children: o })
        ] }),
        /* @__PURE__ */ K.jsxs(
          ghe,
          {
            isFocused: X,
            isSearchable: c,
            onSearch: E,
            children: [
              R.map(({ label: _, value: W }) => /* @__PURE__ */ K.jsx(
                hhe,
                {
                  label: _,
                  value: W,
                  size: D,
                  handleChangeValue: T,
                  optionHasSelected: j
                },
                W
              )),
              R.length <= 0 && /* @__PURE__ */ K.jsx("p", { children: g })
            ]
          }
        ),
        /* @__PURE__ */ K.jsx(
          che,
          {
            disabled: x,
            isFocused: X,
            readOnly: u,
            iconSize: $,
            isLoading: l
          }
        ),
        /* @__PURE__ */ K.jsx(vhe, { iconSize: $, isLoading: l }),
        /* @__PURE__ */ K.jsx(mhe, { handleBlur: Z, isFocused: X })
      ]
    }
  );
}
const fU = Ge({});
function yhe() {
  return xe(fU);
}
function l1e(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: s = "",
    ...a
  } = e, [l, u] = P(t || ""), { inputRef: c, id: p } = uo();
  function d(f) {
    u(f), o && o(f);
  }
  const m = `arkynRadioGroup ${i} ${s}`;
  return /* @__PURE__ */ K.jsxs(
    fU.Provider,
    {
      value: { onChange: d, value: r || l, size: i },
      children: [
        /* @__PURE__ */ K.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: p,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ K.jsx("div", { className: m.trim(), ...a })
      ]
    }
  );
}
function u1e(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...s
  } = e, { onChange: a, size: l, value: u } = yhe(), { error: c } = uo(), g = `arkynRadioBox ${n || l} ${u === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ K.jsxs("label", { className: g.trim(), children: [
    /* @__PURE__ */ K.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => a(t),
        onFocus: () => a(t),
        ...s
      }
    ),
    o
  ] });
}
var Ui = {};
Object.defineProperty(Ui, "__esModule", {
  value: !0
});
var bhe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Xv = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, hU = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: bhe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, t1 = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Gp = 1; Gp < 20; Gp++)
  t1["f" + Gp] = 111 + Gp;
function Wg(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return gU(s, t);
  }), o = function(a) {
    return r.some(function(l) {
      return mU(l, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function whe(e, t) {
  return Wg(e, t);
}
function Che(e, t) {
  return Wg(e, { byKey: !0 }, t);
}
function gU(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in Xv)
    r[Xv[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, m = d.endsWith("?") && d.length > 1;
      m && (d = d.slice(0, -1));
      var f = n1(d), g = Xv[f];
      if (d.length > 1 && !g && !hU[d] && !t1[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !g) && (n ? r.key = f : r.which = vU(d)), g && (r[g] = m ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function mU(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function vU(e) {
  e = n1(e);
  var t = t1[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function n1(e) {
  return e = e.toLowerCase(), e = hU[e] || e, e;
}
var Ohe = Ui.default = Wg, Qv = Ui.isHotkey = Wg;
Ui.isCodeHotkey = whe;
Ui.isKeyHotkey = Che;
Ui.parseHotkey = gU;
Ui.compareHotkey = mU;
Ui.toKeyCode = vU;
Ui.toKeyName = n1;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function h_(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function xhe(e) {
  var t, n;
  return h_(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(h_(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var Ehe = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return xhe(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || ms.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || ms.isOperationList(e.undos[0].operations));
  }
}, ey = /* @__PURE__ */ new WeakMap(), _l = /* @__PURE__ */ new WeakMap(), la = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return Ehe.isHistory(e.history) && G.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return _l.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return ey.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = la.isMerging(e);
    _l.set(e, !0), t(), _l.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = la.isMerging(e);
    _l.set(e, !1), t(), _l.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = la.isSaving(e);
    ey.set(e, !1), t(), ey.set(e, n);
  }
}, Lhe = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && Ce.setSelection(t, i.selectionBefore), la.withoutSaving(t, () => {
        G.withoutNormalizing(t, () => {
          for (var s of i.operations)
            t.apply(s);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      la.withoutSaving(t, () => {
        G.withoutNormalizing(t, () => {
          var s = i.operations.map(ms.inverse).reverse();
          for (var a of s)
            t.apply(a);
          i.selectionBefore && Ce.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: s
    } = i, a = s[s.length - 1], l = a && a.operations[a.operations.length - 1], u = la.isSaving(t), c = la.isMerging(t);
    if (u == null && (u = khe(r)), u) {
      if (c == null && (a == null ? c = !1 : o.length !== 0 ? c = !0 : c = Phe(r, l)), a && c)
        a.operations.push(r);
      else {
        var p = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", p);
      }
      for (; s.length > 100; )
        s.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, Phe = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && ie.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && ie.equals(e.path, t.path)), khe = (e, t) => e.type !== "set_selection", She = The, yU = "֑-߿יִ-﷽ﹰ-ﻼ", bU = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", Dhe = new RegExp("^[^" + bU + "]*[" + yU + "]"), Mhe = new RegExp("^[^" + yU + "]*[" + bU + "]");
function The(e) {
  return e = String(e || ""), Dhe.test(e) ? "rtl" : Mhe.test(e) ? "ltr" : "neutral";
}
const wU = /* @__PURE__ */ th(She);
function jhe(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var r1 = jhe, _he = typeof En == "object" && En && En.Object === Object && En, Ahe = _he, Bhe = Ahe, Ihe = typeof self == "object" && self && self.Object === Object && self, Nhe = Bhe || Ihe || Function("return this")(), CU = Nhe, Fhe = CU, Rhe = function() {
  return Fhe.Date.now();
}, zhe = Rhe, Uhe = /\s/;
function $he(e) {
  for (var t = e.length; t-- && Uhe.test(e.charAt(t)); )
    ;
  return t;
}
var Vhe = $he, Hhe = Vhe, Whe = /^\s+/;
function Zhe(e) {
  return e && e.slice(0, Hhe(e) + 1).replace(Whe, "");
}
var qhe = Zhe, Ghe = CU, Yhe = Ghe.Symbol, OU = Yhe, g_ = OU, xU = Object.prototype, Khe = xU.hasOwnProperty, Jhe = xU.toString, Al = g_ ? g_.toStringTag : void 0;
function Xhe(e) {
  var t = Khe.call(e, Al), n = e[Al];
  try {
    e[Al] = void 0;
    var r = !0;
  } catch {
  }
  var o = Jhe.call(e);
  return r && (t ? e[Al] = n : delete e[Al]), o;
}
var Qhe = Xhe, ege = Object.prototype, tge = ege.toString;
function nge(e) {
  return tge.call(e);
}
var rge = nge, m_ = OU, oge = Qhe, ige = rge, sge = "[object Null]", age = "[object Undefined]", v_ = m_ ? m_.toStringTag : void 0;
function lge(e) {
  return e == null ? e === void 0 ? age : sge : v_ && v_ in Object(e) ? oge(e) : ige(e);
}
var uge = lge;
function cge(e) {
  return e != null && typeof e == "object";
}
var pge = cge, dge = uge, fge = pge, hge = "[object Symbol]";
function gge(e) {
  return typeof e == "symbol" || fge(e) && dge(e) == hge;
}
var mge = gge, vge = qhe, y_ = r1, yge = mge, b_ = NaN, bge = /^[-+]0x[0-9a-f]+$/i, wge = /^0b[01]+$/i, Cge = /^0o[0-7]+$/i, Oge = parseInt;
function xge(e) {
  if (typeof e == "number")
    return e;
  if (yge(e))
    return b_;
  if (y_(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = y_(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = vge(e);
  var n = wge.test(e);
  return n || Cge.test(e) ? Oge(e.slice(2), n ? 2 : 8) : bge.test(e) ? b_ : +e;
}
var Ege = xge, Lge = r1, ty = zhe, w_ = Ege, Pge = "Expected a function", kge = Math.max, Sge = Math.min;
function Dge(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Pge);
  t = w_(t) || 0, Lge(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? kge(w_(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function m(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, s = e.apply(U, S), s;
  }
  function f(C) {
    return u = C, a = setTimeout(x, t), c ? m(C) : s;
  }
  function g(C) {
    var S = C - l, U = C - u, L = t - S;
    return p ? Sge(L, i - U) : L;
  }
  function h(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function x() {
    var C = ty();
    if (h(C))
      return w(C);
    a = setTimeout(x, g(C));
  }
  function w(C) {
    return a = void 0, d && r ? m(C) : (r = o = void 0, s);
  }
  function D() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function O() {
    return a === void 0 ? s : w(ty());
  }
  function y() {
    var C = ty(), S = h(C);
    if (r = arguments, o = this, l = C, S) {
      if (a === void 0)
        return f(l);
      if (p)
        return clearTimeout(a), a = setTimeout(x, t), m(l);
    }
    return a === void 0 && (a = setTimeout(x, t)), s;
  }
  return y.cancel = D, y.flush = O, y;
}
var EU = Dge;
const Mge = /* @__PURE__ */ th(EU);
var Tge = EU, jge = r1, _ge = "Expected a function";
function Age(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(_ge);
  return jge(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Tge(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var Bge = Age;
const Ige = /* @__PURE__ */ th(Bge), C_ = (e) => typeof e == "object" && e != null && e.nodeType === 1, O_ = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", ny = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return O_(n.overflowY, t) || O_(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, Yp = (e, t, n, r, o, i, s, a) => i < e && s > t || i > e && s < t ? 0 : i <= e && a <= n || s >= t && a >= n ? i - e - r : s > t && a < n || i < e && a > n ? s - t + o : 0, Nge = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, x_ = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: s, block: a, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, p = typeof u == "function" ? u : (X) => X !== u;
  if (!C_(e)) throw new TypeError("Invalid target");
  const d = document.scrollingElement || document.documentElement, m = [];
  let f = e;
  for (; C_(f) && p(f); ) {
    if (f = Nge(f), f === d) {
      m.push(f);
      break;
    }
    f != null && f === document.body && ny(f) && !ny(document.documentElement) || f != null && ny(f, c) && m.push(f);
  }
  const g = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, h = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: x, scrollY: w } = window, { height: D, width: O, top: y, right: C, bottom: S, left: U } = e.getBoundingClientRect(), { top: L, right: F, bottom: B, left: $ } = ((X) => {
    const J = window.getComputedStyle(X);
    return { top: parseFloat(J.scrollMarginTop) || 0, right: parseFloat(J.scrollMarginRight) || 0, bottom: parseFloat(J.scrollMarginBottom) || 0, left: parseFloat(J.scrollMarginLeft) || 0 };
  })(e);
  let V = a === "start" || a === "nearest" ? y - L : a === "end" ? S + B : y + D / 2 - L + B, z = l === "center" ? U + O / 2 - $ + F : l === "end" ? C + F : U - $;
  const q = [];
  for (let X = 0; X < m.length; X++) {
    const J = m[X], { height: te, width: ee, top: k, right: j, bottom: H, left: M } = J.getBoundingClientRect();
    if (s === "if-needed" && y >= 0 && U >= 0 && S <= h && C <= g && y >= k && S <= H && U >= M && C <= j) return q;
    const Z = getComputedStyle(J), E = parseInt(Z.borderLeftWidth, 10), T = parseInt(Z.borderTopWidth, 10), R = parseInt(Z.borderRightWidth, 10), _ = parseInt(Z.borderBottomWidth, 10);
    let W = 0, A = 0;
    const Q = "offsetWidth" in J ? J.offsetWidth - J.clientWidth - E - R : 0, N = "offsetHeight" in J ? J.offsetHeight - J.clientHeight - T - _ : 0, ue = "offsetWidth" in J ? J.offsetWidth === 0 ? 0 : ee / J.offsetWidth : 0, ye = "offsetHeight" in J ? J.offsetHeight === 0 ? 0 : te / J.offsetHeight : 0;
    if (d === J) W = a === "start" ? V : a === "end" ? V - h : a === "nearest" ? Yp(w, w + h, h, T, _, w + V, w + V + D, D) : V - h / 2, A = l === "start" ? z : l === "center" ? z - g / 2 : l === "end" ? z - g : Yp(x, x + g, g, E, R, x + z, x + z + O, O), W = Math.max(0, W + w), A = Math.max(0, A + x);
    else {
      W = a === "start" ? V - k - T : a === "end" ? V - H + _ + N : a === "nearest" ? Yp(k, H, te, T, _ + N, V, V + D, D) : V - (k + te / 2) + N / 2, A = l === "start" ? z - M - E : l === "center" ? z - (M + ee / 2) + Q / 2 : l === "end" ? z - j + R + Q : Yp(M, j, ee, E, R + Q, z, z + O, O);
      const { scrollLeft: oe, scrollTop: Ie } = J;
      W = ye === 0 ? 0 : Math.max(0, Math.min(Ie + W / ye, J.scrollHeight - te / ye + N)), A = ue === 0 ? 0 : Math.max(0, Math.min(oe + A / ue, J.scrollWidth - ee / ue + Q)), V += Ie - W, z += oe - A;
    }
    q.push({ el: J, top: W, left: A });
  }
  return q;
}, Fge = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function Rge(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior(x_(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: s } of x_(e, Fge(t))) {
    const a = i - n.top + n.bottom, l = s - n.left + n.right;
    o.scroll({ top: a, left: l, behavior: r });
  }
}
var pa = [], zge = function() {
  return pa.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Uge = function() {
  return pa.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, E_ = "ResizeObserver loop completed with undelivered notifications.", $ge = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: E_
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = E_), window.dispatchEvent(e);
}, Hu;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Hu || (Hu = {}));
var da = function(e) {
  return Object.freeze(e);
}, Vge = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, da(this);
  }
  return e;
}(), LU = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, da(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), o1 = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, PU = function(e) {
  if (o1(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, s = o.offsetHeight;
  return !(i || s || e.getClientRects().length);
}, L_ = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, Hge = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, du = typeof window < "u" ? window : {}, Kp = /* @__PURE__ */ new WeakMap(), P_ = /auto|scroll/, Wge = /^tb|vertical/, Zge = /msie|trident/i.test(du.navigator && du.navigator.userAgent), Ho = function(e) {
  return parseFloat(e || "0");
}, Fa = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Vge((n ? t : e) || 0, (n ? e : t) || 0);
}, k_ = da({
  devicePixelContentBoxSize: Fa(),
  borderBoxSize: Fa(),
  contentBoxSize: Fa(),
  contentRect: new LU(0, 0, 0, 0)
}), kU = function(e, t) {
  if (t === void 0 && (t = !1), Kp.has(e) && !t)
    return Kp.get(e);
  if (PU(e))
    return Kp.set(e, k_), k_;
  var n = getComputedStyle(e), r = o1(e) && e.ownerSVGElement && e.getBBox(), o = !Zge && n.boxSizing === "border-box", i = Wge.test(n.writingMode || ""), s = !r && P_.test(n.overflowY || ""), a = !r && P_.test(n.overflowX || ""), l = r ? 0 : Ho(n.paddingTop), u = r ? 0 : Ho(n.paddingRight), c = r ? 0 : Ho(n.paddingBottom), p = r ? 0 : Ho(n.paddingLeft), d = r ? 0 : Ho(n.borderTopWidth), m = r ? 0 : Ho(n.borderRightWidth), f = r ? 0 : Ho(n.borderBottomWidth), g = r ? 0 : Ho(n.borderLeftWidth), h = p + u, x = l + c, w = g + m, D = d + f, O = a ? e.offsetHeight - D - e.clientHeight : 0, y = s ? e.offsetWidth - w - e.clientWidth : 0, C = o ? h + w : 0, S = o ? x + D : 0, U = r ? r.width : Ho(n.width) - C - y, L = r ? r.height : Ho(n.height) - S - O, F = U + h + y + w, B = L + x + O + D, $ = da({
    devicePixelContentBoxSize: Fa(Math.round(U * devicePixelRatio), Math.round(L * devicePixelRatio), i),
    borderBoxSize: Fa(F, B, i),
    contentBoxSize: Fa(U, L, i),
    contentRect: new LU(p, l, U, L)
  });
  return Kp.set(e, $), $;
}, SU = function(e, t, n) {
  var r = kU(e, n), o = r.borderBoxSize, i = r.contentBoxSize, s = r.devicePixelContentBoxSize;
  switch (t) {
    case Hu.DEVICE_PIXEL_CONTENT_BOX:
      return s;
    case Hu.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, qge = /* @__PURE__ */ function() {
  function e(t) {
    var n = kU(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = da([n.borderBoxSize]), this.contentBoxSize = da([n.contentBoxSize]), this.devicePixelContentBoxSize = da([n.devicePixelContentBoxSize]);
  }
  return e;
}(), DU = function(e) {
  if (PU(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, Gge = function() {
  var e = 1 / 0, t = [];
  pa.forEach(function(s) {
    if (s.activeTargets.length !== 0) {
      var a = [];
      s.activeTargets.forEach(function(u) {
        var c = new qge(u.target), p = DU(u.target);
        a.push(c), u.lastReportedSize = SU(u.target, u.observedBox), p < e && (e = p);
      }), t.push(function() {
        s.callback.call(s.observer, a, s.observer);
      }), s.activeTargets.splice(0, s.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, S_ = function(e) {
  pa.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (DU(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, Yge = function() {
  var e = 0;
  for (S_(e); zge(); )
    e = Gge(), S_(e);
  return Uge() && $ge(), e > 0;
}, ry, MU = [], Kge = function() {
  return MU.splice(0).forEach(function(e) {
    return e();
  });
}, Jge = function(e) {
  if (!ry) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return Kge();
    }).observe(n, r), ry = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  MU.push(e), ry();
}, Xge = function(e) {
  Jge(function() {
    requestAnimationFrame(e);
  });
}, md = 0, Qge = function() {
  return !!md;
}, eme = 250, tme = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, D_ = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], M_ = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, oy = !1, nme = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = eme), !oy) {
      oy = !0;
      var r = M_(t);
      Xge(function() {
        var o = !1;
        try {
          o = Yge();
        } finally {
          if (oy = !1, t = r - M_(), !Qge())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, tme);
    };
    document.body ? n() : du.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), D_.forEach(function(n) {
      return du.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), D_.forEach(function(n) {
      return du.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), t0 = new nme(), T_ = function(e) {
  !md && e > 0 && t0.start(), md += e, !md && t0.stop();
}, rme = function(e) {
  return !o1(e) && !Hge(e) && getComputedStyle(e).display === "inline";
}, ome = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || Hu.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = SU(this.target, this.observedBox, !0);
    return rme(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), ime = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Jp = /* @__PURE__ */ new WeakMap(), j_ = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Xp = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new ime(t, n);
    Jp.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = Jp.get(t), i = o.observationTargets.length === 0;
    j_(o.observationTargets, n) < 0 && (i && pa.push(o), o.observationTargets.push(new ome(n, r && r.box)), T_(1), t0.schedule());
  }, e.unobserve = function(t, n) {
    var r = Jp.get(t), o = j_(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && pa.splice(pa.indexOf(r), 1), r.observationTargets.splice(o, 1), T_(-1));
  }, e.disconnect = function(t) {
    var n = this, r = Jp.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), sme = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Xp.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!L_(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Xp.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!L_(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Xp.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Xp.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function ame(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Za(e, t) {
  if (e == null) return {};
  var n = ame(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function Wu(e) {
  "@babel/helpers - typeof";
  return Wu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Wu(e);
}
function lme(e, t) {
  if (Wu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Wu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function ume(e) {
  var t = lme(e, "string");
  return Wu(t) === "symbol" ? t : String(t);
}
function No(e, t, n) {
  return t = ume(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var i1 = /* @__PURE__ */ Ge(null), As = () => {
  var e = xe(i1);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, iy, sy, TU = parseInt(Ee.version.split(".")[0], 10), jU = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, __ = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), zr = typeof navigator < "u" && /Android/.test(navigator.userAgent), _a = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Xs = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), cme = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), _U = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), pme = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), dme = zr && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), fme = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), hme = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), gme = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), vd = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((iy = navigator.userAgent.match(/Version\/(\d+)/)) !== null && iy !== void 0 && iy[1] && parseInt((sy = navigator.userAgent.match(/Version\/(\d+)/)) === null || sy === void 0 ? void 0 : sy[1], 10) < 17);
var Ki = (!pme || !dme) && !cme && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", Ra = /* @__PURE__ */ new WeakMap(), s1 = /* @__PURE__ */ new WeakMap(), a1 = /* @__PURE__ */ new WeakMap(), AU = /* @__PURE__ */ new WeakMap(), yd = /* @__PURE__ */ new WeakMap(), n0 = /* @__PURE__ */ new WeakMap(), Zu = /* @__PURE__ */ new WeakMap(), fa = /* @__PURE__ */ new WeakMap(), Vf = /* @__PURE__ */ new WeakMap(), Zg = /* @__PURE__ */ new WeakMap(), r0 = /* @__PURE__ */ new WeakMap(), vs = /* @__PURE__ */ new WeakMap(), ua = /* @__PURE__ */ new WeakMap(), fu = /* @__PURE__ */ new WeakMap(), o0 = /* @__PURE__ */ new WeakMap(), l1 = /* @__PURE__ */ new WeakMap(), Fo = /* @__PURE__ */ new WeakMap(), Mi = /* @__PURE__ */ new WeakMap(), Yr = /* @__PURE__ */ new WeakMap(), ls = /* @__PURE__ */ new WeakMap(), us = /* @__PURE__ */ new WeakMap(), BU = /* @__PURE__ */ new WeakMap(), qa = Symbol("placeholder"), IU = Symbol("mark-placeholder"), NU = globalThis.Node, mme = globalThis.Text, u1 = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, vme = (e) => bs(e) && e.nodeType === 8, Io = (e) => bs(e) && e.nodeType === 1, bs = (e) => {
  var t = u1(e);
  return !!t && e instanceof t.Node;
}, i0 = (e) => {
  var t = e && e.anchorNode && u1(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, FU = (e) => bs(e) && e.nodeType === 3, yme = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, bme = (e) => {
  var [t, n] = e;
  if (Io(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = RU(t, o, r ? "backward" : "forward"), r = o < n; Io(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = Cme(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, wme = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, RU = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (vme(o) || Io(o) && o.childNodes.length === 0 || Io(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, Cme = (e, t, n) => {
  var [r] = RU(e, t, n);
  return r;
}, zU = (e) => {
  var t = "";
  if (FU(e) && e.nodeValue)
    return e.nodeValue;
  if (Io(e)) {
    for (var n of Array.from(e.childNodes))
      t += zU(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, Ome = /data-slate-fragment="(.+?)"/m, xme = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(Ome) || [];
  return n;
}, hu = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), c1 = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Io(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = fe.getWindow(e);
  if (o.contains(r))
    return fe.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : c1(e, i, n);
}, Eme = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, A_ = (e, t) => !!(e.compareDocumentPosition(t) & NU.DOCUMENT_POSITION_PRECEDING), Lme = (e, t) => !!(e.compareDocumentPosition(t) & NU.DOCUMENT_POSITION_FOLLOWING), Pme = 0;
class kme {
  constructor() {
    No(this, "id", void 0), this.id = "".concat(Pme++);
  }
}
var fe = {
  androidPendingDiffs: (e) => Yr.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = l1.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = fe.toDOMNode(e, e), n = fe.findDocumentOrShadowRoot(e);
    vs.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = fe.findDocumentOrShadowRoot(e), r = hu(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Ce.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = fe.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = fe.toSlateNode(e, t.target), s = fe.findPath(e, i);
    if (We.isElement(i) && G.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = G.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? G.before(e, u) : G.after(e, u);
      if (c) {
        var p = G.range(e, c);
        return p;
      }
    }
    var d, {
      document: m
    } = fe.getWindow(e);
    if (m.caretRangeFromPoint)
      d = m.caretRangeFromPoint(n, r);
    else {
      var f = m.caretPositionFromPoint(n, r);
      f && (d = m.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var g = fe.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return g;
  },
  findKey: (e, t) => {
    var n = Vf.get(t);
    return n || (n = new kme(), Vf.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = a1.get(r);
      if (o == null) {
        if (G.isEditor(r))
          return n;
        break;
      }
      var i = s1.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Sr.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!vs.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          fe.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = fe.toDOMNode(t, t), o = fe.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = hu(o), s = fe.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(s);
        }
        t.selection || Ce.select(t, G.start(t, [])), vs.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = AU.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = fe.toDOMNode(t, t), s;
    try {
      s = Io(n) ? n : n.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return s ? s.closest("[data-slate-editor]") === i && (!o || s.isContentEditable ? !0 : typeof s.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    s.closest('[contenteditable="false"]') === i || !!s.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => bs(t) && fe.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return G.hasPath(e, n.path) && G.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => fe.hasEditableTarget(e, t) || fe.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => bs(t) && fe.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!ua.get(e),
  isFocused: (e) => !!vs.get(e),
  isReadOnly: (e) => !!r0.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (r0.get(e)) return !1;
    var n = fe.hasTarget(e, t) && fe.toSlateNode(e, t);
    return We.isElement(n) && G.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Zg.get(e), r = G.isEditor(t) ? yd.get(e) : n == null ? void 0 : n.get(fe.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Sr.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = G.node(e, t.path), r = fe.toDOMNode(e, n), o;
    G.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), m = d == null ? p : parseInt(d, 10), f = a + m, g = s[l + 1];
        if (t.offset === f && g !== null && g !== void 0 && g.hasAttribute("data-slate-mark-placeholder")) {
          var h, x = g.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            x instanceof mme ? x : g,
            (h = g.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Sr.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = pe.isBackward(t), i = fe.toDOMPoint(e, n), s = pe.isCollapsed(t) ? i : fe.toDOMPoint(e, r), a = fe.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, m = Io(u) ? u : u.parentElement, f = !!m.getAttribute("data-slate-zero-width"), g = Io(p) ? p : p.parentElement, h = !!g.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Io(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Zu.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : bme(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, m = fe.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), g = f && m.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), x = h && m.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = fe.getWindow(e), y = O.document.createRange();
          y.setStart(u, 0), y.setEnd(s, a);
          var C = y.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (zr && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (g) {
        for (var U = g.querySelectorAll("[data-slate-leaf]"), L = 0; L < U.length; L++) {
          var F = U[L];
          if (fe.hasDOMNode(e, F)) {
            w = F;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (x) {
        var B = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = x.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...B($), ...B($ == null ? void 0 : $.nextElementSibling)];
          w = (V = z.find((M) => Lme(x, M))) !== null && V !== void 0 ? V : null;
        } else {
          var q, X = [...B($ == null ? void 0 : $.previousElementSibling), ...B($)];
          w = (q = X.findLast((M) => A_(x, M))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      zr && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      _a && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (zr && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && fe.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = fe.toSlateNode(e, J), {
          path: ee,
          offset: k
        } = G.start(e, fe.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (k = a), {
          path: ee,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var j = fe.toSlateNode(e, u), H = fe.findPath(e, j);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = i0(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (i0(t)) {
        if (_a && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), m = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && m.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, g = m.startContainer, h = C(f.children[d.startOffset]), x = C(g.children[m.startOffset]);
            c = 0, x.childNodes.length > 0 ? a = x.childNodes[0] : a = x, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, x instanceof HTMLElement ? l = x.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = m.endContainer, l = m.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = m.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        _U && wme(a) || _a ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    _a && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = fe.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = A_(a, u) || a === u && c < l, O = p ? w : fe.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!O)
      return null;
    var y = {
      anchor: w,
      focus: O
    };
    return pe.isExpanded(y) && pe.isForward(y) && Io(u) && G.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = G.unhangRange(e, y, {
      voids: !0
    })), y;
  }
};
function Sme(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!G.hasPath(e, n))
    return !1;
  var o = je.get(e, n);
  if (!Ze.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = ie.next(n);
  if (!G.hasPath(e, i))
    return !1;
  var s = je.get(e, i);
  return Ze.isText(s) && s.text.startsWith(r.text);
}
function UU(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function Dme(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function Mme(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function $U(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), s = Dme(i, o), a = Math.min(i.length - s, o.length - s), l = Mme(i, o, a), u = {
    start: n + s,
    end: r - l,
    text: o.slice(s, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function Tme(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = UU(e, t, n), s = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), a = i.slice(r, s), l = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return $U(e, {
    start: r,
    end: l,
    text: a
  });
}
function jme(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function s0(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!G.hasPath(e, n))
    return null;
  var o = je.get(e, n);
  if (!Ze.isText(o))
    return null;
  var i = G.above(e, {
    match: (a) => We.isElement(a) && G.isBlock(e, a),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var s = G.next(e, {
      at: n,
      match: Ze.isText
    });
    if (!s || !ie.isDescendant(s[1], i[1]))
      return null;
    r -= o.text.length, o = s[0], n = s[1];
  }
  return {
    path: n,
    offset: r
  };
}
function B_(e, t) {
  var n = s0(e, t.anchor);
  if (!n)
    return null;
  if (pe.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = s0(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function a0(e, t, n) {
  var r = Yr.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: p
    } = c;
    return ie.equals(p, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return Ot.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var s = {
      path: t.path,
      offset: i.start
    }, a = Ot.transform(s, n, {
      affinity: "backward"
    });
    return a ? {
      path: a.path,
      offset: a.offset + t.offset - i.start
    } : null;
  }
  var l = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, u = Ot.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && ie.equals(n.path, t.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function I_(e, t, n) {
  var r = a0(e, t.anchor, n);
  if (!r)
    return null;
  if (pe.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = a0(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function _me(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !ie.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !ie.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !ie.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: ie.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: ie.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return ie.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: ie.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: ie.transform(n, t)
      };
  }
  var i = ie.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function N_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? N_(Object(n), !0).forEach(function(r) {
      No(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : N_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ame = 25, Bme = 200, Ime = function() {
}, Nme = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function Fme(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, s = null, a = null, l = 0, u = !1, c = () => {
    var $ = us.get(t);
    if (us.delete(t), $) {
      var {
        selection: V
      } = t, z = B_(t, $);
      z && (!V || !pe.equals(z, V)) && Ce.select(t, z);
    }
  }, p = () => {
    var $ = ls.get(t);
    if (ls.delete(t), !!$) {
      if ($.at) {
        var V = Ot.isPoint($.at) ? s0(t, $.at) : B_(t, $.at);
        if (!V)
          return;
        var z = G.range(t, V);
        (!t.selection || !pe.equals(t.selection, z)) && Ce.select(t, V);
      }
      $.run();
    }
  }, d = () => {
    if (s && (clearTimeout(s), s = null), a && (clearTimeout(a), a = null), !O() && !D()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), D() && (o = "action");
    var $ = t.selection && G.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    Mi.set(t, t.marks), Ime("flush", ls.get(t), Yr.get(t));
    for (var V = O(), z; z = (q = Yr.get(t)) === null || q === void 0 ? void 0 : q[0]; ) {
      var q, X, J = Fo.get(t);
      J !== void 0 && (Fo.delete(t), t.marks = J), J && u === !1 && (u = null);
      var te = jme(z);
      (!t.selection || !pe.equals(t.selection, te)) && Ce.select(t, te), z.diff.text ? G.insertText(t, z.diff.text) : G.deleteFragment(t), Yr.set(t, (X = Yr.get(t)) === null || X === void 0 ? void 0 : X.filter((j) => {
        var {
          id: H
        } = j;
        return H !== z.id;
      })), Sme(t, z) || (V = !1, ls.delete(t), Mi.delete(t), o = "action", us.delete(t), n.cancel(), r.cancel(), $ == null || $.unref());
    }
    var ee = $ == null ? void 0 : $.unref();
    if (ee && !us.get(t) && (!t.selection || !pe.equals(ee, t.selection)) && Ce.select(t, ee), D()) {
      p();
      return;
    }
    V && n(), n.flush(), r.flush(), c();
    var k = Mi.get(t);
    Mi.delete(t), k !== void 0 && (t.marks = k, t.onChange());
  }, m = ($) => {
    i && clearTimeout(i), i = setTimeout(() => {
      ua.set(t, !1), d();
    }, Ame);
  }, f = ($) => {
    ua.set(t, !0), i && (clearTimeout(i), i = null);
  }, g = function() {
    var V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, z = n0.get(t);
    if (z) {
      if (O() || V) {
        z.style.display = "none";
        return;
      }
      z.style.removeProperty("display");
    }
  }, h = ($, V) => {
    var z, q = (z = Yr.get(t)) !== null && z !== void 0 ? z : [];
    Yr.set(t, q);
    var X = je.leaf(t, $), J = q.findIndex((k) => ie.equals(k.path, $));
    if (J < 0) {
      var te = $U(X.text, V);
      te && q.push({
        path: $,
        diff: V,
        id: l++
      }), g();
      return;
    }
    var ee = Tme(X.text, q[J].diff, V);
    if (!ee) {
      q.splice(J, 1), g();
      return;
    }
    q[J] = Qp(Qp({}, q[J]), {}, {
      diff: ee
    });
  }, x = function(V) {
    var {
      at: z
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, us.delete(t), n.cancel(), r.cancel(), D() && d(), ls.set(t, {
      at: z,
      run: V
    }), a = setTimeout(d);
  }, w = ($) => {
    var V;
    if (s && (clearTimeout(s), s = null), !Ra.get(t)) {
      var {
        inputType: z
      } = $, q = null, X = $.dataTransfer || $.data || void 0;
      u !== !1 && z !== "insertText" && z !== "insertCompositionText" && (u = !1);
      var [J] = $.getTargetRanges();
      J && (q = fe.toSlateRange(t, J, {
        exactMatch: !1,
        suppressThrow: !0
      }));
      var te = fe.getWindow(t), ee = te.getSelection();
      if (!q && ee && (J = ee, q = fe.toSlateRange(t, ee, {
        exactMatch: !1,
        suppressThrow: !0
      })), q = (V = q) !== null && V !== void 0 ? V : t.selection, !!q) {
        var k = !0;
        if (z.startsWith("delete")) {
          if (pe.isExpanded(q)) {
            var [j, H] = pe.edges(q), M = je.leaf(t, j.path);
            if (M.text.length === j.offset && H.offset === 0) {
              var Z = G.next(t, {
                at: j.path,
                match: Ze.isText
              });
              Z && ie.equals(Z[1], H.path) && (q = {
                anchor: H,
                focus: H
              });
            }
          }
          var E = z.endsWith("Backward") ? "backward" : "forward", [T, R] = pe.edges(q), [_, W] = G.leaf(t, T.path), A = {
            text: "",
            start: T.offset,
            end: R.offset
          }, Q = Yr.get(t), N = Q == null ? void 0 : Q.find((He) => ie.equals(He.path, W)), ue = N ? [N.diff, A] : [A], ye = UU(_.text, ...ue);
          if (ye.length === 0 && (k = !1), pe.isExpanded(q)) {
            if (k && ie.equals(q.anchor.path, q.focus.path)) {
              var oe = {
                path: q.anchor.path,
                offset: T.offset
              }, Ie = G.range(t, oe, oe);
              return S(Ie), h(q.anchor.path, {
                text: "",
                end: R.offset,
                start: T.offset
              });
            }
            return x(() => G.deleteFragment(t, {
              direction: E
            }), {
              at: q
            });
          }
        }
        switch (z) {
          case "deleteByComposition":
          case "deleteByCut":
          case "deleteByDrag":
            return x(() => G.deleteFragment(t), {
              at: q
            });
          case "deleteContent":
          case "deleteContentForward": {
            var {
              anchor: $e
            } = q;
            if (k && pe.isCollapsed(q)) {
              var Ve = je.leaf(t, $e.path);
              if ($e.offset < Ve.text.length)
                return h($e.path, {
                  text: "",
                  start: $e.offset,
                  end: $e.offset + 1
                });
            }
            return x(() => G.deleteForward(t), {
              at: q
            });
          }
          case "deleteContentBackward": {
            var Ne, {
              anchor: Je
            } = q, Ye = i0(J) ? J.isCollapsed : !!((Ne = J) !== null && Ne !== void 0 && Ne.collapsed);
            return k && Ye && pe.isCollapsed(q) && Je.offset > 0 ? h(Je.path, {
              text: "",
              start: Je.offset - 1,
              end: Je.offset
            }) : x(() => G.deleteBackward(t), {
              at: q
            });
          }
          case "deleteEntireSoftLine":
            return x(() => {
              G.deleteBackward(t, {
                unit: "line"
              }), G.deleteForward(t, {
                unit: "line"
              });
            }, {
              at: q
            });
          case "deleteHardLineBackward":
            return x(() => G.deleteBackward(t, {
              unit: "block"
            }), {
              at: q
            });
          case "deleteSoftLineBackward":
            return x(() => G.deleteBackward(t, {
              unit: "line"
            }), {
              at: q
            });
          case "deleteHardLineForward":
            return x(() => G.deleteForward(t, {
              unit: "block"
            }), {
              at: q
            });
          case "deleteSoftLineForward":
            return x(() => G.deleteForward(t, {
              unit: "line"
            }), {
              at: q
            });
          case "deleteWordBackward":
            return x(() => G.deleteBackward(t, {
              unit: "word"
            }), {
              at: q
            });
          case "deleteWordForward":
            return x(() => G.deleteForward(t, {
              unit: "word"
            }), {
              at: q
            });
          case "insertLineBreak":
            return x(() => G.insertSoftBreak(t), {
              at: q
            });
          case "insertParagraph":
            return x(() => G.insertBreak(t), {
              at: q
            });
          case "insertCompositionText":
          case "deleteCompositionText":
          case "insertFromComposition":
          case "insertFromDrop":
          case "insertFromPaste":
          case "insertFromYank":
          case "insertReplacementText":
          case "insertText": {
            if (Nme(X))
              return x(() => fe.insertData(t, X), {
                at: q
              });
            var Te = X ?? "";
            if (Fo.get(t) && (Te = Te.replace("\uFEFF", "")), z === "insertText" && /.*\n.*\n$/.test(Te) && (Te = Te.slice(0, -1)), Te.includes(`
`))
              return x(() => {
                var He = Te.split(`
`);
                He.forEach((ze, et) => {
                  ze && G.insertText(t, ze), et !== He.length - 1 && G.insertSoftBreak(t);
                });
              }, {
                at: q
              });
            if (ie.equals(q.anchor.path, q.focus.path)) {
              var [Ke, nt] = pe.edges(q), Me = {
                start: Ke.offset,
                end: nt.offset,
                text: Te
              };
              if (Te && u && z === "insertCompositionText") {
                var Ae = u.start + u.text.search(/\S|$/), Fe = Me.start + Me.text.search(/\S|$/);
                Fe === Ae + 1 && Me.end === u.start + u.text.length ? (Me.start -= 1, u = null, F()) : u = !1;
              } else z === "insertText" ? u === null ? u = Me : u && pe.isCollapsed(q) && u.end + u.text.length === Ke.offset ? u = Qp(Qp({}, u), {}, {
                text: u.text + Te
              }) : u = !1 : u = !1;
              if (k) {
                h(Ke.path, Me);
                return;
              }
            }
            return x(() => G.insertText(t, Te), {
              at: q
            });
          }
        }
      }
    }
  }, D = () => !!ls.get(t), O = () => {
    var $;
    return !!(($ = Yr.get(t)) !== null && $ !== void 0 && $.length);
  }, y = () => D() || O(), C = () => o, S = ($) => {
    us.set(t, $), s && (clearTimeout(s), s = null);
    var {
      selection: V
    } = t;
    if ($) {
      var z = !V || !ie.equals(V.anchor.path, $.anchor.path), q = !V || !ie.equals(V.anchor.path.slice(0, -1), $.anchor.path.slice(0, -1));
      (z && u || q) && (u = !1), (z || O()) && (s = setTimeout(d, Bme));
    }
  }, U = () => {
    (D() || !O()) && d();
  }, L = ($) => {
    O() || (g(!0), setTimeout(g));
  }, F = () => {
    D() || (a = setTimeout(d));
  }, B = ($) => {
    if (!(O() || D()) && $.some((z) => c1(t, z, $))) {
      var V;
      (V = BU.get(t)) === null || V === void 0 || V();
    }
  };
  return {
    flush: d,
    scheduleFlush: F,
    hasPendingDiffs: O,
    hasPendingAction: D,
    hasPendingChanges: y,
    isFlushing: C,
    handleUserSelect: S,
    handleCompositionEnd: m,
    handleCompositionStart: f,
    handleDOMBeforeInput: w,
    handleKeyDown: L,
    handleDomMutations: B,
    handleInput: U
  };
}
function Rme() {
  var e = Qe(!1);
  return v(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var qu = vd ? K$ : v;
function zme(e, t, n) {
  var [r] = P(() => new MutationObserver(t));
  qu(() => {
    r.takeRecords();
  }), v(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var Ume = ["node"];
function F_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $me(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? F_(Object(n), !0).forEach(function(r) {
      No(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : F_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Vme = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, Hme = zr ? (e) => {
  var {
    node: t
  } = e, n = Za(e, Ume);
  if (!zr)
    return null;
  var r = As(), o = Rme(), [i] = P(() => Fme($me({
    editor: r
  }, n)));
  return zme(t, i.handleDomMutations, Vme), l1.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, Wme = ["anchor", "focus"], Zme = ["anchor", "focus"], qme = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), VU = (e, t) => {
  var n = Za(e, Wme), r = Za(t, Zme);
  return e[qa] === t[qa] && qme(n, r);
}, Gme = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!pe.equals(r, o) || !VU(r, o))
      return !1;
  }
  return !0;
}, Yme = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !VU(r, o))
      return !1;
  }
  return !0;
};
function R_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kme(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? R_(Object(n), !0).forEach(function(r) {
      No(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : R_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jme = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = As(), s = fe.findPath(i, o), a = ie.parent(s), l = !!n[IU];
  return i.isVoid(r) ? /* @__PURE__ */ Ee.createElement(ay, {
    length: je.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && G.string(i, a) === "" ? /* @__PURE__ */ Ee.createElement(ay, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ Ee.createElement(ay, {
    isMarkPlaceholder: l
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ Ee.createElement(z_, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ Ee.createElement(z_, {
    text: n.text
  });
}, z_ = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = Qe(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = P(o);
  return qu(() => {
    var s = o();
    r.current && r.current.textContent !== s && (r.current.textContent = s);
  }), /* @__PURE__ */ Ee.createElement(Xme, {
    ref: r
  }, i);
}, Xme = /* @__PURE__ */ Le(/* @__PURE__ */ Da((e, t) => /* @__PURE__ */ Ee.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), ay = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ Ee.createElement("span", Kme({}, o), !(zr || jU) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ Ee.createElement("br", null) : null);
};
function U_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function HU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? U_(Object(n), !0).forEach(function(r) {
      No(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : U_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qme = zr ? 300 : 0;
function eve(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function $_(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var tve = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: s = (w) => /* @__PURE__ */ Ee.createElement(rve, HU({}, w))
  } = e, a = As(), l = Qe(null), u = Qe(null), [c, p] = P(!1), d = Qe(null), m = pn((w) => {
    if (eve(l, w == null), w == null) {
      var D;
      n0.delete(a), (D = t.onPlaceholderResize) === null || D === void 0 || D.call(t, null);
    } else {
      if (n0.set(a, w), !l.current) {
        var O = window.ResizeObserver || sme;
        l.current = new O(() => {
          var y;
          (y = t.onPlaceholderResize) === null || y === void 0 || y.call(t, w);
        });
      }
      l.current.observe(w), u.current = w;
    }
  }, [u, t, a]), f = /* @__PURE__ */ Ee.createElement(Jme, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), g = !!t[qa];
  if (v(() => (g ? d.current || (d.current = setTimeout(() => {
    p(!0), d.current = null;
  }, Qme)) : ($_(d), p(!1)), () => $_(d)), [g, p]), g && c) {
    var h = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: Xs ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: m
      }
    };
    f = /* @__PURE__ */ Ee.createElement(Ee.Fragment, null, i(h), f);
  }
  var x = {
    "data-slate-leaf": !0
  };
  return s({
    attributes: x,
    children: f,
    leaf: t,
    text: r
  });
}, nve = /* @__PURE__ */ Ee.memo(tve, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && Ze.equals(t.leaf, e.leaf) && t.leaf[qa] === e.leaf[qa]), rve = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ Ee.createElement("span", HU({}, t), n);
}, ove = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: s
  } = e, a = As(), l = Qe(null), u = Ze.decorations(s, t), c = fe.findKey(a, s), p = [], d = 0; d < u.length; d++) {
    var m = u[d];
    p.push(/* @__PURE__ */ Ee.createElement(nve, {
      isLast: n && d === u.length - 1,
      key: "".concat(c.id, "-").concat(d),
      renderPlaceholder: o,
      leaf: m,
      text: s,
      parent: r,
      renderLeaf: i
    }));
  }
  var f = pn((g) => {
    var h = Zg.get(a);
    g ? (h == null || h.set(c, g), fa.set(s, g), Zu.set(g, s)) : (h == null || h.delete(c), fa.delete(s), l.current && Zu.delete(l.current)), l.current = g;
  }, [l, a, c, s]);
  return /* @__PURE__ */ Ee.createElement("span", {
    "data-slate-node": "text",
    ref: f
  }, p);
}, WU = /* @__PURE__ */ Ee.memo(ove, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && Yme(t.decorations, e.decorations));
function V_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function l0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? V_(Object(n), !0).forEach(function(r) {
      No(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : V_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ive = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (w) => /* @__PURE__ */ Ee.createElement(ave, l0({}, w)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  } = e, a = As(), l = cve(), u = a.isInline(n), c = fe.findKey(a, n), p = pn((w) => {
    var D = Zg.get(a);
    w ? (D == null || D.set(c, w), fa.set(n, w), Zu.set(w, n)) : (D == null || D.delete(c), fa.delete(n));
  }, [a, c, n]), d = qU({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  }), m = {
    "data-slate-node": "element",
    ref: p
  };
  if (u && (m["data-slate-inline"] = !0), !u && G.hasInlines(a, n)) {
    var f = je.string(n), g = wU(f);
    g === "rtl" && (m.dir = g);
  }
  if (G.isVoid(a, n)) {
    m["data-slate-void"] = !0, !l && u && (m.contentEditable = !1);
    var h = u ? "span" : "div", [[x]] = je.texts(n);
    d = /* @__PURE__ */ Ee.createElement(h, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ Ee.createElement(WU, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: x
    })), s1.set(x, 0), a1.set(x, n);
  }
  return r({
    attributes: m,
    children: d,
    element: n
  });
}, sve = /* @__PURE__ */ Ee.memo(ive, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && Gme(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && pe.equals(e.selection, t.selection))), ave = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = As(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ Ee.createElement(i, l0(l0({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, ZU = /* @__PURE__ */ Ge(() => []), lve = () => xe(ZU), uve = /* @__PURE__ */ Ge(!1), qU = (e) => {
  var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  } = e, a = lve(), l = As();
  Ra.set(l, !1);
  for (var u = fe.findPath(l, n), c = [], p = We.isElement(n) && !l.isInline(n) && G.hasInlines(l, n), d = 0; d < n.children.length; d++) {
    var m = u.concat(d), f = n.children[d], g = fe.findKey(l, f), h = G.range(l, m), x = s && pe.intersection(h, s), w = a([f, m]);
    for (var D of t) {
      var O = pe.intersection(D, h);
      O && w.push(O);
    }
    We.isElement(f) ? c.push(/* @__PURE__ */ Ee.createElement(uve.Provider, {
      key: "provider-".concat(g.id),
      value: !!x
    }, /* @__PURE__ */ Ee.createElement(sve, {
      decorations: w,
      element: f,
      key: g.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: x
    }))) : c.push(/* @__PURE__ */ Ee.createElement(WU, {
      decorations: w,
      key: g.id,
      isLast: p && d === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: f
    })), s1.set(f, d), a1.set(f, n);
  }
  return c;
}, GU = /* @__PURE__ */ Ge(!1), cve = () => xe(GU), YU = /* @__PURE__ */ Ge(null), qg = () => {
  var e = xe(YU);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function pve() {
  var e = As(), t = Qe(!1), n = Qe(0), r = pn(() => {
    if (!t.current) {
      t.current = !0;
      var o = fe.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return v(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var dve = 3, fve = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, hve = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, gve = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Xn = (e) => {
  var t = fve[e], n = hve[e], r = gve[e], o = t && Qv(t), i = n && Qv(n), s = r && Qv(r);
  return (a) => !!(o && o(a) || __ && i && i(a) || !__ && s && s(a));
}, er = {
  isBold: Xn("bold"),
  isCompose: Xn("compose"),
  isMoveBackward: Xn("moveBackward"),
  isMoveForward: Xn("moveForward"),
  isDeleteBackward: Xn("deleteBackward"),
  isDeleteForward: Xn("deleteForward"),
  isDeleteLineBackward: Xn("deleteLineBackward"),
  isDeleteLineForward: Xn("deleteLineForward"),
  isDeleteWordBackward: Xn("deleteWordBackward"),
  isDeleteWordForward: Xn("deleteWordForward"),
  isExtendBackward: Xn("extendBackward"),
  isExtendForward: Xn("extendForward"),
  isExtendLineBackward: Xn("extendLineBackward"),
  isExtendLineForward: Xn("extendLineForward"),
  isItalic: Xn("italic"),
  isMoveLineBackward: Xn("moveLineBackward"),
  isMoveLineForward: Xn("moveLineForward"),
  isMoveWordBackward: Xn("moveWordBackward"),
  isMoveWordForward: Xn("moveWordForward"),
  isRedo: Xn("redo"),
  isSoftBreak: Xn("insertSoftBreak"),
  isSplitBlock: Xn("splitBlock"),
  isTransposeCharacter: Xn("transposeCharacter"),
  isUndo: Xn("undo")
}, mve = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => c1(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, vve = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class KU extends Yu {
  constructor() {
    super(...arguments), No(this, "context", null), No(this, "manager", null), No(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, vve);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = mve(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
No(KU, "contextType", i1);
var yve = zr ? KU : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ Ee.createElement(Ee.Fragment, null, t);
}, bve = /* @__PURE__ */ Ge(!1), wve = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], Cve = ["text"];
function H_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? H_(Object(n), !0).forEach(function(r) {
      No(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : H_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ove = (e) => /* @__PURE__ */ Ee.createElement(Ee.Fragment, null, qU(e)), xve = /* @__PURE__ */ Da((e, t) => {
  var n = pn((T) => /* @__PURE__ */ Ee.createElement(Eve, Wo({}, T)), []), {
    autoFocus: r,
    decorate: o = Lve,
    onDOMBeforeInput: i,
    placeholder: s,
    readOnly: a = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: p = Pve,
    style: d = {},
    as: m = "div",
    disableDefaultStyles: f = !1
  } = e, g = Za(e, wve), h = qg(), [x, w] = P(!1), D = Qe(null), O = Qe([]), [y, C] = P(), S = Qe(!1), {
    onUserInput: U,
    receivedUserInput: L
  } = pve(), [, F] = Y$((T) => T + 1, 0);
  BU.set(h, F), r0.set(h, a);
  var B = Nn(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  v(() => {
    D.current && r && D.current.focus();
  }, [r]);
  var $ = Qe(), V = Nn(() => Ige(() => {
    if (Ra.get(h)) {
      V();
      return;
    }
    var T = fe.toDOMNode(h, h), R = T.getRootNode();
    if (!S.current && Xs && R instanceof ShadowRoot) {
      S.current = !0;
      var _ = Eme();
      _ ? document.execCommand("indent") : Ce.deselect(h), S.current = !1;
      return;
    }
    var W = $.current;
    if ((zr || !fe.isComposing(h)) && (!B.isUpdatingSelection || W != null && W.isFlushing()) && !B.isDraggingInternally) {
      var A = fe.findDocumentOrShadowRoot(h), {
        activeElement: Q
      } = A, N = fe.toDOMNode(h, h), ue = hu(A);
      if (Q === N ? (B.latestElement = Q, vs.set(h, !0)) : vs.delete(h), !ue)
        return Ce.deselect(h);
      var {
        anchorNode: ye,
        focusNode: oe
      } = ue, Ie = fe.hasEditableTarget(h, ye) || fe.isTargetInsideNonReadonlyVoid(h, ye), $e = fe.hasTarget(h, oe);
      if (Ie && $e) {
        var Ve = fe.toSlateRange(h, ue, {
          exactMatch: !1,
          suppressThrow: !0
        });
        Ve && (!fe.isComposing(h) && !(W != null && W.hasPendingChanges()) && !(W != null && W.isFlushing()) ? Ce.select(h, Ve) : W == null || W.handleUserSelect(Ve));
      }
      a && (!Ie || !$e) && Ce.deselect(h);
    }
  }, 100), [h, a, B]), z = Nn(() => Mge(V, 0), [V]);
  $.current = Hme({
    node: D,
    onDOMSelectionChange: V,
    scheduleOnDOMSelectionChange: z
  }), qu(() => {
    var T, R, _;
    D.current && (_ = u1(D.current)) ? (AU.set(h, _), yd.set(h, D.current), fa.set(h, D.current), Zu.set(D.current, h)) : fa.delete(h);
    var {
      selection: W
    } = h, A = fe.findDocumentOrShadowRoot(h), Q = hu(A);
    if (!(!Q || !fe.isFocused(h) || (T = $.current) !== null && T !== void 0 && T.hasPendingAction())) {
      var N = (Ie) => {
        var $e = Q.type !== "None";
        if (!(!W && !$e)) {
          var Ve = Q.focusNode, Ne;
          if (_a && Q.rangeCount > 1) {
            var Je = Q.getRangeAt(0), Ye = Q.getRangeAt(Q.rangeCount - 1);
            Je.startContainer === Ve ? Ne = Ye.endContainer : Ne = Je.startContainer;
          } else
            Ne = Q.anchorNode;
          var Te = yd.get(h), Ke = !1;
          if (Te.contains(Ne) && Te.contains(Ve) && (Ke = !0), $e && Ke && W && !Ie) {
            var nt = fe.toSlateRange(h, Q, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (nt && pe.equals(nt, W)) {
              var Me;
              if (!B.hasMarkPlaceholder || (Me = Ne) !== null && Me !== void 0 && (Me = Me.parentElement) !== null && Me !== void 0 && Me.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (W && !fe.hasRange(h, W)) {
            h.selection = fe.toSlateRange(h, Q, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          B.isUpdatingSelection = !0;
          var Ae = W && fe.toDOMRange(h, W);
          return Ae ? (fe.isComposing(h) && !zr ? Q.collapseToEnd() : pe.isBackward(W) ? Q.setBaseAndExtent(Ae.endContainer, Ae.endOffset, Ae.startContainer, Ae.startOffset) : Q.setBaseAndExtent(Ae.startContainer, Ae.startOffset, Ae.endContainer, Ae.endOffset), p(h, Ae)) : Q.removeAllRanges(), Ae;
        }
      };
      Q.rangeCount <= 1 && N();
      var ue = ((R = $.current) === null || R === void 0 ? void 0 : R.isFlushing()) === "action";
      if (!zr || !ue) {
        setTimeout(() => {
          B.isUpdatingSelection = !1;
        });
        return;
      }
      var ye = null, oe = requestAnimationFrame(() => {
        if (ue) {
          var Ie = ($e) => {
            try {
              var Ve = fe.toDOMNode(h, h);
              Ve.focus(), N($e);
            } catch {
            }
          };
          Ie(), ye = setTimeout(() => {
            Ie(!0), B.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(oe), ye && clearTimeout(ye);
      };
    }
  });
  var q = pn((T) => {
    var R = fe.toDOMNode(h, h), _ = R.getRootNode();
    if (S != null && S.current && Xs && _ instanceof ShadowRoot) {
      var W = T.getTargetRanges(), A = W[0], Q = new window.Range();
      Q.setStart(A.startContainer, A.startOffset), Q.setEnd(A.endContainer, A.endOffset);
      var N = fe.toSlateRange(h, Q, {
        exactMatch: !1,
        suppressThrow: !1
      });
      Ce.select(h, N), T.preventDefault(), T.stopImmediatePropagation();
      return;
    }
    if (U(), !a && fe.hasEditableTarget(h, T.target) && !kve(T, i)) {
      var ue;
      if ($.current)
        return $.current.handleDOMBeforeInput(T);
      z.flush(), V.flush();
      var {
        selection: ye
      } = h, {
        inputType: oe
      } = T, Ie = T.dataTransfer || T.data || void 0, $e = oe === "insertCompositionText" || oe === "deleteCompositionText";
      if ($e && fe.isComposing(h))
        return;
      var Ve = !1;
      if (oe === "insertText" && ye && pe.isCollapsed(ye) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      T.data && T.data.length === 1 && /[a-z ]/i.test(T.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      ye.anchor.offset !== 0 && (Ve = !0, h.marks && (Ve = !1), !Ra.get(h))) {
        var Ne, Je, {
          anchor: Ye
        } = ye, [Te, Ke] = fe.toDOMPoint(h, Ye), nt = (Ne = Te.parentElement) === null || Ne === void 0 ? void 0 : Ne.closest("a"), Me = fe.getWindow(h);
        if (Ve && nt && fe.hasDOMNode(h, nt)) {
          var Ae, Fe = Me == null ? void 0 : Me.document.createTreeWalker(nt, NodeFilter.SHOW_TEXT).lastChild();
          Fe === Te && ((Ae = Fe.textContent) === null || Ae === void 0 ? void 0 : Ae.length) === Ke && (Ve = !1);
        }
        if (Ve && Te.parentElement && (Me == null || (Je = Me.getComputedStyle(Te.parentElement)) === null || Je === void 0 ? void 0 : Je.whiteSpace) === "pre") {
          var He = G.above(h, {
            at: Ye.path,
            match: (ot) => We.isElement(ot) && G.isBlock(h, ot)
          });
          He && je.string(He[0]).includes("	") && (Ve = !1);
        }
      }
      if ((!oe.startsWith("delete") || oe.startsWith("deleteBy")) && !Ra.get(h)) {
        var [ze] = T.getTargetRanges();
        if (ze) {
          var et = fe.toSlateRange(h, ze, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!ye || !pe.equals(ye, et)) {
            Ve = !1;
            var _e = !$e && h.selection && G.rangeRef(h, h.selection);
            Ce.select(h, et), _e && fu.set(h, _e);
          }
        }
      }
      if ($e)
        return;
      if (Ve || T.preventDefault(), ye && pe.isExpanded(ye) && oe.startsWith("delete")) {
        var At = oe.endsWith("Backward") ? "backward" : "forward";
        G.deleteFragment(h, {
          direction: At
        });
        return;
      }
      switch (oe) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          G.deleteFragment(h);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          G.deleteForward(h);
          break;
        }
        case "deleteContentBackward": {
          G.deleteBackward(h);
          break;
        }
        case "deleteEntireSoftLine": {
          G.deleteBackward(h, {
            unit: "line"
          }), G.deleteForward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          G.deleteBackward(h, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          G.deleteBackward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          G.deleteForward(h, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          G.deleteForward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          G.deleteBackward(h, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          G.deleteForward(h, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          G.insertSoftBreak(h);
          break;
        case "insertParagraph": {
          G.insertBreak(h);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          oe === "insertFromComposition" && fe.isComposing(h) && (w(!1), ua.set(h, !1)), (Ie == null ? void 0 : Ie.constructor.name) === "DataTransfer" ? fe.insertData(h, Ie) : typeof Ie == "string" && (Ve ? O.current.push(() => G.insertText(h, Ie)) : G.insertText(h, Ie));
          break;
        }
      }
      var rt = (ue = fu.get(h)) === null || ue === void 0 ? void 0 : ue.unref();
      fu.delete(h), rt && (!h.selection || !pe.equals(h.selection, rt)) && Ce.select(h, rt);
    }
  }, [h, V, U, i, a, z]), X = pn((T) => {
    T == null ? (V.cancel(), z.cancel(), yd.delete(h), fa.delete(h), D.current && Ki && D.current.removeEventListener("beforeinput", q)) : Ki && T.addEventListener("beforeinput", q), D.current = T, typeof t == "function" ? t(T) : t && (t.current = T);
  }, [V, z, h, q, t]);
  qu(() => {
    var T = fe.getWindow(h);
    T.document.addEventListener("selectionchange", z);
    var R = () => {
      B.isDraggingInternally = !1;
    };
    return T.document.addEventListener("dragend", R), T.document.addEventListener("drop", R), () => {
      T.document.removeEventListener("selectionchange", z), T.document.removeEventListener("dragend", R), T.document.removeEventListener("drop", R);
    };
  }, [z, B]);
  var J = o([h, []]), te = s && h.children.length === 1 && Array.from(je.texts(h)).length === 1 && je.string(h) === "" && !x, ee = pn((T) => {
    if (T && te) {
      var R;
      C((R = T.getBoundingClientRect()) === null || R === void 0 ? void 0 : R.height);
    } else
      C(void 0);
  }, [te]);
  if (te) {
    var k = G.start(h, []);
    J.push({
      [qa]: !0,
      placeholder: s,
      onPlaceholderResize: ee,
      anchor: k,
      focus: k
    });
  }
  var {
    marks: j
  } = h;
  if (B.hasMarkPlaceholder = !1, h.selection && pe.isCollapsed(h.selection) && j) {
    var {
      anchor: H
    } = h.selection, M = je.leaf(h, H.path), Z = Za(M, Cve);
    if (!Ze.equals(M, j, {
      loose: !0
    })) {
      B.hasMarkPlaceholder = !0;
      var E = Object.fromEntries(Object.keys(Z).map((T) => [T, null]));
      J.push(Wo(Wo(Wo({
        [IU]: !0
      }, E), j), {}, {
        anchor: H,
        focus: H
      }));
    }
  }
  return v(() => {
    setTimeout(() => {
      var {
        selection: T
      } = h;
      if (T) {
        var {
          anchor: R
        } = T, _ = je.leaf(h, R.path);
        if (j && !Ze.equals(_, j, {
          loose: !0
        })) {
          Fo.set(h, j);
          return;
        }
      }
      Fo.delete(h);
    });
  }), /* @__PURE__ */ Ee.createElement(GU.Provider, {
    value: a
  }, /* @__PURE__ */ Ee.createElement(bve.Provider, {
    value: x
  }, /* @__PURE__ */ Ee.createElement(ZU.Provider, {
    value: o
  }, /* @__PURE__ */ Ee.createElement(yve, {
    node: D,
    receivedUserInput: L
  }, /* @__PURE__ */ Ee.createElement(m, Wo(Wo({
    role: a ? void 0 : "textbox",
    "aria-multiline": a ? void 0 : !0
  }, g), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: Ki || !vd ? g.spellCheck : !1,
    autoCorrect: Ki || !vd ? g.autoCorrect : "false",
    autoCapitalize: Ki || !vd ? g.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !a,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: X,
    style: Wo(Wo({}, f ? {} : Wo({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, y ? {
      minHeight: y
    } : {})), d),
    onBeforeInput: pn((T) => {
      if (!Ki && !a && !Rr(T, g.onBeforeInput) && fe.hasSelectableTarget(h, T.target) && (T.preventDefault(), !fe.isComposing(h))) {
        var R = T.data;
        G.insertText(h, R);
      }
    }, [g.onBeforeInput, h, a]),
    onInput: pn((T) => {
      if (!Rr(T, g.onInput)) {
        if ($.current) {
          $.current.handleInput();
          return;
        }
        for (var R of O.current)
          R();
        if (O.current = [], !fe.isFocused(h)) {
          var _ = T.nativeEvent, W = h;
          if (_.inputType === "historyUndo" && typeof W.undo == "function") {
            W.undo();
            return;
          }
          if (_.inputType === "historyRedo" && typeof W.redo == "function") {
            W.redo();
            return;
          }
        }
      }
    }, [g.onInput, h]),
    onBlur: pn((T) => {
      if (!(a || B.isUpdatingSelection || !fe.hasSelectableTarget(h, T.target) || Rr(T, g.onBlur))) {
        var R = fe.findDocumentOrShadowRoot(h);
        if (B.latestElement !== R.activeElement) {
          var {
            relatedTarget: _
          } = T, W = fe.toDOMNode(h, h);
          if (_ !== W && !(Io(_) && _.hasAttribute("data-slate-spacer"))) {
            if (_ != null && bs(_) && fe.hasDOMNode(h, _)) {
              var A = fe.toSlateNode(h, _);
              if (We.isElement(A) && !h.isVoid(A))
                return;
            }
            if (Xs) {
              var Q = hu(R);
              Q == null || Q.removeAllRanges();
            }
            vs.delete(h);
          }
        }
      }
    }, [a, B.isUpdatingSelection, B.latestElement, h, g.onBlur]),
    onClick: pn((T) => {
      if (fe.hasTarget(h, T.target) && !Rr(T, g.onClick) && bs(T.target)) {
        var R = fe.toSlateNode(h, T.target), _ = fe.findPath(h, R);
        if (!G.hasPath(h, _) || je.get(h, _) !== R)
          return;
        if (T.detail === dve && _.length >= 1) {
          var W = _;
          if (!(We.isElement(R) && G.isBlock(h, R))) {
            var A, Q = G.above(h, {
              match: (Ve) => We.isElement(Ve) && G.isBlock(h, Ve),
              at: _
            });
            W = (A = Q == null ? void 0 : Q[1]) !== null && A !== void 0 ? A : _.slice(0, 1);
          }
          var N = G.range(h, W);
          Ce.select(h, N);
          return;
        }
        if (a)
          return;
        var ue = G.start(h, _), ye = G.end(h, _), oe = G.void(h, {
          at: ue
        }), Ie = G.void(h, {
          at: ye
        });
        if (oe && Ie && ie.equals(oe[1], Ie[1])) {
          var $e = G.range(h, ue);
          Ce.select(h, $e);
        }
      }
    }, [h, g.onClick, a]),
    onCompositionEnd: pn((T) => {
      if (fe.hasSelectableTarget(h, T.target)) {
        var R;
        if (fe.isComposing(h) && Promise.resolve().then(() => {
          w(!1), ua.set(h, !1);
        }), (R = $.current) === null || R === void 0 || R.handleCompositionEnd(T), Rr(T, g.onCompositionEnd) || zr)
          return;
        if (!Xs && !fme && !jU && !gme && !hme && T.data) {
          var _ = Fo.get(h);
          Fo.delete(h), _ !== void 0 && (Mi.set(h, h.marks), h.marks = _), G.insertText(h, T.data);
          var W = Mi.get(h);
          Mi.delete(h), W !== void 0 && (h.marks = W);
        }
      }
    }, [g.onCompositionEnd, h]),
    onCompositionUpdate: pn((T) => {
      fe.hasSelectableTarget(h, T.target) && !Rr(T, g.onCompositionUpdate) && (fe.isComposing(h) || (w(!0), ua.set(h, !0)));
    }, [g.onCompositionUpdate, h]),
    onCompositionStart: pn((T) => {
      if (fe.hasSelectableTarget(h, T.target)) {
        var R;
        if ((R = $.current) === null || R === void 0 || R.handleCompositionStart(T), Rr(T, g.onCompositionStart) || zr)
          return;
        w(!0);
        var {
          selection: _
        } = h;
        if (_ && pe.isExpanded(_)) {
          G.deleteFragment(h);
          return;
        }
      }
    }, [g.onCompositionStart, h]),
    onCopy: pn((T) => {
      fe.hasSelectableTarget(h, T.target) && !Rr(T, g.onCopy) && !W_(T) && (T.preventDefault(), fe.setFragmentData(h, T.clipboardData, "copy"));
    }, [g.onCopy, h]),
    onCut: pn((T) => {
      if (!a && fe.hasSelectableTarget(h, T.target) && !Rr(T, g.onCut) && !W_(T)) {
        T.preventDefault(), fe.setFragmentData(h, T.clipboardData, "cut");
        var {
          selection: R
        } = h;
        if (R)
          if (pe.isExpanded(R))
            G.deleteFragment(h);
          else {
            var _ = je.parent(h, R.anchor.path);
            G.isVoid(h, _) && Ce.delete(h);
          }
      }
    }, [a, h, g.onCut]),
    onDragOver: pn((T) => {
      if (fe.hasTarget(h, T.target) && !Rr(T, g.onDragOver)) {
        var R = fe.toSlateNode(h, T.target);
        We.isElement(R) && G.isVoid(h, R) && T.preventDefault();
      }
    }, [g.onDragOver, h]),
    onDragStart: pn((T) => {
      if (!a && fe.hasTarget(h, T.target) && !Rr(T, g.onDragStart)) {
        var R = fe.toSlateNode(h, T.target), _ = fe.findPath(h, R), W = We.isElement(R) && G.isVoid(h, R) || G.void(h, {
          at: _,
          voids: !0
        });
        if (W) {
          var A = G.range(h, _);
          Ce.select(h, A);
        }
        B.isDraggingInternally = !0, fe.setFragmentData(h, T.dataTransfer, "drag");
      }
    }, [a, h, g.onDragStart, B]),
    onDrop: pn((T) => {
      if (!a && fe.hasTarget(h, T.target) && !Rr(T, g.onDrop)) {
        T.preventDefault();
        var R = h.selection, _ = fe.findEventRange(h, T), W = T.dataTransfer;
        Ce.select(h, _), B.isDraggingInternally && R && !pe.equals(R, _) && !G.void(h, {
          at: _,
          voids: !0
        }) && Ce.delete(h, {
          at: R
        }), fe.insertData(h, W), fe.isFocused(h) || fe.focus(h);
      }
    }, [a, h, g.onDrop, B]),
    onDragEnd: pn((T) => {
      !a && B.isDraggingInternally && g.onDragEnd && fe.hasTarget(h, T.target) && g.onDragEnd(T);
    }, [a, B, g, h]),
    onFocus: pn((T) => {
      if (!a && !B.isUpdatingSelection && fe.hasEditableTarget(h, T.target) && !Rr(T, g.onFocus)) {
        var R = fe.toDOMNode(h, h), _ = fe.findDocumentOrShadowRoot(h);
        if (B.latestElement = _.activeElement, _a && T.target !== R) {
          R.focus();
          return;
        }
        vs.set(h, !0);
      }
    }, [a, B, h, g.onFocus]),
    onKeyDown: pn((T) => {
      if (!a && fe.hasEditableTarget(h, T.target)) {
        var R;
        (R = $.current) === null || R === void 0 || R.handleKeyDown(T);
        var {
          nativeEvent: _
        } = T;
        if (fe.isComposing(h) && _.isComposing === !1 && (ua.set(h, !1), w(!1)), Rr(T, g.onKeyDown) || fe.isComposing(h))
          return;
        var {
          selection: W
        } = h, A = h.children[W !== null ? W.focus.path[0] : 0], Q = wU(je.string(A)) === "rtl";
        if (er.isRedo(_)) {
          T.preventDefault();
          var N = h;
          typeof N.redo == "function" && N.redo();
          return;
        }
        if (er.isUndo(_)) {
          T.preventDefault();
          var ue = h;
          typeof ue.undo == "function" && ue.undo();
          return;
        }
        if (er.isMoveLineBackward(_)) {
          T.preventDefault(), Ce.move(h, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (er.isMoveLineForward(_)) {
          T.preventDefault(), Ce.move(h, {
            unit: "line"
          });
          return;
        }
        if (er.isExtendLineBackward(_)) {
          T.preventDefault(), Ce.move(h, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (er.isExtendLineForward(_)) {
          T.preventDefault(), Ce.move(h, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (er.isMoveBackward(_)) {
          T.preventDefault(), W && pe.isCollapsed(W) ? Ce.move(h, {
            reverse: !Q
          }) : Ce.collapse(h, {
            edge: Q ? "end" : "start"
          });
          return;
        }
        if (er.isMoveForward(_)) {
          T.preventDefault(), W && pe.isCollapsed(W) ? Ce.move(h, {
            reverse: Q
          }) : Ce.collapse(h, {
            edge: Q ? "start" : "end"
          });
          return;
        }
        if (er.isMoveWordBackward(_)) {
          T.preventDefault(), W && pe.isExpanded(W) && Ce.collapse(h, {
            edge: "focus"
          }), Ce.move(h, {
            unit: "word",
            reverse: !Q
          });
          return;
        }
        if (er.isMoveWordForward(_)) {
          T.preventDefault(), W && pe.isExpanded(W) && Ce.collapse(h, {
            edge: "focus"
          }), Ce.move(h, {
            unit: "word",
            reverse: Q
          });
          return;
        }
        if (Ki) {
          if ((_U || Xs) && W && (er.isDeleteBackward(_) || er.isDeleteForward(_)) && pe.isCollapsed(W)) {
            var ye = je.parent(h, W.anchor.path);
            if (We.isElement(ye) && G.isVoid(h, ye) && (G.isInline(h, ye) || G.isBlock(h, ye))) {
              T.preventDefault(), G.deleteBackward(h, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (er.isBold(_) || er.isItalic(_) || er.isTransposeCharacter(_)) {
            T.preventDefault();
            return;
          }
          if (er.isSoftBreak(_)) {
            T.preventDefault(), G.insertSoftBreak(h);
            return;
          }
          if (er.isSplitBlock(_)) {
            T.preventDefault(), G.insertBreak(h);
            return;
          }
          if (er.isDeleteBackward(_)) {
            T.preventDefault(), W && pe.isExpanded(W) ? G.deleteFragment(h, {
              direction: "backward"
            }) : G.deleteBackward(h);
            return;
          }
          if (er.isDeleteForward(_)) {
            T.preventDefault(), W && pe.isExpanded(W) ? G.deleteFragment(h, {
              direction: "forward"
            }) : G.deleteForward(h);
            return;
          }
          if (er.isDeleteLineBackward(_)) {
            T.preventDefault(), W && pe.isExpanded(W) ? G.deleteFragment(h, {
              direction: "backward"
            }) : G.deleteBackward(h, {
              unit: "line"
            });
            return;
          }
          if (er.isDeleteLineForward(_)) {
            T.preventDefault(), W && pe.isExpanded(W) ? G.deleteFragment(h, {
              direction: "forward"
            }) : G.deleteForward(h, {
              unit: "line"
            });
            return;
          }
          if (er.isDeleteWordBackward(_)) {
            T.preventDefault(), W && pe.isExpanded(W) ? G.deleteFragment(h, {
              direction: "backward"
            }) : G.deleteBackward(h, {
              unit: "word"
            });
            return;
          }
          if (er.isDeleteWordForward(_)) {
            T.preventDefault(), W && pe.isExpanded(W) ? G.deleteFragment(h, {
              direction: "forward"
            }) : G.deleteForward(h, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [a, h, g.onKeyDown]),
    onPaste: pn((T) => {
      !a && fe.hasEditableTarget(h, T.target) && !Rr(T, g.onPaste) && (!Ki || yme(T.nativeEvent) || Xs) && (T.preventDefault(), fe.insertData(h, T.clipboardData));
    }, [a, h, g.onPaste])
  }), /* @__PURE__ */ Ee.createElement(Ove, {
    decorations: J,
    node: h,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: h.selection
  }))))));
}), Eve = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ Ee.createElement("span", Wo({}, t), n, zr && /* @__PURE__ */ Ee.createElement("br", null))
  );
}, Lve = () => [], Pve = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && pe.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), Rge(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, Rr = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, W_ = (e) => bs(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), kve = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, Sve = /* @__PURE__ */ Ge(!1), Dve = /* @__PURE__ */ Ge({});
function Mve(e) {
  var t = Qe([]).current, n = Qe({
    editor: e
  }).current, r = pn((i) => {
    n.editor = i, t.forEach((s) => s(i));
  }, [t, n]), o = Nn(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var Tve = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], jve = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: s
  } = e, a = Za(e, Tve), [l, u] = Ee.useState(() => {
    if (!je.isNodeList(s))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(Sr.stringify(s)));
    if (!G.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(Sr.stringify(t)));
    return t.children = s, Object.assign(t, a), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: p
  } = Mve(t), d = pn((g) => {
    var h;
    switch (r && r(t.children), g == null || (h = g.operation) === null || h === void 0 ? void 0 : h.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    u((x) => ({
      v: x.v + 1,
      editor: t
    })), p(t);
  }, [t, p, r, o, i]);
  v(() => (o0.set(t, d), () => {
    o0.set(t, () => {
    });
  }), [t, d]);
  var [m, f] = P(fe.isFocused(t));
  return v(() => {
    f(fe.isFocused(t));
  }, [t]), qu(() => {
    var g = () => f(fe.isFocused(t));
    return TU >= 17 ? (document.addEventListener("focusin", g), document.addEventListener("focusout", g), () => {
      document.removeEventListener("focusin", g), document.removeEventListener("focusout", g);
    }) : (document.addEventListener("focus", g, !0), document.addEventListener("blur", g, !0), () => {
      document.removeEventListener("focus", g, !0), document.removeEventListener("blur", g, !0);
    });
  }, []), /* @__PURE__ */ Ee.createElement(Dve.Provider, {
    value: c
  }, /* @__PURE__ */ Ee.createElement(YU.Provider, {
    value: l
  }, /* @__PURE__ */ Ee.createElement(i1.Provider, {
    value: l.editor
  }, /* @__PURE__ */ Ee.createElement(Sve.Provider, {
    value: m
  }, n))));
}, Z_ = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, q_ = (e, t, n) => {
  var r = fe.toDOMRange(e, t).getBoundingClientRect(), o = fe.toDOMRange(e, n).getBoundingClientRect();
  return Z_(r, o) && Z_(o, r);
}, _ve = (e, t) => {
  var n = G.range(e, pe.end(t)), r = Array.from(G.positions(e, {
    at: t
  })), o = 0, i = r.length, s = Math.floor(i / 2);
  if (q_(e, G.range(e, r[o]), n))
    return G.range(e, r[o], n);
  if (r.length < 2)
    return G.range(e, r[r.length - 1], n);
  for (; s !== r.length && s !== o; )
    q_(e, G.range(e, r[s]), n) ? i = s : o = s, s = Math.floor((o + i) / 2);
  return G.range(e, r[i], n);
};
function G_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Y_(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G_(Object(n), !0).forEach(function(r) {
      No(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ave = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: s,
    addMark: a,
    removeMark: l
  } = r;
  return Zg.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var p, d;
    (p = l1.get(r)) === null || p === void 0 || p(), !Fo.get(r) && (d = Yr.get(r)) !== null && d !== void 0 && d.length && Fo.set(r, null), Mi.delete(r), a(u, c);
  }, r.removeMark = (u) => {
    var c;
    !Fo.get(r) && (c = Yr.get(r)) !== null && c !== void 0 && c.length && Fo.set(r, null), Mi.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return s(u);
    if (r.selection && pe.isCollapsed(r.selection)) {
      var c = G.above(r, {
        match: (f) => We.isElement(f) && G.isBlock(r, f),
        at: r.selection
      });
      if (c) {
        var [, p] = c, d = G.range(r, p, r.selection.anchor), m = _ve(r, d);
        pe.isCollapsed(m) || Ce.delete(r, {
          at: m
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], p = [], d = Yr.get(r);
    if (d != null && d.length) {
      var m = d.map((z) => _me(z, u)).filter(Boolean);
      Yr.set(r, m);
    }
    var f = us.get(r);
    f && us.set(r, I_(r, f, u));
    var g = ls.get(r);
    if (g != null && g.at) {
      var h = Ot.isPoint(g == null ? void 0 : g.at) ? a0(r, g.at, u) : I_(r, g.at, u);
      ls.set(r, h ? Y_(Y_({}, g), {}, {
        at: h
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...Ta(r, u.path));
        break;
      }
      case "set_selection": {
        var x;
        (x = fu.get(r)) === null || x === void 0 || x.unref(), fu.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...Ta(r, ie.parent(u.path)));
        break;
      }
      case "merge_node": {
        var w = ie.previous(u.path);
        c.push(...Ta(r, w));
        break;
      }
      case "move_node": {
        var D = ie.common(ie.parent(u.path), ie.parent(u.newPath));
        c.push(...Ta(r, D));
        var O;
        ie.isBefore(u.path, u.newPath) ? (c.push(...Ta(r, ie.parent(u.path))), O = u.newPath) : (c.push(...Ta(r, ie.parent(u.newPath))), O = u.path);
        var y = je.get(t, ie.parent(O)), C = fe.findKey(r, y), S = G.pathRef(r, ie.parent(O));
        p.push([S, C]);
        break;
      }
    }
    switch (o(u), u.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "move_node":
      case "split_node":
        Ra.set(r, !0);
    }
    for (var [U, L] of c) {
      var [F] = G.node(r, U);
      Vf.set(F, L);
    }
    for (var [B, $] of p) {
      if (B.current) {
        var [V] = G.node(r, B.current);
        Vf.set(V, $);
      }
      B.unref();
    }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [p, d] = pe.edges(c), m = G.void(r, {
        at: p.path
      }), f = G.void(r, {
        at: d.path
      });
      if (!(pe.isCollapsed(c) && !m)) {
        var g = fe.toDOMRange(r, c), h = g.cloneContents(), x = h.childNodes[0];
        if (h.childNodes.forEach((F) => {
          F.textContent && F.textContent.trim() !== "" && (x = F);
        }), f) {
          var [w] = f, D = g.cloneRange(), O = fe.toDOMNode(r, w);
          D.setEndAfter(O), h = D.cloneContents();
        }
        if (m && (x = h.querySelector("[data-slate-spacer]")), Array.from(h.querySelectorAll("[data-slate-zero-width]")).forEach((F) => {
          var B = F.getAttribute("data-slate-zero-width") === "n";
          F.textContent = B ? `
` : "";
        }), FU(x)) {
          var y = x.ownerDocument.createElement("span");
          y.style.whiteSpace = "pre", y.appendChild(x), h.appendChild(y), x = y;
        }
        var C = r.getFragment(), S = JSON.stringify(C), U = window.btoa(encodeURIComponent(S));
        x.setAttribute("data-slate-fragment", U), u.setData("application/".concat(n), U);
        var L = h.ownerDocument.createElement("div");
        return L.appendChild(h), L.setAttribute("hidden", "true"), h.ownerDocument.body.appendChild(L), u.setData("text/html", L.innerHTML), u.setData("text/plain", zU(L)), h.ownerDocument.body.removeChild(L), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || xme(u);
    if (c) {
      var p = decodeURIComponent(window.atob(c)), d = JSON.parse(p);
      return r.insertFragment(d), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var p = c.split(/\r\n|\r|\n/), d = !1;
      for (var m of p)
        d && Ce.splitNodes(r, {
          always: !0
        }), r.insertText(m), d = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = TU < 18 ? Ga.unstable_batchedUpdates : (p) => p();
    c(() => {
      var p = o0.get(r);
      p && p(u), i(u);
    });
  }, r;
}, Ta = (e, t) => {
  var n = [];
  for (var [r, o] of G.levels(e, {
    at: t
  })) {
    var i = fe.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function JU(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    G.nodes(e, {
      at: G.unhangRange(e, r),
      match: (i) => !G.isEditor(i) && We.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const K_ = ["listItem", "numberedList"], bd = ["left", "center", "right", "justify"];
function Bve(e, t) {
  const n = bd.includes(t) ? "align" : "type", r = JU(e, t, n), o = K_.includes(t);
  Ce.unwrapNodes(e, {
    match: (s) => !G.isEditor(s) && We.isElement(s) && K_.includes(s.type) && !bd.includes(t),
    split: !0
  });
  let i;
  if (bd.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, Ce.setNodes(e, i), !r && o) {
    const s = { type: t, children: [] };
    Ce.wrapNodes(e, s);
  }
}
function Hs({ format: e, icon: t }) {
  const n = qg(), r = bd.includes(e) ? "align" : "type", i = JU(n, e, r) ? "activeTrue" : "activeFalse";
  function s(a) {
    a.preventDefault(), Bve(n, e);
  }
  return /* @__PURE__ */ K.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: s,
      children: /* @__PURE__ */ K.jsx(t, {})
    }
  );
}
function Ive({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ K.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ K.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ K.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ K.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ K.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ K.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    case "image":
      return /* @__PURE__ */ K.jsxs("div", { style: r, ...e, children: [
        /* @__PURE__ */ K.jsx(
          "img",
          {
            className: "arkynElementImage",
            alt: "arkynElementImage",
            src: (n == null ? void 0 : n.src) || ""
          }
        ),
        t
      ] });
    default:
      return /* @__PURE__ */ K.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
const XU = Ge({});
function Nve(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, a = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ K.jsx(XU.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ K.jsx(iI, { children: t && /* @__PURE__ */ K.jsxs("aside", { className: a.trim(), ...i, children: [
    /* @__PURE__ */ K.jsx(
      mu.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ K.jsx(
      mu.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function Fve(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ K.jsx("footer", { className: o.trim(), ...r });
}
function Rve(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = xe(XU), s = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ K.jsxs("header", { className: s.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ K.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ K.jsx(w0, { size: 24 })
      }
    )
  ] });
}
const u0 = Ge({});
function zve() {
  if (!u0)
    throw new Error("useTabContext must be used within a TabProvider");
  return xe(u0);
}
function Uve(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [s, a] = P(r || ""), [l, u] = P(!0), c = Qe(null), p = `arkynTabContainer ${o || ""}`, [d, m] = P({
    width: "0px",
    left: "0px",
    transition: "none"
  }), f = (h, x) => {
    const w = h.getBoundingClientRect(), D = c.current.getBoundingClientRect(), O = x ? void 0 : "none";
    u(!1), m({
      transition: O,
      width: `${w.width}px`,
      left: `${w.left - D.left}px`
    });
  };
  v(() => {
    const h = c.current;
    if (!h) return;
    let x = null;
    x = h.querySelector("button.activeTrue"), x && f(x);
  }, []);
  const g = (h) => {
    const x = h.target;
    x && (a(x.value), x.classList.add("activeTrue"), f(x, !0), n && n(x.value));
  };
  return /* @__PURE__ */ K.jsxs("nav", { ref: c, className: p.trim(), ...i, children: [
    /* @__PURE__ */ K.jsx(u0.Provider, { value: { handleTabClick: g, showInitialTab: l, value: s }, children: t }),
    /* @__PURE__ */ K.jsx("div", { className: "activeLine", style: d })
  ] });
}
function J_(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: s, handleTabClick: a } = zve(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && s ? "showBorderBottom" : ""} ${l} ${n}`;
  function p(d) {
    a(d), r && r(d);
  }
  return /* @__PURE__ */ K.jsx(
    "button",
    {
      onClick: p,
      className: c.trim(),
      ...o,
      type: "button",
      children: t
    }
  );
}
function $ve(e) {
  const {
    action: t,
    tabLabels: n = ["Adicionar URL", "Upload de arquivo"],
    modalCancelButton: r = "Cancelar",
    modalConfirmButton: o = "Confirmar",
    modalInputImageLabel: i = "Imagem:",
    modalInputUrlLabel: s = "URL da imagem:",
    modalTitle: a = "Inserir imagem"
  } = e, l = qg(), [u, c] = P(!1), [p, d] = P(""), [m, f] = P("url");
  function g(h) {
    h.preventDefault(), !(!p || p === "") && (l.insertNodes([
      { type: "paragraph", children: [{ text: "" }] },
      { type: "image", src: p, children: [{ text: "" }] },
      { type: "paragraph", children: [{ text: "" }] }
    ]), c(!1));
  }
  return /* @__PURE__ */ K.jsxs(K.Fragment, { children: [
    /* @__PURE__ */ K.jsx(
      "button",
      {
        type: "button",
        className: "arkynRichTextInsertImage",
        onMouseDown: () => c(!0),
        children: /* @__PURE__ */ K.jsx(t3, {})
      }
    ),
    /* @__PURE__ */ K.jsxs(
      Nve,
      {
        isVisibled: u,
        makeInvisible: () => c(!1),
        children: [
          /* @__PURE__ */ K.jsx(Rve, { children: a }),
          /* @__PURE__ */ K.jsxs("div", { className: "arkynRichTextInsertImageModalContent", children: [
            /* @__PURE__ */ K.jsxs(Uve, { defaultActive: m, onClick: f, children: [
              /* @__PURE__ */ K.jsx(J_, { value: "url", children: n[0] }),
              /* @__PURE__ */ K.jsx(J_, { value: "file", children: n[1] })
            ] }),
            m === "url" && /* @__PURE__ */ K.jsxs(K.Fragment, { children: [
              /* @__PURE__ */ K.jsxs(c_, { children: [
                /* @__PURE__ */ K.jsx(p_, { children: s }),
                /* @__PURE__ */ K.jsx(
                  Hg,
                  {
                    type: "text",
                    name: "richTextimageURL",
                    defaultValue: p,
                    onChange: (h) => d(h.target.value)
                  }
                )
              ] }),
              p && /* @__PURE__ */ K.jsx(
                "img",
                {
                  className: "arkynRichTextInsertImageModalPreviewImage",
                  src: p,
                  alt: "preview"
                }
              )
            ] }),
            m === "file" && /* @__PURE__ */ K.jsxs(c_, { children: [
              /* @__PURE__ */ K.jsx(p_, { children: i }),
              /* @__PURE__ */ K.jsx(
                Xfe,
                {
                  name: "richTextimageURL",
                  action: t,
                  defaultValue: p,
                  onUpload: (h) => d(h || "")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ K.jsxs(Fve, { children: [
            /* @__PURE__ */ K.jsx(
              $f,
              {
                type: "button",
                scheme: "danger",
                variant: "outline",
                onClick: () => c(!1),
                children: r
              }
            ),
            /* @__PURE__ */ K.jsx($f, { type: "button", onClick: g, children: o })
          ] })
        ]
      }
    )
  ] });
}
function Vve({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ K.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ K.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ K.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ K.jsx("u", { children: t })), /* @__PURE__ */ K.jsx("span", { ...e, children: t });
}
function QU(e, t) {
  const n = G.marks(e);
  return n ? n[t] === !0 : !1;
}
function e$(e, t) {
  QU(e, t) ? G.removeMark(e, t) : G.addMark(e, t, !0);
}
function ed({ format: e, icon: t }) {
  const n = qg(), o = QU(n, e) ? "activeTrue" : "activeFalse";
  function i(s) {
    s.preventDefault(), e$(n, e);
  }
  return /* @__PURE__ */ K.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ K.jsx(t, {})
    }
  );
}
function Hve({ children: e }) {
  return /* @__PURE__ */ K.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
function X_(e) {
  return e.map((t) => je.string(t)).join("");
}
const Q_ = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, td = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
function c1e(e) {
  const {
    name: t,
    hiddenButtons: n,
    imageConfig: r,
    defaultValue: o = "[]",
    enforceCharacterLimit: i = !1,
    onChangeCharactersCount: s,
    maxLimit: a = 2e3,
    onChange: l,
    isError: u
  } = e, c = Nn(() => Lhe(Ave(XH())), []), { id: p, inputRef: d, error: m } = uo(), f = Qe(null);
  function g() {
    try {
      const J = JSON.parse(o);
      return !Array.isArray(J) || J.length <= 0 ? td : J.every(
        (ee) => typeof ee == "object" && ee !== null && "type" in ee && "children" in ee
      ) ? J : td;
    } catch {
      return td;
    }
  }
  const h = X_(g()), [x, w] = P(h.length), [D, O] = P(
    JSON.stringify(g()) || "[]"
  ), [y, C] = P(!1), S = d || f, U = u || !!m, L = pn(Vve, []), F = pn(Ive, []);
  function B(J) {
    const te = X_(J);
    w(te.length), s && s(te.length), !(i && te.length >= a) && (O(JSON.stringify(J)), l && l(J), c.children = J, Ce.setNodes(c, { children: J }));
  }
  const $ = y ? "focusTrue" : "focusFalse", z = `arkynRichText ${U || a < x ? "errorTrue" : "errorFalse"} ${$}`, q = a - x;
  function X(J) {
    return !(n != null && n.includes(J));
  }
  return /* @__PURE__ */ K.jsxs(
    jve,
    {
      editor: c,
      initialValue: g(),
      onChange: B,
      onValueChange: B,
      children: [
        /* @__PURE__ */ K.jsxs("div", { className: z, children: [
          /* @__PURE__ */ K.jsxs(Hve, { children: [
            X("headingOne") && /* @__PURE__ */ K.jsx(Hs, { format: "headingOne", icon: n3 }),
            X("headingTwo") && /* @__PURE__ */ K.jsx(Hs, { format: "headingTwo", icon: r3 }),
            X("blockQuote") && /* @__PURE__ */ K.jsx(Hs, { format: "blockQuote", icon: o3 }),
            X("bold") && /* @__PURE__ */ K.jsx(ed, { format: "bold", icon: i3 }),
            X("italic") && /* @__PURE__ */ K.jsx(ed, { format: "italic", icon: s3 }),
            X("underline") && /* @__PURE__ */ K.jsx(ed, { format: "underline", icon: a3 }),
            X("code") && /* @__PURE__ */ K.jsx(ed, { format: "code", icon: l3 }),
            X("left") && /* @__PURE__ */ K.jsx(Hs, { format: "left", icon: u3 }),
            X("right") && /* @__PURE__ */ K.jsx(Hs, { format: "right", icon: c3 }),
            X("center") && /* @__PURE__ */ K.jsx(Hs, { format: "center", icon: p3 }),
            X("justify") && /* @__PURE__ */ K.jsx(Hs, { format: "justify", icon: d3 }),
            r && X("image") && /* @__PURE__ */ K.jsx($ve, { ...r })
          ] }),
          /* @__PURE__ */ K.jsx(
            xve,
            {
              className: "editorContainer",
              renderElement: F,
              renderLeaf: L,
              spellCheck: !0,
              id: p,
              onFocus: () => C(!0),
              onBlur: () => C(!1),
              onKeyDown: (J) => {
                for (const te in Q_)
                  if (Ohe(te, J)) {
                    J.preventDefault();
                    const ee = Q_[te];
                    e$(c, ee);
                  }
              }
            }
          ),
          q < 0 && /* @__PURE__ */ K.jsx("div", { className: "restatesCharacters", children: q })
        ] }),
        /* @__PURE__ */ K.jsx("input", { type: "hidden", ref: S, name: t, value: D }),
        /* @__PURE__ */ K.jsx("input", { type: "hidden", name: `${t}Count`, value: x })
      ]
    }
  );
}
function Wve(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: p,
    onBlur: d,
    title: m,
    style: f,
    closeOnSelect: g = !0,
    ...h
  } = e, y = `arkyn_select ${a ? "hasPrefix" : ""} ${s} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, S = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: y,
    prefix: FI(a, S, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: p,
    onBlur: d,
    title: m,
    closeOnSelect: g,
    style: f,
    iconSize: S,
    Spinner: /* @__PURE__ */ K.jsx(ri, { className: "spinner", size: S, strokeWidth: 2.5 }),
    ...h
  };
}
function p1e(e) {
  var T;
  const [t, n] = P(""), [r, o] = P(!1), { inputRef: i, id: s, error: a } = uo(), l = Qe(null), u = i || l, c = e.isError || !!a, {
    disabled: p,
    title: d,
    style: m,
    className: f,
    prefix: g,
    iconSize: h,
    isLoading: x,
    LeftIcon: w,
    value: D = null,
    defaultValue: O = "",
    onFocus: y,
    onBlur: C,
    Spinner: S,
    name: U,
    placeholder: L,
    onSelect: F,
    options: B,
    optionMaxHeight: $,
    closeOnSelect: V,
    isSearchable: z,
    onSearch: q,
    ...X
  } = Wve({ ...e, id: s, isError: c }, r), [J, te] = P(O);
  function ee() {
    p || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function k(R) {
    r || (o(!0), y && y(R));
  }
  function j() {
    o(!1), C && u.current && u.current.blur();
  }
  function H(R) {
    const { label: _, value: W } = R;
    te(J !== W ? W : ""), F && F({ label: _, value: W }), V && j();
  }
  const M = typeof D == "string" ? D : J, Z = ((T = B.find((R) => R.value === M)) == null ? void 0 : T.label) || "", E = () => {
    if (!r && Z) return !0;
    if (!r && !Z) return !1;
    if (r && Z) return !0;
    if (r && !Z) return !1;
  };
  return /* @__PURE__ */ K.jsxs(K.Fragment, { children: [
    /* @__PURE__ */ K.jsxs(
      "section",
      {
        title: d,
        style: m,
        onClick: ee,
        className: `${f} placeholder_dark_${E()}`,
        children: [
          g,
          w && /* @__PURE__ */ K.jsx(w, { size: h, strokeWidth: 2.5 }),
          /* @__PURE__ */ K.jsx(
            "input",
            {
              disabled: p,
              readOnly: !0,
              placeholder: Z || L,
              onFocus: k,
              ...X
            }
          ),
          /* @__PURE__ */ K.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: U,
              value: M || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ K.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: $ },
              children: [
                z && /* @__PURE__ */ K.jsx(
                  Hg,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: tI,
                    onChange: (R) => n(R.target.value)
                  }
                ),
                B.filter((R) => !!(e.onSearch || !e.isSearchable || R.label.toLowerCase().includes(t.toLowerCase()))).map(({ label: R, value: _ }) => /* @__PURE__ */ K.jsxs(
                  "div",
                  {
                    onClick: () => H({ label: R, value: _ }),
                    className: M === _ ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      R,
                      " ",
                      /* @__PURE__ */ K.jsx(b0, {})
                    ]
                  },
                  _
                )),
                B.length <= 0 && /* @__PURE__ */ K.jsx("p", { children: "Sem opções disponíveis" })
              ]
            }
          ),
          !x && /* @__PURE__ */ K.jsx(
            eI,
            {
              className: "arkyn_select_arrow",
              size: h,
              strokeWidth: 2.5
            }
          ),
          x && S
        ]
      }
    ),
    r && /* @__PURE__ */ K.jsx("aside", { className: "arkyn_select_overlay", onClick: j })
  ] });
}
function d1e(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: s,
    className: a = "",
    onCheck: l,
    ...u
  } = e, [c, p] = P(n), { id: d, inputRef: m } = uo(), f = typeof r == "boolean" ? r : c;
  function g() {
    p(!c), l && l(f ? i : o || "checked");
  }
  const x = `arkynSwitch ${f ? "checkedTrue" : "checkedFalse"} ${t} ${a}`;
  return /* @__PURE__ */ K.jsx("button", { type: "button", onClick: g, className: x, ...u, children: /* @__PURE__ */ K.jsx(
    "input",
    {
      id: d,
      type: "hidden",
      name: s,
      ref: m,
      onClick: g,
      value: f ? o || "checked" : i
    }
  ) });
}
function f1e(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: s,
    onBlur: a,
    title: l,
    style: u,
    ...c
  } = e, [p, d] = P(!1), { inputRef: m, id: f, error: g } = uo(), h = Qe(null), x = m || h, D = e.isError || !!g ? "errorTrue" : "errorFalse", C = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${D} ${p ? "focusedTrue" : "focusedFalse"} ${r}`;
  function S() {
    o || !(x != null && x.current) || (d(!0), x.current.focus());
  }
  function U(F) {
    d(!0), s && s(F);
  }
  function L(F) {
    d(!1), a && a(F);
  }
  return /* @__PURE__ */ K.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: S,
      className: C,
      children: /* @__PURE__ */ K.jsx(
        "textarea",
        {
          id: f,
          disabled: o,
          readOnly: i,
          ref: x,
          onFocus: U,
          onBlur: L,
          ...c
        }
      )
    }
  );
}
function h1e(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ K.jsx("nav", { className: r, ...n });
}
function g1e(e) {
  const { pathname: t } = O0(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...s
  } = e, l = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ K.jsxs("p", { className: l, children: [
    /* @__PURE__ */ K.jsx(Ey, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ K.jsxs(g3, { to: i, className: l, ...s, children: [
    /* @__PURE__ */ K.jsx(Ey, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function t$(e = "") {
  const t = O0(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([s, a]) => {
      a === void 0 ? n.delete(`${r}${s}`) : n.set(`${r}${s}`, String(a));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let s = n.toString();
      return s && (s = "?" + s), s;
    }
  };
}
function eA(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function m1e(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    currentPage: s = 1,
    registerPerPage: a = 20,
    ...l
  } = e, u = oI(), { getParam: c, getScopedSearch: p } = t$(t), d = Number(c("page")) || s, m = Number(c("per_page")) || a, f = Math.ceil(n / m), g = d > 1 ? eA(d - 1 - i, d - 1) : [], h = d < f ? eA(
    d,
    Math.min(d + i, f)
  ) : [];
  function x(w) {
    u(p({ page: w }));
  }
  return /* @__PURE__ */ K.jsxs("div", { className: "arkynPagination", ...l, children: [
    /* @__PURE__ */ K.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d <= 1,
        onClick: () => x(d - 1),
        children: /* @__PURE__ */ K.jsx(f3, {})
      }
    ),
    d > 1 + i && /* @__PURE__ */ K.jsxs(K.Fragment, { children: [
      /* @__PURE__ */ K.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => x(1),
          children: "1"
        }
      ),
      d > 2 + i && /* @__PURE__ */ K.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ K.jsx(E1, {}) })
    ] }),
    g.length > 0 && g.map((w, D) => /* @__PURE__ */ K.jsx(
      "button",
      {
        onClick: () => x(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      D
    )),
    /* @__PURE__ */ K.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: d }),
    h.length > 0 && h.map((w, D) => /* @__PURE__ */ K.jsx(
      "button",
      {
        onClick: () => x(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      D
    )),
    d + i < f && /* @__PURE__ */ K.jsxs(K.Fragment, { children: [
      d + 1 + i < f && /* @__PURE__ */ K.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ K.jsx(E1, {}) }),
      /* @__PURE__ */ K.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => x(f),
          children: f
        }
      )
    ] }),
    /* @__PURE__ */ K.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d >= f,
        onClick: () => x(d + 1),
        children: /* @__PURE__ */ K.jsx(Ey, {})
      }
    )
  ] });
}
const n$ = Ge({});
function v1e(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...s
  } = e, a = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ K.jsx(n$.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ K.jsx(iI, { children: t && /* @__PURE__ */ K.jsxs("aside", { className: u.trim(), ...s, children: [
    /* @__PURE__ */ K.jsx(
      mu.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ K.jsx(
      mu.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${a})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${a})` },
        children: o
      }
    )
  ] }) }) });
}
function y1e(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = xe(n$), s = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ K.jsxs("header", { className: s.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ K.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ K.jsx(w0, { size: 24 })
      }
    )
  ] });
}
function b1e(e) {
  const {
    children: t,
    button: n,
    closeOnClick: r,
    className: o = "",
    orientation: i = "bottomLeft"
  } = e, [s, a] = P(!1), u = `arkynPopover ${i} ${s ? "visibleTrue" : "visibleFalse"} ${o}`;
  function c() {
    s || a(!0);
  }
  return /* @__PURE__ */ K.jsxs("div", { className: u, onClick: c, children: [
    n,
    /* @__PURE__ */ K.jsx(
      mu.div,
      {
        style: { visibility: s ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: s ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && a(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    s && /* @__PURE__ */ K.jsx("div", { onClick: () => a(!1), className: "arkynPopoverOverlay" })
  ] });
}
function w1e(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ K.jsx(XB, {});
      case "danger":
        return /* @__PURE__ */ K.jsx(JB, {});
      default:
        return /* @__PURE__ */ K.jsx(KB, {});
    }
  }
  return /* @__PURE__ */ K.jsxs("div", { className: r, children: [
    /* @__PURE__ */ K.jsxs("div", { children: [
      /* @__PURE__ */ K.jsx("div", { className: "bg" }),
      /* @__PURE__ */ K.jsx(o, {})
    ] }),
    /* @__PURE__ */ K.jsx("p", { children: /* @__PURE__ */ K.jsx("span", { children: t }) })
  ] });
}
var br = {}, p1 = {}, Ec = {}, Lc = {}, r$ = "Expected a function", tA = NaN, Zve = "[object Symbol]", qve = /^\s+|\s+$/g, Gve = /^[-+]0x[0-9a-f]+$/i, Yve = /^0b[01]+$/i, Kve = /^0o[0-7]+$/i, Jve = parseInt, Xve = typeof En == "object" && En && En.Object === Object && En, Qve = typeof self == "object" && self && self.Object === Object && self, eye = Xve || Qve || Function("return this")(), tye = Object.prototype, nye = tye.toString, rye = Math.max, oye = Math.min, ly = function() {
  return eye.Date.now();
};
function iye(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(r$);
  t = nA(t) || 0, Hf(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? rye(nA(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function m(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, s = e.apply(U, S), s;
  }
  function f(C) {
    return u = C, a = setTimeout(x, t), c ? m(C) : s;
  }
  function g(C) {
    var S = C - l, U = C - u, L = t - S;
    return p ? oye(L, i - U) : L;
  }
  function h(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function x() {
    var C = ly();
    if (h(C))
      return w(C);
    a = setTimeout(x, g(C));
  }
  function w(C) {
    return a = void 0, d && r ? m(C) : (r = o = void 0, s);
  }
  function D() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function O() {
    return a === void 0 ? s : w(ly());
  }
  function y() {
    var C = ly(), S = h(C);
    if (r = arguments, o = this, l = C, S) {
      if (a === void 0)
        return f(l);
      if (p)
        return a = setTimeout(x, t), m(l);
    }
    return a === void 0 && (a = setTimeout(x, t)), s;
  }
  return y.cancel = D, y.flush = O, y;
}
function sye(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(r$);
  return Hf(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), iye(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Hf(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function aye(e) {
  return !!e && typeof e == "object";
}
function lye(e) {
  return typeof e == "symbol" || aye(e) && nye.call(e) == Zve;
}
function nA(e) {
  if (typeof e == "number")
    return e;
  if (lye(e))
    return tA;
  if (Hf(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Hf(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(qve, "");
  var n = Yve.test(e);
  return n || Kve.test(e) ? Jve(e.slice(2), n ? 2 : 8) : Gve.test(e) ? tA : +e;
}
var uye = sye, Pc = {};
Object.defineProperty(Pc, "__esModule", {
  value: !0
});
Pc.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), wd.has(n) || wd.set(n, /* @__PURE__ */ new Set());
  var i = wd.get(n);
  if (!i.has(o)) {
    var s = function() {
      var a = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return a;
    }();
    t.addEventListener(n, r, s ? { passive: !0 } : !1), i.add(o);
  }
};
Pc.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), wd.get(n).delete(r.name || n);
};
var wd = /* @__PURE__ */ new Map();
Object.defineProperty(Lc, "__esModule", {
  value: !0
});
var cye = uye, pye = fye(cye), dye = Pc;
function fye(e) {
  return e && e.__esModule ? e : { default: e };
}
var hye = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, pye.default)(t, n);
}, ir = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = hye(function(o) {
        ir.scrollHandler(t);
      }, n);
      ir.scrollSpyContainers.push(t), (0, dye.addPassiveEventListener)(t, "scroll", r);
    }
  },
  isMounted: function(t) {
    return ir.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.pageYOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = ir.scrollSpyContainers[ir.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(ir.currentPositionX(t), ir.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    ir.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = ir.scrollSpyContainers[ir.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t), t(ir.currentPositionX(n), ir.currentPositionY(n));
  },
  updateStates: function() {
    ir.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    ir.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), ir.spySetState && ir.spySetState.length && ir.spySetState.indexOf(t) > -1 && ir.spySetState.splice(ir.spySetState.indexOf(t), 1), document.removeEventListener("scroll", ir.scrollHandler);
  },
  update: function() {
    return ir.scrollSpyContainers.forEach(function(t) {
      return ir.scrollHandler(t);
    });
  }
};
Lc.default = ir;
var ll = {}, kc = {};
Object.defineProperty(kc, "__esModule", {
  value: !0
});
var gye = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, s = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", s) : history.replaceState(history.state, "", s);
}, mye = function() {
  return window.location.hash.replace(/^#/, "");
}, vye = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, yye = function(t) {
  return getComputedStyle(t).position !== "static";
}, uy = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, bye = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (yye(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = uy(n, o), s = i.offsetTop, a = i.offsetParent;
      if (a !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return s;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return uy(n, l).offsetTop - uy(t, l).offsetTop;
};
kc.default = {
  updateHash: gye,
  getHash: mye,
  filterElementInContainer: vye,
  scrollOffset: bye
};
var Gg = {}, d1 = {};
Object.defineProperty(d1, "__esModule", {
  value: !0
});
d1.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var f1 = {};
Object.defineProperty(f1, "__esModule", {
  value: !0
});
var wye = Pc, Cye = ["mousedown", "mousewheel", "touchmove", "keydown"];
f1.default = {
  subscribe: function(t) {
    return typeof document < "u" && Cye.forEach(function(n) {
      return (0, wye.addPassiveEventListener)(document, n, t);
    });
  }
};
var Sc = {};
Object.defineProperty(Sc, "__esModule", {
  value: !0
});
var c0 = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      c0.registered[t] = n;
    },
    remove: function(t) {
      c0.registered[t] = null;
    }
  }
};
Sc.default = c0;
Object.defineProperty(Gg, "__esModule", {
  value: !0
});
var Oye = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, xye = kc;
Yg(xye);
var Eye = d1, rA = Yg(Eye), Lye = f1, Pye = Yg(Lye), kye = Sc, Ko = Yg(kye);
function Yg(e) {
  return e && e.__esModule ? e : { default: e };
}
var o$ = function(t) {
  return rA.default[t.smooth] || rA.default.defaultEasing;
}, Sye = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, Dye = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, p0 = function() {
  return Dye() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), i$ = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, s$ = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, a$ = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, Mye = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, Tye = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, jye = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Ko.default.registered.end && Ko.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    p0.call(window, i);
    return;
  }
  Ko.default.registered.end && Ko.default.registered.end(o.to, o.target, o.currentPosition);
}, h1 = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, Dc = function(t, n, r, o) {
  n.data = n.data || i$(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (Pye.default.subscribe(i), h1(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? s$(n) : a$(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    Ko.default.registered.end && Ko.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = Sye(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var s = o$(n), a = jye.bind(null, s, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      Ko.default.registered.begin && Ko.default.registered.begin(n.data.to, n.data.target), p0.call(window, a);
    }, n.delay);
    return;
  }
  Ko.default.registered.begin && Ko.default.registered.begin(n.data.to, n.data.target), p0.call(window, a);
}, Kg = function(t) {
  return t = Oye({}, t), t.data = t.data || i$(), t.absolute = !0, t;
}, _ye = function(t) {
  Dc(0, Kg(t));
}, Aye = function(t, n) {
  Dc(t, Kg(n));
}, Bye = function(t) {
  t = Kg(t), h1(t), Dc(t.horizontal ? Mye(t) : Tye(t), t);
}, Iye = function(t, n) {
  n = Kg(n), h1(n);
  var r = n.horizontal ? s$(n) : a$(n);
  Dc(t + r, n);
};
Gg.default = {
  animateTopScroll: Dc,
  getAnimationType: o$,
  scrollToTop: _ye,
  scrollToBottom: Bye,
  scrollTo: Aye,
  scrollMore: Iye
};
Object.defineProperty(ll, "__esModule", {
  value: !0
});
var Nye = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Fye = kc, Rye = g1(Fye), zye = Gg, Uye = g1(zye), $ye = Sc, nd = g1($ye);
function g1(e) {
  return e && e.__esModule ? e : { default: e };
}
var rd = {}, oA = void 0;
ll.default = {
  unmount: function() {
    rd = {};
  },
  register: function(t, n) {
    rd[t] = n;
  },
  unregister: function(t) {
    delete rd[t];
  },
  get: function(t) {
    return rd[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return oA = t;
  },
  getActiveLink: function() {
    return oA;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = Nye({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, s = void 0;
    o ? s = document.getElementById(o) : i && i.nodeType ? s = i : s = document, n.absolute = !0;
    var a = n.horizontal, l = Rye.default.scrollOffset(s, r, a) + (n.offset || 0);
    if (!n.smooth) {
      nd.default.registered.begin && nd.default.registered.begin(t, r), s === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : s.scrollTop = l, nd.default.registered.end && nd.default.registered.end(t, r);
      return;
    }
    Uye.default.animateTopScroll(l, n, t, r);
  }
};
var d0 = { exports: {} }, od = { exports: {} }, un = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iA;
function Vye() {
  if (iA) return un;
  iA = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case a:
                case c:
                case f:
                case m:
                case s:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function O(y) {
    return D(y) === u;
  }
  return un.AsyncMode = l, un.ConcurrentMode = u, un.ContextConsumer = a, un.ContextProvider = s, un.Element = t, un.ForwardRef = c, un.Fragment = r, un.Lazy = f, un.Memo = m, un.Portal = n, un.Profiler = i, un.StrictMode = o, un.Suspense = p, un.isAsyncMode = function(y) {
    return O(y) || D(y) === l;
  }, un.isConcurrentMode = O, un.isContextConsumer = function(y) {
    return D(y) === a;
  }, un.isContextProvider = function(y) {
    return D(y) === s;
  }, un.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, un.isForwardRef = function(y) {
    return D(y) === c;
  }, un.isFragment = function(y) {
    return D(y) === r;
  }, un.isLazy = function(y) {
    return D(y) === f;
  }, un.isMemo = function(y) {
    return D(y) === m;
  }, un.isPortal = function(y) {
    return D(y) === n;
  }, un.isProfiler = function(y) {
    return D(y) === i;
  }, un.isStrictMode = function(y) {
    return D(y) === o;
  }, un.isSuspense = function(y) {
    return D(y) === p;
  }, un.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === m || y.$$typeof === s || y.$$typeof === a || y.$$typeof === c || y.$$typeof === h || y.$$typeof === x || y.$$typeof === w || y.$$typeof === g);
  }, un.typeOf = D, un;
}
var cn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sA;
function Hye() {
  return sA || (sA = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === m || N.$$typeof === s || N.$$typeof === a || N.$$typeof === c || N.$$typeof === h || N.$$typeof === x || N.$$typeof === w || N.$$typeof === g);
    }
    function O(N) {
      if (typeof N == "object" && N !== null) {
        var ue = N.$$typeof;
        switch (ue) {
          case t:
            var ye = N.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ye;
              default:
                var oe = ye && ye.$$typeof;
                switch (oe) {
                  case a:
                  case c:
                  case f:
                  case m:
                  case s:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, S = a, U = s, L = t, F = c, B = r, $ = f, V = m, z = n, q = i, X = o, J = p, te = !1;
    function ee(N) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(N) || O(N) === l;
    }
    function k(N) {
      return O(N) === u;
    }
    function j(N) {
      return O(N) === a;
    }
    function H(N) {
      return O(N) === s;
    }
    function M(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function Z(N) {
      return O(N) === c;
    }
    function E(N) {
      return O(N) === r;
    }
    function T(N) {
      return O(N) === f;
    }
    function R(N) {
      return O(N) === m;
    }
    function _(N) {
      return O(N) === n;
    }
    function W(N) {
      return O(N) === i;
    }
    function A(N) {
      return O(N) === o;
    }
    function Q(N) {
      return O(N) === p;
    }
    cn.AsyncMode = y, cn.ConcurrentMode = C, cn.ContextConsumer = S, cn.ContextProvider = U, cn.Element = L, cn.ForwardRef = F, cn.Fragment = B, cn.Lazy = $, cn.Memo = V, cn.Portal = z, cn.Profiler = q, cn.StrictMode = X, cn.Suspense = J, cn.isAsyncMode = ee, cn.isConcurrentMode = k, cn.isContextConsumer = j, cn.isContextProvider = H, cn.isElement = M, cn.isForwardRef = Z, cn.isFragment = E, cn.isLazy = T, cn.isMemo = R, cn.isPortal = _, cn.isProfiler = W, cn.isStrictMode = A, cn.isSuspense = Q, cn.isValidElementType = D, cn.typeOf = O;
  }()), cn;
}
var aA;
function l$() {
  return aA || (aA = 1, process.env.NODE_ENV === "production" ? od.exports = Vye() : od.exports = Hye()), od.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var cy, lA;
function Wye() {
  if (lA) return cy;
  lA = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return cy = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, cy;
}
var py, uA;
function m1() {
  if (uA) return py;
  uA = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return py = e, py;
}
var dy, cA;
function u$() {
  return cA || (cA = 1, dy = Function.call.bind(Object.prototype.hasOwnProperty)), dy;
}
var fy, pA;
function Zye() {
  if (pA) return fy;
  pA = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = m1(), n = {}, r = u$();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var m = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (m ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, fy = o, fy;
}
var hy, dA;
function qye() {
  if (dA) return hy;
  dA = 1;
  var e = l$(), t = Wye(), n = m1(), r = u$(), o = Zye(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return hy = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var j = k && (u && k[u] || k[c]);
      if (typeof j == "function")
        return j;
    }
    var d = "<<anonymous>>", m = {
      array: x("array"),
      bigint: x("bigint"),
      bool: x("boolean"),
      func: x("function"),
      number: x("number"),
      object: x("object"),
      string: x("string"),
      symbol: x("symbol"),
      any: w(),
      arrayOf: D,
      element: O(),
      elementType: y(),
      instanceOf: C,
      node: F(),
      objectOf: U,
      oneOf: S,
      oneOfType: L,
      shape: $,
      exact: V
    };
    function f(k, j) {
      return k === j ? k !== 0 || 1 / k === 1 / j : k !== k && j !== j;
    }
    function g(k, j) {
      this.message = k, this.data = j && typeof j == "object" ? j : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function h(k) {
      if (process.env.NODE_ENV !== "production")
        var j = {}, H = 0;
      function M(E, T, R, _, W, A, Q) {
        if (_ = _ || d, A = A || R, Q !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = _ + ":" + R;
            !j[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + _ + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), j[ue] = !0, H++);
          }
        }
        return T[R] == null ? E ? T[R] === null ? new g("The " + W + " `" + A + "` is marked as required " + ("in `" + _ + "`, but its value is `null`.")) : new g("The " + W + " `" + A + "` is marked as required in " + ("`" + _ + "`, but its value is `undefined`.")) : null : k(T, R, _, W, A);
      }
      var Z = M.bind(null, !1);
      return Z.isRequired = M.bind(null, !0), Z;
    }
    function x(k) {
      function j(H, M, Z, E, T, R) {
        var _ = H[M], W = X(_);
        if (W !== k) {
          var A = J(_);
          return new g(
            "Invalid " + E + " `" + T + "` of type " + ("`" + A + "` supplied to `" + Z + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return h(j);
    }
    function w() {
      return h(s);
    }
    function D(k) {
      function j(H, M, Z, E, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + Z + "` has invalid PropType notation inside arrayOf.");
        var R = H[M];
        if (!Array.isArray(R)) {
          var _ = X(R);
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected an array."));
        }
        for (var W = 0; W < R.length; W++) {
          var A = k(R, W, Z, E, T + "[" + W + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return h(j);
    }
    function O() {
      function k(j, H, M, Z, E) {
        var T = j[H];
        if (!a(T)) {
          var R = X(T);
          return new g("Invalid " + Z + " `" + E + "` of type " + ("`" + R + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(k);
    }
    function y() {
      function k(j, H, M, Z, E) {
        var T = j[H];
        if (!e.isValidElementType(T)) {
          var R = X(T);
          return new g("Invalid " + Z + " `" + E + "` of type " + ("`" + R + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(k);
    }
    function C(k) {
      function j(H, M, Z, E, T) {
        if (!(H[M] instanceof k)) {
          var R = k.name || d, _ = ee(H[M]);
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected ") + ("instance of `" + R + "`."));
        }
        return null;
      }
      return h(j);
    }
    function S(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function j(H, M, Z, E, T) {
        for (var R = H[M], _ = 0; _ < k.length; _++)
          if (f(R, k[_]))
            return null;
        var W = JSON.stringify(k, function(Q, N) {
          var ue = J(N);
          return ue === "symbol" ? String(N) : N;
        });
        return new g("Invalid " + E + " `" + T + "` of value `" + String(R) + "` " + ("supplied to `" + Z + "`, expected one of " + W + "."));
      }
      return h(j);
    }
    function U(k) {
      function j(H, M, Z, E, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + Z + "` has invalid PropType notation inside objectOf.");
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type " + ("`" + _ + "` supplied to `" + Z + "`, expected an object."));
        for (var W in R)
          if (r(R, W)) {
            var A = k(R, W, Z, E, T + "." + W, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return h(j);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var j = 0; j < k.length; j++) {
        var H = k[j];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(H) + " at index " + j + "."
          ), s;
      }
      function M(Z, E, T, R, _) {
        for (var W = [], A = 0; A < k.length; A++) {
          var Q = k[A], N = Q(Z, E, T, R, _, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && W.push(N.data.expectedType);
        }
        var ue = W.length > 0 ? ", expected one of type [" + W.join(", ") + "]" : "";
        return new g("Invalid " + R + " `" + _ + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return h(M);
    }
    function F() {
      function k(j, H, M, Z, E) {
        return z(j[H]) ? null : new g("Invalid " + Z + " `" + E + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return h(k);
    }
    function B(k, j, H, M, Z) {
      return new g(
        (k || "React class") + ": " + j + " type `" + H + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Z + "`."
      );
    }
    function $(k) {
      function j(H, M, Z, E, T) {
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type `" + _ + "` " + ("supplied to `" + Z + "`, expected `object`."));
        for (var W in k) {
          var A = k[W];
          if (typeof A != "function")
            return B(Z, E, T, W, J(A));
          var Q = A(R, W, Z, E, T + "." + W, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return h(j);
    }
    function V(k) {
      function j(H, M, Z, E, T) {
        var R = H[M], _ = X(R);
        if (_ !== "object")
          return new g("Invalid " + E + " `" + T + "` of type `" + _ + "` " + ("supplied to `" + Z + "`, expected `object`."));
        var W = t({}, H[M], k);
        for (var A in W) {
          var Q = k[A];
          if (r(k, A) && typeof Q != "function")
            return B(Z, E, T, A, J(Q));
          if (!Q)
            return new g(
              "Invalid " + E + " `" + T + "` key `" + A + "` supplied to `" + Z + "`.\nBad object: " + JSON.stringify(H[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var N = Q(R, A, Z, E, T + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return h(j);
    }
    function z(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every(z);
          if (k === null || a(k))
            return !0;
          var j = p(k);
          if (j) {
            var H = j.call(k), M;
            if (j !== k.entries) {
              for (; !(M = H.next()).done; )
                if (!z(M.value))
                  return !1;
            } else
              for (; !(M = H.next()).done; ) {
                var Z = M.value;
                if (Z && !z(Z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(k, j) {
      return k === "symbol" ? !0 : j ? j["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && j instanceof Symbol : !1;
    }
    function X(k) {
      var j = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : q(j, k) ? "symbol" : j;
    }
    function J(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var j = X(k);
      if (j === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return j;
    }
    function te(k) {
      var j = J(k);
      switch (j) {
        case "array":
        case "object":
          return "an " + j;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + j;
        default:
          return j;
      }
    }
    function ee(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return m.checkPropTypes = o, m.resetWarningCache = o.resetWarningCache, m.PropTypes = m, m;
  }, hy;
}
var gy, fA;
function Gye() {
  if (fA) return gy;
  fA = 1;
  var e = m1();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, gy = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, gy;
}
if (process.env.NODE_ENV !== "production") {
  var Yye = l$(), Kye = !0;
  d0.exports = qye()(Yye.isElement, Kye);
} else
  d0.exports = Gye()();
var Jg = d0.exports, Xg = {};
Object.defineProperty(Xg, "__esModule", {
  value: !0
});
var Jye = kc, my = Xye(Jye);
function Xye(e) {
  return e && e.__esModule ? e : { default: e };
}
var Qye = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return my.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && my.default.getHash() !== t && my.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Xg.default = Qye;
Object.defineProperty(Ec, "__esModule", {
  value: !0
});
var id = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, ebe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), tbe = Ee, hA = Mc(tbe), nbe = Lc, sd = Mc(nbe), rbe = ll, obe = Mc(rbe), ibe = Jg, Qn = Mc(ibe), sbe = Xg, Ji = Mc(sbe);
function Mc(e) {
  return e && e.__esModule ? e : { default: e };
}
function abe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lbe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ube(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var gA = {
  to: Qn.default.string.isRequired,
  containerId: Qn.default.string,
  container: Qn.default.object,
  activeClass: Qn.default.string,
  activeStyle: Qn.default.object,
  spy: Qn.default.bool,
  horizontal: Qn.default.bool,
  smooth: Qn.default.oneOfType([Qn.default.bool, Qn.default.string]),
  offset: Qn.default.number,
  delay: Qn.default.number,
  isDynamic: Qn.default.bool,
  onClick: Qn.default.func,
  duration: Qn.default.oneOfType([Qn.default.number, Qn.default.func]),
  absolute: Qn.default.bool,
  onSetActive: Qn.default.func,
  onSetInactive: Qn.default.func,
  ignoreCancelEvents: Qn.default.bool,
  hashSpy: Qn.default.bool,
  saveHashHistory: Qn.default.bool,
  spyThrottle: Qn.default.number
};
Ec.default = function(e, t) {
  var n = t || obe.default, r = function(i) {
    ube(s, i);
    function s(a) {
      abe(this, s);
      var l = lbe(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return ebe(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          sd.default.isMounted(l) || sd.default.mount(l, this.props.spyThrottle), this.props.hashSpy && (Ji.default.isMounted() || Ji.default.mount(n), Ji.default.mapContainer(this.props.to, l)), sd.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        sd.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = id({}, this.props.style, this.props.activeStyle) : u = id({}, this.props.style);
        var c = id({}, this.props);
        for (var p in gA)
          c.hasOwnProperty(p) && delete c[p];
        return c.className = l, c.style = u, c.onClick = this.handleClick, hA.default.createElement(e, c);
      }
    }]), s;
  }(hA.default.PureComponent), o = function() {
    var s = this;
    this.scrollTo = function(a, l) {
      n.scrollTo(a, id({}, s.state, l));
    }, this.handleClick = function(a) {
      s.props.onClick && s.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), s.scrollTo(s.props.to, s.props);
    }, this.spyHandler = function(a, l) {
      var u = s.getScrollSpyContainer();
      if (!(Ji.default.isMounted() && !Ji.default.isInitialized())) {
        var c = s.props.horizontal, p = s.props.to, d = null, m = void 0, f = void 0;
        if (c) {
          var g = 0, h = 0, x = 0;
          if (u.getBoundingClientRect) {
            var w = u.getBoundingClientRect();
            x = w.left;
          }
          if (!d || s.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var D = d.getBoundingClientRect();
            g = D.left - x + a, h = g + D.width;
          }
          var O = a - s.props.offset;
          m = O >= Math.floor(g) && O < Math.floor(h), f = O < Math.floor(g) || O >= Math.floor(h);
        } else {
          var y = 0, C = 0, S = 0;
          if (u.getBoundingClientRect) {
            var U = u.getBoundingClientRect();
            S = U.top;
          }
          if (!d || s.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var L = d.getBoundingClientRect();
            y = L.top - S + l, C = y + L.height;
          }
          var F = l - s.props.offset;
          m = F >= Math.floor(y) && F < Math.floor(C), f = F < Math.floor(y) || F >= Math.floor(C);
        }
        var B = n.getActiveLink();
        if (f) {
          if (p === B && n.setActiveLink(void 0), s.props.hashSpy && Ji.default.getHash() === p) {
            var $ = s.props.saveHashHistory, V = $ === void 0 ? !1 : $;
            Ji.default.changeHash("", V);
          }
          s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive(p, d));
        }
        if (m && (B !== p || s.state.active === !1)) {
          n.setActiveLink(p);
          var z = s.props.saveHashHistory, q = z === void 0 ? !1 : z;
          s.props.hashSpy && Ji.default.changeHash(p, q), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(p, d));
        }
      }
    };
  };
  return r.propTypes = gA, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(p1, "__esModule", {
  value: !0
});
var cbe = Ee, mA = c$(cbe), pbe = Ec, dbe = c$(pbe);
function c$(e) {
  return e && e.__esModule ? e : { default: e };
}
function fbe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function vA(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function hbe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var gbe = function(e) {
  hbe(t, e);
  function t() {
    var n, r, o, i;
    fbe(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = vA(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return mA.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), vA(o, i);
  }
  return t;
}(mA.default.Component);
p1.default = (0, dbe.default)(gbe);
var v1 = {};
Object.defineProperty(v1, "__esModule", {
  value: !0
});
var mbe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), vbe = Ee, yA = p$(vbe), ybe = Ec, bbe = p$(ybe);
function p$(e) {
  return e && e.__esModule ? e : { default: e };
}
function wbe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Cbe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Obe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var xbe = function(e) {
  Obe(t, e);
  function t() {
    return wbe(this, t), Cbe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return mbe(t, [{
    key: "render",
    value: function() {
      return yA.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(yA.default.Component);
v1.default = (0, bbe.default)(xbe);
var y1 = {}, Qg = {};
Object.defineProperty(Qg, "__esModule", {
  value: !0
});
var Ebe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Lbe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Pbe = Ee, bA = em(Pbe), kbe = Ga;
em(kbe);
var Sbe = ll, wA = em(Sbe), Dbe = Jg, CA = em(Dbe);
function em(e) {
  return e && e.__esModule ? e : { default: e };
}
function Mbe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Tbe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function jbe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Qg.default = function(e) {
  var t = function(n) {
    jbe(r, n);
    function r(o) {
      Mbe(this, r);
      var i = Tbe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Lbe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        wA.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        wA.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return bA.default.createElement(e, Ebe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(bA.default.Component);
  return t.propTypes = {
    name: CA.default.string,
    id: CA.default.string
  }, t;
};
Object.defineProperty(y1, "__esModule", {
  value: !0
});
var OA = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, _be = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Abe = Ee, xA = b1(Abe), Bbe = Qg, Ibe = b1(Bbe), Nbe = Jg, EA = b1(Nbe);
function b1(e) {
  return e && e.__esModule ? e : { default: e };
}
function Fbe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Rbe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function zbe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var d$ = function(e) {
  zbe(t, e);
  function t() {
    return Fbe(this, t), Rbe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return _be(t, [{
    key: "render",
    value: function() {
      var r = this, o = OA({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, xA.default.createElement(
        "div",
        OA({}, o, { ref: function(s) {
          r.props.parentBindings.domNode = s;
        } }),
        this.props.children
      );
    }
  }]), t;
}(xA.default.Component);
d$.propTypes = {
  name: EA.default.string,
  id: EA.default.string
};
y1.default = (0, Ibe.default)(d$);
var vy = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, LA = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function PA(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function kA(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function SA(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ad = Ee, Ws = Lc, yy = ll, cr = Jg, Xi = Xg, DA = {
  to: cr.string.isRequired,
  containerId: cr.string,
  container: cr.object,
  activeClass: cr.string,
  spy: cr.bool,
  smooth: cr.oneOfType([cr.bool, cr.string]),
  offset: cr.number,
  delay: cr.number,
  isDynamic: cr.bool,
  onClick: cr.func,
  duration: cr.oneOfType([cr.number, cr.func]),
  absolute: cr.bool,
  onSetActive: cr.func,
  onSetInactive: cr.func,
  ignoreCancelEvents: cr.bool,
  hashSpy: cr.bool,
  spyThrottle: cr.number
}, Ube = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || yy, o = function(s) {
      SA(a, s);
      function a(l) {
        PA(this, a);
        var u = kA(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return LA(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            Ws.isMounted(u) || Ws.mount(u, this.props.spyThrottle), this.props.hashSpy && (Xi.isMounted() || Xi.mount(r), Xi.mapContainer(this.props.to, u)), this.props.spy && Ws.addStateHandler(this.stateHandler), Ws.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Ws.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = vy({}, this.props);
          for (var p in DA)
            c.hasOwnProperty(p) && delete c[p];
          return c.className = u, c.onClick = this.handleClick, ad.createElement(t, c);
        }
      }]), a;
    }(ad.Component), i = function() {
      var a = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, vy({}, a.state, u));
      }, this.handleClick = function(l) {
        a.props.onClick && a.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), a.scrollTo(a.props.to, a.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== a.props.to && (a.state !== null && a.state.active && a.props.onSetInactive && a.props.onSetInactive(), a.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = a.getScrollSpyContainer();
        if (!(Xi.isMounted() && !Xi.isInitialized())) {
          var c = a.props.to, p = null, d = 0, m = 0, f = 0;
          if (u.getBoundingClientRect) {
            var g = u.getBoundingClientRect();
            f = g.top;
          }
          if (!p || a.props.isDynamic) {
            if (p = r.get(c), !p)
              return;
            var h = p.getBoundingClientRect();
            d = h.top - f + l, m = d + h.height;
          }
          var x = l - a.props.offset, w = x >= Math.floor(d) && x < Math.floor(m), D = x < Math.floor(d) || x >= Math.floor(m), O = r.getActiveLink();
          if (D)
            return c === O && r.setActiveLink(void 0), a.props.hashSpy && Xi.getHash() === c && Xi.changeHash(), a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive()), Ws.updateStates();
          if (w && O !== c)
            return r.setActiveLink(c), a.props.hashSpy && Xi.changeHash(c), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(c)), Ws.updateStates();
        }
      };
    };
    return o.propTypes = DA, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      SA(o, r);
      function o(i) {
        PA(this, o);
        var s = kA(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return s.childBindings = {
          domNode: null
        }, s;
      }
      return LA(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(s) {
          this.props.name !== s.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          yy.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(s) {
          yy.register(s, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return ad.createElement(t, vy({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(ad.Component);
    return n.propTypes = {
      name: cr.string,
      id: cr.string
    }, n;
  }
}, $be = Ube;
Object.defineProperty(br, "__esModule", {
  value: !0
});
br.Helpers = br.ScrollElement = br.ScrollLink = x$ = br.animateScroll = br.scrollSpy = br.Events = br.scroller = br.Element = br.Button = br.Link = void 0;
var Vbe = p1, f$ = ui(Vbe), Hbe = v1, h$ = ui(Hbe), Wbe = y1, g$ = ui(Wbe), Zbe = ll, m$ = ui(Zbe), qbe = Sc, v$ = ui(qbe), Gbe = Lc, y$ = ui(Gbe), Ybe = Gg, b$ = ui(Ybe), Kbe = Ec, w$ = ui(Kbe), Jbe = Qg, C$ = ui(Jbe), Xbe = $be, O$ = ui(Xbe);
function ui(e) {
  return e && e.__esModule ? e : { default: e };
}
br.Link = f$.default;
br.Button = h$.default;
br.Element = g$.default;
br.scroller = m$.default;
br.Events = v$.default;
br.scrollSpy = y$.default;
var x$ = br.animateScroll = b$.default;
br.ScrollLink = w$.default;
br.ScrollElement = C$.default;
br.Helpers = O$.default;
br.default = { Link: f$.default, Button: h$.default, Element: g$.default, scroller: m$.default, Events: v$.default, scrollSpy: y$.default, animateScroll: b$.default, ScrollLink: w$.default, ScrollElement: C$.default, Helpers: O$.default };
const w1 = Ge({}), E$ = Ge({});
function Qbe() {
  const e = xe(E$);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function MA(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function C1e() {
  const e = C0(), { closeModal: t, closeAll: n } = xe(w1), { showToast: r } = Qbe(), { getParam: o } = t$(), { pathname: i } = O0(), s = oI(), a = o("closeAllModals");
  v(() => {
    a === "true" && (n(), s(i));
  }, [a]), v(() => {
    const l = e == null ? void 0 : e.closeModalKey;
    l && t(l);
  }, [e]), v(() => {
    const l = e == null ? void 0 : e.closeAllModals;
    typeof l == "boolean" && l && n();
  }, [e]), v(() => {
    const l = e == null ? void 0 : e.toast, u = e == null ? void 0 : e.message;
    MA(l) && r(l), !MA(l) && u && r({ message: u, type: "danger" });
  }, [e]), v(() => {
    var l, u;
    if (typeof ((l = e == null ? void 0 : e.data) == null ? void 0 : l.scrollTo) == "string") {
      const c = document.getElementById((u = e == null ? void 0 : e.data) == null ? void 0 : u.scrollTo);
      c && x$.scrollTo(c.offsetTop - 200);
    }
  }, [e]);
}
const L$ = Ge({});
function O1e(e) {
  const t = xe(L$);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, s = r(e), a = n(e);
    return { drawerIsOpen: s, drawerData: a, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function e0e() {
  return () => {
  };
}
function t0e() {
  return J$(
    e0e,
    () => !0,
    () => !1
  );
}
function x1e(e) {
  const t = xe(w1);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, s = r(e), a = n(e);
    return { modalIsOpen: s, modalData: a, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function E1e(e) {
  const { children: t = !1 } = e, [n, r] = P([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function s(l, u) {
    const c = o(l);
    r(c ? (p) => [...p.filter((m) => m.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function a(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ K.jsx(
    L$.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: s, closeDrawer: a },
      children: t
    }
  );
}
function Gu(e) {
  "@babel/helpers - typeof";
  return Gu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Gu(e);
}
function n0e(e, t) {
  if (Gu(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Gu(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function r0e(e) {
  var t = n0e(e, "string");
  return Gu(t) == "symbol" ? t : t + "";
}
function de(e, t, n) {
  return (t = r0e(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function P$(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var by, TA;
function o0e() {
  if (TA) return by;
  TA = 1;
  var e = process.env.NODE_ENV, t = function(r, o, i, s, a, l, u, c) {
    if (e !== "production" && o === void 0)
      throw new Error("invariant requires an error message argument");
    if (!r) {
      var p;
      if (o === void 0)
        p = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [i, s, a, l, u, c], m = 0;
        p = new Error(o.replace(/%s/g, function() {
          return d[m++];
        })), p.name = "Invariant Violation";
      }
      throw p.framesToPop = 1, p;
    }
  };
  return by = t, by;
}
var i0e = o0e(), kr = /* @__PURE__ */ P$(i0e), ht = Ge(null);
function s0e() {
  kr(!!xe, "useGoogleMap is React hook and requires React version 16.8+");
  var e = xe(ht);
  return kr(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function a0e(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function l0e(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function u0e(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return l0e(e, i), o;
}
function c0e(e, t, n) {
  var r = a0e(n, function(i, s, a) {
    return typeof e[a] == "function" && i.push(google.maps.event.addListener(t, s, e[a])), i;
  }, []);
  return r;
}
function p0e(e) {
  google.maps.event.removeListener(e);
}
function _t() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(p0e);
}
function kt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = c0e(o, i, n);
  return u0e(t, r, o, i), s;
}
var jA = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, _A = {
  extraMapTypes(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center(e, t) {
    e.setCenter(t);
  },
  clickableIcons(e, t) {
    e.setClickableIcons(t);
  },
  heading(e, t) {
    e.setHeading(t);
  },
  mapTypeId(e, t) {
    e.setMapTypeId(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  streetView(e, t) {
    e.setStreetView(t);
  },
  tilt(e, t) {
    e.setTilt(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
function d0e(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: m,
    onMouseOver: f,
    onMouseDown: g,
    onMouseUp: h,
    onRightClick: x,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: O
  } = e, [y, C] = P(null), S = Qe(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null), [A, Q] = P(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof s < "u" && y.setCenter(s);
  }, [y, s]), v(() => {
    y && l && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && g && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(y, "mousedown", g)));
  }, [g]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && m && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(y, "mouseout", m)));
  }, [m]), v(() => {
    y && f && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && h && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && x && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(y, "rightclick", x)));
  }, [x]), v(() => {
    y && a && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(y, "click", a)));
  }, [a]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [a]), v(() => {
    var N = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(N), N !== null && D && D(N), () => {
      N !== null && O && O(N);
    };
  }, []), K.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: K.jsx(ht.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
Le(d0e);
let f0e = class extends be {
  constructor() {
    super(...arguments), de(this, "state", {
      map: null
    }), de(this, "registeredEvents", []), de(this, "mapRef", null), de(this, "getInstance", () => this.mapRef === null ? null : new google.maps.Map(this.mapRef, this.props.options)), de(this, "panTo", (t) => {
      var n = this.getInstance();
      n && n.panTo(t);
    }), de(this, "setMapCallback", () => {
      this.state.map !== null && this.props.onLoad && this.props.onLoad(this.state.map);
    }), de(this, "getRef", (t) => {
      this.mapRef = t;
    });
  }
  componentDidMount() {
    var t = this.getInstance();
    this.registeredEvents = kt({
      updaterMap: _A,
      eventMap: jA,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        map: t
      };
    }, this.setMapCallback);
  }
  componentDidUpdate(t) {
    this.state.map !== null && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: _A,
      eventMap: jA,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.map
    }));
  }
  componentWillUnmount() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), _t(this.registeredEvents));
  }
  render() {
    return K.jsx("div", {
      id: this.props.id,
      ref: this.getRef,
      style: this.props.mapContainerStyle,
      className: this.props.mapContainerClassName,
      children: K.jsx(ht.Provider, {
        value: this.state.map,
        children: this.state.map !== null ? this.props.children : null
      })
    });
  }
};
function AA(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function k$(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        AA(i, r, o, s, a, "next", l);
      }
      function a(l) {
        AA(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function S$(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return kr(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var ca = typeof document < "u";
function D$(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return ca ? new Promise(function(i, s) {
    var a = document.getElementById(n), l = window;
    if (a) {
      var u = a.getAttribute("data-state");
      if (a.src === t && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, p = a.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, a.onerror = function(m) {
          p && p(m), s(m);
        };
        return;
      } else
        a.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(f) {
      d.setAttribute("data-state", "error"), s(f);
    }, l.initMap = function() {
      d.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function BA(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function M$() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return BA(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return BA(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
var Bl = !1;
function T$() {
  return K.jsx("div", {
    children: "Loading..."
  });
}
var f0 = {
  id: "script-loader",
  version: "weekly"
};
class j$ extends be {
  constructor() {
    super(...arguments), de(this, "check", wr()), de(this, "state", {
      loaded: !1
    }), de(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), de(this, "isCleaningUp", /* @__PURE__ */ k$(function* () {
      function t(n) {
        if (!Bl)
          n();
        else if (ca)
          var r = window.setInterval(function() {
            Bl || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), de(this, "cleanup", () => {
      Bl = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(r) {
        return typeof r.src == "string" && r.src.includes("maps.googleapis");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(r) {
        return r.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(r) {
        return r.innerText !== void 0 && r.innerText.length > 0 && r.innerText.includes(".gm-");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      });
    }), de(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && M$(), kr(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: S$(this.props)
      };
      D$(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (ca) {
      if (window.google && window.google.maps && !Bl) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), ca && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (ca) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Bl = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return K.jsxs(K.Fragment, {
      children: [K.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || K.jsx(T$, {})]
    });
  }
}
de(j$, "defaultProps", f0);
function h0e(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function C1(e, t) {
  if (e == null) return {};
  var n, r, o = h0e(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var IA;
function g0e(e) {
  var {
    id: t = f0.id,
    version: n = f0.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, m = Qe(!1), [f, g] = P(!1), [h, x] = P(void 0);
  v(function() {
    return m.current = !0, () => {
      m.current = !1;
    };
  }, []), v(function() {
    ca && u && M$();
  }, [u]), v(function() {
    f && kr(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = S$({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!ca)
      return;
    function y() {
      m.current && (g(!0), IA = w);
    }
    if (window.google && window.google.maps && IA === w) {
      y();
      return;
    }
    D$({
      id: t,
      url: w,
      nonce: r
    }).then(y).catch(function(S) {
      m.current && x(S), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(S);
    });
  }, [t, w, r]);
  var D = Qe();
  return v(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var m0e = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], v0e = K.jsx(T$, {});
function y0e(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = C1(e, m0e), {
    isLoaded: a,
    loadError: l
  } = g0e(s);
  return v(function() {
    a && typeof n == "function" && n();
  }, [a, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || v0e;
}
Le(y0e);
var NA;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(NA || (NA = {}));
function FA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FA(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var RA = {}, zA = {
  options(e, t) {
    e.setOptions(t);
  }
};
function b0e(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = xe(ht), [i, s] = P(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var a = new google.maps.TrafficLayer(Wf(Wf({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Le(b0e);
class w0e extends be {
  constructor() {
    super(...arguments), de(this, "state", {
      trafficLayer: null
    }), de(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), de(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Wf(Wf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: zA,
      eventMap: RA,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: zA,
      eventMap: RA,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), _t(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
de(w0e, "contextType", ht);
function C0e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = xe(ht), [o, i] = P(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
Le(C0e);
class O0e extends be {
  constructor() {
    super(...arguments), de(this, "state", {
      bicyclingLayer: null
    }), de(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
de(O0e, "contextType", ht);
function x0e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = xe(ht), [o, i] = P(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Le(x0e);
class E0e extends be {
  constructor() {
    super(...arguments), de(this, "state", {
      transitLayer: null
    }), de(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
de(E0e, "contextType", ht);
function UA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UA(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $A = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, VA = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function L0e(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = xe(ht), [d, m] = P(null), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), g(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && s && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(d, "polygoncomplete", s)));
  }, [d, s]), v(() => {
    d && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", a)));
  }, [d, a]), v(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    kr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var F = new google.maps.drawing.DrawingManager(Zf(Zf({}, t), {}, {
      map: p
    }));
    return n && F.setDrawingMode(n), r && g(google.maps.event.addListener(F, "circlecomplete", r)), o && x(google.maps.event.addListener(F, "markercomplete", o)), i && D(google.maps.event.addListener(F, "overlaycomplete", i)), s && y(google.maps.event.addListener(F, "polygoncomplete", s)), a && S(google.maps.event.addListener(F, "polylinecomplete", a)), l && L(google.maps.event.addListener(F, "rectanglecomplete", l)), m(F), u && u(F), () => {
      d !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
Le(L0e);
class P0e extends be {
  constructor(t) {
    super(t), de(this, "registeredEvents", []), de(this, "state", {
      drawingManager: null
    }), de(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), kr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Zf(Zf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: VA,
      eventMap: $A,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: VA,
      eventMap: $A,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), _t(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
de(P0e, "contextType", ht);
function HA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function za(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HA(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var WA = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, ZA = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, qf = {};
function k0e(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: m,
    shape: f,
    title: g,
    zIndex: h,
    onClick: x,
    onDblClick: w,
    onDrag: D,
    onDragEnd: O,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: L,
    onRightClick: F,
    onClickableChanged: B,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: q,
    onIconChanged: X,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: k,
    onZindexChanged: j,
    onLoad: H,
    onUnmount: M
  } = e, Z = xe(ht), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null), [Q, N] = P(null), [ue, ye] = P(null), [oe, Ie] = P(null), [$e, Ve] = P(null), [Ne, Je] = P(null), [Ye, Te] = P(null), [Ke, nt] = P(null), [Me, Ae] = P(null), [Fe, He] = P(null), [ze, et] = P(null), [_e, At] = P(null), [rt, ot] = P(null), [at, qt] = P(null), [lt, Gt] = P(null), [Xe, bt] = P(null), [tt, Yt] = P(null), [ut, dn] = P(null), [Kt, fn] = P(null), [Jt, hn] = P(null);
  v(() => {
    E !== null && E.setMap(Z);
  }, [Z]), v(() => {
    typeof n < "u" && E !== null && E.setOptions(n);
  }, [E, n]), v(() => {
    typeof s < "u" && E !== null && E.setDraggable(s);
  }, [E, s]), v(() => {
    t && E !== null && E.setPosition(t);
  }, [E, t]), v(() => {
    typeof a < "u" && E !== null && E.setVisible(a);
  }, [E, a]), v(() => {
    E == null || E.setAnimation(l);
  }, [E, l]), v(() => {
    E && u !== void 0 && E.setClickable(u);
  }, [E, u]), v(() => {
    E && c !== void 0 && E.setCursor(c);
  }, [E, c]), v(() => {
    E && p !== void 0 && E.setIcon(p);
  }, [E, p]), v(() => {
    E && d !== void 0 && E.setLabel(d);
  }, [E, d]), v(() => {
    E && m !== void 0 && E.setOpacity(m);
  }, [E, m]), v(() => {
    E && f !== void 0 && E.setShape(f);
  }, [E, f]), v(() => {
    E && g !== void 0 && E.setTitle(g);
  }, [E, g]), v(() => {
    E && h !== void 0 && E.setZIndex(h);
  }, [E, h]), v(() => {
    E && w && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(E, "dblclick", w)));
  }, [w]), v(() => {
    E && O && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(E, "dragend", O)));
  }, [O]), v(() => {
    E && y && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(E, "dragstart", y)));
  }, [y]), v(() => {
    E && L && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(E, "mousedown", L)));
  }, [L]), v(() => {
    E && C && (oe !== null && google.maps.event.removeListener(oe), Ie(google.maps.event.addListener(E, "mouseout", C)));
  }, [C]), v(() => {
    E && S && ($e !== null && google.maps.event.removeListener($e), Ve(google.maps.event.addListener(E, "mouseover", S)));
  }, [S]), v(() => {
    E && U && (Ne !== null && google.maps.event.removeListener(Ne), Je(google.maps.event.addListener(E, "mouseup", U)));
  }, [U]), v(() => {
    E && F && (Ye !== null && google.maps.event.removeListener(Ye), Te(google.maps.event.addListener(E, "rightclick", F)));
  }, [F]), v(() => {
    E && x && (Ke !== null && google.maps.event.removeListener(Ke), nt(google.maps.event.addListener(E, "click", x)));
  }, [x]), v(() => {
    E && D && (Me !== null && google.maps.event.removeListener(Me), Ae(google.maps.event.addListener(E, "drag", D)));
  }, [D]), v(() => {
    E && B && (Fe !== null && google.maps.event.removeListener(Fe), He(google.maps.event.addListener(E, "clickable_changed", B)));
  }, [B]), v(() => {
    E && $ && (ze !== null && google.maps.event.removeListener(ze), et(google.maps.event.addListener(E, "cursor_changed", $)));
  }, [$]), v(() => {
    E && V && (_e !== null && google.maps.event.removeListener(_e), At(google.maps.event.addListener(E, "animation_changed", V)));
  }, [V]), v(() => {
    E && z && (rt !== null && google.maps.event.removeListener(rt), ot(google.maps.event.addListener(E, "draggable_changed", z)));
  }, [z]), v(() => {
    E && q && (at !== null && google.maps.event.removeListener(at), qt(google.maps.event.addListener(E, "flat_changed", q)));
  }, [q]), v(() => {
    E && X && (lt !== null && google.maps.event.removeListener(lt), Gt(google.maps.event.addListener(E, "icon_changed", X)));
  }, [X]), v(() => {
    E && J && (Xe !== null && google.maps.event.removeListener(Xe), bt(google.maps.event.addListener(E, "position_changed", J)));
  }, [J]), v(() => {
    E && te && (tt !== null && google.maps.event.removeListener(tt), Yt(google.maps.event.addListener(E, "shape_changed", te)));
  }, [te]), v(() => {
    E && ee && (ut !== null && google.maps.event.removeListener(ut), dn(google.maps.event.addListener(E, "title_changed", ee)));
  }, [ee]), v(() => {
    E && k && (Kt !== null && google.maps.event.removeListener(Kt), fn(google.maps.event.addListener(E, "visible_changed", k)));
  }, [k]), v(() => {
    E && j && (Jt !== null && google.maps.event.removeListener(Jt), hn(google.maps.event.addListener(E, "zindex_changed", j)));
  }, [j]), v(() => {
    var wt = za(za(za({}, n || qf), r ? qf : {
      map: Z
    }), {}, {
      position: t
    }), re = new google.maps.Marker(wt);
    return r ? r.addMarker(re, !!o) : re.setMap(Z), t && re.setPosition(t), typeof a < "u" && re.setVisible(a), typeof s < "u" && re.setDraggable(s), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof m < "u" && re.setOpacity(m), f && re.setShape(f), typeof g == "string" && re.setTitle(g), typeof h == "number" && re.setZIndex(h), w && _(google.maps.event.addListener(re, "dblclick", w)), O && A(google.maps.event.addListener(re, "dragend", O)), y && N(google.maps.event.addListener(re, "dragstart", y)), L && ye(google.maps.event.addListener(re, "mousedown", L)), C && Ie(google.maps.event.addListener(re, "mouseout", C)), S && Ve(google.maps.event.addListener(re, "mouseover", S)), U && Je(google.maps.event.addListener(re, "mouseup", U)), F && Te(google.maps.event.addListener(re, "rightclick", F)), x && nt(google.maps.event.addListener(re, "click", x)), D && Ae(google.maps.event.addListener(re, "drag", D)), B && He(google.maps.event.addListener(re, "clickable_changed", B)), $ && et(google.maps.event.addListener(re, "cursor_changed", $)), V && At(google.maps.event.addListener(re, "animation_changed", V)), z && ot(google.maps.event.addListener(re, "draggable_changed", z)), q && qt(google.maps.event.addListener(re, "flat_changed", q)), X && Gt(google.maps.event.addListener(re, "icon_changed", X)), J && bt(google.maps.event.addListener(re, "position_changed", J)), te && Yt(google.maps.event.addListener(re, "shape_changed", te)), ee && dn(google.maps.event.addListener(re, "title_changed", ee)), k && fn(google.maps.event.addListener(re, "visible_changed", k)), j && hn(google.maps.event.addListener(re, "zindex_changed", j)), T(re), H && H(re), () => {
      R !== null && google.maps.event.removeListener(R), W !== null && google.maps.event.removeListener(W), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), $e !== null && google.maps.event.removeListener($e), Ne !== null && google.maps.event.removeListener(Ne), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Fe !== null && google.maps.event.removeListener(Fe), ze !== null && google.maps.event.removeListener(ze), _e !== null && google.maps.event.removeListener(_e), rt !== null && google.maps.event.removeListener(rt), at !== null && google.maps.event.removeListener(at), lt !== null && google.maps.event.removeListener(lt), Xe !== null && google.maps.event.removeListener(Xe), ut !== null && google.maps.event.removeListener(ut), Kt !== null && google.maps.event.removeListener(Kt), Jt !== null && google.maps.event.removeListener(Jt), M && M(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Fn = Nn(() => i ? it.map(i, (wt) => {
    if (!ti(wt))
      return wt;
    var re = wt;
    return ni(re, {
      anchor: E
    });
  }) : null, [i, E]);
  return K.jsx(K.Fragment, {
    children: Fn
  }) || null;
}
Le(k0e);
class _$ extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return k$(function* () {
      var n = za(za(za({}, t.props.options || qf), t.props.clusterer ? qf : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = kt({
        updaterMap: ZA,
        eventMap: WA,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: ZA,
      eventMap: WA,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), _t(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? it.map(this.props.children, (n) => {
      if (!ti(n))
        return n;
      var r = n;
      return ni(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
de(_$, "contextType", ht);
var S0e = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var m = document.createElement("div");
        m.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (m.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (m.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(m), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), D0e = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new S0e(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function M0e(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var T0e = 2e3, j0e = 500, _0e = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", A0e = "png", B0e = [53, 56, 66, 78, 90], I0e = "cluster", A$ = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || _0e, this.imageExtension = r.imageExtension || A0e, this.imageSizes = r.imageSizes || B0e, this.calculator = r.calculator || M0e, this.batchSize = r.batchSize || T0e, this.batchSizeIE = r.batchSizeIE || j0e, this.clusterClass = r.clusterClass || I0e, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new D0e(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var m = d[p];
            m.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var s = i;
          this.prototype[s] = o.prototype[s];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function qA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function N0e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qA(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Bo = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, rn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, F0e = {};
function R0e(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: m,
    minimumClusterSize: f,
    styles: g,
    title: h,
    zoomOnClick: x,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: O,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [L, F] = P(null), B = xe(ht), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null);
  return v(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, Bo.onMouseOut, C)));
  }, [C]), v(() => {
    L && y && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(L, Bo.onMouseOver, y)));
  }, [y]), v(() => {
    L && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(L, Bo.onClick, w)));
  }, [w]), v(() => {
    L && D && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(L, Bo.onClusteringBegin, D)));
  }, [D]), v(() => {
    L && O && (X !== null && google.maps.event.removeListener(X), q(google.maps.event.addListener(L, Bo.onClusteringEnd, O)));
  }, [O]), v(() => {
    typeof r < "u" && L !== null && rn.averageCenter(L, r);
  }, [L, r]), v(() => {
    typeof o < "u" && L !== null && rn.batchSizeIE(L, o);
  }, [L, o]), v(() => {
    typeof i < "u" && L !== null && rn.calculator(L, i);
  }, [L, i]), v(() => {
    typeof s < "u" && L !== null && rn.clusterClass(L, s);
  }, [L, s]), v(() => {
    typeof a < "u" && L !== null && rn.enableRetinaIcons(L, a);
  }, [L, a]), v(() => {
    typeof l < "u" && L !== null && rn.gridSize(L, l);
  }, [L, l]), v(() => {
    typeof u < "u" && L !== null && rn.ignoreHidden(L, u);
  }, [L, u]), v(() => {
    typeof c < "u" && L !== null && rn.imageExtension(L, c);
  }, [L, c]), v(() => {
    typeof p < "u" && L !== null && rn.imagePath(L, p);
  }, [L, p]), v(() => {
    typeof d < "u" && L !== null && rn.imageSizes(L, d);
  }, [L, d]), v(() => {
    typeof m < "u" && L !== null && rn.maxZoom(L, m);
  }, [L, m]), v(() => {
    typeof f < "u" && L !== null && rn.minimumClusterSize(L, f);
  }, [L, f]), v(() => {
    typeof g < "u" && L !== null && rn.styles(L, g);
  }, [L, g]), v(() => {
    typeof h < "u" && L !== null && rn.title(L, h);
  }, [L, h]), v(() => {
    typeof x < "u" && L !== null && rn.zoomOnClick(L, x);
  }, [L, x]), v(() => {
    if (B) {
      var H = N0e({}, n || F0e), M = new A$(B, [], H);
      return r && rn.averageCenter(M, r), o && rn.batchSizeIE(M, o), i && rn.calculator(M, i), s && rn.clusterClass(M, s), a && rn.enableRetinaIcons(M, a), l && rn.gridSize(M, l), u && rn.ignoreHidden(M, u), c && rn.imageExtension(M, c), p && rn.imagePath(M, p), d && rn.imageSizes(M, d), m && rn.maxZoom(M, m), f && rn.minimumClusterSize(M, f), g && rn.styles(M, g), h && rn.title(M, h), x && rn.zoomOnClick(M, x), C && ee(google.maps.event.addListener(M, Bo.onMouseOut, C)), y && j(google.maps.event.addListener(M, Bo.onMouseOver, y)), w && V(google.maps.event.addListener(M, Bo.onClick, w)), D && q(google.maps.event.addListener(M, Bo.onClusteringBegin, D)), O && J(google.maps.event.addListener(M, Bo.onClusteringEnd, O)), F(M), S && S(M), () => {
        te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), U && U(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
Le(R0e);
class z0e extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      markerClusterer: null
    }), de(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new A$(this.context, [], this.props.options);
      this.registeredEvents = kt({
        updaterMap: rn,
        eventMap: Bo,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: rn,
      eventMap: Bo,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), _t(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
de(z0e, "contextType", ht);
function GA(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var B$ = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(c) {
        c.returnValue = !1, c.preventDefault && c.preventDefault(), t.enableEventPropagation || GA(c);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, GA));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, m = this.infoBoxClearance.width, f = this.infoBoxClearance.height, g = this.getProjection(), h = g.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + m ? r = h.x + u - m : h.x + p + u + m > a && (r = h.x + p + u + m - a), this.alignBottom ? h.y < -c + f + d ? o = h.y + c - f - d : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + d + c + f > l && (o = h.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), U0e = ["position"], $0e = ["position"];
function YA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YA(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var KA = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, JA = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, V0e = {};
function H0e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = xe(ht), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), F = Qe(null);
  return v(() => {
    m && f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (m) {
      var B = r || V0e, {
        position: $
      } = B, V = C1(B, U0e), z;
      $ && !($ instanceof google.maps.LatLng) && (z = new google.maps.LatLng($.lat, $.lng));
      var q = new B$(Gf(Gf({}, V), z ? {
        position: z
      } : {}));
      F.current = document.createElement("div"), g(q), s && x(google.maps.event.addListener(q, "closeclick", s)), a && D(google.maps.event.addListener(q, "domready", a)), l && y(google.maps.event.addListener(q, "content_changed", l)), u && S(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(F.current), n ? q.open(m, n) : q.getPosition() ? q.open(m) : kr(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), F.current ? Cr(it.only(t), F.current) : null;
}
Le(H0e);
class W0e extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "containerElement", null), de(this, "state", {
      infoBox: null
    }), de(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : kr(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), de(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = C1(t, $0e), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new B$(Gf(Gf({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = kt({
      updaterMap: JA,
      eventMap: KA,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: JA,
      eventMap: KA,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), _t(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Cr(it.only(this.props.children), this.containerElement) : null;
  }
}
de(W0e, "contextType", ht);
var wy, XA;
function Z0e() {
  return XA || (XA = 1, wy = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), wy;
}
var q0e = Z0e(), QA = /* @__PURE__ */ P$(q0e), eB = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Cy = 1, Il = 8;
class O1 {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Cy)
      throw new Error("Got v".concat(o, " data when expected v").concat(Cy, "."));
    var i = eB[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new O1(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = eB.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Il, t), this.coords = new this.ArrayType(this.data, Il + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Il + s + a + l), this.ids = new this.IndexArrayType(this.data, Il, t), this.coords = new this.ArrayType(this.data, Il + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Cy << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return h0(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (var m = d; m <= p; m++) {
          var f = s[2 * m], g = s[2 * m + 1];
          f >= t && f <= r && g >= n && g <= o && u.push(i[m]);
        }
        continue;
      }
      var h = d + p >> 1, x = s[2 * h], w = s[2 * h + 1];
      x >= t && x <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= x : n <= w) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= x : o >= w) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (var m = d; m <= p; m++)
          tB(i[2 * m], i[2 * m + 1], t, n) <= u && l.push(o[m]);
        continue;
      }
      var f = d + p >> 1, g = i[2 * f], h = i[2 * f + 1];
      tB(g, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= g : n - r <= h) && (a.push(d), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= h) && (a.push(f + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function h0(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    I$(e, t, s, r, o, i), h0(e, t, n, r, s - 1, 1 - i), h0(e, t, n, s + 1, o, 1 - i);
  }
}
function I$(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - a * u / s + c)), d = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      I$(e, t, n, p, d, i);
    }
    var m = t[2 * n + i], f = r, g = o;
    for (Nl(e, t, r, n), t[2 * o + i] > m && Nl(e, t, r, o); f < g; ) {
      for (Nl(e, t, f, g), f++, g--; t[2 * f + i] < m; ) f++;
      for (; t[2 * g + i] > m; ) g--;
    }
    t[2 * r + i] === m ? Nl(e, t, r, g) : (g++, Nl(e, t, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1);
  }
}
function Nl(e, t, n, r) {
  Oy(e, n, r), Oy(t, 2 * n, 2 * r), Oy(t, 2 * n + 1, 2 * r + 1);
}
function Oy(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function tB(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var G0e = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, nB = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Zs = 2, cs = 3, xy = 4, rs = 5, N$ = 6;
class Y0e {
  constructor(t) {
    this.options = Object.assign(Object.create(G0e), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = nB(ld(u)), d = nB(ud(c));
        s.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var m = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var g = +Date.now();
      m = this.trees[f] = this._createTree(this._cluster(m, f)), n && console.log("z%d: %d clusters in %dms", f, m.numItems, +Date.now() - g);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(ld(r), ud(s), ld(i), ud(o)), p = u.data, d = [];
    for (var m of c) {
      var f = this.stride * m;
      d.push(p[f + rs] > 1 ? rB(p, f, this.clusterProps) : this.points[p[f + cs]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (var d of c) {
      var m = d * this.stride;
      s[m + xy] === t && p.push(s[m + rs] > 1 ? rB(s, m, this.clusterProps) : this.points[s[m + cs]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new O1(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + rs] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = F$(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var m = this.points[n[l + cs]];
        c = m.properties;
        var [f, g] = m.geometry.coordinates;
        p = ld(f), d = ud(g);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, x = void 0;
      u || this.options.generateId ? x = n[l + cs] : x = this.points[n[l + cs]].id, x !== void 0 && (h.id = x), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Zs] <= n)) {
        l[p + Zs] = n;
        var d = l[p], m = l[p + 1], f = t.within(l[p], l[p + 1], a), g = l[p + rs], h = g;
        for (var x of f) {
          var w = x * c;
          l[w + Zs] > n && (h += l[w + rs]);
        }
        if (h > g && h >= s) {
          var D = d * g, O = m * g, y = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var L = U * c;
            if (!(l[L + Zs] <= n)) {
              l[L + Zs] = n;
              var F = l[L + rs];
              D += l[L] * F, O += l[L + 1] * F, l[L + xy] = S, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + xy] = S, u.push(D / h, O / h, 1 / 0, S, -1, h), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (h > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Zs] <= n)) {
                l[V + Zs] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + rs] > 1) {
      var o = this.clusterProps[t[n + N$]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + cs]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function rB(e, t, n) {
  return {
    type: "Feature",
    id: e[t + cs],
    properties: F$(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [K0e(e[t]), J0e(e[t + 1])]
    }
  };
}
function F$(e, t, n) {
  var r = e[t + rs], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + N$], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + cs],
    point_count: r,
    point_count_abbreviated: o
  });
}
function ld(e) {
  return e / 360 + 0.5;
}
function ud(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function K0e(e) {
  return (e - 0.5) * 360;
}
function J0e(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function X0e(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class bo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class g0 {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(bo.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => bo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (bo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Q0e {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return ewe(n);
  }
}
var ewe = (e) => {
  var t = e.map((n) => new g0({
    position: bo.getPosition(n),
    markers: [n]
  }));
  return t;
};
class twe extends Q0e {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = X0e(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Y0e(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!QA(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = bo.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !QA(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new g0({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new g0({
      markers: [i],
      position: bo.getPosition(i)
    });
  }
}
class nwe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class rwe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (bo.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(a, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var m = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(m);
  }
}
function owe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class x1 {
  constructor() {
    owe(x1, google.maps.OverlayView);
  }
}
var gu;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(gu || (gu = {}));
var iwe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class swe extends x1 {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new twe(o),
      renderer: s = new rwe(),
      onClusterClick: a = iwe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (bo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, gu.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || bo.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => bo.setMap(l, null)));
      }
      google.maps.event.trigger(this, gu.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => bo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new nwe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => bo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, gu.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), bo.setMap(r.marker, n);
    });
  }
}
function oB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function awe(e) {
  var t = s0e(), [n, r] = P(null);
  return v(() => {
    if (t && n === null) {
      var o = new swe(iB(iB({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function lwe(e) {
  var {
    children: t,
    options: n
  } = e, r = awe(n);
  return r !== null ? t(r) : null;
}
Le(lwe);
var sB = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, aB = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function uwe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = xe(ht), [f, g] = P(null), [h, x] = P(null), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), F = Qe(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var B = new google.maps.InfoWindow(r);
    return g(B), F.current = document.createElement("div"), s && x(google.maps.event.addListener(B, "closeclick", s)), a && D(google.maps.event.addListener(B, "domready", a)), l && y(google.maps.event.addListener(B, "content_changed", l)), u && S(google.maps.event.addListener(B, "position_changed", u)), c && L(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(F.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(m, n) : B.getPosition() ? B.open(m) : kr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      h && google.maps.event.removeListener(h), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(B), B.close();
    };
  }, []), F.current ? Cr(it.only(t), F.current) : null;
}
Le(uwe);
class cwe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "containerElement", null), de(this, "state", {
      infoWindow: null
    }), de(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : kr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), de(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = kt({
      updaterMap: aB,
      eventMap: sB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: aB,
      eventMap: sB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (_t(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Cr(it.only(this.props.children), this.containerElement) : null;
  }
}
de(cwe, "contextType", ht);
function lB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var uB = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, cB = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, pwe = {};
function dwe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onLoad: x,
    onUnmount: w
  } = e, D = xe(ht), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null);
  return v(() => {
    O !== null && O.setMap(D);
  }, [D]), v(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), v(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), v(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), v(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), v(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), v(() => {
    O && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(O, "dblclick", s)));
  }, [s]), v(() => {
    O && a && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(O, "dragend", a)));
  }, [a]), v(() => {
    O && l && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), v(() => {
    O && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), v(() => {
    O && c && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), v(() => {
    O && p && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), v(() => {
    O && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), v(() => {
    O && m && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(O, "mouseup", m)));
  }, [m]), v(() => {
    O && f && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), v(() => {
    O && g && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(O, "click", g)));
  }, [g]), v(() => {
    O && h && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(O, "drag", h)));
  }, [h]), v(() => {
    var _ = new google.maps.Polyline(Yf(Yf({}, t || pwe), {}, {
      map: D
    }));
    return i && _.setPath(i), typeof o < "u" && _.setVisible(o), typeof r < "u" && _.setEditable(r), typeof n < "u" && _.setDraggable(n), s && S(google.maps.event.addListener(_, "dblclick", s)), a && L(google.maps.event.addListener(_, "dragend", a)), l && B(google.maps.event.addListener(_, "dragstart", l)), u && V(google.maps.event.addListener(_, "mousedown", u)), c && q(google.maps.event.addListener(_, "mousemove", c)), p && J(google.maps.event.addListener(_, "mouseout", p)), d && ee(google.maps.event.addListener(_, "mouseover", d)), m && j(google.maps.event.addListener(_, "mouseup", m)), f && M(google.maps.event.addListener(_, "rightclick", f)), g && E(google.maps.event.addListener(_, "click", g)), h && R(google.maps.event.addListener(_, "drag", h)), y(_), x && x(_), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), w && w(_), _.setMap(null);
    };
  }, []), null;
}
Le(dwe);
class fwe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      polyline: null
    }), de(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Yf(Yf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: cB,
      eventMap: uB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: cB,
      eventMap: uB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), _t(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
de(fwe, "contextType", ht);
function pB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var fB = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, hB = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function hwe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: x,
    onLoad: w,
    onUnmount: D,
    onEdit: O
  } = e, y = xe(ht), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof s < "u" && C !== null && C.setPaths(s);
  }, [C, s]), v(() => {
    C && typeof a == "function" && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(C, "dblclick", a)));
  }, [a]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      O == null || O(C);
    }));
  }, [C, O]), v(() => {
    C && typeof l == "function" && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof m == "function" && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(C, "mouseover", m)));
  }, [m]), v(() => {
    C && typeof f == "function" && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof g == "function" && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(C, "rightclick", g)));
  }, [g]), v(() => {
    C && typeof h == "function" && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(C, "click", h)));
  }, [h]), v(() => {
    C && typeof x == "function" && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(C, "drag", x)));
  }, [x]), v(() => {
    var A = new google.maps.Polygon(dB(dB({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), s && A.setPaths(s), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), a && L(google.maps.event.addListener(A, "dblclick", a)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), m && j(google.maps.event.addListener(A, "mouseover", m)), f && M(google.maps.event.addListener(A, "mouseup", f)), g && E(google.maps.event.addListener(A, "rightclick", g)), h && R(google.maps.event.addListener(A, "click", h)), x && W(google.maps.event.addListener(A, "drag", x)), S(A), w && w(A), () => {
      U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), T !== null && google.maps.event.removeListener(T), D && D(A), A.setMap(null);
    };
  }, []), null;
}
Le(hwe);
class gwe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = kt({
      updaterMap: hB,
      eventMap: fB,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: hB,
      eventMap: fB,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), _t(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
de(gwe, "contextType", ht);
function gB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mB = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, vB = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function mwe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onBoundsChanged: x,
    onLoad: w,
    onUnmount: D
  } = e, O = xe(ht), [y, C] = P(null), [S, U] = P(null), [L, F] = P(null), [B, $] = P(null), [V, z] = P(null), [q, X] = P(null), [J, te] = P(null), [ee, k] = P(null), [j, H] = P(null), [M, Z] = P(null), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null);
  return v(() => {
    y !== null && y.setMap(O);
  }, [O]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && s && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(y, "dblclick", s)));
  }, [s]), v(() => {
    y && a && (L !== null && google.maps.event.removeListener(L), F(google.maps.event.addListener(y, "dragend", a)));
  }, [a]), v(() => {
    y && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (q !== null && google.maps.event.removeListener(q), X(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && m && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(y, "mouseup", m)));
  }, [m]), v(() => {
    y && f && (M !== null && google.maps.event.removeListener(M), Z(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && g && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(y, "click", g)));
  }, [g]), v(() => {
    y && h && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(y, "drag", h)));
  }, [h]), v(() => {
    y && x && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(y, "bounds_changed", x)));
  }, [x]), v(() => {
    var Q = new google.maps.Rectangle(Kf(Kf({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), s && U(google.maps.event.addListener(Q, "dblclick", s)), a && F(google.maps.event.addListener(Q, "dragend", a)), l && $(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && X(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && k(google.maps.event.addListener(Q, "mouseover", d)), m && H(google.maps.event.addListener(Q, "mouseup", m)), f && Z(google.maps.event.addListener(Q, "rightclick", f)), g && T(google.maps.event.addListener(Q, "click", g)), h && _(google.maps.event.addListener(Q, "drag", h)), x && A(google.maps.event.addListener(Q, "bounds_changed", x)), C(Q), w && w(Q), () => {
      S !== null && google.maps.event.removeListener(S), L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), M !== null && google.maps.event.removeListener(M), E !== null && google.maps.event.removeListener(E), R !== null && google.maps.event.removeListener(R), W !== null && google.maps.event.removeListener(W), D && D(Q), Q.setMap(null);
    };
  }, []), null;
}
Le(mwe);
class vwe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      rectangle: null
    }), de(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Kf(Kf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: vB,
      eventMap: mB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: vB,
      eventMap: mB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), _t(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
de(vwe, "contextType", ht);
function yB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var bB = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, wB = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, ywe = {};
function bwe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: x,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: O,
    onUnmount: y
  } = e, C = xe(ht), [S, U] = P(null), [L, F] = P(null), [B, $] = P(null), [V, z] = P(null), [q, X] = P(null), [J, te] = P(null), [ee, k] = P(null), [j, H] = P(null), [M, Z] = P(null), [E, T] = P(null), [R, _] = P(null), [W, A] = P(null), [Q, N] = P(null), [ue, ye] = P(null);
  return v(() => {
    S !== null && S.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), v(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), v(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), v(() => {
    typeof s < "u" && S !== null && S.setVisible(s);
  }, [S, s]), v(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), v(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), v(() => {
    S && a && (L !== null && google.maps.event.removeListener(L), F(google.maps.event.addListener(S, "dblclick", a)));
  }, [a]), v(() => {
    S && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), v(() => {
    S && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), v(() => {
    S && c && (q !== null && google.maps.event.removeListener(q), X(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), v(() => {
    S && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), v(() => {
    S && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), v(() => {
    S && m && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(S, "mouseover", m)));
  }, [m]), v(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), Z(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), v(() => {
    S && g && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(S, "rightclick", g)));
  }, [g]), v(() => {
    S && h && (R !== null && google.maps.event.removeListener(R), _(google.maps.event.addListener(S, "click", h)));
  }, [h]), v(() => {
    S && x && (W !== null && google.maps.event.removeListener(W), A(google.maps.event.addListener(S, "drag", x)));
  }, [x]), v(() => {
    S && w && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(S, "center_changed", w)));
  }, [h]), v(() => {
    S && D && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), v(() => {
    var oe = new google.maps.Circle(Jf(Jf({}, t || ywe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof s < "u" && oe.setVisible(s), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), a && F(google.maps.event.addListener(oe, "dblclick", a)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), m && H(google.maps.event.addListener(oe, "mouseover", m)), f && Z(google.maps.event.addListener(oe, "mouseup", f)), g && T(google.maps.event.addListener(oe, "rightclick", g)), h && _(google.maps.event.addListener(oe, "click", h)), x && A(google.maps.event.addListener(oe, "drag", x)), w && N(google.maps.event.addListener(oe, "center_changed", w)), D && ye(google.maps.event.addListener(oe, "radius_changed", D)), U(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), M !== null && google.maps.event.removeListener(M), E !== null && google.maps.event.removeListener(E), R !== null && google.maps.event.removeListener(R), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
Le(bwe);
class wwe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      circle: null
    }), de(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Jf(Jf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: wB,
      eventMap: bB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: wB,
      eventMap: bB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), _t(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
de(wwe, "contextType", ht);
function CB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var OB = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, xB = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Cwe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: m,
    onSetProperty: f,
    onLoad: g,
    onUnmount: h
  } = e, x = xe(ht), [w, D] = P(null), [O, y] = P(null), [C, S] = P(null), [U, L] = P(null), [F, B] = P(null), [$, V] = P(null), [z, q] = P(null), [X, J] = P(null), [te, ee] = P(null), [k, j] = P(null), [H, M] = P(null), [Z, E] = P(null), [T, R] = P(null), [_, W] = P(null);
  return v(() => {
    w !== null && w.setMap(x);
  }, [x]), v(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && s && (F !== null && google.maps.event.removeListener(F), B(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), v(() => {
    w && a && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), j(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && (H !== null && google.maps.event.removeListener(H), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (Z !== null && google.maps.event.removeListener(Z), E(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && m && (T !== null && google.maps.event.removeListener(T), R(google.maps.event.addListener(w, "setgeometry", m)));
  }, [m]), v(() => {
    w && f && (_ !== null && google.maps.event.removeListener(_), W(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (x !== null) {
      var A = new google.maps.Data(Xf(Xf({}, t), {}, {
        map: x
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), s && B(google.maps.event.addListener(A, "mouseout", s)), a && V(google.maps.event.addListener(A, "mouseover", a)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && j(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && E(google.maps.event.addListener(A, "removeproperty", d)), m && R(google.maps.event.addListener(A, "setgeometry", m)), f && W(google.maps.event.addListener(A, "setproperty", f)), D(A), g && g(A);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), F !== null && google.maps.event.removeListener(F), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), Z !== null && google.maps.event.removeListener(Z), T !== null && google.maps.event.removeListener(T), _ !== null && google.maps.event.removeListener(_), h && h(w), w.setMap(null));
    };
  }, []), null;
}
Le(Cwe);
class Owe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      data: null
    }), de(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Xf(Xf({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = kt({
        updaterMap: xB,
        eventMap: OB,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: xB,
      eventMap: OB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), _t(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
de(Owe, "contextType", ht);
function EB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function LB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PB = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, kB = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class xwe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      kmlLayer: null
    }), de(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(LB(LB({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: kB,
      eventMap: PB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: kB,
      eventMap: PB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), _t(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
de(xwe, "contextType", ht);
function R$(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Ewe(e, t) {
  return new t(e.lat, e.lng);
}
function Lwe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Pwe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function kwe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Swe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Dwe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function z$(e, t, n, r) {
  return n !== void 0 ? Swe(e, t, kwe(n, google.maps.LatLngBounds, Lwe)) : Dwe(e, t, Pwe(r, google.maps.LatLng, Ewe));
}
function Mwe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function SB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Twe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function jwe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = Twe({}, this.container ? R$(this.container, o) : {
        x: 0,
        y: 0
      }), u = z$(a, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function DB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _we(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function MB(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function TB(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Awe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = xe(ht), c = Nn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Nn(() => jwe(c, r, t, n, a), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    s == null || s(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), oi.createPortal(l, c);
}
Le(Awe);
class ul extends be {
  constructor(t) {
    super(t), de(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), de(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      kr(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), de(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), de(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = _we({
        x: 0,
        y: 0
      }, this.containerRef.current ? R$(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = z$(r, o, this.props.bounds, this.props.position);
      if (!Mwe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), de(this, "draw", () => {
      this.onPositionElement();
    }), de(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = wr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = MB(t.position), r = MB(this.props.position), o = TB(t.bounds), i = TB(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? oi.createPortal(K.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: it.only(this.props.children)
    }), t) : null;
  }
}
de(ul, "FLOAT_PANE", "floatPane");
de(ul, "MAP_PANE", "mapPane");
de(ul, "MARKER_LAYER", "markerLayer");
de(ul, "OVERLAY_LAYER", "overlayLayer");
de(ul, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
de(ul, "contextType", ht);
function Bwe() {
}
function jB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _B(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var AB = {
  onDblClick: "dblclick",
  onClick: "click"
}, BB = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Iwe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = xe(ht), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Nn(() => new google.maps.GroundOverlay(t, s, r), []);
  return v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), v(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Le(Iwe);
class U$ extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      groundOverlay: null
    }), de(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    kr(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, _B(_B({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: BB,
      eventMap: AB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: BB,
      eventMap: AB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
de(U$, "defaultProps", {
  onLoad: Bwe
});
de(U$, "contextType", ht);
function IB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var NB = {}, FB = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Nwe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = xe(ht), [s, a] = P(null);
  return v(() => {
    google.maps.visualization || kr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    kr(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(Qf(Qf({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Le(Nwe);
class Fwe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      heatmapLayer: null
    }), de(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    kr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), kr(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Qf(Qf({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: FB,
      eventMap: NB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    _t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: FB,
      eventMap: NB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), _t(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
de(Fwe, "contextType", ht);
var RB = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, zB = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Rwe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      streetViewPanorama: null
    }), de(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = kt({
      updaterMap: zB,
      eventMap: RB,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: zB,
      eventMap: RB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), _t(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
de(Rwe, "contextType", ht);
class zwe extends be {
  constructor() {
    super(...arguments), de(this, "state", {
      streetViewService: null
    }), de(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
de(zwe, "contextType", ht);
var UB = {
  onDirectionsChanged: "directions_changed"
}, $B = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Uwe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      directionsRenderer: null
    }), de(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = kt({
      updaterMap: $B,
      eventMap: UB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: $B,
      eventMap: UB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), _t(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
de(Uwe, "contextType", ht);
var VB = {
  onPlacesChanged: "places_changed"
}, HB = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class $$ extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "containerElement", wr()), de(this, "state", {
      searchBox: null
    }), de(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (kr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = kt({
          updaterMap: HB,
          eventMap: VB,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (_t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: HB,
      eventMap: VB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), _t(this.registeredEvents));
  }
  render() {
    return K.jsx("div", {
      ref: this.containerElement,
      children: it.only(this.props.children)
    });
  }
}
de($$, "contextType", ht);
var WB = {
  onPlaceChanged: "place_changed"
}, ZB = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class V$ extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "containerElement", wr()), de(this, "state", {
      autocomplete: null
    }), de(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    kr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = kt({
        updaterMap: ZB,
        eventMap: WB,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    _t(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: ZB,
      eventMap: WB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && _t(this.registeredEvents);
  }
  render() {
    return K.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: it.only(this.props.children)
    });
  }
}
de(V$, "defaultProps", {
  className: ""
});
de(V$, "contextType", ht);
function P1e({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ K.jsx(
    j$,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function k1e(e) {
  const { children: t = !1 } = e, [n, r] = P([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((p) => p.key === u)) == null ? void 0 : c.data;
  }
  function s(u, c) {
    const p = o(u);
    r(p ? (d) => [...d.filter((f) => f.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function a(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ K.jsx(
    w1.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: s, closeModal: a, closeAll: l },
      children: t
    }
  );
}
let $we = { data: "" }, Vwe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || $we, Hwe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Wwe = /\/\*[^]*?\*\/|  +/g, qB = /\n+/g, gs = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? gs(s, i) : i + "{" + gs(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += gs(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += gs.p ? gs.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Li = {}, H$ = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + H$(e[n]);
    return t;
  }
  return e;
}, Zwe = (e, t, n, r, o) => {
  let i = H$(e), s = Li[i] || (Li[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Li[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Hwe.exec(u.replace(Wwe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(qB, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(qB, " ").trim();
      return d[0];
    })(e);
    Li[s] = gs(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Li.g ? Li.g : null;
  return n && (Li.g = Li[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Li[s], t, r, a), s;
}, qwe = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : gs(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function tm(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Zwe(n.unshift ? n.raw ? qwe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Vwe(t.target), t.g, t.o, t.k);
}
let W$, m0, v0;
tm.bind({ g: 1 });
let Ii = tm.bind({ k: 1 });
function Gwe(e, t, n, r) {
  gs.p = t, W$ = e, m0 = n, v0 = r;
}
function Bs(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: m0 && m0() }, a), n.o = / *go\d+/.test(l), a.className = tm.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), v0 && u[0] && v0(a), W$(u, a);
    }
    return o;
  };
}
var Ywe = (e) => typeof e == "function", eh = (e, t) => Ywe(e) ? e(t) : e, Kwe = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), Z$ = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Jwe = 20, Cd = /* @__PURE__ */ new Map(), Xwe = 1e3, GB = (e) => {
  if (Cd.has(e)) return;
  let t = setTimeout(() => {
    Cd.delete(e), Ma({ type: 4, toastId: e });
  }, Xwe);
  Cd.set(e, t);
}, Qwe = (e) => {
  let t = Cd.get(e);
  t && clearTimeout(t);
}, y0 = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, Jwe) };
    case 1:
      return t.toast.id && Qwe(t.toast.id), { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return e.toasts.find((i) => i.id === n.id) ? y0(e, { type: 1, toast: n }) : y0(e, { type: 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return r ? GB(r) : e.toasts.forEach((i) => {
        GB(i.id);
      }), { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, Od = [], xd = { toasts: [], pausedAt: void 0 }, Ma = (e) => {
  xd = y0(xd, e), Od.forEach((t) => {
    t(xd);
  });
}, eCe = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, tCe = (e = {}) => {
  let [t, n] = P(xd);
  v(() => (Od.push(n), () => {
    let o = Od.indexOf(n);
    o > -1 && Od.splice(o, 1);
  }), [t]);
  let r = t.toasts.map((o) => {
    var i, s;
    return { ...e, ...e[o.type], ...o, duration: o.duration || ((i = e[o.type]) == null ? void 0 : i.duration) || (e == null ? void 0 : e.duration) || eCe[o.type], style: { ...e.style, ...(s = e[o.type]) == null ? void 0 : s.style, ...o.style } };
  });
  return { ...t, toasts: r };
}, nCe = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || Kwe() }), Tc = (e) => (t, n) => {
  let r = nCe(t, e, n);
  return Ma({ type: 2, toast: r }), r.id;
}, wo = (e, t) => Tc("blank")(e, t);
wo.error = Tc("error");
wo.success = Tc("success");
wo.loading = Tc("loading");
wo.custom = Tc("custom");
wo.dismiss = (e) => {
  Ma({ type: 3, toastId: e });
};
wo.remove = (e) => Ma({ type: 4, toastId: e });
wo.promise = (e, t, n) => {
  let r = wo.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return e.then((o) => (wo.success(eh(t.success, o), { id: r, ...n, ...n == null ? void 0 : n.success }), o)).catch((o) => {
    wo.error(eh(t.error, o), { id: r, ...n, ...n == null ? void 0 : n.error });
  }), e;
};
var rCe = (e, t) => {
  Ma({ type: 1, toast: { id: e, height: t } });
}, oCe = () => {
  Ma({ type: 5, time: Date.now() });
}, iCe = (e) => {
  let { toasts: t, pausedAt: n } = tCe(e);
  v(() => {
    if (n) return;
    let i = Date.now(), s = t.map((a) => {
      if (a.duration === 1 / 0) return;
      let l = (a.duration || 0) + a.pauseDuration - (i - a.createdAt);
      if (l < 0) {
        a.visible && wo.dismiss(a.id);
        return;
      }
      return setTimeout(() => wo.dismiss(a.id), l);
    });
    return () => {
      s.forEach((a) => a && clearTimeout(a));
    };
  }, [t, n]);
  let r = pn(() => {
    n && Ma({ type: 6, time: Date.now() });
  }, [n]), o = pn((i, s) => {
    let { reverseOrder: a = !1, gutter: l = 8, defaultPosition: u } = s || {}, c = t.filter((m) => (m.position || u) === (i.position || u) && m.height), p = c.findIndex((m) => m.id === i.id), d = c.filter((m, f) => f < p && m.visible).length;
    return c.filter((m) => m.visible).slice(...a ? [d + 1] : [0, d]).reduce((m, f) => m + (f.height || 0) + l, 0);
  }, [t]);
  return { toasts: t, handlers: { updateHeight: rCe, startPause: oCe, endPause: r, calculateOffset: o } };
}, sCe = Ii`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, aCe = Ii`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, lCe = Ii`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, uCe = Bs("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${sCe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${aCe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${lCe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, cCe = Ii`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, pCe = Bs("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${cCe} 1s linear infinite;
`, dCe = Ii`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, fCe = Ii`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, hCe = Bs("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${dCe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${fCe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, gCe = Bs("div")`
  position: absolute;
`, mCe = Bs("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, vCe = Ii`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, yCe = Bs("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${vCe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, bCe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ue.createElement(yCe, null, t) : t : n === "blank" ? null : Ue.createElement(mCe, null, Ue.createElement(pCe, { ...r }), n !== "loading" && Ue.createElement(gCe, null, n === "error" ? Ue.createElement(uCe, { ...r }) : Ue.createElement(hCe, { ...r })));
}, wCe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, CCe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, OCe = "0%{opacity:0;} 100%{opacity:1;}", xCe = "0%{opacity:1;} 100%{opacity:0;}", ECe = Bs("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, LCe = Bs("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, PCe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Z$() ? [OCe, xCe] : [wCe(n), CCe(n)];
  return { animation: t ? `${Ii(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ii(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, kCe = Ue.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? PCe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ue.createElement(bCe, { toast: e }), s = Ue.createElement(LCe, { ...e.ariaProps }, eh(e.message, e));
  return Ue.createElement(ECe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ue.createElement(Ue.Fragment, null, i, s));
});
Gwe(Ue.createElement);
var SCe = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = Ue.useCallback((s) => {
    if (s) {
      let a = () => {
        let l = s.getBoundingClientRect().height;
        r(e, l);
      };
      a(), new MutationObserver(a).observe(s, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return Ue.createElement("div", { ref: i, className: t, style: n }, o);
}, DCe = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: Z$() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, MCe = tm`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, cd = 16, TCe = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: s }) => {
  let { toasts: a, handlers: l } = iCe(n);
  return Ue.createElement("div", { style: { position: "fixed", zIndex: 9999, top: cd, left: cd, right: cd, bottom: cd, pointerEvents: "none", ...i }, className: s, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, a.map((u) => {
    let c = u.position || t, p = l.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }), d = DCe(c, p);
    return Ue.createElement(SCe, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? MCe : "", style: d }, u.type === "custom" ? eh(u.message, u) : o ? o(u) : Ue.createElement(kCe, { toast: u, position: c }));
  }));
}, YB = wo;
function S1e({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return YB.success(n.message, {
          style: {
            background: "#10B981",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#059669",
            secondary: "#ffffff"
          }
        });
      case "danger":
        return YB.error(n.message, {
          style: {
            background: "#E11D48",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#BE123C",
            secondary: "#ffffff"
          }
        });
    }
  }
  return /* @__PURE__ */ K.jsxs(E$.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ K.jsx(
      TCe,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
function jCe({ children: e, fallback: t = null }) {
  return t0e() ? /* @__PURE__ */ K.jsx(K.Fragment, { children: e() }) : /* @__PURE__ */ K.jsx(K.Fragment, { children: t });
}
function D1e({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ K.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ K.jsx(
    f0e,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ K.jsx(_$, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ K.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ K.jsx(h3, {}) });
}
function M1e({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = P(null), s = (l) => i(l), a = () => {
    var m, f, g, h;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function p(x) {
      const w = c.find((D) => D.types[0] === x);
      return w ? w.long_name : "";
    }
    function d(x) {
      const w = c.find((D) => D.types[0] === x);
      return w ? w.short_name : "";
    }
    if (u) {
      const x = p("route"), w = p("street_number"), D = p("sublocality_level_1"), O = p("administrative_area_level_2"), y = p("administrative_area_level_1"), C = d("administrative_area_level_1"), S = p("postal_code"), U = (f = (m = u.geometry) == null ? void 0 : m.location) == null ? void 0 : f.lat(), L = (h = (g = u.geometry) == null ? void 0 : g.location) == null ? void 0 : h.lng();
      t && t({
        street: x,
        city: O,
        state: y,
        district: D,
        cep: S,
        streetNumber: w,
        stateShortName: C,
        coordinates: { lat: U, lng: L }
      });
    }
  };
  return /* @__PURE__ */ K.jsx(
    $$,
    {
      onLoad: s,
      onPlacesChanged: a,
      options: n,
      children: /* @__PURE__ */ K.jsx(Hg, { type: "text", onChange: (l) => e(l.target.value), ...r })
    }
  );
}
function q$(e) {
  const { dataLayer: t, dataLayerName: n } = e;
  return `
  window.${n} = window.${n} || [];
  window.${n}.push(${JSON.stringify(t)})`;
}
function _Ce(e) {
  const { id: t, events: n, dataLayer: r, dataLayerName: o, preview: i, auth: s } = e, a = `&gtm_auth=${s}`, l = `&gtm_preview=${i}`;
  t || console.warn("GTM Id is required");
  const u = `
    <iframe src="https://www.googletagmanager.com/ns.html?id=${t}${a}${l}&gtm_cookies_win=x"
      height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>`, c = `
    (function(w,d,s,l,i){w[l]=w[l]||[];
      w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', ${JSON.stringify(
    n
  ).slice(1, -1)}});
      var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
      j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'${a}${l}&gtm_cookies_win=x';
      f.parentNode.insertBefore(j,f);
    })(window,document,'script','${o}','${t}');`, p = q$({ dataLayer: r, dataLayerName: o });
  return {
    iframe: u,
    script: c,
    dataLayerVar: p
  };
}
let ACe = class {
  initializeDataScript(t) {
    const n = document.createElement("script");
    return n.innerHTML = t, n;
  }
  initializeGTMElements(t) {
    const n = _Ce(t), r = () => {
      const s = document.createElement("noscript");
      return s.innerHTML = n.iframe, s;
    }, o = () => {
      const s = document.createElement("script");
      return s.innerHTML = n.script, s;
    }, i = this.initializeDataScript(n.dataLayerVar);
    return {
      noScript: r,
      script: o,
      dataScript: i
    };
  }
  initializeDataLayer(t) {
    const { dataLayer: n, dataLayerName: r } = t;
    if (window[r]) return window[r].push(n);
    const o = q$({ dataLayer: n, dataLayerName: r }), i = this.initializeDataScript(o);
    document.head.insertBefore(i, document.head.childNodes[0]);
  }
  initialize(t) {
    const {
      events: n,
      gtmId: r,
      dataLayer: o,
      auth: i = "",
      preview: s = "",
      dataLayerName: a = "dataLayer"
    } = t, l = this.initializeGTMElements({
      id: r,
      events: n,
      dataLayer: o || void 0,
      dataLayerName: a,
      auth: i,
      preview: s
    });
    o && document.head.appendChild(l.dataScript), document.head.insertBefore(l.script(), document.head.childNodes[0]), document.body.insertBefore(l.noScript(), document.body.childNodes[0]);
  }
};
function BCe(e) {
  return new ACe().initialize(e), /* @__PURE__ */ K.jsx(K.Fragment, {});
}
function j1e(e) {
  const {
    gtmId: t,
    auth: n = "",
    preview: r = "",
    dataLayerName: o = "dataLayer",
    events: i = {},
    dataLayer: s = {}
  } = e;
  return /* @__PURE__ */ K.jsx(jCe, { children: () => /* @__PURE__ */ K.jsx(
    BCe,
    {
      auth: n,
      dataLayer: s,
      dataLayerName: o,
      events: i,
      gtmId: t,
      preview: r
    }
  ) });
}
export {
  $Ce as AlertContainer,
  VCe as AlertContent,
  HCe as AlertDescription,
  WCe as AlertIcon,
  b3 as AlertTitle,
  o1e as AudioUpload,
  YCe as Badge,
  h1e as BreadcrumbContainer,
  g1e as BreadcrumbLink,
  $f as Button,
  KCe as Card,
  i1e as Checkbox,
  jCe as ClientOnly,
  JCe as Divider,
  v1e as DrawerContainer,
  y1e as DrawerHeader,
  E1e as DrawerProvider,
  c_ as FormController,
  s1e as FormError,
  p_ as FormLabel,
  D1e as GoogleMap,
  P1e as GoogleProvider,
  M1e as GoogleSearchPlaces,
  j1e as GoogleTagManager,
  Zfe as IconButton,
  Xfe as ImageUpload,
  Hg as Input,
  Nve as ModalContainer,
  Fve as ModalFooter,
  Rve as ModalHeader,
  k1e as ModalProvider,
  a1e as MultiSelect,
  m1e as Pagination,
  b1e as Popover,
  u1e as RadioBox,
  l1e as RadioGroup,
  c1e as RichText,
  p1e as Select,
  XCe as Skeleton,
  Vfe as Slider,
  d1e as Switch,
  J_ as TabButton,
  Uve as TabContainer,
  QCe as TableBody,
  e1e as TableCaption,
  t1e as TableContainer,
  n1e as TableFooter,
  r1e as TableHeader,
  f1e as Textarea,
  w1e as Toast,
  S1e as ToastProvider,
  qfe as Tooltip,
  ZCe as getHtmlFromRichTextValue,
  qCe as getRichTextValueFromHtml,
  GCe as isHtml,
  FI as morpheme,
  C1e as useAutomation,
  O1e as useDrawer,
  lU as useFieldErrors,
  uo as useFormController,
  t0e as useHydrated,
  x1e as useModal,
  t$ as useScopedParams,
  Qbe as useToast
};
