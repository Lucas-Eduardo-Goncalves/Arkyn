import * as _e from "react";
import Oe, { createContext as He, useContext as ge, Children as ut, forwardRef as ka, memo as me, useState as E, useRef as vt, useEffect as h, useMemo as zt, isValidElement as wi, cloneElement as Oi, Component as Kl, PureComponent as pe, createRef as jn, useId as Jfe, useCallback as ur, useReducer as Qfe, useLayoutEffect as ehe, useSyncExternalStore as the } from "react";
import { Info as Tee, AlertTriangle as nhe, XCircle as jee, CheckCircle2 as Aee, Loader2 as tl, Pause as rhe, Play as ohe, RefreshCw as Iee, Check as aT, ChevronDown as Bee, X as lT, Search as Nee, Image as ihe, Heading1 as she, Heading2 as ahe, Quote as lhe, Bold as uhe, Italic as che, Underline as phe, Code as dhe, AlignLeft as fhe, AlignRight as hhe, AlignCenter as ghe, AlignJustify as mhe, ChevronRight as XS, ChevronLeft as vhe, Ellipsis as LN, MapPinned as yhe } from "lucide-react";
import { useActionData as uT, useNavigation as Ree, useFetchers as cT, useLocation as pT, Link as bhe, useNavigate as Fee } from "@remix-run/react";
import { InputMask as whe } from "@react-input/mask";
import * as Ci from "react-dom";
import nl, { createPortal as An } from "react-dom";
import { AnimatePresence as zee, motion as Jh } from "framer-motion";
var Pr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function rO(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var KS = { exports: {} }, tf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var EN;
function Ohe() {
  if (EN) return tf;
  EN = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return tf.Fragment = n, tf.jsx = a, tf.jsxs = a, tf;
}
var nf = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var kN;
function Che() {
  return kN || (kN = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var T = f && g[f] || g[v];
      return typeof T == "function" ? T : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var T = arguments.length, Z = new Array(T > 1 ? T - 1 : 0), ee = 1; ee < T; ee++)
          Z[ee - 1] = arguments[ee];
        D("error", g, Z);
      }
    }
    function D(g, T, Z) {
      {
        var ee = L.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (T += "%s", Z = Z.concat([ae]));
        var ue = Z.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + T), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function R(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function N(g, T, Z) {
      var ee = g.displayName;
      if (ee)
        return ee;
      var ae = T.displayName || T.name || "";
      return ae !== "" ? Z + "(" + ae + ")" : Z;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var T = g;
            return V(T) + ".Consumer";
          case a:
            var Z = g;
            return V(Z._context) + ".Provider";
          case l:
            return N(g, g.render, "ForwardRef");
          case p:
            var ee = g.displayName || null;
            return ee !== null ? ee : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, X = 0, G, Y, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function W() {
      {
        if (X === 0) {
          G = console.log, Y = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        X++;
      }
    }
    function O() {
      {
        if (X--, X === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, g, {
              value: G
            }),
            info: H({}, g, {
              value: Y
            }),
            warn: H({}, g, {
              value: Q
            }),
            error: H({}, g, {
              value: J
            }),
            group: H({}, g, {
              value: P
            }),
            groupCollapsed: H({}, g, {
              value: _
            }),
            groupEnd: H({}, g, {
              value: z
            })
          });
        }
        X < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = L.ReactCurrentDispatcher, F;
    function j(g, T, Z) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            F = ee && ee[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, A;
    {
      var K = typeof WeakMap == "function" ? WeakMap : Map;
      A = new K();
    }
    function B(g, T) {
      if (!g || q)
        return "";
      {
        var Z = A.get(g);
        if (Z !== void 0)
          return Z;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (T) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Le) {
              ee = Le;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (Le) {
              ee = Le;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Le) {
            ee = Le;
          }
          g();
        }
      } catch (Le) {
        if (Le && ee && typeof Le.stack == "string") {
          for (var ie = Le.stack.split(`
`), we = ee.stack.split(`
`), de = ie.length - 1, fe = we.length - 1; de >= 1 && fe >= 0 && ie[de] !== we[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== we[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== we[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", g.displayName)), typeof g == "function" && A.set(g, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var kt = g ? g.displayName || g.name : "", mt = kt ? j(kt) : "";
      return typeof g == "function" && A.set(g, mt), mt;
    }
    function le(g, T, Z) {
      return B(g, !1);
    }
    function he(g) {
      var T = g.prototype;
      return !!(T && T.isReactComponent);
    }
    function re(g, T, Z) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return B(g, he(g));
      if (typeof g == "string")
        return j(g);
      switch (g) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return re(g.type, T, Z);
          case d: {
            var ee = g, ae = ee._payload, ue = ee._init;
            try {
              return re(ue(ae), T, Z);
            } catch {
            }
          }
        }
      return "";
    }
    var Se = Object.prototype.hasOwnProperty, We = {}, Ze = L.ReactDebugCurrentFrame;
    function Me(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        Ze.setExtraStackFrame(Z);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(g, T, Z, ee, ae) {
      {
        var ue = Function.call.bind(Se);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var we = Error((ee || "React class") + ": " + Z + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw we.name = "Invariant Violation", we;
              }
              ie = g[se](T, se, ee, Z, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Me(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", Z, se, typeof ie), Me(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Me(ae), w("Failed %s type: %s", Z, ie.message), Me(null));
          }
      }
    }
    var Ve = Array.isArray;
    function be(g) {
      return Ve(g);
    }
    function qe(g) {
      {
        var T = typeof Symbol == "function" && Symbol.toStringTag, Z = T && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return Z;
      }
    }
    function ct(g) {
      try {
        return ye(g), !1;
      } catch {
        return !0;
      }
    }
    function ye(g) {
      return "" + g;
    }
    function xe(g) {
      if (ct(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qe(g)), ye(g);
    }
    var Ee = L.ReactCurrentOwner, Ue = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, De, st, ve;
    ve = {};
    function wt(g) {
      if (Se.call(g, "ref")) {
        var T = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function at(g) {
      if (Se.call(g, "key")) {
        var T = Object.getOwnPropertyDescriptor(g, "key").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function lt(g, T) {
      if (typeof g.ref == "string" && Ee.current && T && Ee.current.stateNode !== T) {
        var Z = $(Ee.current.type);
        ve[Z] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ee.current.type), g.ref), ve[Z] = !0);
      }
    }
    function pt(g, T) {
      {
        var Z = function() {
          De || (De = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: Z,
          configurable: !0
        });
      }
    }
    function Ot(g, T) {
      {
        var Z = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: Z,
          configurable: !0
        });
      }
    }
    var dt = function(g, T, Z, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: T,
        ref: Z,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function Ct(g, T, Z, ee, ae) {
      {
        var ue, se = {}, ie = null, we = null;
        Z !== void 0 && (xe(Z), ie = "" + Z), at(T) && (xe(T.key), ie = "" + T.key), wt(T) && (we = T.ref, lt(T, ae));
        for (ue in T)
          Se.call(T, ue) && !Ue.hasOwnProperty(ue) && (se[ue] = T[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || we) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && pt(se, fe), we && Ot(se, fe);
        }
        return dt(g, ie, we, ae, ee, Ee.current, se);
      }
    }
    var Xe = L.ReactCurrentOwner, ht = L.ReactDebugCurrentFrame;
    function ot(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        ht.setExtraStackFrame(Z);
      } else
        ht.setExtraStackFrame(null);
    }
    var xt;
    xt = !1;
    function ft(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Pt() {
      {
        if (Xe.current) {
          var g = $(Xe.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Lt(g) {
      return "";
    }
    var St = {};
    function Et(g) {
      {
        var T = Pt();
        if (!T) {
          var Z = typeof g == "string" ? g : g.displayName || g.name;
          Z && (T = `

Check the top-level render call using <` + Z + ">.");
        }
        return T;
      }
    }
    function Mt(g, T) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var Z = Et(T);
        if (St[Z])
          return;
        St[Z] = !0;
        var ee = "";
        g && g._owner && g._owner !== Xe.current && (ee = " It was passed a child from " + $(g._owner.type) + "."), ot(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Z, ee), ot(null);
      }
    }
    function _t(g, T) {
      {
        if (typeof g != "object")
          return;
        if (be(g))
          for (var Z = 0; Z < g.length; Z++) {
            var ee = g[Z];
            ft(ee) && Mt(ee, T);
          }
        else if (ft(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              ft(se.value) && Mt(se.value, T);
        }
      }
    }
    function gt(g) {
      {
        var T = g.type;
        if (T == null || typeof T == "string")
          return;
        var Z;
        if (typeof T == "function")
          Z = T.propTypes;
        else if (typeof T == "object" && (T.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        T.$$typeof === p))
          Z = T.propTypes;
        else
          return;
        if (Z) {
          var ee = $(T);
          rt(Z, g.props, "prop", ee, g);
        } else if (T.PropTypes !== void 0 && !xt) {
          xt = !0;
          var ae = $(T);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof T.getDefaultProps == "function" && !T.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function te(g) {
      {
        for (var T = Object.keys(g.props), Z = 0; Z < T.length; Z++) {
          var ee = T[Z];
          if (ee !== "children" && ee !== "key") {
            ot(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), ot(null);
            break;
          }
        }
        g.ref !== null && (ot(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), ot(null));
      }
    }
    var Br = {};
    function Nr(g, T, Z, ee, ae, ue) {
      {
        var se = R(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var we = Lt();
          we ? ie += we : ie += Pt();
          var de;
          g === null ? de = "null" : be(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = Ct(g, T, Z, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = T.children;
          if (ze !== void 0)
            if (ee)
              if (be(ze)) {
                for (var kt = 0; kt < ze.length; kt++)
                  _t(ze[kt], g);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              _t(ze, g);
        }
        if (Se.call(T, "key")) {
          var mt = $(g), Le = Object.keys(T).filter(function(Si) {
            return Si !== "key";
          }), In = Le.length > 0 ? "{key: someKey, " + Le.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Br[mt + In]) {
            var Pi = Le.length > 0 ? "{" + Le.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, In, mt, Pi, mt), Br[mt + In] = !0;
          }
        }
        return g === r ? te(fe) : gt(fe), fe;
      }
    }
    function xi(g, T, Z) {
      return Nr(g, T, Z, !0);
    }
    function Li(g, T, Z) {
      return Nr(g, T, Z, !1);
    }
    var Ei = Li, ki = xi;
    nf.Fragment = r, nf.jsx = Ei, nf.jsxs = ki;
  }()), nf;
}
process.env.NODE_ENV === "production" ? KS.exports = Ohe() : KS.exports = Che();
var oe = KS.exports;
function xhe(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ oe.jsx("div", { className: r.trim(), ...n });
}
const Uee = He({});
function Lhe() {
  return ge(Uee);
}
function Myt(e) {
  const { schema: t, children: n, className: r, ...o } = e, s = !((u) => {
    let c = !1;
    const p = (d) => {
      Array.isArray(d) ? d.forEach(p) : d && typeof d == "object" && "type" in d && (d.type === xhe ? c = !0 : d.props && d.props.children && p(d.props.children));
    };
    return p(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${t} ${s} ${r}`;
  return /* @__PURE__ */ oe.jsx(Uee.Provider, { value: e, children: /* @__PURE__ */ oe.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function Dyt(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ oe.jsx("div", { className: r.trim(), ...n });
}
function _yt(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ oe.jsx("div", { className: r.trim(), ...n });
}
function Tyt(e) {
  const { className: t, ...n } = e, { schema: r } = Lhe(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ oe.jsx(Aee, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ oe.jsx(jee, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ oe.jsx(nhe, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ oe.jsx(Tee, { className: o, ...n });
  }
}
function v0(e, t) {
  return t ? /* @__PURE__ */ oe.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ oe.jsx(oe.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function PN(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Ri(e) {
  var t, n;
  return PN(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(PN(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var Wee = Symbol.for("immer-nothing"), SN = Symbol.for("immer-draftable"), Gs = Symbol.for("immer-state"), Ehe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ss(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Ehe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var vd = Object.getPrototypeOf;
function Mp(e) {
  return !!e && !!e[Gs];
}
function Dp(e) {
  var t;
  return e ? Hee(e) || Array.isArray(e) || !!e[SN] || !!((t = e.constructor) != null && t[SN]) || iO(e) || sO(e) : !1;
}
var khe = Object.prototype.constructor.toString();
function Hee(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = vd(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === khe;
}
function y0(e, t) {
  oO(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function oO(e) {
  const t = e[Gs];
  return t ? t.type_ : Array.isArray(e) ? 1 : iO(e) ? 2 : sO(e) ? 3 : 0;
}
function GS(e, t) {
  return oO(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Vee(e, t, n) {
  const r = oO(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Phe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function iO(e) {
  return e instanceof Map;
}
function sO(e) {
  return e instanceof Set;
}
function Gc(e) {
  return e.copy_ || e.base_;
}
function YS(e, t) {
  if (iO(e))
    return new Map(e);
  if (sO(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Hee(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Gs];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(vd(e), r);
  } else {
    const r = vd(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function dT(e, t = !1) {
  return aO(e) || Mp(e) || !Dp(e) || (oO(e) > 1 && (e.set = e.add = e.clear = e.delete = She), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => dT(r, !0))), e;
}
function She() {
  ss(2);
}
function aO(e) {
  return Object.isFrozen(e);
}
var Mhe = {};
function _p(e) {
  const t = Mhe[e];
  return t || ss(0, e), t;
}
var Qh;
function $ee() {
  return Qh;
}
function Dhe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function MN(e, t) {
  t && (_p("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function JS(e) {
  QS(e), e.drafts_.forEach(_he), e.drafts_ = null;
}
function QS(e) {
  e === Qh && (Qh = e.parent_);
}
function DN(e) {
  return Qh = Dhe(Qh, e);
}
function _he(e) {
  const t = e[Gs];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function _N(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Gs].modified_ && (JS(t), ss(4)), Dp(e) && (e = b0(t, e), t.parent_ || w0(t, e)), t.patches_ && _p("Patches").generateReplacementPatches_(
    n[Gs].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = b0(t, n, []), JS(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== Wee ? e : void 0;
}
function b0(e, t, n) {
  if (aO(t))
    return t;
  const r = t[Gs];
  if (!r)
    return y0(
      t,
      (o, i) => TN(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return w0(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), y0(
      i,
      (s, l) => TN(e, r, o, s, l, n, a)
    ), w0(e, o, !1), n && e.patches_ && _p("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function TN(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ss(5), Mp(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !GS(t.assigned_, r) ? i.concat(r) : void 0, l = b0(e, o, s);
    if (Vee(n, r, l), Mp(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Dp(o) && !aO(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    b0(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && w0(e, o);
  }
}
function w0(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && dT(t, n);
}
function The(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : $ee(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = fT;
  n && (o = [r], i = eg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var fT = {
  get(e, t) {
    if (t === Gs)
      return e;
    const n = Gc(e);
    if (!GS(n, t))
      return jhe(e, n, t);
    const r = n[t];
    return e.finalized_ || !Dp(r) ? r : r === AL(e.base_, t) ? (IL(e), e.copy_[t] = tM(r, e)) : r;
  },
  has(e, t) {
    return t in Gc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Gc(e));
  },
  set(e, t, n) {
    const r = Zee(Gc(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = AL(Gc(e), t), i = o == null ? void 0 : o[Gs];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Phe(n, o) && (n !== void 0 || GS(e.base_, t)))
        return !0;
      IL(e), eM(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return AL(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, IL(e), eM(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Gc(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ss(11);
  },
  getPrototypeOf(e) {
    return vd(e.base_);
  },
  setPrototypeOf() {
    ss(12);
  }
}, eg = {};
y0(fT, (e, t) => {
  eg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
eg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ss(13), eg.set.call(this, e, t, void 0);
};
eg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ss(14), fT.set.call(this, e[0], t, n, e[0]);
};
function AL(e, t) {
  const n = e[Gs];
  return (n ? Gc(n) : e)[t];
}
function jhe(e, t, n) {
  var o;
  const r = Zee(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function Zee(e, t) {
  if (!(t in e))
    return;
  let n = vd(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = vd(n);
  }
}
function eM(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && eM(e.parent_));
}
function IL(e) {
  e.copy_ || (e.copy_ = YS(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Ahe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(l = i, ...u) {
          return a.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && ss(6), r !== void 0 && typeof r != "function" && ss(7);
      let o;
      if (Dp(t)) {
        const i = DN(this), a = tM(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? JS(i) : QS(i);
        }
        return MN(i, r), _N(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === Wee && (o = void 0), this.autoFreeze_ && dT(o, !0), r) {
          const i = [], a = [];
          _p("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ss(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (a, ...s) => this.produceWithPatches(a, (l) => t(l, ...s));
      let r, o;
      return [this.produce(t, n, (a, s) => {
        r = a, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Dp(e) || ss(8), Mp(e) && (e = Ihe(e));
    const t = DN(this), n = tM(e, void 0);
    return n[Gs].isManual_ = !0, QS(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Gs];
    (!n || !n.isManual_) && ss(9);
    const { scope_: r } = n;
    return MN(r, t), _N(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = _p("Patches").applyPatches_;
    return Mp(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function tM(e, t) {
  const n = iO(e) ? _p("MapSet").proxyMap_(e, t) : sO(e) ? _p("MapSet").proxySet_(e, t) : The(e, t);
  return (t ? t.scope_ : $ee()).drafts_.push(n), n;
}
function Ihe(e) {
  return Mp(e) || ss(10, e), qee(e);
}
function qee(e) {
  if (!Dp(e) || aO(e))
    return e;
  const t = e[Gs];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = YS(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = YS(e, !0);
  return y0(n, (r, o) => {
    Vee(n, r, qee(o));
  }), t && (t.finalized_ = !1), n;
}
var Ys = new Ahe(), hT = Ys.produce;
Ys.produceWithPatches.bind(
  Ys
);
Ys.setAutoFreeze.bind(Ys);
Ys.setUseStrictShallowCopy.bind(Ys);
Ys.applyPatches.bind(Ys);
var jN = Ys.createDraft.bind(Ys), AN = Ys.finishDraft.bind(Ys), Bhe = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ce.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Nhe = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = Gt.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Rhe = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = Ce.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, O0 = /* @__PURE__ */ new WeakMap(), C0 = /* @__PURE__ */ new WeakMap(), fh = /* @__PURE__ */ new WeakMap(), Xee = /* @__PURE__ */ new WeakMap(), IN = /* @__PURE__ */ new WeakMap(), BN = /* @__PURE__ */ new WeakMap(), NN = /* @__PURE__ */ new WeakMap(), ce = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = ce.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ce.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return ce.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ce.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return ce.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && ce.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return ce.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && ce.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && ce.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && ce.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && ce.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && ce.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!ce.isAncestor(t, e) && !ce.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (ce.equals(i, r) || ce.endsBefore(i, r) || ce.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (ce.equals(a, r) || ce.isAncestor(a, r))
          return null;
        ce.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        ce.equals(s, r) || ce.endsBefore(s, r) ? r[s.length - 1] -= 1 : ce.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (ce.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else ce.endsBefore(u, r) ? r[u.length - 1] += 1 : ce.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (ce.equals(p, d))
          return r;
        if (ce.isAncestor(p, r) || ce.equals(p, r)) {
          var y = d.slice();
          return ce.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else ce.isSibling(p, d) && (ce.isAncestor(d, r) || ce.equals(d, r)) ? ce.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : ce.endsBefore(d, r) || ce.equals(d, r) || ce.isAncestor(d, r) ? (ce.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : ce.endsBefore(p, r) && (ce.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function tg(e) {
  "@babel/helpers - typeof";
  return tg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, tg(e);
}
function Fhe(e, t) {
  if (tg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (tg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function zhe(e) {
  var t = Fhe(e, "string");
  return tg(t) === "symbol" ? t : String(t);
}
function Ki(e, t, n) {
  return t = zhe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function RN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RN(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Uhe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = it.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Ce.points(t))
          t[l] = Gt.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = it.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of Ce.points(t))
          t[b] = Gt.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = it.get(e, L), D = ce.previous(L), x = it.get(e, D), m = it.parent(e, L), C = L[L.length - 1];
      if (bt.isText(w) && bt.isText(x))
        x.text += w.text;
      else if (!bt.isText(w) && !bt.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(bi.stringify(w), " ").concat(bi.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of Ce.points(t))
          t[U] = Gt.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: R
      } = n;
      if (ce.isAncestor(k, R))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(R, "] because the destination is inside itself."));
      var N = it.get(e, k), V = it.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var H = ce.transform(k, n), X = it.get(e, ce.parent(H)), G = H[H.length - 1];
      if (X.children.splice(G, 0, N), t)
        for (var [Y, Q] of Ce.points(t))
          t[Q] = Gt.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = it.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of Ce.points(t)) {
          var W = Gt.transform(z, n);
          if (t != null && W != null)
            t[M] = W;
          else {
            var O = void 0, I = void 0;
            for (var [F, j] of it.texts(e))
              if (ce.compare(j, J) === -1)
                O = [F, j];
              else {
                I = [F, j];
                break;
              }
            var q = !1;
            O && I && (ce.equals(I[1], J) ? q = !ce.hasPrevious(I[1]) : q = ce.common(O[1], J).length < ce.common(I[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : I ? (z.path = I[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: K,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = it.leaf(e, A), he = le.text.slice(0, K), re = le.text.slice(K + B.length);
      if (le.text = he + re, t)
        for (var [Se, We] of Ce.points(t))
          t[We] = Gt.transform(Se, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: Me,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = it.get(e, Ze);
      for (var be in rt) {
        if (be === "children" || be === "text")
          throw new Error('Cannot set the "'.concat(be, '" property of nodes!'));
        var qe = rt[be];
        qe == null ? delete Ve[be] : Ve[be] = qe;
      }
      for (var ct in Me)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!Ce.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(bi.stringify(ye), " when there is no current selection."));
          t = rf({}, ye);
        }
        for (var xe in ye) {
          var Ee = ye[xe];
          if (Ee == null) {
            if (xe === "anchor" || xe === "focus")
              throw new Error('Cannot remove the "'.concat(xe, '" selection property'));
            delete t[xe];
          } else
            t[xe] = Ee;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ue,
        position: De,
        properties: st
      } = n;
      if (Ue.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ue, "] because the root node cannot be split."));
      var ve = it.get(e, Ue), wt = it.parent(e, Ue), at = Ue[Ue.length - 1], lt;
      if (bt.isText(ve)) {
        var pt = ve.text.slice(0, De), Ot = ve.text.slice(De);
        ve.text = pt, lt = rf(rf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = ve.children.slice(0, De), Ct = ve.children.slice(De);
        ve.children = dt, lt = rf(rf({}, st), {}, {
          children: Ct
        });
      }
      if (wt.children.splice(at + 1, 0, lt), t)
        for (var [Xe, ht] of Ce.points(t))
          t[ht] = Gt.transform(Xe, n);
      break;
    }
  }
  return t;
}, Whe = {
  transform(e, t) {
    e.children = jN(e.children);
    var n = e.selection && jN(e.selection);
    try {
      n = Uhe(e, n, t);
    } finally {
      e.children = AN(e.children), n ? e.selection = Mp(n) ? AN(n) : n : e.selection = null;
    }
  }
}, Hhe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Vhe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Kee = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Ri(r) && Ri(o)) {
      if (!Kee(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function $he(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Fl(e, t) {
  if (e == null) return {};
  var n = $he(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Zhe = ["anchor", "focus"];
function FN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qhe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FN(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ce = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Ce.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Ce.edges(e);
    return t;
  },
  equals(e, t) {
    return Gt.equals(e.anchor, t.anchor) && Gt.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Ce.isRange(t)) {
      if (Ce.includes(e, t.anchor) || Ce.includes(e, t.focus))
        return !0;
      var [n, r] = Ce.edges(e), [o, i] = Ce.edges(t);
      return Gt.isBefore(n, o) && Gt.isAfter(r, i);
    }
    var [a, s] = Ce.edges(e), l = !1, u = !1;
    return Gt.isPoint(t) ? (l = Gt.compare(t, a) >= 0, u = Gt.compare(t, s) <= 0) : (l = ce.compare(t, a.path) >= 0, u = ce.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Fl(e, Zhe), [r, o] = Ce.edges(e), [i, a] = Ce.edges(t), s = Gt.isBefore(r, i) ? i : r, l = Gt.isBefore(o, a) ? o : a;
    return Gt.isBefore(l, s) ? null : qhe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Gt.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Gt.equals(t, n);
  },
  isExpanded(e) {
    return !Ce.isCollapsed(e);
  },
  isForward(e) {
    return !Ce.isBackward(e);
  },
  isRange(e) {
    return Ri(e) && Gt.isPoint(e.anchor) && Gt.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Ce.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return hT(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Ce.isCollapsed(r);
        Ce.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Ce.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Gt.transform(r.anchor, t, {
        affinity: i
      }), u = Gt.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, zN = (e) => Ri(e) && it.isNodeList(e.children) && !ne.isEditor(e), yt = {
  isAncestor(e) {
    return Ri(e) && it.isNodeList(e.children);
  },
  isElement: zN,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => yt.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return zN(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Xhe = ["children"], Khe = ["text"], UN = /* @__PURE__ */ new WeakMap(), it = {
  ancestor(e, t) {
    var n = it.get(e, t);
    if (bt.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(bi.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ce.ancestors(t, n)) {
        var o = it.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (bt.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(bi.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(bi.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = it.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = it.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = ce.common(t, n), o = it.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = it.get(e, t);
    if (ne.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(bi.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of it.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of it.nodes(e, t))
        yt.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (yt.isAncestor(e)) {
      var t = Fl(e, Xhe);
      return t;
    } else {
      var t = Fl(e, Khe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = it.get(e, n); r && !(bt.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (bt.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(bi.stringify(e)));
    var n = hT({
      children: e.children
    }, (r) => {
      var [o, i] = Ce.edges(t), a = it.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Ce.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Ce.includes(t, s)) {
          var l = it.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (ce.equals(s, i.path)) {
          var c = it.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (ce.equals(s, o.path)) {
          var p = it.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      ne.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (bt.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(bi.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (bt.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return bt.isText(e) || yt.isElement(e) || ne.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = UN.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => it.isNode(r));
    return UN.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = it.get(e, n); r && !(bt.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = it.get(e, t);
    if (!bt.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(bi.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ce.levels(t, n)) {
        var o = it.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return yt.isElement(e) && yt.isElementProps(t) && yt.matches(e, t) || bt.isText(e) && bt.isTextProps(t) && bt.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? ce.isBefore(s, i) : ce.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !bt.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          ce.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = it.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = ce.next(s);
          if (it.has(e, c)) {
            s = c, l = it.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = ce.previous(s);
          s = p, l = it.get(e, s);
          continue;
        }
        s = ce.parent(s), l = it.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = ce.parent(t), r = it.get(e, n);
    if (bt.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return bt.isText(e) ? e.text : e.children.map(it.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of it.nodes(e, t))
        bt.isText(n) && (yield [n, r]);
    }();
  }
};
function WN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function eo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WN(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qu = {
  isNodeOperation(e) {
    return Qu.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Ri(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return ce.isPath(e.path) && it.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ce.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && ce.isPath(e.path) && Ri(e.properties);
      case "move_node":
        return ce.isPath(e.path) && ce.isPath(e.newPath);
      case "remove_node":
        return ce.isPath(e.path) && it.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ce.isPath(e.path);
      case "set_node":
        return ce.isPath(e.path) && Ri(e.properties) && Ri(e.newProperties);
      case "set_selection":
        return e.properties === null && Ce.isRange(e.newProperties) || e.newProperties === null && Ce.isRange(e.properties) || Ri(e.properties) && Ri(e.newProperties);
      case "split_node":
        return ce.isPath(e.path) && typeof e.position == "number" && Ri(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Qu.isOperation(t));
  },
  isSelectionOperation(e) {
    return Qu.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Qu.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return eo(eo({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return eo(eo({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return eo(eo({}, e), {}, {
          type: "split_node",
          path: ce.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (ce.equals(t, n))
          return e;
        if (ce.isSibling(n, t))
          return eo(eo({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = ce.transform(n, e), o = ce.transform(ce.next(n), e);
        return eo(eo({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return eo(eo({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return eo(eo({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return eo(eo({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? eo(eo({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? eo(eo({}, e), {}, {
          properties: null,
          newProperties: s
        }) : eo(eo({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return eo(eo({}, e), {}, {
          type: "merge_node",
          path: ce.next(e.path)
        });
    }
  }
}, HN = /* @__PURE__ */ new WeakMap(), Ghe = (e) => {
  var t = HN.get(e);
  if (t !== void 0)
    return t;
  if (!Ri(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Ri(e.marks)) && (e.selection === null || Ce.isRange(e.selection)) && it.isNodeList(e.children) && Qu.isOperationList(e.operations);
  return HN.set(e, n), n;
}, ne = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Ghe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, Yhe = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(ce.isPath);
  }
};
function VN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $N(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VN(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Gt = {
  compare(e, t) {
    var n = ce.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Gt.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Gt.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && ce.equals(e.path, t.path);
  },
  isPoint(e) {
    return Ri(e) && typeof e.offset == "number" && ce.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return hT(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = ce.transform(i, t, n);
          break;
        }
        case "insert_text": {
          ce.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          ce.equals(t.path, i) && (r.offset += t.position), r.path = ce.transform(i, t, n);
          break;
        }
        case "remove_text": {
          ce.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (ce.equals(t.path, i) || ce.isAncestor(t.path, i))
            return null;
          r.path = ce.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (ce.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = ce.transform(i, t, $N($N({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = ce.transform(i, t, n);
          break;
        }
      }
    });
  }
}, ZN = void 0, bi = {
  setScrubber(e) {
    ZN = e;
  },
  stringify(e) {
    return JSON.stringify(e, ZN);
  }
}, Jhe = ["text"], Qhe = ["anchor", "focus"];
function qN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qN(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var bt = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Fl(i, Jhe);
      return a;
    }
    return Kee(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Ri(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => bt.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [dl({}, e)];
    for (var r of t) {
      var o = Fl(r, Qhe), [i, a] = Ce.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = dl(dl({}, f), {}, {
            text: f.text.slice(L)
          }), f = dl(dl({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = dl(dl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = dl(dl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, gT = (e) => e.selection ? e.selection : e.children.length > 0 ? ne.end(e, []) : [0], Sd = (e, t) => {
  var [n] = ne.node(e, t);
  return (r) => r === n;
}, mT = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? ige(t) : t, i = Dt.None, a = Dt.None, s = 0, l = null, u = null;
  for (var c of o) {
    var p = c.codePointAt(0);
    if (!p) break;
    var d = vge(c, p);
    if ([i, a] = r ? [a, d] : [d, i], od(i, Dt.ZWJ) && od(a, Dt.ExtPict) && (r ? l = XN(t.substring(0, s)) : l = XN(t.substring(0, t.length - s)), !l) || od(i, Dt.RI) && od(a, Dt.RI) && (u !== null ? u = !u : r ? u = !0 : u = Cge(t.substring(0, t.length - s)), !u) || i !== Dt.None && a !== Dt.None && bge(i, a))
      break;
    s += c.length;
  }
  return s || 1;
}, ege = /\s/, tge = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, nge = /['\u2018\u2019]/, rge = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = mT(t, n), [a, s] = vT(t, i, n);
    if (oge(a, s, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = s;
  }
  return r;
}, vT = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, oge = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (ege.test(t))
    return !1;
  if (nge.test(t)) {
    var o = mT(n, r), [i, a] = vT(n, o, r);
    if (e(i, a, r))
      return !0;
  }
  return !tge.test(t);
}, ige = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (age(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (sge(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, sge = (e) => e >= 55296 && e <= 56319, age = (e) => e >= 56320 && e <= 57343, Dt;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Dt || (Dt = {}));
var lge = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, uge = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, cge = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, pge = /^[\u1100-\u115F\uA960-\uA97C]$/, dge = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, fge = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, hge = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, gge = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, mge = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, vge = (e, t) => {
  var n = Dt.Any;
  return e.search(lge) !== -1 && (n |= Dt.Extend), t === 8205 && (n |= Dt.ZWJ), t >= 127462 && t <= 127487 && (n |= Dt.RI), e.search(uge) !== -1 && (n |= Dt.Prepend), e.search(cge) !== -1 && (n |= Dt.SpacingMark), e.search(pge) !== -1 && (n |= Dt.L), e.search(dge) !== -1 && (n |= Dt.V), e.search(fge) !== -1 && (n |= Dt.T), e.search(hge) !== -1 && (n |= Dt.LV), e.search(gge) !== -1 && (n |= Dt.LVT), e.search(mge) !== -1 && (n |= Dt.ExtPict), n;
};
function od(e, t) {
  return (e & t) !== 0;
}
var yge = [
  // GB6
  [Dt.L, Dt.L | Dt.V | Dt.LV | Dt.LVT],
  // GB7
  [Dt.LV | Dt.V, Dt.V | Dt.T],
  // GB8
  [Dt.LVT | Dt.T, Dt.T],
  // GB9
  [Dt.Any, Dt.Extend | Dt.ZWJ],
  // GB9a
  [Dt.Any, Dt.SpacingMark],
  // GB9b
  [Dt.Prepend, Dt.Any],
  // GB11
  [Dt.ZWJ, Dt.ExtPict],
  // GB12 and GB13
  [Dt.RI, Dt.RI]
];
function bge(e, t) {
  return yge.findIndex((n) => od(e, n[0]) && od(t, n[1])) === -1;
}
var wge = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, XN = (e) => e.search(wge) !== -1, Oge = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, Cge = (e) => {
  var t = e.match(Oge);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, xge = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    ne.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = gT(e)
      } = n;
      if (ce.isPath(o) && (o = ne.range(e, o)), Ce.isRange(o))
        if (Ce.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Ce.end(o);
          if (!r && ne.void(e, {
            at: i
          }))
            return;
          var a = Ce.start(o), s = ne.pointRef(e, a), l = ne.pointRef(e, i);
          $e.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, $e.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && ne.void(e, {
        at: o
      }) || ne.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function KN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KN(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $e = pv(pv(pv(pv({}, Whe), Hhe), Vhe), xge), e0 = /* @__PURE__ */ new WeakMap(), Lge = (e) => e0.get(e) || !1, Ege = (e, t, n) => {
  var r = e0.get(e) || !1;
  e0.set(e, !0);
  try {
    t(), n();
  } finally {
    e0.set(e, r);
  }
};
function Gee(e, t, n) {
  var r = O0.get(e) || [], o = C0.get(e) || /* @__PURE__ */ new Set(), i, a, s = (p) => {
    if (p) {
      var d = p.join(",");
      a.has(d) || (a.add(d), i.push(p));
    }
  };
  if (n) {
    i = [], a = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      s(u);
    }
  } else
    i = r, a = o;
  for (var c of t)
    s(c);
  O0.set(e, i), C0.set(e, a);
}
var kge = (e, t) => {
  for (var n of ne.pathRefs(e))
    Bhe.transform(n, t);
  for (var r of ne.pointRefs(e))
    Nhe.transform(r, t);
  for (var o of ne.rangeRefs(e))
    Rhe.transform(o, t);
  if (!Lge(e)) {
    var i = ce.operationCanTransformPath(t) ? (a) => ce.transform(a, t) : void 0;
    Gee(e, e.getDirtyPaths(t), i);
  }
  $e.transform(e, t), e.operations.push(t), ne.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), fh.get(e) || (fh.set(e, !0), Promise.resolve().then(() => {
    fh.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, Pge = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return ce.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = ce.levels(o), a = bt.isText(r) ? [] : Array.from(it.nodes(r), (R) => {
        var [, N] = R;
        return o.concat(N);
      });
      return [...i, ...a];
    }
    case "merge_node": {
      var {
        path: s
      } = t, l = ce.ancestors(s), u = ce.previous(s);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: p
      } = t;
      if (ce.equals(c, p))
        return [];
      var d = [], y = [];
      for (var f of ce.ancestors(c)) {
        var v = ce.transform(f, t);
        d.push(v);
      }
      for (var b of ce.ancestors(p)) {
        var L = ce.transform(b, t);
        y.push(L);
      }
      var w = y[y.length - 1], D = p[p.length - 1], x = w.concat(D);
      return [...d, ...y, x];
    }
    case "remove_node": {
      var {
        path: m
      } = t, C = ce.ancestors(m);
      return [...C];
    }
    case "split_node": {
      var {
        path: S
      } = t, U = ce.levels(S), k = ce.next(S);
      return [...U, k];
    }
    default:
      return [];
  }
}, Sge = (e) => {
  var {
    selection: t
  } = e;
  return t ? it.fragment(e, t) : [];
}, Mge = (e, t) => {
  var [n, r] = t;
  if (!bt.isText(n)) {
    if (yt.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      $e.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = ne.isEditor(n) ? !1 : yt.isElement(n) && (e.isInline(n) || n.children.length === 0 || bt.isText(n.children[0]) || e.isInline(n.children[0])), a = 0, s = 0; s < n.children.length; s++, a++) {
      var l = it.get(e, r);
      if (!bt.isText(l)) {
        var u = l.children[a], c = l.children[a - 1], p = s === n.children.length - 1, d = bt.isText(u) || yt.isElement(u) && e.isInline(u);
        if (d !== i)
          $e.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--;
        else if (yt.isElement(u)) {
          if (e.isInline(u)) {
            if (c == null || !bt.isText(c)) {
              var y = {
                text: ""
              };
              $e.insertNodes(e, y, {
                at: r.concat(a),
                voids: !0
              }), a++;
            } else if (p) {
              var f = {
                text: ""
              };
              $e.insertNodes(e, f, {
                at: r.concat(a + 1),
                voids: !0
              }), a++;
            }
          }
        } else {
          if (!bt.isText(u) && !("children" in u)) {
            var v = u;
            v.children = [];
          }
          c != null && bt.isText(c) && (bt.equals(u, c, {
            loose: !0
          }) ? ($e.mergeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--) : c.text === "" ? ($e.removeNodes(e, {
            at: r.concat(a - 1),
            voids: !0
          }), a--) : u.text === "" && ($e.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--));
        }
      }
    }
  }
}, Dge = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, _ge = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: a
  } = n;
  if (i) {
    var s = ne.path(t, i), l = o === "lowest";
    for (var [u, c] of ne.levels(t, {
      at: s,
      voids: r,
      match: a,
      reverse: l
    }))
      if (!bt.isText(u)) {
        if (Ce.isRange(i)) {
          if (ce.isAncestor(c, i.anchor.path) && ce.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!ce.equals(s, c))
          return [u, c];
      }
  }
};
function GN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function YN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GN(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Tge = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (p, d) => {
      if (!bt.isText(p))
        return !1;
      var [y, f] = ne.parent(e, d);
      return !e.isVoid(y) || e.markableVoid(y);
    }, i = Ce.isExpanded(r), a = !1;
    if (!i) {
      var [s, l] = ne.node(e, r);
      if (s && o(s, l)) {
        var [u] = ne.parent(e, l);
        a = u && e.markableVoid(u);
      }
    }
    if (i || a)
      $e.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = YN(YN({}, ne.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, fh.get(e) || e.onChange();
    }
  }
};
function JN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function QN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JN(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jge = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ne.point(t, n, {
    edge: "end"
  }), i = ne.end(t, []), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of ne.positions(t, QN(QN({}, r), {}, {
    at: a
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function eR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eR(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Age = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ne.start(t, []), i = ne.point(t, n, {
    edge: "start"
  }), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of ne.positions(t, tR(tR({}, r), {}, {
    at: a,
    reverse: !0
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, Ige = (e, t) => {
  var {
    selection: n
  } = e;
  n && Ce.isCollapsed(n) && $e.delete(e, {
    unit: t,
    reverse: !0
  });
}, Bge = (e, t) => {
  var {
    selection: n
  } = e;
  n && Ce.isCollapsed(n) && $e.delete(e, {
    unit: t
  });
}, Nge = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && Ce.isExpanded(r) && $e.delete(t, {
    reverse: n === "backward"
  });
}, Rge = (e, t) => [ne.start(e, t), ne.end(e, t)];
function nR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nR(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fge = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return ne.above(t, rR(rR({}, n), {}, {
    match: (r) => yt.isElement(r) && ne.isElementReadOnly(t, r)
  }));
}, zge = (e, t) => ne.point(e, t, {
  edge: "end"
}), Uge = (e, t) => {
  var n = ne.path(e, t, {
    edge: "start"
  });
  return ne.node(e, n);
}, Wge = (e, t) => {
  var n = ne.range(e, t);
  return it.fragment(e, n);
};
function oR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oR(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Hge = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return ne.above(t, iR(iR({}, n), {}, {
    match: (r) => yt.isElement(r) && ne.isVoid(t, r)
  }));
}, Vge = (e, t) => t.children.some((n) => yt.isElement(n) && ne.isBlock(e, n)), $ge = (e, t) => t.children.some((n) => bt.isText(n) || ne.isInline(e, n)), Zge = (e, t) => it.has(e, t), qge = (e, t) => t.children.every((n) => bt.isText(n)), Xge = (e) => {
  $e.splitNodes(e, {
    always: !0
  });
}, Kge = (e, t, n) => {
  $e.insertNodes(e, t, n);
}, Gge = (e) => {
  $e.splitNodes(e, {
    always: !0
  });
};
function sR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yge(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sR(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jge = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var a = Yge({
        text: n
      }, i);
      $e.insertNodes(t, a, {
        at: r.at,
        voids: r.voids
      });
    } else
      $e.insertText(t, n, r);
    t.marks = null;
  }
}, Qge = (e, t) => !e.isInline(t), eme = (e, t, n) => ne.isStart(e, t, n) || ne.isEnd(e, t, n), tme = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && bt.isText(r) && r.text === "" && !e.isVoid(t);
}, nme = (e, t, n) => {
  var r = ne.end(e, n);
  return Gt.equals(t, r);
}, rme = (e) => {
  var t = Xee.get(e);
  return t === void 0 ? !0 : t;
}, ome = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = ne.start(e, n);
  return Gt.equals(t, r);
}, ime = (e, t) => {
  var n = ne.path(e, t, {
    edge: "end"
  });
  return ne.node(e, n);
}, sme = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ne.path(t, n, r), i = it.leaf(t, o);
  return [i, o];
};
function ame(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var a = [], s = ne.path(e, n);
      for (var [l, u] of it.levels(e, s))
        if (i(l, u) && (a.push([l, u]), !o && yt.isElement(l) && ne.isVoid(e, l)))
          break;
      r && a.reverse(), yield* a;
    }
  }();
}
var lme = ["text"], ume = ["text"], cme = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (Ce.isExpanded(r)) {
    var a = ne.isEnd(t, o, o.path);
    if (a) {
      var s = ne.after(t, o);
      s && (o = s);
    }
    var [l] = ne.nodes(t, {
      match: bt.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = Fl(u, lme);
      return c;
    } else
      return {};
  }
  var {
    path: p
  } = o, [d] = ne.leaf(t, p);
  if (o.offset === 0) {
    var y = ne.previous(t, {
      at: p,
      match: bt.isText
    }), f = ne.above(t, {
      match: (x) => yt.isElement(x) && ne.isVoid(t, x) && t.markableVoid(x)
    });
    if (!f) {
      var v = ne.above(t, {
        match: (x) => yt.isElement(x) && ne.isBlock(t, x)
      });
      if (y && v) {
        var [b, L] = y, [, w] = v;
        ce.isAncestor(w, L) && (d = b);
      }
    }
  }
  var D = Fl(d, ume);
  return D;
}, pme = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = ne.after(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = ne.last(t, []), u = [s.path, l];
      if (ce.isPath(a) && a.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (ce.isPath(a)) {
          var [c] = ne.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = ne.nodes(t, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, dme = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ne.path(t, n, r), i = it.get(t, o);
  return [i, o];
};
function fme(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: a = !1,
      ignoreNonSelectable: s = !1
    } = t, {
      match: l
    } = t;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if (Yhe.isSpan(n))
        u = n[0], c = n[1];
      else {
        var p = ne.path(e, n, {
          edge: "start"
        }), d = ne.path(e, n, {
          edge: "end"
        });
        u = i ? d : p, c = i ? p : d;
      }
      var y = it.nodes(e, {
        reverse: i,
        from: u,
        to: c,
        pass: (x) => {
          var [m] = x;
          return yt.isElement(m) ? !!(!a && (ne.isVoid(e, m) || ne.isElementReadOnly(e, m)) || s && !ne.isSelectable(e, m)) : !1;
        }
      }), f = [], v;
      for (var [b, L] of y)
        if (!(s && yt.isElement(b) && !ne.isSelectable(e, b))) {
          var w = v && ce.compare(L, v[1]) === 0;
          if (!(r === "highest" && w)) {
            if (!l(b, L)) {
              if (o && !w && bt.isText(b))
                return;
              continue;
            }
            if (r === "lowest" && w) {
              v = [b, L];
              continue;
            }
            var D = r === "lowest" ? v : [b, L];
            D && (o ? f.push(D) : yield D), v = [b, L];
          }
        }
      r === "lowest" && v && (o ? f.push(v) : yield v), o && (yield* f);
    }
  }();
}
var hme = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => O0.get(c) || [], a = (c) => C0.get(c) || /* @__PURE__ */ new Set(), s = (c) => {
    var p = i(c).pop(), d = p.join(",");
    return a(c).delete(d), p;
  };
  if (ne.isNormalizing(t)) {
    if (r) {
      var l = Array.from(it.nodes(t), (c) => {
        var [, p] = c;
        return p;
      }), u = new Set(l.map((c) => c.join(",")));
      O0.set(t, l), C0.set(t, u);
    }
    i(t).length !== 0 && ne.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (it.has(t, c)) {
          var p = ne.node(t, c), [d, y] = p;
          yt.isElement(d) && d.children.length === 0 && t.normalizeNode(p, {
            operation: o
          });
        }
      for (var f = i(t), v = f.length, b = 0; f.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: f,
          iteration: b,
          initialDirtyPathsLength: v,
          operation: o
        }))
          return;
        var L = s(t);
        if (it.has(t, L)) {
          var w = ne.node(t, L);
          t.normalizeNode(w, {
            operation: o
          });
        }
        b++, f = i(t);
      }
    });
  }
}, gme = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ne.path(t, n, r), i = ce.parent(o), a = ne.node(t, i);
  return a;
}, mme = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = ne.pathRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = ne.pathRefs(t);
  return a.add(i), i;
}, vme = (e) => {
  var t = IN.get(e);
  return t || (t = /* @__PURE__ */ new Set(), IN.set(e, t)), t;
}, yme = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (ce.isPath(n)) {
    if (i === "start") {
      var [, a] = it.first(t, n);
      n = a;
    } else if (i === "end") {
      var [, s] = it.last(t, n);
      n = s;
    }
  }
  return Ce.isRange(n) && (i === "start" ? n = Ce.start(n) : i === "end" ? n = Ce.end(n) : n = ce.common(n.anchor.path, n.focus.path)), Gt.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, bme = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = ne.pointRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = ne.pointRefs(t);
  return a.add(i), i;
}, wme = (e) => {
  var t = BN.get(e);
  return t || (t = /* @__PURE__ */ new Set(), BN.set(e, t)), t;
}, Ome = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (ce.isPath(n)) {
    var i;
    if (o === "end") {
      var [, a] = it.last(t, n);
      i = a;
    } else {
      var [, s] = it.first(t, n);
      i = s;
    }
    var l = it.get(t, i);
    if (!bt.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (Ce.isRange(n)) {
    var [u, c] = Ce.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function Cme(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: a = !1
    } = t;
    if (!n)
      return;
    var s = ne.range(e, n), [l, u] = Ce.edges(s), c = o ? u : l, p = !1, d = "", y = 0, f = 0, v = 0;
    for (var [b, L] of ne.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: a
    })) {
      if (yt.isElement(b)) {
        if (!i && (e.isVoid(b) || e.isElementReadOnly(b))) {
          yield ne.start(e, L);
          continue;
        }
        if (e.isInline(b)) continue;
        if (ne.hasInlines(e, b)) {
          var w = ce.isAncestor(L, u.path) ? u : ne.end(e, L), D = ce.isAncestor(L, l.path) ? l : ne.start(e, L);
          d = ne.string(e, {
            anchor: D,
            focus: w
          }, {
            voids: i
          }), p = !0;
        }
      }
      if (bt.isText(b)) {
        var x = ce.equals(L, c.path);
        for (x ? (f = o ? c.offset : b.text.length - c.offset, v = c.offset) : (f = b.text.length, v = o ? f : 0), (x || p || r === "offset") && (yield {
          path: L,
          offset: v
        }, p = !1); ; ) {
          if (y === 0) {
            if (d === "") break;
            y = m(d, r, o), d = vT(d, y, o)[1];
          }
          if (v = o ? v - y : v + y, f = f - y, f < 0) {
            y = -f;
            break;
          }
          y = 0, yield {
            path: L,
            offset: v
          };
        }
      }
    }
    function m(C, S, U) {
      return S === "character" ? mT(C, U) : S === "word" ? rge(C, U) : S === "line" || S === "block" ? C.length : 1;
    }
  }();
}
var xme = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = ne.before(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = ne.first(t, []), u = [s.path, l];
      if (ce.isPath(a) && a.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (ce.isPath(a)) {
          var [c] = ne.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = ne.nodes(t, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, Lme = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = ne.rangeRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = ne.rangeRefs(t);
  return a.add(i), i;
}, Eme = (e) => {
  var t = NN.get(e);
  return t || (t = /* @__PURE__ */ new Set(), NN.set(e, t)), t;
}, kme = (e, t, n) => {
  if (Ce.isRange(t) && !n)
    return t;
  var r = ne.start(e, t), o = ne.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function aR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pme(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aR(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Sme = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, p) => {
      if (!bt.isText(c))
        return !1;
      var [d, y] = ne.parent(e, p);
      return !e.isVoid(d) || e.markableVoid(d);
    }, o = Ce.isExpanded(n), i = !1;
    if (!o) {
      var [a, s] = ne.node(e, n);
      if (a && r(a, s)) {
        var [l] = ne.parent(e, s);
        i = l && e.markableVoid(l);
      }
    }
    if (o || i)
      $e.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = Pme({}, ne.marks(e) || {});
      delete u[t], e.marks = u, fh.get(e) || e.onChange();
    }
  }
}, Mme = (e, t) => {
  Xee.set(e, t);
}, Dme = (e, t) => ne.point(e, t, {
  edge: "start"
}), _me = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = ne.range(t, n), [a, s] = Ce.edges(i), l = "";
  for (var [u, c] of ne.nodes(t, {
    at: i,
    match: bt.isText,
    voids: o
  })) {
    var p = u.text;
    ce.equals(c, s.path) && (p = p.slice(0, s.offset)), ce.equals(c, a.path) && (p = p.slice(a.offset)), l += p;
  }
  return l;
}, Tme = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, a] = Ce.edges(n);
  if (i.offset !== 0 || a.offset !== 0 || Ce.isCollapsed(n) || ce.hasPrevious(a.path))
    return n;
  var s = ne.above(t, {
    at: a,
    match: (f) => yt.isElement(f) && ne.isBlock(t, f),
    voids: o
  }), l = s ? s[1] : [], u = ne.start(t, i), c = {
    anchor: u,
    focus: a
  }, p = !0;
  for (var [d, y] of ne.nodes(t, {
    at: c,
    match: bt.isText,
    reverse: !0,
    voids: o
  })) {
    if (p) {
      p = !1;
      continue;
    }
    if (d.text !== "" || ce.isBefore(y, l)) {
      a = {
        path: y,
        offset: d.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: a
  };
}, jme = (e, t) => {
  var n = ne.isNormalizing(e);
  ne.setNormalizing(e, !1);
  try {
    t();
  } finally {
    ne.setNormalizing(e, n);
  }
  ne.normalize(e);
}, Ame = (e, t, n) => {
  var [r, o] = t;
  return yt.isElement(r) && ne.isEmpty(e, r) || bt.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, Ime = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ne.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: a = "character",
      distance: s = 1,
      voids: l = !1
    } = n, {
      at: u = t.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var p = !1;
      if (Ce.isRange(u) && Ce.isCollapsed(u) && (p = !0, u = u.anchor), Gt.isPoint(u)) {
        var d = ne.void(t, {
          at: u,
          mode: "highest"
        });
        if (!l && d) {
          var [, y] = d;
          u = y;
        } else {
          var f = {
            unit: a,
            distance: s
          }, v = i ? ne.before(t, u, f) || ne.start(t, []) : ne.after(t, u, f) || ne.end(t, []);
          u = {
            anchor: u,
            focus: v
          }, c = !0;
        }
      }
      if (ce.isPath(u)) {
        $e.removeNodes(t, {
          at: u,
          voids: l
        });
        return;
      }
      if (!Ce.isCollapsed(u)) {
        if (!c) {
          var [, b] = Ce.edges(u), L = ne.end(t, []);
          Gt.equals(b, L) || (u = ne.unhangRange(t, u, {
            voids: l
          }));
        }
        var [w, D] = Ce.edges(u), x = ne.above(t, {
          match: (he) => yt.isElement(he) && ne.isBlock(t, he),
          at: w,
          voids: l
        }), m = ne.above(t, {
          match: (he) => yt.isElement(he) && ne.isBlock(t, he),
          at: D,
          voids: l
        }), C = x && m && !ce.equals(x[1], m[1]), S = ce.equals(w.path, D.path), U = l ? null : (r = ne.void(t, {
          at: w,
          mode: "highest"
        })) !== null && r !== void 0 ? r : ne.elementReadOnly(t, {
          at: w,
          mode: "highest"
        }), k = l ? null : (o = ne.void(t, {
          at: D,
          mode: "highest"
        })) !== null && o !== void 0 ? o : ne.elementReadOnly(t, {
          at: D,
          mode: "highest"
        });
        if (U) {
          var R = ne.before(t, w);
          R && x && ce.isAncestor(x[1], R.path) && (w = R);
        }
        if (k) {
          var N = ne.after(t, D);
          N && m && ce.isAncestor(m[1], N.path) && (D = N);
        }
        var V = [], $;
        for (var H of ne.nodes(t, {
          at: u,
          voids: l
        })) {
          var [X, G] = H;
          $ && ce.compare(G, $) === 0 || (!l && yt.isElement(X) && (ne.isVoid(t, X) || ne.isElementReadOnly(t, X)) || !ce.isCommon(G, w.path) && !ce.isCommon(G, D.path)) && (V.push(H), $ = G);
        }
        var Y = Array.from(V, (he) => {
          var [, re] = he;
          return ne.pathRef(t, re);
        }), Q = ne.pointRef(t, w), J = ne.pointRef(t, D), P = "";
        if (!S && !U) {
          var _ = Q.current, [z] = ne.leaf(t, _), {
            path: M
          } = _, {
            offset: W
          } = w, O = z.text.slice(W);
          O.length > 0 && (t.apply({
            type: "remove_text",
            path: M,
            offset: W,
            text: O
          }), P = O);
        }
        if (Y.reverse().map((he) => he.unref()).filter((he) => he !== null).forEach((he) => $e.removeNodes(t, {
          at: he,
          voids: l
        })), !k) {
          var I = J.current, [F] = ne.leaf(t, I), {
            path: j
          } = I, q = S ? w.offset : 0, A = F.text.slice(q, D.offset);
          A.length > 0 && (t.apply({
            type: "remove_text",
            path: j,
            offset: q,
            text: A
          }), P = A);
        }
        !S && C && J.current && Q.current && $e.mergeNodes(t, {
          at: J.current,
          hanging: !0,
          voids: l
        }), p && i && a === "character" && P.length > 1 && P.match(/[\u0E00-\u0E7F]+/) && $e.insertText(t, P.slice(0, P.length - s));
        var K = Q.unref(), B = J.unref(), le = i ? K || B : B || K;
        n.at == null && le && $e.select(t, le);
      }
    }
  });
}, Bme = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  ne.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: a = gT(t),
      batchDirty: s = !0
    } = r;
    if (n.length) {
      if (Ce.isRange(a))
        if (o || (a = ne.unhangRange(t, a, {
          voids: i
        })), Ce.isCollapsed(a))
          a = a.anchor;
        else {
          var [, l] = Ce.edges(a);
          if (!i && ne.void(t, {
            at: l
          }))
            return;
          var u = ne.pointRef(t, l);
          $e.delete(t, {
            at: a
          }), a = u.unref();
        }
      else ce.isPath(a) && (a = ne.start(t, a));
      if (!(!i && ne.void(t, {
        at: a
      }))) {
        var c = ne.above(t, {
          at: a,
          match: (O) => yt.isElement(O) && ne.isInline(t, O),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, p] = c;
          if (ne.isEnd(t, a, p)) {
            var d = ne.after(t, p);
            a = d;
          } else if (ne.isStart(t, a, p)) {
            var y = ne.before(t, p);
            a = y;
          }
        }
        var f = ne.above(t, {
          match: (O) => yt.isElement(O) && ne.isBlock(t, O),
          at: a,
          voids: i
        }), [, v] = f, b = ne.isStart(t, a, v), L = ne.isEnd(t, a, v), w = b && L, D = !b || b && L, x = !L, [, m] = it.first({
          children: n
        }, []), [, C] = it.last({
          children: n
        }, []), S = [], U = (O) => {
          var [I, F] = O, j = F.length === 0;
          return j ? !1 : w ? !0 : !(D && ce.isAncestor(F, m) && yt.isElement(I) && !t.isVoid(I) && !t.isInline(I) || x && ce.isAncestor(F, C) && yt.isElement(I) && !t.isVoid(I) && !t.isInline(I));
        };
        for (var k of it.nodes({
          children: n
        }, {
          pass: U
        }))
          U(k) && S.push(k);
        var R = [], N = [], V = [], $ = !0, H = !1;
        for (var [X] of S)
          yt.isElement(X) && !t.isInline(X) ? ($ = !1, H = !0, N.push(X)) : $ ? R.push(X) : V.push(X);
        var [G] = ne.nodes(t, {
          at: a,
          match: (O) => bt.isText(O) || ne.isInline(t, O),
          mode: "highest",
          voids: i
        }), [, Y] = G, Q = ne.isStart(t, a, Y), J = ne.isEnd(t, a, Y), P = ne.pathRef(t, L && !V.length ? ce.next(v) : v), _ = ne.pathRef(t, J ? ce.next(Y) : Y);
        $e.splitNodes(t, {
          at: a,
          match: (O) => H ? yt.isElement(O) && ne.isBlock(t, O) : bt.isText(O) || ne.isInline(t, O),
          mode: H ? "lowest" : "highest",
          always: H && (!b || R.length > 0) && (!L || V.length > 0),
          voids: i
        });
        var z = ne.pathRef(t, !Q || Q && J ? ce.next(Y) : Y);
        if ($e.insertNodes(t, R, {
          at: z.current,
          match: (O) => bt.isText(O) || ne.isInline(t, O),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), w && !R.length && N.length && !V.length && $e.delete(t, {
          at: v,
          voids: i
        }), $e.insertNodes(t, N, {
          at: P.current,
          match: (O) => yt.isElement(O) && ne.isBlock(t, O),
          mode: "lowest",
          voids: i,
          batchDirty: s
        }), $e.insertNodes(t, V, {
          at: _.current,
          match: (O) => bt.isText(O) || ne.isInline(t, O),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), !r.at) {
          var M;
          if (V.length > 0 && _.current ? M = ce.previous(_.current) : N.length > 0 && P.current ? M = ce.previous(P.current) : z.current && (M = ce.previous(z.current)), M) {
            var W = ne.end(t, M);
            $e.select(t, W);
          }
        }
        z.unref(), P.unref(), _.unref();
      }
    }
  });
}, Nme = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      $e.select(t, o.anchor);
    else if (r === "focus")
      $e.select(t, o.focus);
    else if (r === "start") {
      var [i] = Ce.edges(o);
      $e.select(t, i);
    } else if (r === "end") {
      var [, a] = Ce.edges(o);
      $e.select(t, a);
    }
  } else return;
}, Rme = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, Fme = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: a = !1
  } = n, {
    edge: s = null
  } = n;
  if (r) {
    s === "start" && (s = Ce.isBackward(r) ? "focus" : "anchor"), s === "end" && (s = Ce.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, p = {};
    if (s == null || s === "anchor") {
      var d = a ? ne.before(t, l, c) : ne.after(t, l, c);
      d && (p.anchor = d);
    }
    if (s == null || s === "focus") {
      var y = a ? ne.before(t, u, c) : ne.after(t, u, c);
      y && (p.focus = y);
    }
    $e.setSelection(t, p);
  }
}, zme = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = ne.range(e, t), n) {
    $e.setSelection(e, t);
    return;
  }
  if (!Ce.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(bi.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function lR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lR(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ume = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = Ce.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = Ce.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: a,
      focus: s
    } = o, l = i === "anchor" ? a : s;
    $e.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: uR(uR({}, l), n)
    });
  }
}, Wme = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !Gt.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !Gt.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, Hme = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  ne.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: a = "lowest",
      batchDirty: s = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (it.isNode(n) && (n = [n]), n.length !== 0) {
      var [p] = n;
      if (l || (l = gT(t), c !== !1 && (c = !0)), c == null && (c = !1), Ce.isRange(l))
        if (o || (l = ne.unhangRange(t, l, {
          voids: i
        })), Ce.isCollapsed(l))
          l = l.anchor;
        else {
          var [, d] = Ce.edges(l), y = ne.pointRef(t, d);
          $e.delete(t, {
            at: l
          }), l = y.unref();
        }
      if (Gt.isPoint(l)) {
        u == null && (bt.isText(p) ? u = (R) => bt.isText(R) : t.isInline(p) ? u = (R) => bt.isText(R) || ne.isInline(t, R) : u = (R) => yt.isElement(R) && ne.isBlock(t, R));
        var [f] = ne.nodes(t, {
          at: l.path,
          match: u,
          mode: a,
          voids: i
        });
        if (f) {
          var [, v] = f, b = ne.pathRef(t, v), L = ne.isEnd(t, l, v);
          $e.splitNodes(t, {
            at: l,
            match: u,
            mode: a,
            voids: i
          });
          var w = b.unref();
          l = L ? ce.next(w) : w;
        } else
          return;
      }
      var D = ce.parent(l), x = l[l.length - 1];
      if (!(!i && ne.void(t, {
        at: D
      }))) {
        if (s) {
          var m = [], C = ce.levels(D);
          Ege(t, () => {
            var R = function() {
              var $ = D.concat(x);
              x++;
              var H = {
                type: "insert_node",
                path: $,
                node: N
              };
              t.apply(H), l = ce.next(l), m.push(H), bt.isText ? C.push(...Array.from(it.nodes(N), (X) => {
                var [, G] = X;
                return $.concat(G);
              })) : C.push($);
            };
            for (var N of n)
              R();
          }, () => {
            Gee(t, C, (R) => {
              var N = R;
              for (var V of m)
                if (ce.operationCanTransformPath(V) && (N = ce.transform(N, V), !N))
                  return null;
              return N;
            });
          });
        } else
          for (var S of n) {
            var U = D.concat(x);
            x++, t.apply({
              type: "insert_node",
              path: U,
              node: S
            }), l = ce.next(l);
          }
        if (l = ce.previous(l), c) {
          var k = ne.end(t, l);
          k && $e.select(t, k);
        }
      }
    }
  });
}, Vme = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ne.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: a
    } = n;
    if (a == null && (a = ce.isPath(r) ? Sd(t, r) : (x) => yt.isElement(x) && ne.isBlock(t, x)), !!r) {
      var s = ne.nodes(t, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), l = Array.from(s, (x) => {
        var [, m] = x;
        return ne.pathRef(t, m);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var p = ne.node(t, ce.parent(c)), [d, y] = p, f = c[c.length - 1], {
          length: v
        } = d.children;
        if (v === 1) {
          var b = ce.next(y);
          $e.moveNodes(t, {
            at: c,
            to: b,
            voids: i
          }), $e.removeNodes(t, {
            at: y,
            voids: i
          });
        } else if (f === 0)
          $e.moveNodes(t, {
            at: c,
            to: y,
            voids: i
          });
        else if (f === v - 1) {
          var L = ce.next(y);
          $e.moveNodes(t, {
            at: c,
            to: L,
            voids: i
          });
        } else {
          var w = ce.next(c), D = ce.next(y);
          $e.splitNodes(t, {
            at: w,
            voids: i
          }), $e.moveNodes(t, {
            at: c,
            to: D,
            voids: i
          });
        }
      }
    }
  });
}, $me = ["text"], Zme = ["children"], Yee = (e, t) => {
  if (yt.isElement(t)) {
    var n = t;
    return ne.isVoid(e, t) ? !0 : n.children.length === 1 ? Yee(e, n.children[0]) : !1;
  } else return !ne.isEditor(t);
}, qme = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ne.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: a = !1,
      mode: s = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (ce.isPath(o)) {
          var [l] = ne.parent(t, o);
          r = (R) => l.children.includes(R);
        } else
          r = (R) => yt.isElement(R) && ne.isBlock(t, R);
      if (!i && Ce.isRange(o) && (o = ne.unhangRange(t, o, {
        voids: a
      })), Ce.isRange(o))
        if (Ce.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = Ce.edges(o), c = ne.pointRef(t, u);
          $e.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && $e.select(t, o);
        }
      var [p] = ne.nodes(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      }), d = ne.previous(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      });
      if (!(!p || !d)) {
        var [y, f] = p, [v, b] = d;
        if (!(f.length === 0 || b.length === 0)) {
          var L = ce.next(b), w = ce.common(f, b), D = ce.isSibling(f, b), x = Array.from(ne.levels(t, {
            at: f
          }), (R) => {
            var [N] = R;
            return N;
          }).slice(w.length).slice(0, -1), m = ne.above(t, {
            at: f,
            mode: "highest",
            match: (R) => x.includes(R) && Yee(t, R)
          }), C = m && ne.pathRef(t, m[1]), S, U;
          if (bt.isText(y) && bt.isText(v)) {
            var k = Fl(y, $me);
            U = v.text.length, S = k;
          } else if (yt.isElement(y) && yt.isElement(v)) {
            var k = Fl(y, Zme);
            U = v.children.length, S = k;
          } else
            throw new Error("Cannot merge the node at path [".concat(f, "] with the previous sibling because it is not the same kind: ").concat(bi.stringify(y), " ").concat(bi.stringify(v)));
          D || $e.moveNodes(t, {
            at: f,
            to: L,
            voids: a
          }), C && $e.removeNodes(t, {
            at: C.current,
            voids: a
          }), ne.shouldMergeNodesRemovePrevNode(t, d, p) ? $e.removeNodes(t, {
            at: b,
            voids: a
          }) : t.apply({
            type: "merge_node",
            path: L,
            position: U,
            properties: S
          }), C && C.unref();
        }
      }
    }
  });
}, Xme = (e, t) => {
  ne.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: a
    } = t;
    if (r) {
      a == null && (a = ce.isPath(r) ? Sd(e, r) : (y) => yt.isElement(y) && ne.isBlock(e, y));
      var s = ne.pathRef(e, n), l = ne.nodes(e, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), u = Array.from(l, (y) => {
        var [, f] = y;
        return ne.pathRef(e, f);
      });
      for (var c of u) {
        var p = c.unref(), d = s.current;
        p.length !== 0 && e.apply({
          type: "move_node",
          path: p,
          newPath: d
        }), s.current && ce.isSibling(d, p) && ce.isAfter(d, p) && (s.current = ce.next(s.current));
      }
      s.unref();
    }
  });
}, Kme = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ne.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = ce.isPath(a) ? Sd(t, a) : (y) => yt.isElement(y) && ne.isBlock(t, y)), !r && Ce.isRange(a) && (a = ne.unhangRange(t, a, {
        voids: o
      }));
      var l = ne.nodes(t, {
        at: a,
        match: s,
        mode: i,
        voids: o
      }), u = Array.from(l, (y) => {
        var [, f] = y;
        return ne.pathRef(t, f);
      });
      for (var c of u) {
        var p = c.unref();
        if (p) {
          var [d] = ne.node(t, p);
          t.apply({
            type: "remove_node",
            path: p,
            node: d
          });
        }
      }
    }
  });
}, Gme = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  ne.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: a,
      merge: s
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: p = !1
    } = r;
    if (i) {
      if (o == null && (o = ce.isPath(i) ? Sd(t, i) : (U) => yt.isElement(U) && ne.isBlock(t, U)), !l && Ce.isRange(i) && (i = ne.unhangRange(t, i, {
        voids: p
      })), c && Ce.isRange(i)) {
        if (Ce.isCollapsed(i) && ne.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var d = ne.rangeRef(t, i, {
          affinity: "inward"
        }), [y, f] = Ce.edges(i), v = u === "lowest" ? "lowest" : "highest", b = ne.isEnd(t, f, f.path);
        $e.splitNodes(t, {
          at: f,
          match: o,
          mode: v,
          voids: p,
          always: !b
        });
        var L = ne.isStart(t, y, y.path);
        $e.splitNodes(t, {
          at: y,
          match: o,
          mode: v,
          voids: p,
          always: !L
        }), i = d.unref(), r.at == null && $e.select(t, i);
      }
      a || (a = (U, k) => U !== k);
      for (var [w, D] of ne.nodes(t, {
        at: i,
        match: o,
        mode: u,
        voids: p
      })) {
        var x = {}, m = {};
        if (D.length !== 0) {
          var C = !1;
          for (var S in n)
            S === "children" || S === "text" || a(n[S], w[S]) && (C = !0, w.hasOwnProperty(S) && (x[S] = w[S]), s ? n[S] != null && (m[S] = s(w[S], n[S])) : n[S] != null && (m[S] = n[S]));
          C && t.apply({
            type: "set_node",
            path: D,
            properties: x,
            newProperties: m
          });
        }
      }
    }
  });
}, Yme = (e, t) => {
  if (Ce.isCollapsed(t))
    return t.anchor;
  var [, n] = Ce.edges(t), r = ne.pointRef(e, n);
  return $e.delete(e, {
    at: t
  }), r.unref();
}, Jme = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ne.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: a = t.selection,
      height: s = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (J) => yt.isElement(J) && ne.isBlock(t, J)), Ce.isRange(a) && (a = Yme(t, a)), ce.isPath(a)) {
      var u = a, c = ne.point(t, u), [p] = ne.parent(t, u);
      i = (J) => J === p, s = c.path.length - u.length + 1, a = c, l = !0;
    }
    if (a) {
      var d = ne.pointRef(t, a, {
        affinity: "backward"
      }), y;
      try {
        var [f] = ne.nodes(t, {
          at: a,
          match: i,
          mode: r,
          voids: o
        });
        if (!f)
          return;
        var v = ne.void(t, {
          at: a,
          mode: "highest"
        }), b = 0;
        if (!o && v) {
          var [L, w] = v;
          if (yt.isElement(L) && t.isInline(L)) {
            var D = ne.after(t, w);
            if (!D) {
              var x = {
                text: ""
              }, m = ce.next(w);
              $e.insertNodes(t, x, {
                at: m,
                voids: o
              }), D = ne.point(t, m);
            }
            a = D, l = !0;
          }
          var C = a.path.length - w.length;
          s = C + 1, l = !0;
        }
        y = ne.pointRef(t, a);
        var S = a.path.length - s, [, U] = f, k = a.path.slice(0, S), R = s === 0 ? a.offset : a.path[S] + b;
        for (var [N, V] of ne.levels(t, {
          at: k,
          reverse: !0,
          voids: o
        })) {
          var $ = !1;
          if (V.length < U.length || V.length === 0 || !o && yt.isElement(N) && ne.isVoid(t, N))
            break;
          var H = d.current, X = ne.isEnd(t, H, V);
          if (l || !d || !ne.isEdge(t, H, V)) {
            $ = !0;
            var G = it.extractProps(N);
            t.apply({
              type: "split_node",
              path: V,
              position: R,
              properties: G
            });
          }
          R = V[V.length - 1] + ($ || X ? 1 : 0);
        }
        if (n.at == null) {
          var Y = y.current || ne.end(t, []);
          $e.select(t, Y);
        }
      } finally {
        var Q;
        d.unref(), (Q = y) === null || Q === void 0 || Q.unref();
      }
    }
  });
}, Qme = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  $e.setNodes(t, o, r);
}, eve = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ne.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = ce.isPath(a) ? Sd(t, a) : (y) => yt.isElement(y) && ne.isBlock(t, y)), ce.isPath(a) && (a = ne.range(t, a));
      var l = Ce.isRange(a) ? ne.rangeRef(t, a) : null, u = ne.nodes(t, {
        at: a,
        match: s,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (y) => {
          var [, f] = y;
          return ne.pathRef(t, f);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), p = function() {
        var f = d.unref(), [v] = ne.node(t, f), b = ne.range(t, f);
        o && l && (b = Ce.intersection(l.current, b)), $e.liftNodes(t, {
          at: b,
          match: (L) => yt.isAncestor(v) && v.children.includes(L),
          voids: i
        });
      };
      for (var d of c)
        p();
      l && l.unref();
    }
  });
};
function cR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cR(Object(n), !0).forEach(function(r) {
      Ki(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tve = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  ne.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: a = !1
    } = r, {
      match: s,
      at: l = t.selection
    } = r;
    if (l) {
      if (s == null && (ce.isPath(l) ? s = Sd(t, l) : t.isInline(n) ? s = (b) => yt.isElement(b) && ne.isInline(t, b) || bt.isText(b) : s = (b) => yt.isElement(b) && ne.isBlock(t, b)), i && Ce.isRange(l)) {
        var [u, c] = Ce.edges(l), p = ne.rangeRef(t, l, {
          affinity: "inward"
        });
        $e.splitNodes(t, {
          at: c,
          match: s,
          voids: a
        }), $e.splitNodes(t, {
          at: u,
          match: s,
          voids: a
        }), l = p.unref(), r.at == null && $e.select(t, l);
      }
      var d = Array.from(ne.nodes(t, {
        at: l,
        match: t.isInline(n) ? (b) => yt.isElement(b) && ne.isBlock(t, b) : (b) => ne.isEditor(b),
        mode: "lowest",
        voids: a
      })), y = function() {
        var L = Ce.isRange(l) ? Ce.intersection(l, ne.range(t, v)) : l;
        if (!L)
          return 0;
        var w = Array.from(ne.nodes(t, {
          at: L,
          match: s,
          mode: o,
          voids: a
        }));
        if (w.length > 0) {
          var [D] = w, x = w[w.length - 1], [, m] = D, [, C] = x;
          if (m.length === 0 && C.length === 0)
            return 0;
          var S = ce.equals(m, C) ? ce.parent(m) : ce.common(m, C), U = ne.range(t, m, C), k = ne.node(t, S), [R] = k, N = S.length + 1, V = ce.next(C.slice(0, N)), $ = pR(pR({}, n), {}, {
            children: []
          });
          $e.insertNodes(t, $, {
            at: V,
            voids: a
          }), $e.moveNodes(t, {
            at: U,
            match: (H) => yt.isAncestor(R) && R.children.includes(H),
            to: V.concat(0),
            voids: a
          });
        }
      }, f;
      for (var [, v] of d)
        f = y();
    }
  });
}, nve = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kge(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tge(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ige(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Bge(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nge(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Sge(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Xge(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Gge(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Bme(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Kge(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jge(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mge(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Sme(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Pge(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Dge(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _ge(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jge(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Age(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nme(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ime(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Rme(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Rge(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fge(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zge(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Uge(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Wge(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cme(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vge(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $ge(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zge(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qge(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hme(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Qge(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eme(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return tme(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nme(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rme(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ome(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ime(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sme(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ame(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vme(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qme(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fme(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Xme(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pme(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dme(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fme(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hme(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gme(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yme(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mme(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vme(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ome(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bme(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wme(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Cme(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xme(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kme(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Lme(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Eme(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Kme(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zme(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Gme(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mme(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ume(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Wme(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jme(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Dme(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _me(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tme(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Qme(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eve(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hge(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jme(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return tve(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ame(e, ...r);
    }
  };
  return e;
};
const Jee = (e) => {
  if (bt.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if (yt.isElement(e)) {
    const t = e.children.map((r) => Jee(r)).join(""), n = e.align || "left";
    switch (e.type) {
      case "image":
        return `<img src="${e.src}" class="align_${n}" />`;
      case "paragraph":
        return `<p class="align_${n}">${t}</p>`;
      case "blockQuote":
        return `<blockquote class="align_${n}">${t}</blockquote>`;
      case "bulletedList":
        return `<ul class="align_${n}">${t}</ul>`;
      case "headingOne":
        return `<h1 class="align_${n}">${t}</h1>`;
      case "headingTwo":
        return `<h2 class="align_${n}">${t}</h2>`;
      case "listItem":
        return `<li class="align_${n}">${t}</li>`;
      case "numberedList":
        return `<ol class="align_${n}">${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, jyt = (e) => e.map((t) => Jee(t)).join("");
var Qee = {}, yT = {}, bT = {};
Object.defineProperty(bT, "__esModule", { value: !0 });
bT.default = sve;
var dR = "html", fR = "head", dv = "body", rve = /<([a-zA-Z]+[0-9]?)/, hR = /<head[^]*>/i, gR = /<body[^]*>/i, x0 = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, nM = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, mR = typeof window == "object" && window.DOMParser;
if (typeof mR == "function") {
  var ove = new mR(), ive = "text/html";
  nM = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), ove.parseFromString(e, ive);
  }, x0 = nM;
}
if (typeof document == "object" && document.implementation) {
  var fv = document.implementation.createHTMLDocument();
  x0 = function(e, t) {
    if (t) {
      var n = fv.documentElement.querySelector(t);
      return n && (n.innerHTML = e), fv;
    }
    return fv.documentElement.innerHTML = e, fv;
  };
}
var hv = typeof document == "object" && document.createElement("template"), rM;
hv && hv.content && (rM = function(e) {
  return hv.innerHTML = e, hv.content.childNodes;
});
function sve(e) {
  var t, n, r = e.match(rve), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case dR: {
      var i = nM(e);
      if (!hR.test(e)) {
        var a = i.querySelector(fR);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!gR.test(e)) {
        var a = i.querySelector(dv);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(dR);
    }
    case fR:
    case dv: {
      var s = x0(e).querySelectorAll(o);
      return gR.test(e) && hR.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (rM)
        return rM(e);
      var a = x0(e, dv).querySelector(dv);
      return a.childNodes;
    }
  }
}
var lO = {}, wT = {}, OT = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(OT);
var an = {}, rc = Pr && Pr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), hh = Pr && Pr.__assign || function() {
  return hh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, hh.apply(this, arguments);
};
Object.defineProperty(an, "__esModule", { value: !0 });
an.cloneNode = an.hasChildren = an.isDocument = an.isDirective = an.isComment = an.isText = an.isCDATA = an.isTag = an.Element = an.Document = an.CDATA = an.NodeWithChildren = an.ProcessingInstruction = an.Comment = an.Text = an.DataNode = an.Node = void 0;
var Cs = OT, CT = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), xT(this, t);
    }, e;
  }()
);
an.Node = CT;
var uO = (
  /** @class */
  function(e) {
    rc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(CT)
);
an.DataNode = uO;
var ete = (
  /** @class */
  function(e) {
    rc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Cs.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uO)
);
an.Text = ete;
var tte = (
  /** @class */
  function(e) {
    rc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Cs.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uO)
);
an.Comment = tte;
var nte = (
  /** @class */
  function(e) {
    rc(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Cs.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uO)
);
an.ProcessingInstruction = nte;
var cO = (
  /** @class */
  function(e) {
    rc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(CT)
);
an.NodeWithChildren = cO;
var rte = (
  /** @class */
  function(e) {
    rc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Cs.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cO)
);
an.CDATA = rte;
var ote = (
  /** @class */
  function(e) {
    rc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Cs.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cO)
);
an.Document = ote;
var ite = (
  /** @class */
  function(e) {
    rc(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Cs.ElementType.Script : n === "style" ? Cs.ElementType.Style : Cs.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cO)
);
an.Element = ite;
function ste(e) {
  return (0, Cs.isTag)(e);
}
an.isTag = ste;
function ate(e) {
  return e.type === Cs.ElementType.CDATA;
}
an.isCDATA = ate;
function lte(e) {
  return e.type === Cs.ElementType.Text;
}
an.isText = lte;
function ute(e) {
  return e.type === Cs.ElementType.Comment;
}
an.isComment = ute;
function cte(e) {
  return e.type === Cs.ElementType.Directive;
}
an.isDirective = cte;
function pte(e) {
  return e.type === Cs.ElementType.Root;
}
an.isDocument = pte;
function ave(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
an.hasChildren = ave;
function xT(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (lte(e))
    n = new ete(e.data);
  else if (ute(e))
    n = new tte(e.data);
  else if (ste(e)) {
    var r = t ? BL(e.children) : [], o = new ite(e.name, hh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = hh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = hh({}, e["x-attribsPrefix"])), n = o;
  } else if (ate(e)) {
    var r = t ? BL(e.children) : [], i = new rte(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (pte(e)) {
    var r = t ? BL(e.children) : [], a = new ote(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (cte(e)) {
    var s = new nte(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
an.cloneNode = xT;
function BL(e) {
  for (var t = e.map(function(r) {
    return xT(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Pr && Pr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Pr && Pr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = OT, o = an;
  n(an, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(wT);
var dte = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(dte);
Object.defineProperty(lO, "__esModule", { value: !0 });
lO.formatAttributes = fte;
lO.formatDOM = hte;
var gv = wT, lve = dte;
function uve(e) {
  return lve.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function fte(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function cve(e) {
  e = e.toLowerCase();
  var t = uve(e);
  return t || e;
}
function hte(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = cve(s.nodeName);
        o = new gv.Element(l, fte(s.attributes)), o.children = hte(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new gv.Text(s.nodeValue);
        break;
      case 8:
        o = new gv.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new gv.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var pve = Pr && Pr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(yT, "__esModule", { value: !0 });
yT.default = gve;
var dve = pve(bT), fve = lO, hve = /<(![a-zA-Z\s]+)>/;
function gve(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(hve), n = t ? t[1] : void 0;
  return (0, fve.formatDOM)((0, dve.default)(e), null, n);
}
var pO = {}, Pa = {}, dO = {}, mve = 0;
dO.SAME = mve;
var vve = 1;
dO.CAMELCASE = vve;
dO.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const gte = 0, oc = 1, fO = 2, hO = 3, LT = 4, mte = 5, vte = 6;
function yve(e) {
  return Mi.hasOwnProperty(e) ? Mi[e] : null;
}
function Gi(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === fO || t === hO || t === LT, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Mi = {}, bve = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
bve.forEach((e) => {
  Mi[e] = new Gi(
    e,
    gte,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Mi[e] = new Gi(
    e,
    oc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Mi[e] = new Gi(
    e,
    fO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Mi[e] = new Gi(
    e,
    fO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Mi[e] = new Gi(
    e,
    hO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Mi[e] = new Gi(
    e,
    hO,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Mi[e] = new Gi(
    e,
    LT,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Mi[e] = new Gi(
    e,
    vte,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Mi[e] = new Gi(
    e,
    mte,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const ET = /[\-\:]([a-z])/g, kT = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(ET, kT);
  Mi[t] = new Gi(
    t,
    oc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(ET, kT);
  Mi[t] = new Gi(
    t,
    oc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(ET, kT);
  Mi[t] = new Gi(
    t,
    oc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Mi[e] = new Gi(
    e,
    oc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const wve = "xlinkHref";
Mi[wve] = new Gi(
  "xlinkHref",
  oc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Mi[e] = new Gi(
    e,
    oc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Ove,
  SAME: Cve,
  possibleStandardNames: vR
} = dO, xve = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Lve = xve + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Eve = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Lve + "]*$")
), kve = Object.keys(
  vR
).reduce((e, t) => {
  const n = vR[t];
  return n === Cve ? e[t] = t : n === Ove ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Pa.BOOLEAN = hO;
Pa.BOOLEANISH_STRING = fO;
Pa.NUMERIC = mte;
Pa.OVERLOADED_BOOLEAN = LT;
Pa.POSITIVE_NUMERIC = vte;
Pa.RESERVED = gte;
Pa.STRING = oc;
Pa.getPropertyInfo = yve;
Pa.isCustomAttribute = Eve;
Pa.possibleStandardNames = kve;
var PT = {}, ST = {}, yR = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Pve = /\n/g, Sve = /^\s*/, Mve = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Dve = /^:\s*/, _ve = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Tve = /^[;\s]*/, jve = /^\s+|\s+$/g, Ave = `
`, bR = "/", wR = "*", sp = "", Ive = "comment", Bve = "declaration", Nve = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(Pve);
    v && (n += v.length);
    var b = f.lastIndexOf(Ave);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(Sve);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(bR != e.charAt(0) || wR != e.charAt(1))) {
      for (var v = 2; sp != e.charAt(v) && (wR != e.charAt(v) || bR != e.charAt(v + 1)); )
        ++v;
      if (v += 2, sp === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: Ive,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(Mve);
    if (v) {
      if (p(), !l(Dve)) return s("property missing ':'");
      var b = l(_ve), L = f({
        type: Bve,
        property: OR(v[0].replace(yR, sp)),
        value: b ? OR(b[0].replace(yR, sp)) : sp
      });
      return l(Tve), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function OR(e) {
  return e ? e.replace(jve, sp) : sp;
}
var Rve = Pr && Pr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ST, "__esModule", { value: !0 });
ST.default = zve;
var Fve = Rve(Nve);
function zve(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Fve.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var gO = {};
Object.defineProperty(gO, "__esModule", { value: !0 });
gO.camelCase = void 0;
var Uve = /^--[a-zA-Z0-9_-]+$/, Wve = /-([a-z])/g, Hve = /^[^-]+$/, Vve = /^-(webkit|moz|ms|o|khtml)-/, $ve = /^-(ms)-/, Zve = function(e) {
  return !e || Hve.test(e) || Uve.test(e);
}, qve = function(e, t) {
  return t.toUpperCase();
}, CR = function(e, t) {
  return "".concat(t, "-");
}, Xve = function(e, t) {
  return t === void 0 && (t = {}), Zve(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace($ve, CR) : e = e.replace(Vve, CR), e.replace(Wve, qve));
};
gO.camelCase = Xve;
var Kve = Pr && Pr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Gve = Kve(ST), Yve = gO;
function oM(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Gve.default)(e, function(r, o) {
    r && o && (n[(0, Yve.camelCase)(r, t)] = o);
  }), n;
}
oM.default = oM;
var Jve = oM;
(function(e) {
  var t = Pr && Pr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Oe, r = t(Jve), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(PT);
Object.defineProperty(pO, "__esModule", { value: !0 });
pO.default = nye;
var Gf = Pa, xR = PT, Qve = ["checked", "value"], eye = ["input", "select", "textarea"], tye = {
  reset: !0,
  submit: !0
};
function nye(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && tye[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Gf.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = LR(a);
    if (s) {
      var l = (0, Gf.getPropertyInfo)(s);
      switch (Qve.includes(s) && eye.includes(t) && !r && (s = LR("default" + a)), n[s] = i, l && l.type) {
        case Gf.BOOLEAN:
          n[s] = !0;
          break;
        case Gf.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    xR.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, xR.setStyleProp)(e.style, n), n;
}
function LR(e) {
  return Gf.possibleStandardNames[e];
}
var MT = {}, rye = Pr && Pr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(MT, "__esModule", { value: !0 });
MT.default = yte;
var NL = Oe, oye = rye(pO), gh = PT, iye = {
  cloneElement: NL.cloneElement,
  createElement: NL.createElement,
  isValidElement: NL.isValidElement
};
function yte(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || gh.returnFirstArg, i = t.library || iye, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, gh.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    sye(f) ? ((0, gh.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, oye.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = yte(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function sye(e) {
  return gh.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, gh.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Pr && Pr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(yT);
  e.htmlToDOM = n.default;
  var r = t(pO);
  e.attributesToProps = r.default;
  var o = t(MT);
  e.domToReact = o.default;
  var i = wT;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(Qee);
const ER = /* @__PURE__ */ rO(Qee), aye = ER.default || ER, iM = (e) => {
  var r;
  if (typeof e == "string")
    return { text: e };
  const t = Array.isArray(e.props.children) ? e.props.children.map((o) => iM(o)) : [{ text: e.props.children || "" }], n = (r = e.props.className) == null ? void 0 : r.replace("align_", "");
  switch (e.type) {
    case "img":
      return {
        type: "image",
        align: n,
        src: e.props.src,
        children: [{ text: "" }]
      };
    case "p":
      return { type: "paragraph", align: n, children: t };
    case "blockquote":
      return { type: "blockQuote", align: n, children: t };
    case "ul":
      return { type: "bulletedList", align: n, children: t };
    case "ol":
      return { type: "numberedList", align: n, children: t };
    case "li":
      return { type: "listItem", align: n, children: t };
    case "h1":
      return { type: "headingOne", align: n, children: t };
    case "h2":
      return { type: "headingTwo", align: n, children: t };
    case "strong":
      return { text: e.props.children, bold: !0 };
    case "code":
      return { text: e.props.children, code: !0 };
    case "em":
      return { text: e.props.children, italic: !0 };
    case "u":
      return { text: e.props.children, underline: !0 };
    default:
      return { text: e.props.children || "" };
  }
}, Ayt = (e) => {
  const t = aye(e);
  return Array.isArray(t) ? t.map((n) => typeof n == "string" ? { text: n } : iM(n)) : typeof t == "string" ? [{ text: t }] : [iM(t)];
}, Iyt = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function bte(e, t, n) {
  if (!e) return /* @__PURE__ */ oe.jsx(oe.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ oe.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ oe.jsx("p", { className: n, children: /* @__PURE__ */ oe.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function Byt(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: a = "",
    children: s,
    ...l
  } = e, c = { md: 12, lg: 14 }[r], p = `arkynBadge ${t} ${n} ${r} ${a}`;
  return /* @__PURE__ */ oe.jsxs("div", { className: p.trim(), ...l, children: [
    v0(c, o),
    s,
    v0(c, i)
  ] });
}
function Nyt(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ oe.jsx("div", { className: r.trim(), ...n });
}
function Ryt(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ oe.jsx("div", { className: o.trim(), ...r });
}
function Fyt(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ oe.jsx("aside", { className: r.trim(), ...n });
}
function zyt(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, a = ut.count(r) === 0;
  return /* @__PURE__ */ oe.jsx("tbody", { className: i.trim(), ...o, children: a ? /* @__PURE__ */ oe.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ oe.jsx("td", { colSpan: 100, children: /* @__PURE__ */ oe.jsx("div", { children: t }) }) }) : r });
}
function Uyt(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ oe.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ oe.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function Wyt(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ oe.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ oe.jsx("table", { children: t }) });
}
function Hyt(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ oe.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ oe.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ oe.jsx("tr", { children: /* @__PURE__ */ oe.jsx("th", { colSpan: 100, children: /* @__PURE__ */ oe.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function Vyt(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ oe.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ oe.jsx("tr", { children: n }),
    /* @__PURE__ */ oe.jsx("tr", { className: "spacingRow" })
  ] });
}
var Sr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function lye(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var sM = { exports: {} }, of = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var kR;
function uye() {
  if (kR) return of;
  kR = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return of.Fragment = n, of.jsx = a, of.jsxs = a, of;
}
var mv = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var PR;
function cye() {
  return PR || (PR = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var T = f && g[f] || g[v];
      return typeof T == "function" ? T : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var T = arguments.length, Z = new Array(T > 1 ? T - 1 : 0), ee = 1; ee < T; ee++)
          Z[ee - 1] = arguments[ee];
        D("error", g, Z);
      }
    }
    function D(g, T, Z) {
      {
        var ee = L.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (T += "%s", Z = Z.concat([ae]));
        var ue = Z.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + T), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function R(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function N(g, T, Z) {
      var ee = g.displayName;
      if (ee)
        return ee;
      var ae = T.displayName || T.name || "";
      return ae !== "" ? Z + "(" + ae + ")" : Z;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var T = g;
            return V(T) + ".Consumer";
          case a:
            var Z = g;
            return V(Z._context) + ".Provider";
          case l:
            return N(g, g.render, "ForwardRef");
          case p:
            var ee = g.displayName || null;
            return ee !== null ? ee : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, X = 0, G, Y, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function W() {
      {
        if (X === 0) {
          G = console.log, Y = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        X++;
      }
    }
    function O() {
      {
        if (X--, X === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, g, {
              value: G
            }),
            info: H({}, g, {
              value: Y
            }),
            warn: H({}, g, {
              value: Q
            }),
            error: H({}, g, {
              value: J
            }),
            group: H({}, g, {
              value: P
            }),
            groupCollapsed: H({}, g, {
              value: _
            }),
            groupEnd: H({}, g, {
              value: z
            })
          });
        }
        X < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = L.ReactCurrentDispatcher, F;
    function j(g, T, Z) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            F = ee && ee[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, A;
    {
      var K = typeof WeakMap == "function" ? WeakMap : Map;
      A = new K();
    }
    function B(g, T) {
      if (!g || q)
        return "";
      {
        var Z = A.get(g);
        if (Z !== void 0)
          return Z;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (T) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Le) {
              ee = Le;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (Le) {
              ee = Le;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Le) {
            ee = Le;
          }
          g();
        }
      } catch (Le) {
        if (Le && ee && typeof Le.stack == "string") {
          for (var ie = Le.stack.split(`
`), we = ee.stack.split(`
`), de = ie.length - 1, fe = we.length - 1; de >= 1 && fe >= 0 && ie[de] !== we[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== we[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== we[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", g.displayName)), typeof g == "function" && A.set(g, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var kt = g ? g.displayName || g.name : "", mt = kt ? j(kt) : "";
      return typeof g == "function" && A.set(g, mt), mt;
    }
    function le(g, T, Z) {
      return B(g, !1);
    }
    function he(g) {
      var T = g.prototype;
      return !!(T && T.isReactComponent);
    }
    function re(g, T, Z) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return B(g, he(g));
      if (typeof g == "string")
        return j(g);
      switch (g) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return re(g.type, T, Z);
          case d: {
            var ee = g, ae = ee._payload, ue = ee._init;
            try {
              return re(ue(ae), T, Z);
            } catch {
            }
          }
        }
      return "";
    }
    var Se = Object.prototype.hasOwnProperty, We = {}, Ze = L.ReactDebugCurrentFrame;
    function Me(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        Ze.setExtraStackFrame(Z);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(g, T, Z, ee, ae) {
      {
        var ue = Function.call.bind(Se);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var we = Error((ee || "React class") + ": " + Z + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw we.name = "Invariant Violation", we;
              }
              ie = g[se](T, se, ee, Z, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Me(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", Z, se, typeof ie), Me(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Me(ae), w("Failed %s type: %s", Z, ie.message), Me(null));
          }
      }
    }
    var Ve = Array.isArray;
    function be(g) {
      return Ve(g);
    }
    function qe(g) {
      {
        var T = typeof Symbol == "function" && Symbol.toStringTag, Z = T && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return Z;
      }
    }
    function ct(g) {
      try {
        return ye(g), !1;
      } catch {
        return !0;
      }
    }
    function ye(g) {
      return "" + g;
    }
    function xe(g) {
      if (ct(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qe(g)), ye(g);
    }
    var Ee = L.ReactCurrentOwner, Ue = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, De, st, ve;
    ve = {};
    function wt(g) {
      if (Se.call(g, "ref")) {
        var T = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function at(g) {
      if (Se.call(g, "key")) {
        var T = Object.getOwnPropertyDescriptor(g, "key").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function lt(g, T) {
      if (typeof g.ref == "string" && Ee.current && T && Ee.current.stateNode !== T) {
        var Z = $(Ee.current.type);
        ve[Z] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ee.current.type), g.ref), ve[Z] = !0);
      }
    }
    function pt(g, T) {
      {
        var Z = function() {
          De || (De = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: Z,
          configurable: !0
        });
      }
    }
    function Ot(g, T) {
      {
        var Z = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: Z,
          configurable: !0
        });
      }
    }
    var dt = function(g, T, Z, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: T,
        ref: Z,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function Ct(g, T, Z, ee, ae) {
      {
        var ue, se = {}, ie = null, we = null;
        Z !== void 0 && (xe(Z), ie = "" + Z), at(T) && (xe(T.key), ie = "" + T.key), wt(T) && (we = T.ref, lt(T, ae));
        for (ue in T)
          Se.call(T, ue) && !Ue.hasOwnProperty(ue) && (se[ue] = T[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || we) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && pt(se, fe), we && Ot(se, fe);
        }
        return dt(g, ie, we, ae, ee, Ee.current, se);
      }
    }
    var Xe = L.ReactCurrentOwner, ht = L.ReactDebugCurrentFrame;
    function ot(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        ht.setExtraStackFrame(Z);
      } else
        ht.setExtraStackFrame(null);
    }
    var xt;
    xt = !1;
    function ft(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Pt() {
      {
        if (Xe.current) {
          var g = $(Xe.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Lt(g) {
      return "";
    }
    var St = {};
    function Et(g) {
      {
        var T = Pt();
        if (!T) {
          var Z = typeof g == "string" ? g : g.displayName || g.name;
          Z && (T = `

Check the top-level render call using <` + Z + ">.");
        }
        return T;
      }
    }
    function Mt(g, T) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var Z = Et(T);
        if (St[Z])
          return;
        St[Z] = !0;
        var ee = "";
        g && g._owner && g._owner !== Xe.current && (ee = " It was passed a child from " + $(g._owner.type) + "."), ot(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Z, ee), ot(null);
      }
    }
    function _t(g, T) {
      {
        if (typeof g != "object")
          return;
        if (be(g))
          for (var Z = 0; Z < g.length; Z++) {
            var ee = g[Z];
            ft(ee) && Mt(ee, T);
          }
        else if (ft(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              ft(se.value) && Mt(se.value, T);
        }
      }
    }
    function gt(g) {
      {
        var T = g.type;
        if (T == null || typeof T == "string")
          return;
        var Z;
        if (typeof T == "function")
          Z = T.propTypes;
        else if (typeof T == "object" && (T.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        T.$$typeof === p))
          Z = T.propTypes;
        else
          return;
        if (Z) {
          var ee = $(T);
          rt(Z, g.props, "prop", ee, g);
        } else if (T.PropTypes !== void 0 && !xt) {
          xt = !0;
          var ae = $(T);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof T.getDefaultProps == "function" && !T.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function te(g) {
      {
        for (var T = Object.keys(g.props), Z = 0; Z < T.length; Z++) {
          var ee = T[Z];
          if (ee !== "children" && ee !== "key") {
            ot(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), ot(null);
            break;
          }
        }
        g.ref !== null && (ot(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), ot(null));
      }
    }
    var Br = {};
    function Nr(g, T, Z, ee, ae, ue) {
      {
        var se = R(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var we = Lt();
          we ? ie += we : ie += Pt();
          var de;
          g === null ? de = "null" : be(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = Ct(g, T, Z, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = T.children;
          if (ze !== void 0)
            if (ee)
              if (be(ze)) {
                for (var kt = 0; kt < ze.length; kt++)
                  _t(ze[kt], g);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              _t(ze, g);
        }
        if (Se.call(T, "key")) {
          var mt = $(g), Le = Object.keys(T).filter(function(Si) {
            return Si !== "key";
          }), In = Le.length > 0 ? "{key: someKey, " + Le.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Br[mt + In]) {
            var Pi = Le.length > 0 ? "{" + Le.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, In, mt, Pi, mt), Br[mt + In] = !0;
          }
        }
        return g === r ? te(fe) : gt(fe), fe;
      }
    }
    function xi(g, T, Z) {
      return Nr(g, T, Z, !0);
    }
    function Li(g, T, Z) {
      return Nr(g, T, Z, !1);
    }
    var Ei = Li, ki = xi;
    mv.Fragment = r, mv.jsx = Ei, mv.jsxs = ki;
  }()), mv;
}
process.env.NODE_ENV === "production" ? sM.exports = uye() : sM.exports = cye();
var yr = sM.exports;
He({});
function SR(e, t) {
  return t ? /* @__PURE__ */ yr.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ yr.jsx(yr.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function MR(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Fi(e) {
  var t, n;
  return MR(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(MR(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var wte = Symbol.for("immer-nothing"), DR = Symbol.for("immer-draftable"), Js = Symbol.for("immer-state"), pye = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function as(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = pye[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var yd = Object.getPrototypeOf;
function Tp(e) {
  return !!e && !!e[Js];
}
function jp(e) {
  var t;
  return e ? Ote(e) || Array.isArray(e) || !!e[DR] || !!((t = e.constructor) != null && t[DR]) || vO(e) || yO(e) : !1;
}
var dye = Object.prototype.constructor.toString();
function Ote(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = yd(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === dye;
}
function L0(e, t) {
  mO(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function mO(e) {
  const t = e[Js];
  return t ? t.type_ : Array.isArray(e) ? 1 : vO(e) ? 2 : yO(e) ? 3 : 0;
}
function aM(e, t) {
  return mO(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Cte(e, t, n) {
  const r = mO(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function fye(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function vO(e) {
  return e instanceof Map;
}
function yO(e) {
  return e instanceof Set;
}
function Yc(e) {
  return e.copy_ || e.base_;
}
function lM(e, t) {
  if (vO(e))
    return new Map(e);
  if (yO(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Ote(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Js];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(yd(e), r);
  } else {
    const r = yd(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function DT(e, t = !1) {
  return bO(e) || Tp(e) || !jp(e) || (mO(e) > 1 && (e.set = e.add = e.clear = e.delete = hye), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => DT(r, !0))), e;
}
function hye() {
  as(2);
}
function bO(e) {
  return Object.isFrozen(e);
}
var gye = {};
function Ap(e) {
  const t = gye[e];
  return t || as(0, e), t;
}
var ng;
function xte() {
  return ng;
}
function mye(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function _R(e, t) {
  t && (Ap("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function uM(e) {
  cM(e), e.drafts_.forEach(vye), e.drafts_ = null;
}
function cM(e) {
  e === ng && (ng = e.parent_);
}
function TR(e) {
  return ng = mye(ng, e);
}
function vye(e) {
  const t = e[Js];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function jR(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Js].modified_ && (uM(t), as(4)), jp(e) && (e = E0(t, e), t.parent_ || k0(t, e)), t.patches_ && Ap("Patches").generateReplacementPatches_(
    n[Js].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = E0(t, n, []), uM(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== wte ? e : void 0;
}
function E0(e, t, n) {
  if (bO(t))
    return t;
  const r = t[Js];
  if (!r)
    return L0(
      t,
      (o, i) => AR(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return k0(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), L0(
      i,
      (s, l) => AR(e, r, o, s, l, n, a)
    ), k0(e, o, !1), n && e.patches_ && Ap("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function AR(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && as(5), Tp(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !aM(t.assigned_, r) ? i.concat(r) : void 0, l = E0(e, o, s);
    if (Cte(n, r, l), Tp(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (jp(o) && !bO(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    E0(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && k0(e, o);
  }
}
function k0(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && DT(t, n);
}
function yye(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : xte(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = _T;
  n && (o = [r], i = rg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var _T = {
  get(e, t) {
    if (t === Js)
      return e;
    const n = Yc(e);
    if (!aM(n, t))
      return bye(e, n, t);
    const r = n[t];
    return e.finalized_ || !jp(r) ? r : r === RL(e.base_, t) ? (FL(e), e.copy_[t] = dM(r, e)) : r;
  },
  has(e, t) {
    return t in Yc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Yc(e));
  },
  set(e, t, n) {
    const r = Lte(Yc(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = RL(Yc(e), t), i = o == null ? void 0 : o[Js];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (fye(n, o) && (n !== void 0 || aM(e.base_, t)))
        return !0;
      FL(e), pM(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return RL(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, FL(e), pM(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Yc(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    as(11);
  },
  getPrototypeOf(e) {
    return yd(e.base_);
  },
  setPrototypeOf() {
    as(12);
  }
}, rg = {};
L0(_T, (e, t) => {
  rg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
rg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && as(13), rg.set.call(this, e, t, void 0);
};
rg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && as(14), _T.set.call(this, e[0], t, n, e[0]);
};
function RL(e, t) {
  const n = e[Js];
  return (n ? Yc(n) : e)[t];
}
function bye(e, t, n) {
  var r;
  const o = Lte(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function Lte(e, t) {
  if (!(t in e))
    return;
  let n = yd(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = yd(n);
  }
}
function pM(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && pM(e.parent_));
}
function FL(e) {
  e.copy_ || (e.copy_ = lM(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var wye = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && as(6), r !== void 0 && typeof r != "function" && as(7);
      let o;
      if (jp(t)) {
        const i = TR(this), a = dM(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? uM(i) : cM(i);
        }
        return _R(i, r), jR(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === wte && (o = void 0), this.autoFreeze_ && DT(o, !0), r) {
          const i = [], a = [];
          Ap("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        as(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    jp(e) || as(8), Tp(e) && (e = Oye(e));
    const t = TR(this), n = dM(e, void 0);
    return n[Js].isManual_ = !0, cM(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Js];
    (!n || !n.isManual_) && as(9);
    const { scope_: r } = n;
    return _R(r, t), jR(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Ap("Patches").applyPatches_;
    return Tp(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function dM(e, t) {
  const n = vO(e) ? Ap("MapSet").proxyMap_(e, t) : yO(e) ? Ap("MapSet").proxySet_(e, t) : yye(e, t);
  return (t ? t.scope_ : xte()).drafts_.push(n), n;
}
function Oye(e) {
  return Tp(e) || as(10, e), Ete(e);
}
function Ete(e) {
  if (!jp(e) || bO(e))
    return e;
  const t = e[Js];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = lM(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = lM(e, !0);
  return L0(n, (r, o) => {
    Cte(n, r, Ete(o));
  }), t && (t.finalized_ = !1), n;
}
var Qs = new wye(), TT = Qs.produce;
Qs.produceWithPatches.bind(
  Qs
);
Qs.setAutoFreeze.bind(Qs);
Qs.setUseStrictShallowCopy.bind(Qs);
Qs.applyPatches.bind(Qs);
var IR = Qs.createDraft.bind(Qs), BR = Qs.finishDraft.bind(Qs), Ke = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ke.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ke.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ke.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ke.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ke.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ke.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ke.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ke.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ke.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ke.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ke.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ke.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ke.isAncestor(t, e) && !Ke.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ke.equals(i, r) || Ke.endsBefore(i, r) || Ke.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ke.equals(a, r) || Ke.isAncestor(a, r))
          return null;
        Ke.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ke.equals(s, r) || Ke.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ke.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ke.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ke.endsBefore(u, r) ? r[u.length - 1] += 1 : Ke.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ke.equals(p, d))
          return r;
        if (Ke.isAncestor(p, r) || Ke.equals(p, r)) {
          var y = d.slice();
          return Ke.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else Ke.isSibling(p, d) && (Ke.isAncestor(d, r) || Ke.equals(d, r)) ? Ke.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ke.endsBefore(d, r) || Ke.equals(d, r) || Ke.isAncestor(d, r) ? (Ke.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ke.endsBefore(p, r) && (Ke.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function og(e) {
  "@babel/helpers - typeof";
  return og = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, og(e);
}
function Cye(e, t) {
  if (og(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (og(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function xye(e) {
  var t = Cye(e, "string");
  return og(t) === "symbol" ? t : String(t);
}
function Md(e, t, n) {
  return t = xye(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function NR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NR(Object(n), !0).forEach(function(r) {
      Md(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Lye = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Tt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Yt.points(t))
          t[l] = Zr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Tt.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of Yt.points(t))
          t[b] = Zr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = Tt.get(e, L), D = Ke.previous(L), x = Tt.get(e, D), m = Tt.parent(e, L), C = L[L.length - 1];
      if (qo.isText(w) && qo.isText(x))
        x.text += w.text;
      else if (!qo.isText(w) && !qo.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(Ts.stringify(w), " ").concat(Ts.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of Yt.points(t))
          t[U] = Zr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: R
      } = n;
      if (Ke.isAncestor(k, R))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(R, "] because the destination is inside itself."));
      var N = Tt.get(e, k), V = Tt.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var H = Ke.transform(k, n), X = Tt.get(e, Ke.parent(H)), G = H[H.length - 1];
      if (X.children.splice(G, 0, N), t)
        for (var [Y, Q] of Yt.points(t))
          t[Q] = Zr.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = Tt.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of Yt.points(t)) {
          var W = Zr.transform(z, n);
          if (t != null && W != null)
            t[M] = W;
          else {
            var O = void 0, I = void 0;
            for (var [F, j] of Tt.texts(e))
              if (Ke.compare(j, J) === -1)
                O = [F, j];
              else {
                I = [F, j];
                break;
              }
            var q = !1;
            O && I && (Ke.equals(I[1], J) ? q = !Ke.hasPrevious(I[1]) : q = Ke.common(O[1], J).length < Ke.common(I[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : I ? (z.path = I[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: K,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = Tt.leaf(e, A), he = le.text.slice(0, K), re = le.text.slice(K + B.length);
      if (le.text = he + re, t)
        for (var [Se, We] of Yt.points(t))
          t[We] = Zr.transform(Se, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: Me,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = Tt.get(e, Ze);
      for (var be in rt) {
        if (be === "children" || be === "text")
          throw new Error('Cannot set the "'.concat(be, '" property of nodes!'));
        var qe = rt[be];
        qe == null ? delete Ve[be] : Ve[be] = qe;
      }
      for (var ct in Me)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!Yt.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Ts.stringify(ye), " when there is no current selection."));
          t = sf({}, ye);
        }
        for (var xe in ye) {
          var Ee = ye[xe];
          if (Ee == null) {
            if (xe === "anchor" || xe === "focus")
              throw new Error('Cannot remove the "'.concat(xe, '" selection property'));
            delete t[xe];
          } else
            t[xe] = Ee;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ue,
        position: De,
        properties: st
      } = n;
      if (Ue.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ue, "] because the root node cannot be split."));
      var ve = Tt.get(e, Ue), wt = Tt.parent(e, Ue), at = Ue[Ue.length - 1], lt;
      if (qo.isText(ve)) {
        var pt = ve.text.slice(0, De), Ot = ve.text.slice(De);
        ve.text = pt, lt = sf(sf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = ve.children.slice(0, De), Ct = ve.children.slice(De);
        ve.children = dt, lt = sf(sf({}, st), {}, {
          children: Ct
        });
      }
      if (wt.children.splice(at + 1, 0, lt), t)
        for (var [Xe, ht] of Yt.points(t))
          t[ht] = Zr.transform(Xe, n);
      break;
    }
  }
  return t;
}, Eye = {
  transform(e, t) {
    e.children = IR(e.children);
    var n = e.selection && IR(e.selection);
    try {
      n = Lye(e, n, t);
    } finally {
      e.children = BR(e.children), n ? e.selection = Tp(n) ? BR(n) : n : e.selection = null;
    }
  }
}, kye = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Pye = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, kte = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Fi(r) && Fi(o)) {
      if (!kte(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Sye(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function ig(e, t) {
  if (e == null) return {};
  var n = Sye(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Mye = ["anchor", "focus"];
function RR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dye(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RR(Object(n), !0).forEach(function(r) {
      Md(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Yt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Yt.edges(e);
    return t;
  },
  equals(e, t) {
    return Zr.equals(e.anchor, t.anchor) && Zr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Yt.isRange(t)) {
      if (Yt.includes(e, t.anchor) || Yt.includes(e, t.focus))
        return !0;
      var [n, r] = Yt.edges(e), [o, i] = Yt.edges(t);
      return Zr.isBefore(n, o) && Zr.isAfter(r, i);
    }
    var [a, s] = Yt.edges(e), l = !1, u = !1;
    return Zr.isPoint(t) ? (l = Zr.compare(t, a) >= 0, u = Zr.compare(t, s) <= 0) : (l = Ke.compare(t, a.path) >= 0, u = Ke.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = ig(e, Mye), [r, o] = Yt.edges(e), [i, a] = Yt.edges(t), s = Zr.isBefore(r, i) ? i : r, l = Zr.isBefore(o, a) ? o : a;
    return Zr.isBefore(l, s) ? null : Dye({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Zr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Zr.equals(t, n);
  },
  isExpanded(e) {
    return !Yt.isCollapsed(e);
  },
  isForward(e) {
    return !Yt.isBackward(e);
  },
  isRange(e) {
    return Fi(e) && Zr.isPoint(e.anchor) && Zr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Yt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return TT(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Yt.isCollapsed(r);
        Yt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Yt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Zr.transform(r.anchor, t, {
        affinity: i
      }), u = Zr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, FR = (e) => Fi(e) && Tt.isNodeList(e.children) && !br.isEditor(e), Dl = {
  isAncestor(e) {
    return Fi(e) && Tt.isNodeList(e.children);
  },
  isElement: FR,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Dl.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return FR(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, _ye = ["children"], Tye = ["text"], zR = /* @__PURE__ */ new WeakMap(), Tt = {
  ancestor(e, t) {
    var n = Tt.get(e, t);
    if (qo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Ts.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ke.ancestors(t, n)) {
        var o = Tt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (qo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Ts.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Ts.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Tt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Tt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ke.common(t, n), o = Tt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Tt.get(e, t);
    if (br.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Ts.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Tt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Tt.nodes(e, t))
        Dl.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Dl.isAncestor(e)) {
      var t = ig(e, _ye);
      return t;
    } else {
      var t = ig(e, Tye);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Tt.get(e, n); r && !(qo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (qo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Ts.stringify(e)));
    var n = TT({
      children: e.children
    }, (r) => {
      var [o, i] = Yt.edges(t), a = Tt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Yt.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Yt.includes(t, s)) {
          var l = Tt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ke.equals(s, i.path)) {
          var c = Tt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ke.equals(s, o.path)) {
          var p = Tt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      br.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (qo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Ts.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (qo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return qo.isText(e) || Dl.isElement(e) || br.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = zR.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Tt.isNode(r));
    return zR.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Tt.get(e, n); r && !(qo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Tt.get(e, t);
    if (!qo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Ts.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ke.levels(t, n)) {
        var o = Tt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Dl.isElement(e) && Dl.isElementProps(t) && Dl.matches(e, t) || qo.isText(e) && qo.isTextProps(t) && qo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ke.isBefore(s, i) : Ke.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !qo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ke.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Tt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ke.next(s);
          if (Tt.has(e, c)) {
            s = c, l = Tt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ke.previous(s);
          s = p, l = Tt.get(e, s);
          continue;
        }
        s = Ke.parent(s), l = Tt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ke.parent(t), r = Tt.get(e, n);
    if (qo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return qo.isText(e) ? e.text : e.children.map(Tt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Tt.nodes(e, t))
        qo.isText(n) && (yield [n, r]);
    }();
  }
};
function UR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function to(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UR(Object(n), !0).forEach(function(r) {
      Md(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yf = {
  isNodeOperation(e) {
    return Yf.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Fi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ke.isPath(e.path) && Tt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ke.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ke.isPath(e.path) && Fi(e.properties);
      case "move_node":
        return Ke.isPath(e.path) && Ke.isPath(e.newPath);
      case "remove_node":
        return Ke.isPath(e.path) && Tt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ke.isPath(e.path);
      case "set_node":
        return Ke.isPath(e.path) && Fi(e.properties) && Fi(e.newProperties);
      case "set_selection":
        return e.properties === null && Yt.isRange(e.newProperties) || e.newProperties === null && Yt.isRange(e.properties) || Fi(e.properties) && Fi(e.newProperties);
      case "split_node":
        return Ke.isPath(e.path) && typeof e.position == "number" && Fi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Yf.isOperation(t));
  },
  isSelectionOperation(e) {
    return Yf.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Yf.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return to(to({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return to(to({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return to(to({}, e), {}, {
          type: "split_node",
          path: Ke.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ke.equals(t, n))
          return e;
        if (Ke.isSibling(n, t))
          return to(to({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ke.transform(n, e), o = Ke.transform(Ke.next(n), e);
        return to(to({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return to(to({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return to(to({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return to(to({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? to(to({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? to(to({}, e), {}, {
          properties: null,
          newProperties: s
        }) : to(to({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return to(to({}, e), {}, {
          type: "merge_node",
          path: Ke.next(e.path)
        });
    }
  }
}, WR = /* @__PURE__ */ new WeakMap(), jye = (e) => {
  var t = WR.get(e);
  if (t !== void 0)
    return t;
  if (!Fi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Fi(e.marks)) && (e.selection === null || Yt.isRange(e.selection)) && Tt.isNodeList(e.children) && Yf.isOperationList(e.operations);
  return WR.set(e, n), n;
}, br = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return jye(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function HR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function VR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HR(Object(n), !0).forEach(function(r) {
      Md(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Zr = {
  compare(e, t) {
    var n = Ke.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Zr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Zr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ke.equals(e.path, t.path);
  },
  isPoint(e) {
    return Fi(e) && typeof e.offset == "number" && Ke.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return TT(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ke.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ke.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ke.equals(t.path, i) && (r.offset += t.position), r.path = Ke.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ke.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ke.equals(t.path, i) || Ke.isAncestor(t.path, i))
            return null;
          r.path = Ke.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ke.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ke.transform(i, t, VR(VR({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ke.transform(i, t, n);
          break;
        }
      }
    });
  }
}, $R = void 0, Ts = {
  setScrubber(e) {
    $R = e;
  },
  stringify(e) {
    return JSON.stringify(e, $R);
  }
}, Aye = ["text"], Iye = ["anchor", "focus"];
function ZR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZR(Object(n), !0).forEach(function(r) {
      Md(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = ig(i, Aye);
      return a;
    }
    return kte(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Fi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => qo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [fl({}, e)];
    for (var r of t) {
      var o = ig(r, Iye), [i, a] = Yt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = fl(fl({}, f), {}, {
            text: f.text.slice(L)
          }), f = fl(fl({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = fl(fl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = fl(fl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, Bye = (e) => e.selection ? e.selection : e.children.length > 0 ? br.end(e, []) : [0], Rr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Rr || (Rr = {}));
Rr.L, Rr.L | Rr.V | Rr.LV | Rr.LVT, Rr.LV | Rr.V, Rr.V | Rr.T, Rr.LVT | Rr.T, Rr.T, Rr.Any, Rr.Extend | Rr.ZWJ, Rr.Any, Rr.SpacingMark, Rr.Prepend, Rr.Any, Rr.ZWJ, Rr.ExtPict, Rr.RI, Rr.RI;
var Nye = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    br.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Bye(e)
      } = n;
      if (Ke.isPath(o) && (o = br.range(e, o)), Yt.isRange(o))
        if (Yt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Yt.end(o);
          if (!r && br.void(e, {
            at: i
          }))
            return;
          var a = Yt.start(o), s = br.pointRef(e, a), l = br.pointRef(e, i);
          P0.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, P0.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && br.void(e, {
        at: o
      }) || br.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function qR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qR(Object(n), !0).forEach(function(r) {
      Md(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var P0 = vv(vv(vv(vv({}, Eye), kye), Pye), Nye), Pte = {}, jT = {}, AT = {};
Object.defineProperty(AT, "__esModule", { value: !0 });
AT.default = Uye;
var XR = "html", KR = "head", yv = "body", Rye = /<([a-zA-Z]+[0-9]?)/, GR = /<head[^]*>/i, YR = /<body[^]*>/i, S0 = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, fM = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, JR = typeof window == "object" && window.DOMParser;
if (typeof JR == "function") {
  var Fye = new JR(), zye = "text/html";
  fM = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Fye.parseFromString(e, zye);
  }, S0 = fM;
}
if (typeof document == "object" && document.implementation) {
  var bv = document.implementation.createHTMLDocument();
  S0 = function(e, t) {
    if (t) {
      var n = bv.documentElement.querySelector(t);
      return n && (n.innerHTML = e), bv;
    }
    return bv.documentElement.innerHTML = e, bv;
  };
}
var wv = typeof document == "object" && document.createElement("template"), hM;
wv && wv.content && (hM = function(e) {
  return wv.innerHTML = e, wv.content.childNodes;
});
function Uye(e) {
  var t, n, r = e.match(Rye), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case XR: {
      var i = fM(e);
      if (!GR.test(e)) {
        var a = i.querySelector(KR);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!YR.test(e)) {
        var a = i.querySelector(yv);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(XR);
    }
    case KR:
    case yv: {
      var s = S0(e).querySelectorAll(o);
      return YR.test(e) && GR.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (hM)
        return hM(e);
      var a = S0(e, yv).querySelector(yv);
      return a.childNodes;
    }
  }
}
var wO = {}, IT = {}, BT = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(BT);
var ln = {}, ic = Sr && Sr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), mh = Sr && Sr.__assign || function() {
  return mh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, mh.apply(this, arguments);
};
Object.defineProperty(ln, "__esModule", { value: !0 });
ln.cloneNode = ln.hasChildren = ln.isDocument = ln.isDirective = ln.isComment = ln.isText = ln.isCDATA = ln.isTag = ln.Element = ln.Document = ln.CDATA = ln.NodeWithChildren = ln.ProcessingInstruction = ln.Comment = ln.Text = ln.DataNode = ln.Node = void 0;
var xs = BT, NT = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), RT(this, t);
    }, e;
  }()
);
ln.Node = NT;
var OO = (
  /** @class */
  function(e) {
    ic(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(NT)
);
ln.DataNode = OO;
var Ste = (
  /** @class */
  function(e) {
    ic(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = xs.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(OO)
);
ln.Text = Ste;
var Mte = (
  /** @class */
  function(e) {
    ic(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = xs.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(OO)
);
ln.Comment = Mte;
var Dte = (
  /** @class */
  function(e) {
    ic(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = xs.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(OO)
);
ln.ProcessingInstruction = Dte;
var CO = (
  /** @class */
  function(e) {
    ic(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(NT)
);
ln.NodeWithChildren = CO;
var _te = (
  /** @class */
  function(e) {
    ic(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = xs.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(CO)
);
ln.CDATA = _te;
var Tte = (
  /** @class */
  function(e) {
    ic(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = xs.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(CO)
);
ln.Document = Tte;
var jte = (
  /** @class */
  function(e) {
    ic(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? xs.ElementType.Script : n === "style" ? xs.ElementType.Style : xs.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(CO)
);
ln.Element = jte;
function Ate(e) {
  return (0, xs.isTag)(e);
}
ln.isTag = Ate;
function Ite(e) {
  return e.type === xs.ElementType.CDATA;
}
ln.isCDATA = Ite;
function Bte(e) {
  return e.type === xs.ElementType.Text;
}
ln.isText = Bte;
function Nte(e) {
  return e.type === xs.ElementType.Comment;
}
ln.isComment = Nte;
function Rte(e) {
  return e.type === xs.ElementType.Directive;
}
ln.isDirective = Rte;
function Fte(e) {
  return e.type === xs.ElementType.Root;
}
ln.isDocument = Fte;
function Wye(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
ln.hasChildren = Wye;
function RT(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (Bte(e))
    n = new Ste(e.data);
  else if (Nte(e))
    n = new Mte(e.data);
  else if (Ate(e)) {
    var r = t ? zL(e.children) : [], o = new jte(e.name, mh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = mh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = mh({}, e["x-attribsPrefix"])), n = o;
  } else if (Ite(e)) {
    var r = t ? zL(e.children) : [], i = new _te(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (Fte(e)) {
    var r = t ? zL(e.children) : [], a = new Tte(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (Rte(e)) {
    var s = new Dte(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
ln.cloneNode = RT;
function zL(e) {
  for (var t = e.map(function(r) {
    return RT(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Sr && Sr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Sr && Sr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = BT, o = ln;
  n(ln, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(IT);
var zte = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(zte);
Object.defineProperty(wO, "__esModule", { value: !0 });
wO.formatAttributes = Ute;
wO.formatDOM = Wte;
var Ov = IT, Hye = zte;
function Vye(e) {
  return Hye.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function Ute(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function $ye(e) {
  e = e.toLowerCase();
  var t = Vye(e);
  return t || e;
}
function Wte(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = $ye(s.nodeName);
        o = new Ov.Element(l, Ute(s.attributes)), o.children = Wte(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Ov.Text(s.nodeValue);
        break;
      case 8:
        o = new Ov.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Ov.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var Zye = Sr && Sr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(jT, "__esModule", { value: !0 });
jT.default = Gye;
var qye = Zye(AT), Xye = wO, Kye = /<(![a-zA-Z\s]+)>/;
function Gye(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Kye), n = t ? t[1] : void 0;
  return (0, Xye.formatDOM)((0, qye.default)(e), null, n);
}
var xO = {}, Sa = {}, LO = {}, Yye = 0;
LO.SAME = Yye;
var Jye = 1;
LO.CAMELCASE = Jye;
LO.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const Hte = 0, sc = 1, EO = 2, kO = 3, FT = 4, Vte = 5, $te = 6;
function Qye(e) {
  return Di.hasOwnProperty(e) ? Di[e] : null;
}
function Yi(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === EO || t === kO || t === FT, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Di = {}, ebe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
ebe.forEach((e) => {
  Di[e] = new Yi(
    e,
    Hte,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Di[e] = new Yi(
    e,
    sc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Di[e] = new Yi(
    e,
    EO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Di[e] = new Yi(
    e,
    EO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Di[e] = new Yi(
    e,
    kO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Di[e] = new Yi(
    e,
    kO,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Di[e] = new Yi(
    e,
    FT,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Di[e] = new Yi(
    e,
    $te,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Di[e] = new Yi(
    e,
    Vte,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const zT = /[\-\:]([a-z])/g, UT = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(zT, UT);
  Di[t] = new Yi(
    t,
    sc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(zT, UT);
  Di[t] = new Yi(
    t,
    sc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(zT, UT);
  Di[t] = new Yi(
    t,
    sc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Di[e] = new Yi(
    e,
    sc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const tbe = "xlinkHref";
Di[tbe] = new Yi(
  "xlinkHref",
  sc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Di[e] = new Yi(
    e,
    sc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: nbe,
  SAME: rbe,
  possibleStandardNames: QR
} = LO, obe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ibe = obe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", sbe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + ibe + "]*$")
), abe = Object.keys(
  QR
).reduce((e, t) => {
  const n = QR[t];
  return n === rbe ? e[t] = t : n === nbe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Sa.BOOLEAN = kO;
Sa.BOOLEANISH_STRING = EO;
Sa.NUMERIC = Vte;
Sa.OVERLOADED_BOOLEAN = FT;
Sa.POSITIVE_NUMERIC = $te;
Sa.RESERVED = Hte;
Sa.STRING = sc;
Sa.getPropertyInfo = Qye;
Sa.isCustomAttribute = sbe;
Sa.possibleStandardNames = abe;
var WT = {}, HT = {}, eF = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, lbe = /\n/g, ube = /^\s*/, cbe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, pbe = /^:\s*/, dbe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, fbe = /^[;\s]*/, hbe = /^\s+|\s+$/g, gbe = `
`, tF = "/", nF = "*", ap = "", mbe = "comment", vbe = "declaration", ybe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(lbe);
    v && (n += v.length);
    var b = f.lastIndexOf(gbe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(ube);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(tF != e.charAt(0) || nF != e.charAt(1))) {
      for (var v = 2; ap != e.charAt(v) && (nF != e.charAt(v) || tF != e.charAt(v + 1)); )
        ++v;
      if (v += 2, ap === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: mbe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(cbe);
    if (v) {
      if (p(), !l(pbe)) return s("property missing ':'");
      var b = l(dbe), L = f({
        type: vbe,
        property: rF(v[0].replace(eF, ap)),
        value: b ? rF(b[0].replace(eF, ap)) : ap
      });
      return l(fbe), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function rF(e) {
  return e ? e.replace(hbe, ap) : ap;
}
var bbe = Sr && Sr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(HT, "__esModule", { value: !0 });
HT.default = Obe;
var wbe = bbe(ybe);
function Obe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, wbe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var PO = {};
Object.defineProperty(PO, "__esModule", { value: !0 });
PO.camelCase = void 0;
var Cbe = /^--[a-zA-Z0-9_-]+$/, xbe = /-([a-z])/g, Lbe = /^[^-]+$/, Ebe = /^-(webkit|moz|ms|o|khtml)-/, kbe = /^-(ms)-/, Pbe = function(e) {
  return !e || Lbe.test(e) || Cbe.test(e);
}, Sbe = function(e, t) {
  return t.toUpperCase();
}, oF = function(e, t) {
  return "".concat(t, "-");
}, Mbe = function(e, t) {
  return t === void 0 && (t = {}), Pbe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(kbe, oF) : e = e.replace(Ebe, oF), e.replace(xbe, Sbe));
};
PO.camelCase = Mbe;
var Dbe = Sr && Sr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, _be = Dbe(HT), Tbe = PO;
function gM(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, _be.default)(e, function(r, o) {
    r && o && (n[(0, Tbe.camelCase)(r, t)] = o);
  }), n;
}
gM.default = gM;
var jbe = gM;
(function(e) {
  var t = Sr && Sr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Oe, r = t(jbe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(WT);
Object.defineProperty(xO, "__esModule", { value: !0 });
xO.default = Nbe;
var Jf = Sa, iF = WT, Abe = ["checked", "value"], Ibe = ["input", "select", "textarea"], Bbe = {
  reset: !0,
  submit: !0
};
function Nbe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Bbe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Jf.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = sF(a);
    if (s) {
      var l = (0, Jf.getPropertyInfo)(s);
      switch (Abe.includes(s) && Ibe.includes(t) && !r && (s = sF("default" + a)), n[s] = i, l && l.type) {
        case Jf.BOOLEAN:
          n[s] = !0;
          break;
        case Jf.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    iF.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, iF.setStyleProp)(e.style, n), n;
}
function sF(e) {
  return Jf.possibleStandardNames[e];
}
var VT = {}, Rbe = Sr && Sr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(VT, "__esModule", { value: !0 });
VT.default = Zte;
var UL = Oe, Fbe = Rbe(xO), vh = WT, zbe = {
  cloneElement: UL.cloneElement,
  createElement: UL.createElement,
  isValidElement: UL.isValidElement
};
function Zte(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || vh.returnFirstArg, i = t.library || zbe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, vh.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    Ube(f) ? ((0, vh.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, Fbe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = Zte(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Ube(e) {
  return vh.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, vh.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Sr && Sr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(jT);
  e.htmlToDOM = n.default;
  var r = t(xO);
  e.attributesToProps = r.default;
  var o = t(VT);
  e.domToReact = o.default;
  var i = IT;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(Pte);
const aF = /* @__PURE__ */ lye(Pte);
aF.default;
function Wbe(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ yr.jsx("div", { className: o.trim(), ...r });
}
var Mr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Hbe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var mM = { exports: {} }, af = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lF;
function Vbe() {
  if (lF) return af;
  lF = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return af.Fragment = n, af.jsx = a, af.jsxs = a, af;
}
var Cv = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uF;
function $be() {
  return uF || (uF = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var T = f && g[f] || g[v];
      return typeof T == "function" ? T : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var T = arguments.length, Z = new Array(T > 1 ? T - 1 : 0), ee = 1; ee < T; ee++)
          Z[ee - 1] = arguments[ee];
        D("error", g, Z);
      }
    }
    function D(g, T, Z) {
      {
        var ee = L.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (T += "%s", Z = Z.concat([ae]));
        var ue = Z.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + T), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function R(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function N(g, T, Z) {
      var ee = g.displayName;
      if (ee)
        return ee;
      var ae = T.displayName || T.name || "";
      return ae !== "" ? Z + "(" + ae + ")" : Z;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var T = g;
            return V(T) + ".Consumer";
          case a:
            var Z = g;
            return V(Z._context) + ".Provider";
          case l:
            return N(g, g.render, "ForwardRef");
          case p:
            var ee = g.displayName || null;
            return ee !== null ? ee : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, X = 0, G, Y, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function W() {
      {
        if (X === 0) {
          G = console.log, Y = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        X++;
      }
    }
    function O() {
      {
        if (X--, X === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, g, {
              value: G
            }),
            info: H({}, g, {
              value: Y
            }),
            warn: H({}, g, {
              value: Q
            }),
            error: H({}, g, {
              value: J
            }),
            group: H({}, g, {
              value: P
            }),
            groupCollapsed: H({}, g, {
              value: _
            }),
            groupEnd: H({}, g, {
              value: z
            })
          });
        }
        X < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = L.ReactCurrentDispatcher, F;
    function j(g, T, Z) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            F = ee && ee[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, A;
    {
      var K = typeof WeakMap == "function" ? WeakMap : Map;
      A = new K();
    }
    function B(g, T) {
      if (!g || q)
        return "";
      {
        var Z = A.get(g);
        if (Z !== void 0)
          return Z;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (T) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Le) {
              ee = Le;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (Le) {
              ee = Le;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Le) {
            ee = Le;
          }
          g();
        }
      } catch (Le) {
        if (Le && ee && typeof Le.stack == "string") {
          for (var ie = Le.stack.split(`
`), we = ee.stack.split(`
`), de = ie.length - 1, fe = we.length - 1; de >= 1 && fe >= 0 && ie[de] !== we[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== we[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== we[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", g.displayName)), typeof g == "function" && A.set(g, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var kt = g ? g.displayName || g.name : "", mt = kt ? j(kt) : "";
      return typeof g == "function" && A.set(g, mt), mt;
    }
    function le(g, T, Z) {
      return B(g, !1);
    }
    function he(g) {
      var T = g.prototype;
      return !!(T && T.isReactComponent);
    }
    function re(g, T, Z) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return B(g, he(g));
      if (typeof g == "string")
        return j(g);
      switch (g) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return re(g.type, T, Z);
          case d: {
            var ee = g, ae = ee._payload, ue = ee._init;
            try {
              return re(ue(ae), T, Z);
            } catch {
            }
          }
        }
      return "";
    }
    var Se = Object.prototype.hasOwnProperty, We = {}, Ze = L.ReactDebugCurrentFrame;
    function Me(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        Ze.setExtraStackFrame(Z);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(g, T, Z, ee, ae) {
      {
        var ue = Function.call.bind(Se);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var we = Error((ee || "React class") + ": " + Z + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw we.name = "Invariant Violation", we;
              }
              ie = g[se](T, se, ee, Z, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Me(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", Z, se, typeof ie), Me(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Me(ae), w("Failed %s type: %s", Z, ie.message), Me(null));
          }
      }
    }
    var Ve = Array.isArray;
    function be(g) {
      return Ve(g);
    }
    function qe(g) {
      {
        var T = typeof Symbol == "function" && Symbol.toStringTag, Z = T && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return Z;
      }
    }
    function ct(g) {
      try {
        return ye(g), !1;
      } catch {
        return !0;
      }
    }
    function ye(g) {
      return "" + g;
    }
    function xe(g) {
      if (ct(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qe(g)), ye(g);
    }
    var Ee = L.ReactCurrentOwner, Ue = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, De, st, ve;
    ve = {};
    function wt(g) {
      if (Se.call(g, "ref")) {
        var T = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function at(g) {
      if (Se.call(g, "key")) {
        var T = Object.getOwnPropertyDescriptor(g, "key").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function lt(g, T) {
      if (typeof g.ref == "string" && Ee.current && T && Ee.current.stateNode !== T) {
        var Z = $(Ee.current.type);
        ve[Z] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ee.current.type), g.ref), ve[Z] = !0);
      }
    }
    function pt(g, T) {
      {
        var Z = function() {
          De || (De = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: Z,
          configurable: !0
        });
      }
    }
    function Ot(g, T) {
      {
        var Z = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: Z,
          configurable: !0
        });
      }
    }
    var dt = function(g, T, Z, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: T,
        ref: Z,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function Ct(g, T, Z, ee, ae) {
      {
        var ue, se = {}, ie = null, we = null;
        Z !== void 0 && (xe(Z), ie = "" + Z), at(T) && (xe(T.key), ie = "" + T.key), wt(T) && (we = T.ref, lt(T, ae));
        for (ue in T)
          Se.call(T, ue) && !Ue.hasOwnProperty(ue) && (se[ue] = T[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || we) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && pt(se, fe), we && Ot(se, fe);
        }
        return dt(g, ie, we, ae, ee, Ee.current, se);
      }
    }
    var Xe = L.ReactCurrentOwner, ht = L.ReactDebugCurrentFrame;
    function ot(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        ht.setExtraStackFrame(Z);
      } else
        ht.setExtraStackFrame(null);
    }
    var xt;
    xt = !1;
    function ft(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Pt() {
      {
        if (Xe.current) {
          var g = $(Xe.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Lt(g) {
      return "";
    }
    var St = {};
    function Et(g) {
      {
        var T = Pt();
        if (!T) {
          var Z = typeof g == "string" ? g : g.displayName || g.name;
          Z && (T = `

Check the top-level render call using <` + Z + ">.");
        }
        return T;
      }
    }
    function Mt(g, T) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var Z = Et(T);
        if (St[Z])
          return;
        St[Z] = !0;
        var ee = "";
        g && g._owner && g._owner !== Xe.current && (ee = " It was passed a child from " + $(g._owner.type) + "."), ot(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Z, ee), ot(null);
      }
    }
    function _t(g, T) {
      {
        if (typeof g != "object")
          return;
        if (be(g))
          for (var Z = 0; Z < g.length; Z++) {
            var ee = g[Z];
            ft(ee) && Mt(ee, T);
          }
        else if (ft(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              ft(se.value) && Mt(se.value, T);
        }
      }
    }
    function gt(g) {
      {
        var T = g.type;
        if (T == null || typeof T == "string")
          return;
        var Z;
        if (typeof T == "function")
          Z = T.propTypes;
        else if (typeof T == "object" && (T.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        T.$$typeof === p))
          Z = T.propTypes;
        else
          return;
        if (Z) {
          var ee = $(T);
          rt(Z, g.props, "prop", ee, g);
        } else if (T.PropTypes !== void 0 && !xt) {
          xt = !0;
          var ae = $(T);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof T.getDefaultProps == "function" && !T.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function te(g) {
      {
        for (var T = Object.keys(g.props), Z = 0; Z < T.length; Z++) {
          var ee = T[Z];
          if (ee !== "children" && ee !== "key") {
            ot(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), ot(null);
            break;
          }
        }
        g.ref !== null && (ot(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), ot(null));
      }
    }
    var Br = {};
    function Nr(g, T, Z, ee, ae, ue) {
      {
        var se = R(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var we = Lt();
          we ? ie += we : ie += Pt();
          var de;
          g === null ? de = "null" : be(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = Ct(g, T, Z, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = T.children;
          if (ze !== void 0)
            if (ee)
              if (be(ze)) {
                for (var kt = 0; kt < ze.length; kt++)
                  _t(ze[kt], g);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              _t(ze, g);
        }
        if (Se.call(T, "key")) {
          var mt = $(g), Le = Object.keys(T).filter(function(Si) {
            return Si !== "key";
          }), In = Le.length > 0 ? "{key: someKey, " + Le.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Br[mt + In]) {
            var Pi = Le.length > 0 ? "{" + Le.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, In, mt, Pi, mt), Br[mt + In] = !0;
          }
        }
        return g === r ? te(fe) : gt(fe), fe;
      }
    }
    function xi(g, T, Z) {
      return Nr(g, T, Z, !0);
    }
    function Li(g, T, Z) {
      return Nr(g, T, Z, !1);
    }
    var Ei = Li, ki = xi;
    Cv.Fragment = r, Cv.jsx = Ei, Cv.jsxs = ki;
  }()), Cv;
}
process.env.NODE_ENV === "production" ? mM.exports = Vbe() : mM.exports = $be();
var gs = mM.exports;
He({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function cF(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function zi(e) {
  var t, n;
  return cF(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(cF(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var qte = Symbol.for("immer-nothing"), pF = Symbol.for("immer-draftable"), ea = Symbol.for("immer-state"), Zbe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ls(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Zbe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var bd = Object.getPrototypeOf;
function Ip(e) {
  return !!e && !!e[ea];
}
function Bp(e) {
  var t;
  return e ? Xte(e) || Array.isArray(e) || !!e[pF] || !!((t = e.constructor) != null && t[pF]) || MO(e) || DO(e) : !1;
}
var qbe = Object.prototype.constructor.toString();
function Xte(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = bd(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === qbe;
}
function M0(e, t) {
  SO(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function SO(e) {
  const t = e[ea];
  return t ? t.type_ : Array.isArray(e) ? 1 : MO(e) ? 2 : DO(e) ? 3 : 0;
}
function vM(e, t) {
  return SO(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Kte(e, t, n) {
  const r = SO(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Xbe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function MO(e) {
  return e instanceof Map;
}
function DO(e) {
  return e instanceof Set;
}
function Jc(e) {
  return e.copy_ || e.base_;
}
function yM(e, t) {
  if (MO(e))
    return new Map(e);
  if (DO(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Xte(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ea];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(bd(e), r);
  } else {
    const r = bd(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function $T(e, t = !1) {
  return _O(e) || Ip(e) || !Bp(e) || (SO(e) > 1 && (e.set = e.add = e.clear = e.delete = Kbe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => $T(r, !0))), e;
}
function Kbe() {
  ls(2);
}
function _O(e) {
  return Object.isFrozen(e);
}
var Gbe = {};
function Np(e) {
  const t = Gbe[e];
  return t || ls(0, e), t;
}
var sg;
function Gte() {
  return sg;
}
function Ybe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function dF(e, t) {
  t && (Np("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function bM(e) {
  wM(e), e.drafts_.forEach(Jbe), e.drafts_ = null;
}
function wM(e) {
  e === sg && (sg = e.parent_);
}
function fF(e) {
  return sg = Ybe(sg, e);
}
function Jbe(e) {
  const t = e[ea];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function hF(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ea].modified_ && (bM(t), ls(4)), Bp(e) && (e = D0(t, e), t.parent_ || _0(t, e)), t.patches_ && Np("Patches").generateReplacementPatches_(
    n[ea].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = D0(t, n, []), bM(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== qte ? e : void 0;
}
function D0(e, t, n) {
  if (_O(t))
    return t;
  const r = t[ea];
  if (!r)
    return M0(
      t,
      (o, i) => gF(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return _0(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), M0(
      i,
      (s, l) => gF(e, r, o, s, l, n, a)
    ), _0(e, o, !1), n && e.patches_ && Np("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function gF(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ls(5), Ip(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !vM(t.assigned_, r) ? i.concat(r) : void 0, l = D0(e, o, s);
    if (Kte(n, r, l), Ip(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Bp(o) && !_O(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    D0(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && _0(e, o);
  }
}
function _0(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && $T(t, n);
}
function Qbe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : Gte(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = ZT;
  n && (o = [r], i = ag);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var ZT = {
  get(e, t) {
    if (t === ea)
      return e;
    const n = Jc(e);
    if (!vM(n, t))
      return e0e(e, n, t);
    const r = n[t];
    return e.finalized_ || !Bp(r) ? r : r === WL(e.base_, t) ? (HL(e), e.copy_[t] = CM(r, e)) : r;
  },
  has(e, t) {
    return t in Jc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Jc(e));
  },
  set(e, t, n) {
    const r = Yte(Jc(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = WL(Jc(e), t), i = o == null ? void 0 : o[ea];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Xbe(n, o) && (n !== void 0 || vM(e.base_, t)))
        return !0;
      HL(e), OM(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return WL(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, HL(e), OM(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Jc(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ls(11);
  },
  getPrototypeOf(e) {
    return bd(e.base_);
  },
  setPrototypeOf() {
    ls(12);
  }
}, ag = {};
M0(ZT, (e, t) => {
  ag[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
ag.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ls(13), ag.set.call(this, e, t, void 0);
};
ag.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ls(14), ZT.set.call(this, e[0], t, n, e[0]);
};
function WL(e, t) {
  const n = e[ea];
  return (n ? Jc(n) : e)[t];
}
function e0e(e, t, n) {
  var r;
  const o = Yte(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function Yte(e, t) {
  if (!(t in e))
    return;
  let n = bd(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = bd(n);
  }
}
function OM(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && OM(e.parent_));
}
function HL(e) {
  e.copy_ || (e.copy_ = yM(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var t0e = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ls(6), r !== void 0 && typeof r != "function" && ls(7);
      let o;
      if (Bp(t)) {
        const i = fF(this), a = CM(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? bM(i) : wM(i);
        }
        return dF(i, r), hF(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === qte && (o = void 0), this.autoFreeze_ && $T(o, !0), r) {
          const i = [], a = [];
          Np("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ls(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Bp(e) || ls(8), Ip(e) && (e = n0e(e));
    const t = fF(this), n = CM(e, void 0);
    return n[ea].isManual_ = !0, wM(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ea];
    (!n || !n.isManual_) && ls(9);
    const { scope_: r } = n;
    return dF(r, t), hF(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Np("Patches").applyPatches_;
    return Ip(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function CM(e, t) {
  const n = MO(e) ? Np("MapSet").proxyMap_(e, t) : DO(e) ? Np("MapSet").proxySet_(e, t) : Qbe(e, t);
  return (t ? t.scope_ : Gte()).drafts_.push(n), n;
}
function n0e(e) {
  return Ip(e) || ls(10, e), Jte(e);
}
function Jte(e) {
  if (!Bp(e) || _O(e))
    return e;
  const t = e[ea];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = yM(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = yM(e, !0);
  return M0(n, (r, o) => {
    Kte(n, r, Jte(o));
  }), t && (t.finalized_ = !1), n;
}
var ta = new t0e(), qT = ta.produce;
ta.produceWithPatches.bind(
  ta
);
ta.setAutoFreeze.bind(ta);
ta.setUseStrictShallowCopy.bind(ta);
ta.applyPatches.bind(ta);
var mF = ta.createDraft.bind(ta), vF = ta.finishDraft.bind(ta), Ge = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ge.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ge.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ge.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ge.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ge.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ge.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ge.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ge.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ge.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ge.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ge.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ge.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ge.isAncestor(t, e) && !Ge.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ge.equals(i, r) || Ge.endsBefore(i, r) || Ge.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ge.equals(a, r) || Ge.isAncestor(a, r))
          return null;
        Ge.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ge.equals(s, r) || Ge.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ge.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ge.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ge.endsBefore(u, r) ? r[u.length - 1] += 1 : Ge.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ge.equals(p, d))
          return r;
        if (Ge.isAncestor(p, r) || Ge.equals(p, r)) {
          var y = d.slice();
          return Ge.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else Ge.isSibling(p, d) && (Ge.isAncestor(d, r) || Ge.equals(d, r)) ? Ge.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ge.endsBefore(d, r) || Ge.equals(d, r) || Ge.isAncestor(d, r) ? (Ge.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ge.endsBefore(p, r) && (Ge.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function lg(e) {
  "@babel/helpers - typeof";
  return lg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, lg(e);
}
function r0e(e, t) {
  if (lg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (lg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function o0e(e) {
  var t = r0e(e, "string");
  return lg(t) === "symbol" ? t : String(t);
}
function Dd(e, t, n) {
  return t = o0e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function yF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yF(Object(n), !0).forEach(function(r) {
      Dd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var i0e = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = jt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Jt.points(t))
          t[l] = qr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = jt.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of Jt.points(t))
          t[b] = qr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = jt.get(e, L), D = Ge.previous(L), x = jt.get(e, D), m = jt.parent(e, L), C = L[L.length - 1];
      if (Xo.isText(w) && Xo.isText(x))
        x.text += w.text;
      else if (!Xo.isText(w) && !Xo.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(js.stringify(w), " ").concat(js.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of Jt.points(t))
          t[U] = qr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: R
      } = n;
      if (Ge.isAncestor(k, R))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(R, "] because the destination is inside itself."));
      var N = jt.get(e, k), V = jt.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var H = Ge.transform(k, n), X = jt.get(e, Ge.parent(H)), G = H[H.length - 1];
      if (X.children.splice(G, 0, N), t)
        for (var [Y, Q] of Jt.points(t))
          t[Q] = qr.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = jt.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of Jt.points(t)) {
          var W = qr.transform(z, n);
          if (t != null && W != null)
            t[M] = W;
          else {
            var O = void 0, I = void 0;
            for (var [F, j] of jt.texts(e))
              if (Ge.compare(j, J) === -1)
                O = [F, j];
              else {
                I = [F, j];
                break;
              }
            var q = !1;
            O && I && (Ge.equals(I[1], J) ? q = !Ge.hasPrevious(I[1]) : q = Ge.common(O[1], J).length < Ge.common(I[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : I ? (z.path = I[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: K,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = jt.leaf(e, A), he = le.text.slice(0, K), re = le.text.slice(K + B.length);
      if (le.text = he + re, t)
        for (var [Se, We] of Jt.points(t))
          t[We] = qr.transform(Se, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: Me,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = jt.get(e, Ze);
      for (var be in rt) {
        if (be === "children" || be === "text")
          throw new Error('Cannot set the "'.concat(be, '" property of nodes!'));
        var qe = rt[be];
        qe == null ? delete Ve[be] : Ve[be] = qe;
      }
      for (var ct in Me)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!Jt.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(js.stringify(ye), " when there is no current selection."));
          t = lf({}, ye);
        }
        for (var xe in ye) {
          var Ee = ye[xe];
          if (Ee == null) {
            if (xe === "anchor" || xe === "focus")
              throw new Error('Cannot remove the "'.concat(xe, '" selection property'));
            delete t[xe];
          } else
            t[xe] = Ee;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ue,
        position: De,
        properties: st
      } = n;
      if (Ue.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ue, "] because the root node cannot be split."));
      var ve = jt.get(e, Ue), wt = jt.parent(e, Ue), at = Ue[Ue.length - 1], lt;
      if (Xo.isText(ve)) {
        var pt = ve.text.slice(0, De), Ot = ve.text.slice(De);
        ve.text = pt, lt = lf(lf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = ve.children.slice(0, De), Ct = ve.children.slice(De);
        ve.children = dt, lt = lf(lf({}, st), {}, {
          children: Ct
        });
      }
      if (wt.children.splice(at + 1, 0, lt), t)
        for (var [Xe, ht] of Jt.points(t))
          t[ht] = qr.transform(Xe, n);
      break;
    }
  }
  return t;
}, s0e = {
  transform(e, t) {
    e.children = mF(e.children);
    var n = e.selection && mF(e.selection);
    try {
      n = i0e(e, n, t);
    } finally {
      e.children = vF(e.children), n ? e.selection = Ip(n) ? vF(n) : n : e.selection = null;
    }
  }
}, a0e = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, l0e = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Qte = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (zi(r) && zi(o)) {
      if (!Qte(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function u0e(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function ug(e, t) {
  if (e == null) return {};
  var n = u0e(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var c0e = ["anchor", "focus"];
function bF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function p0e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bF(Object(n), !0).forEach(function(r) {
      Dd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Jt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Jt.edges(e);
    return t;
  },
  equals(e, t) {
    return qr.equals(e.anchor, t.anchor) && qr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Jt.isRange(t)) {
      if (Jt.includes(e, t.anchor) || Jt.includes(e, t.focus))
        return !0;
      var [n, r] = Jt.edges(e), [o, i] = Jt.edges(t);
      return qr.isBefore(n, o) && qr.isAfter(r, i);
    }
    var [a, s] = Jt.edges(e), l = !1, u = !1;
    return qr.isPoint(t) ? (l = qr.compare(t, a) >= 0, u = qr.compare(t, s) <= 0) : (l = Ge.compare(t, a.path) >= 0, u = Ge.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = ug(e, c0e), [r, o] = Jt.edges(e), [i, a] = Jt.edges(t), s = qr.isBefore(r, i) ? i : r, l = qr.isBefore(o, a) ? o : a;
    return qr.isBefore(l, s) ? null : p0e({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return qr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return qr.equals(t, n);
  },
  isExpanded(e) {
    return !Jt.isCollapsed(e);
  },
  isForward(e) {
    return !Jt.isBackward(e);
  },
  isRange(e) {
    return zi(e) && qr.isPoint(e.anchor) && qr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Jt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return qT(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Jt.isCollapsed(r);
        Jt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Jt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = qr.transform(r.anchor, t, {
        affinity: i
      }), u = qr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, wF = (e) => zi(e) && jt.isNodeList(e.children) && !wr.isEditor(e), _l = {
  isAncestor(e) {
    return zi(e) && jt.isNodeList(e.children);
  },
  isElement: wF,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => _l.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return wF(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, d0e = ["children"], f0e = ["text"], OF = /* @__PURE__ */ new WeakMap(), jt = {
  ancestor(e, t) {
    var n = jt.get(e, t);
    if (Xo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(js.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ge.ancestors(t, n)) {
        var o = jt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Xo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(js.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(js.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = jt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = jt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ge.common(t, n), o = jt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = jt.get(e, t);
    if (wr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(js.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of jt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of jt.nodes(e, t))
        _l.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (_l.isAncestor(e)) {
      var t = ug(e, d0e);
      return t;
    } else {
      var t = ug(e, f0e);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = jt.get(e, n); r && !(Xo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Xo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(js.stringify(e)));
    var n = qT({
      children: e.children
    }, (r) => {
      var [o, i] = Jt.edges(t), a = jt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Jt.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Jt.includes(t, s)) {
          var l = jt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ge.equals(s, i.path)) {
          var c = jt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ge.equals(s, o.path)) {
          var p = jt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      wr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Xo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(js.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Xo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Xo.isText(e) || _l.isElement(e) || wr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = OF.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => jt.isNode(r));
    return OF.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = jt.get(e, n); r && !(Xo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = jt.get(e, t);
    if (!Xo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(js.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ge.levels(t, n)) {
        var o = jt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return _l.isElement(e) && _l.isElementProps(t) && _l.matches(e, t) || Xo.isText(e) && Xo.isTextProps(t) && Xo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ge.isBefore(s, i) : Ge.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Xo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ge.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = jt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ge.next(s);
          if (jt.has(e, c)) {
            s = c, l = jt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ge.previous(s);
          s = p, l = jt.get(e, s);
          continue;
        }
        s = Ge.parent(s), l = jt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ge.parent(t), r = jt.get(e, n);
    if (Xo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Xo.isText(e) ? e.text : e.children.map(jt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of jt.nodes(e, t))
        Xo.isText(n) && (yield [n, r]);
    }();
  }
};
function CF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function no(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CF(Object(n), !0).forEach(function(r) {
      Dd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qf = {
  isNodeOperation(e) {
    return Qf.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!zi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ge.isPath(e.path) && jt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ge.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ge.isPath(e.path) && zi(e.properties);
      case "move_node":
        return Ge.isPath(e.path) && Ge.isPath(e.newPath);
      case "remove_node":
        return Ge.isPath(e.path) && jt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ge.isPath(e.path);
      case "set_node":
        return Ge.isPath(e.path) && zi(e.properties) && zi(e.newProperties);
      case "set_selection":
        return e.properties === null && Jt.isRange(e.newProperties) || e.newProperties === null && Jt.isRange(e.properties) || zi(e.properties) && zi(e.newProperties);
      case "split_node":
        return Ge.isPath(e.path) && typeof e.position == "number" && zi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Qf.isOperation(t));
  },
  isSelectionOperation(e) {
    return Qf.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Qf.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return no(no({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return no(no({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return no(no({}, e), {}, {
          type: "split_node",
          path: Ge.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ge.equals(t, n))
          return e;
        if (Ge.isSibling(n, t))
          return no(no({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ge.transform(n, e), o = Ge.transform(Ge.next(n), e);
        return no(no({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return no(no({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return no(no({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return no(no({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? no(no({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? no(no({}, e), {}, {
          properties: null,
          newProperties: s
        }) : no(no({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return no(no({}, e), {}, {
          type: "merge_node",
          path: Ge.next(e.path)
        });
    }
  }
}, xF = /* @__PURE__ */ new WeakMap(), h0e = (e) => {
  var t = xF.get(e);
  if (t !== void 0)
    return t;
  if (!zi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || zi(e.marks)) && (e.selection === null || Jt.isRange(e.selection)) && jt.isNodeList(e.children) && Qf.isOperationList(e.operations);
  return xF.set(e, n), n;
}, wr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return h0e(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function LF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function EF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LF(Object(n), !0).forEach(function(r) {
      Dd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qr = {
  compare(e, t) {
    var n = Ge.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return qr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return qr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ge.equals(e.path, t.path);
  },
  isPoint(e) {
    return zi(e) && typeof e.offset == "number" && Ge.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return qT(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ge.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ge.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ge.equals(t.path, i) && (r.offset += t.position), r.path = Ge.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ge.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ge.equals(t.path, i) || Ge.isAncestor(t.path, i))
            return null;
          r.path = Ge.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ge.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ge.transform(i, t, EF(EF({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ge.transform(i, t, n);
          break;
        }
      }
    });
  }
}, kF = void 0, js = {
  setScrubber(e) {
    kF = e;
  },
  stringify(e) {
    return JSON.stringify(e, kF);
  }
}, g0e = ["text"], m0e = ["anchor", "focus"];
function PF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PF(Object(n), !0).forEach(function(r) {
      Dd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = ug(i, g0e);
      return a;
    }
    return Qte(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return zi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Xo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [hl({}, e)];
    for (var r of t) {
      var o = ug(r, m0e), [i, a] = Jt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = hl(hl({}, f), {}, {
            text: f.text.slice(L)
          }), f = hl(hl({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = hl(hl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = hl(hl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, v0e = (e) => e.selection ? e.selection : e.children.length > 0 ? wr.end(e, []) : [0], Fr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Fr || (Fr = {}));
Fr.L, Fr.L | Fr.V | Fr.LV | Fr.LVT, Fr.LV | Fr.V, Fr.V | Fr.T, Fr.LVT | Fr.T, Fr.T, Fr.Any, Fr.Extend | Fr.ZWJ, Fr.Any, Fr.SpacingMark, Fr.Prepend, Fr.Any, Fr.ZWJ, Fr.ExtPict, Fr.RI, Fr.RI;
var y0e = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    wr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = v0e(e)
      } = n;
      if (Ge.isPath(o) && (o = wr.range(e, o)), Jt.isRange(o))
        if (Jt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Jt.end(o);
          if (!r && wr.void(e, {
            at: i
          }))
            return;
          var a = Jt.start(o), s = wr.pointRef(e, a), l = wr.pointRef(e, i);
          T0.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, T0.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && wr.void(e, {
        at: o
      }) || wr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function SF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SF(Object(n), !0).forEach(function(r) {
      Dd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var T0 = xv(xv(xv(xv({}, s0e), a0e), l0e), y0e), ene = {}, XT = {}, KT = {};
Object.defineProperty(KT, "__esModule", { value: !0 });
KT.default = C0e;
var MF = "html", DF = "head", Lv = "body", b0e = /<([a-zA-Z]+[0-9]?)/, _F = /<head[^]*>/i, TF = /<body[^]*>/i, j0 = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, xM = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, jF = typeof window == "object" && window.DOMParser;
if (typeof jF == "function") {
  var w0e = new jF(), O0e = "text/html";
  xM = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), w0e.parseFromString(e, O0e);
  }, j0 = xM;
}
if (typeof document == "object" && document.implementation) {
  var Ev = document.implementation.createHTMLDocument();
  j0 = function(e, t) {
    if (t) {
      var n = Ev.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Ev;
    }
    return Ev.documentElement.innerHTML = e, Ev;
  };
}
var kv = typeof document == "object" && document.createElement("template"), LM;
kv && kv.content && (LM = function(e) {
  return kv.innerHTML = e, kv.content.childNodes;
});
function C0e(e) {
  var t, n, r = e.match(b0e), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case MF: {
      var i = xM(e);
      if (!_F.test(e)) {
        var a = i.querySelector(DF);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!TF.test(e)) {
        var a = i.querySelector(Lv);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(MF);
    }
    case DF:
    case Lv: {
      var s = j0(e).querySelectorAll(o);
      return TF.test(e) && _F.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (LM)
        return LM(e);
      var a = j0(e, Lv).querySelector(Lv);
      return a.childNodes;
    }
  }
}
var TO = {}, GT = {}, YT = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(YT);
var un = {}, ac = Mr && Mr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), yh = Mr && Mr.__assign || function() {
  return yh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, yh.apply(this, arguments);
};
Object.defineProperty(un, "__esModule", { value: !0 });
un.cloneNode = un.hasChildren = un.isDocument = un.isDirective = un.isComment = un.isText = un.isCDATA = un.isTag = un.Element = un.Document = un.CDATA = un.NodeWithChildren = un.ProcessingInstruction = un.Comment = un.Text = un.DataNode = un.Node = void 0;
var Ls = YT, JT = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), QT(this, t);
    }, e;
  }()
);
un.Node = JT;
var jO = (
  /** @class */
  function(e) {
    ac(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(JT)
);
un.DataNode = jO;
var tne = (
  /** @class */
  function(e) {
    ac(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ls.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(jO)
);
un.Text = tne;
var nne = (
  /** @class */
  function(e) {
    ac(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ls.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(jO)
);
un.Comment = nne;
var rne = (
  /** @class */
  function(e) {
    ac(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ls.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(jO)
);
un.ProcessingInstruction = rne;
var AO = (
  /** @class */
  function(e) {
    ac(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(JT)
);
un.NodeWithChildren = AO;
var one = (
  /** @class */
  function(e) {
    ac(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ls.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(AO)
);
un.CDATA = one;
var ine = (
  /** @class */
  function(e) {
    ac(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ls.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(AO)
);
un.Document = ine;
var sne = (
  /** @class */
  function(e) {
    ac(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ls.ElementType.Script : n === "style" ? Ls.ElementType.Style : Ls.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(AO)
);
un.Element = sne;
function ane(e) {
  return (0, Ls.isTag)(e);
}
un.isTag = ane;
function lne(e) {
  return e.type === Ls.ElementType.CDATA;
}
un.isCDATA = lne;
function une(e) {
  return e.type === Ls.ElementType.Text;
}
un.isText = une;
function cne(e) {
  return e.type === Ls.ElementType.Comment;
}
un.isComment = cne;
function pne(e) {
  return e.type === Ls.ElementType.Directive;
}
un.isDirective = pne;
function dne(e) {
  return e.type === Ls.ElementType.Root;
}
un.isDocument = dne;
function x0e(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
un.hasChildren = x0e;
function QT(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (une(e))
    n = new tne(e.data);
  else if (cne(e))
    n = new nne(e.data);
  else if (ane(e)) {
    var r = t ? VL(e.children) : [], o = new sne(e.name, yh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = yh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = yh({}, e["x-attribsPrefix"])), n = o;
  } else if (lne(e)) {
    var r = t ? VL(e.children) : [], i = new one(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (dne(e)) {
    var r = t ? VL(e.children) : [], a = new ine(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (pne(e)) {
    var s = new rne(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
un.cloneNode = QT;
function VL(e) {
  for (var t = e.map(function(r) {
    return QT(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Mr && Mr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Mr && Mr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = YT, o = un;
  n(un, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(GT);
var fne = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(fne);
Object.defineProperty(TO, "__esModule", { value: !0 });
TO.formatAttributes = hne;
TO.formatDOM = gne;
var Pv = GT, L0e = fne;
function E0e(e) {
  return L0e.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function hne(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function k0e(e) {
  e = e.toLowerCase();
  var t = E0e(e);
  return t || e;
}
function gne(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = k0e(s.nodeName);
        o = new Pv.Element(l, hne(s.attributes)), o.children = gne(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Pv.Text(s.nodeValue);
        break;
      case 8:
        o = new Pv.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Pv.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var P0e = Mr && Mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(XT, "__esModule", { value: !0 });
XT.default = _0e;
var S0e = P0e(KT), M0e = TO, D0e = /<(![a-zA-Z\s]+)>/;
function _0e(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(D0e), n = t ? t[1] : void 0;
  return (0, M0e.formatDOM)((0, S0e.default)(e), null, n);
}
var IO = {}, Ma = {}, BO = {}, T0e = 0;
BO.SAME = T0e;
var j0e = 1;
BO.CAMELCASE = j0e;
BO.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const mne = 0, lc = 1, NO = 2, RO = 3, ej = 4, vne = 5, yne = 6;
function A0e(e) {
  return _i.hasOwnProperty(e) ? _i[e] : null;
}
function Ji(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === NO || t === RO || t === ej, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const _i = {}, I0e = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
I0e.forEach((e) => {
  _i[e] = new Ji(
    e,
    mne,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  _i[e] = new Ji(
    e,
    lc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  _i[e] = new Ji(
    e,
    NO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  _i[e] = new Ji(
    e,
    NO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  _i[e] = new Ji(
    e,
    RO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  _i[e] = new Ji(
    e,
    RO,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  _i[e] = new Ji(
    e,
    ej,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  _i[e] = new Ji(
    e,
    yne,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  _i[e] = new Ji(
    e,
    vne,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const tj = /[\-\:]([a-z])/g, nj = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(tj, nj);
  _i[t] = new Ji(
    t,
    lc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(tj, nj);
  _i[t] = new Ji(
    t,
    lc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(tj, nj);
  _i[t] = new Ji(
    t,
    lc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  _i[e] = new Ji(
    e,
    lc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const B0e = "xlinkHref";
_i[B0e] = new Ji(
  "xlinkHref",
  lc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  _i[e] = new Ji(
    e,
    lc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: N0e,
  SAME: R0e,
  possibleStandardNames: AF
} = BO, F0e = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", z0e = F0e + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", U0e = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + z0e + "]*$")
), W0e = Object.keys(
  AF
).reduce((e, t) => {
  const n = AF[t];
  return n === R0e ? e[t] = t : n === N0e ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Ma.BOOLEAN = RO;
Ma.BOOLEANISH_STRING = NO;
Ma.NUMERIC = vne;
Ma.OVERLOADED_BOOLEAN = ej;
Ma.POSITIVE_NUMERIC = yne;
Ma.RESERVED = mne;
Ma.STRING = lc;
Ma.getPropertyInfo = A0e;
Ma.isCustomAttribute = U0e;
Ma.possibleStandardNames = W0e;
var rj = {}, oj = {}, IF = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, H0e = /\n/g, V0e = /^\s*/, $0e = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Z0e = /^:\s*/, q0e = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, X0e = /^[;\s]*/, K0e = /^\s+|\s+$/g, G0e = `
`, BF = "/", NF = "*", lp = "", Y0e = "comment", J0e = "declaration", Q0e = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(H0e);
    v && (n += v.length);
    var b = f.lastIndexOf(G0e);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(V0e);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(BF != e.charAt(0) || NF != e.charAt(1))) {
      for (var v = 2; lp != e.charAt(v) && (NF != e.charAt(v) || BF != e.charAt(v + 1)); )
        ++v;
      if (v += 2, lp === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: Y0e,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l($0e);
    if (v) {
      if (p(), !l(Z0e)) return s("property missing ':'");
      var b = l(q0e), L = f({
        type: J0e,
        property: RF(v[0].replace(IF, lp)),
        value: b ? RF(b[0].replace(IF, lp)) : lp
      });
      return l(X0e), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function RF(e) {
  return e ? e.replace(K0e, lp) : lp;
}
var ewe = Mr && Mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(oj, "__esModule", { value: !0 });
oj.default = nwe;
var twe = ewe(Q0e);
function nwe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, twe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var FO = {};
Object.defineProperty(FO, "__esModule", { value: !0 });
FO.camelCase = void 0;
var rwe = /^--[a-zA-Z0-9_-]+$/, owe = /-([a-z])/g, iwe = /^[^-]+$/, swe = /^-(webkit|moz|ms|o|khtml)-/, awe = /^-(ms)-/, lwe = function(e) {
  return !e || iwe.test(e) || rwe.test(e);
}, uwe = function(e, t) {
  return t.toUpperCase();
}, FF = function(e, t) {
  return "".concat(t, "-");
}, cwe = function(e, t) {
  return t === void 0 && (t = {}), lwe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(awe, FF) : e = e.replace(swe, FF), e.replace(owe, uwe));
};
FO.camelCase = cwe;
var pwe = Mr && Mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, dwe = pwe(oj), fwe = FO;
function EM(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, dwe.default)(e, function(r, o) {
    r && o && (n[(0, fwe.camelCase)(r, t)] = o);
  }), n;
}
EM.default = EM;
var hwe = EM;
(function(e) {
  var t = Mr && Mr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Oe, r = t(hwe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(rj);
Object.defineProperty(IO, "__esModule", { value: !0 });
IO.default = ywe;
var eh = Ma, zF = rj, gwe = ["checked", "value"], mwe = ["input", "select", "textarea"], vwe = {
  reset: !0,
  submit: !0
};
function ywe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && vwe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, eh.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = UF(a);
    if (s) {
      var l = (0, eh.getPropertyInfo)(s);
      switch (gwe.includes(s) && mwe.includes(t) && !r && (s = UF("default" + a)), n[s] = i, l && l.type) {
        case eh.BOOLEAN:
          n[s] = !0;
          break;
        case eh.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    zF.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, zF.setStyleProp)(e.style, n), n;
}
function UF(e) {
  return eh.possibleStandardNames[e];
}
var ij = {}, bwe = Mr && Mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ij, "__esModule", { value: !0 });
ij.default = bne;
var $L = Oe, wwe = bwe(IO), bh = rj, Owe = {
  cloneElement: $L.cloneElement,
  createElement: $L.createElement,
  isValidElement: $L.isValidElement
};
function bne(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || bh.returnFirstArg, i = t.library || Owe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, bh.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    Cwe(f) ? ((0, bh.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, wwe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = bne(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Cwe(e) {
  return bh.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, bh.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Mr && Mr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(XT);
  e.htmlToDOM = n.default;
  var r = t(IO);
  e.attributesToProps = r.default;
  var o = t(ij);
  e.domToReact = o.default;
  var i = GT;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(ene);
const xwe = /* @__PURE__ */ Hbe(ene);
xwe.default;
var Dr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Lwe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var kM = { exports: {} }, uf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WF;
function Ewe() {
  if (WF) return uf;
  WF = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return uf.Fragment = n, uf.jsx = a, uf.jsxs = a, uf;
}
var Sv = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var HF;
function kwe() {
  return HF || (HF = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var T = f && g[f] || g[v];
      return typeof T == "function" ? T : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var T = arguments.length, Z = new Array(T > 1 ? T - 1 : 0), ee = 1; ee < T; ee++)
          Z[ee - 1] = arguments[ee];
        D("error", g, Z);
      }
    }
    function D(g, T, Z) {
      {
        var ee = L.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (T += "%s", Z = Z.concat([ae]));
        var ue = Z.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + T), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function R(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function N(g, T, Z) {
      var ee = g.displayName;
      if (ee)
        return ee;
      var ae = T.displayName || T.name || "";
      return ae !== "" ? Z + "(" + ae + ")" : Z;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var T = g;
            return V(T) + ".Consumer";
          case a:
            var Z = g;
            return V(Z._context) + ".Provider";
          case l:
            return N(g, g.render, "ForwardRef");
          case p:
            var ee = g.displayName || null;
            return ee !== null ? ee : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, X = 0, G, Y, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function W() {
      {
        if (X === 0) {
          G = console.log, Y = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        X++;
      }
    }
    function O() {
      {
        if (X--, X === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, g, {
              value: G
            }),
            info: H({}, g, {
              value: Y
            }),
            warn: H({}, g, {
              value: Q
            }),
            error: H({}, g, {
              value: J
            }),
            group: H({}, g, {
              value: P
            }),
            groupCollapsed: H({}, g, {
              value: _
            }),
            groupEnd: H({}, g, {
              value: z
            })
          });
        }
        X < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = L.ReactCurrentDispatcher, F;
    function j(g, T, Z) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            F = ee && ee[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, A;
    {
      var K = typeof WeakMap == "function" ? WeakMap : Map;
      A = new K();
    }
    function B(g, T) {
      if (!g || q)
        return "";
      {
        var Z = A.get(g);
        if (Z !== void 0)
          return Z;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (T) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Le) {
              ee = Le;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (Le) {
              ee = Le;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Le) {
            ee = Le;
          }
          g();
        }
      } catch (Le) {
        if (Le && ee && typeof Le.stack == "string") {
          for (var ie = Le.stack.split(`
`), we = ee.stack.split(`
`), de = ie.length - 1, fe = we.length - 1; de >= 1 && fe >= 0 && ie[de] !== we[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== we[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== we[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", g.displayName)), typeof g == "function" && A.set(g, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var kt = g ? g.displayName || g.name : "", mt = kt ? j(kt) : "";
      return typeof g == "function" && A.set(g, mt), mt;
    }
    function le(g, T, Z) {
      return B(g, !1);
    }
    function he(g) {
      var T = g.prototype;
      return !!(T && T.isReactComponent);
    }
    function re(g, T, Z) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return B(g, he(g));
      if (typeof g == "string")
        return j(g);
      switch (g) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return re(g.type, T, Z);
          case d: {
            var ee = g, ae = ee._payload, ue = ee._init;
            try {
              return re(ue(ae), T, Z);
            } catch {
            }
          }
        }
      return "";
    }
    var Se = Object.prototype.hasOwnProperty, We = {}, Ze = L.ReactDebugCurrentFrame;
    function Me(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        Ze.setExtraStackFrame(Z);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(g, T, Z, ee, ae) {
      {
        var ue = Function.call.bind(Se);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var we = Error((ee || "React class") + ": " + Z + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw we.name = "Invariant Violation", we;
              }
              ie = g[se](T, se, ee, Z, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Me(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", Z, se, typeof ie), Me(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Me(ae), w("Failed %s type: %s", Z, ie.message), Me(null));
          }
      }
    }
    var Ve = Array.isArray;
    function be(g) {
      return Ve(g);
    }
    function qe(g) {
      {
        var T = typeof Symbol == "function" && Symbol.toStringTag, Z = T && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return Z;
      }
    }
    function ct(g) {
      try {
        return ye(g), !1;
      } catch {
        return !0;
      }
    }
    function ye(g) {
      return "" + g;
    }
    function xe(g) {
      if (ct(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qe(g)), ye(g);
    }
    var Ee = L.ReactCurrentOwner, Ue = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, De, st, ve;
    ve = {};
    function wt(g) {
      if (Se.call(g, "ref")) {
        var T = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function at(g) {
      if (Se.call(g, "key")) {
        var T = Object.getOwnPropertyDescriptor(g, "key").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function lt(g, T) {
      if (typeof g.ref == "string" && Ee.current && T && Ee.current.stateNode !== T) {
        var Z = $(Ee.current.type);
        ve[Z] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ee.current.type), g.ref), ve[Z] = !0);
      }
    }
    function pt(g, T) {
      {
        var Z = function() {
          De || (De = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: Z,
          configurable: !0
        });
      }
    }
    function Ot(g, T) {
      {
        var Z = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: Z,
          configurable: !0
        });
      }
    }
    var dt = function(g, T, Z, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: T,
        ref: Z,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function Ct(g, T, Z, ee, ae) {
      {
        var ue, se = {}, ie = null, we = null;
        Z !== void 0 && (xe(Z), ie = "" + Z), at(T) && (xe(T.key), ie = "" + T.key), wt(T) && (we = T.ref, lt(T, ae));
        for (ue in T)
          Se.call(T, ue) && !Ue.hasOwnProperty(ue) && (se[ue] = T[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || we) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && pt(se, fe), we && Ot(se, fe);
        }
        return dt(g, ie, we, ae, ee, Ee.current, se);
      }
    }
    var Xe = L.ReactCurrentOwner, ht = L.ReactDebugCurrentFrame;
    function ot(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        ht.setExtraStackFrame(Z);
      } else
        ht.setExtraStackFrame(null);
    }
    var xt;
    xt = !1;
    function ft(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Pt() {
      {
        if (Xe.current) {
          var g = $(Xe.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Lt(g) {
      return "";
    }
    var St = {};
    function Et(g) {
      {
        var T = Pt();
        if (!T) {
          var Z = typeof g == "string" ? g : g.displayName || g.name;
          Z && (T = `

Check the top-level render call using <` + Z + ">.");
        }
        return T;
      }
    }
    function Mt(g, T) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var Z = Et(T);
        if (St[Z])
          return;
        St[Z] = !0;
        var ee = "";
        g && g._owner && g._owner !== Xe.current && (ee = " It was passed a child from " + $(g._owner.type) + "."), ot(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Z, ee), ot(null);
      }
    }
    function _t(g, T) {
      {
        if (typeof g != "object")
          return;
        if (be(g))
          for (var Z = 0; Z < g.length; Z++) {
            var ee = g[Z];
            ft(ee) && Mt(ee, T);
          }
        else if (ft(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              ft(se.value) && Mt(se.value, T);
        }
      }
    }
    function gt(g) {
      {
        var T = g.type;
        if (T == null || typeof T == "string")
          return;
        var Z;
        if (typeof T == "function")
          Z = T.propTypes;
        else if (typeof T == "object" && (T.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        T.$$typeof === p))
          Z = T.propTypes;
        else
          return;
        if (Z) {
          var ee = $(T);
          rt(Z, g.props, "prop", ee, g);
        } else if (T.PropTypes !== void 0 && !xt) {
          xt = !0;
          var ae = $(T);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof T.getDefaultProps == "function" && !T.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function te(g) {
      {
        for (var T = Object.keys(g.props), Z = 0; Z < T.length; Z++) {
          var ee = T[Z];
          if (ee !== "children" && ee !== "key") {
            ot(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), ot(null);
            break;
          }
        }
        g.ref !== null && (ot(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), ot(null));
      }
    }
    var Br = {};
    function Nr(g, T, Z, ee, ae, ue) {
      {
        var se = R(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var we = Lt();
          we ? ie += we : ie += Pt();
          var de;
          g === null ? de = "null" : be(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = Ct(g, T, Z, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = T.children;
          if (ze !== void 0)
            if (ee)
              if (be(ze)) {
                for (var kt = 0; kt < ze.length; kt++)
                  _t(ze[kt], g);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              _t(ze, g);
        }
        if (Se.call(T, "key")) {
          var mt = $(g), Le = Object.keys(T).filter(function(Si) {
            return Si !== "key";
          }), In = Le.length > 0 ? "{key: someKey, " + Le.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Br[mt + In]) {
            var Pi = Le.length > 0 ? "{" + Le.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, In, mt, Pi, mt), Br[mt + In] = !0;
          }
        }
        return g === r ? te(fe) : gt(fe), fe;
      }
    }
    function xi(g, T, Z) {
      return Nr(g, T, Z, !0);
    }
    function Li(g, T, Z) {
      return Nr(g, T, Z, !1);
    }
    var Ei = Li, ki = xi;
    Sv.Fragment = r, Sv.jsx = Ei, Sv.jsxs = ki;
  }()), Sv;
}
process.env.NODE_ENV === "production" ? kM.exports = Ewe() : kM.exports = kwe();
var ms = kM.exports;
He({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function VF(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Ui(e) {
  var t, n;
  return VF(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(VF(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var wne = Symbol.for("immer-nothing"), $F = Symbol.for("immer-draftable"), na = Symbol.for("immer-state"), Pwe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function us(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Pwe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var wd = Object.getPrototypeOf;
function Rp(e) {
  return !!e && !!e[na];
}
function Fp(e) {
  var t;
  return e ? One(e) || Array.isArray(e) || !!e[$F] || !!((t = e.constructor) != null && t[$F]) || UO(e) || WO(e) : !1;
}
var Swe = Object.prototype.constructor.toString();
function One(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = wd(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Swe;
}
function A0(e, t) {
  zO(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function zO(e) {
  const t = e[na];
  return t ? t.type_ : Array.isArray(e) ? 1 : UO(e) ? 2 : WO(e) ? 3 : 0;
}
function PM(e, t) {
  return zO(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Cne(e, t, n) {
  const r = zO(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Mwe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function UO(e) {
  return e instanceof Map;
}
function WO(e) {
  return e instanceof Set;
}
function Qc(e) {
  return e.copy_ || e.base_;
}
function SM(e, t) {
  if (UO(e))
    return new Map(e);
  if (WO(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = One(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[na];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(wd(e), r);
  } else {
    const r = wd(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function sj(e, t = !1) {
  return HO(e) || Rp(e) || !Fp(e) || (zO(e) > 1 && (e.set = e.add = e.clear = e.delete = Dwe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => sj(r, !0))), e;
}
function Dwe() {
  us(2);
}
function HO(e) {
  return Object.isFrozen(e);
}
var _we = {};
function zp(e) {
  const t = _we[e];
  return t || us(0, e), t;
}
var cg;
function xne() {
  return cg;
}
function Twe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function ZF(e, t) {
  t && (zp("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function MM(e) {
  DM(e), e.drafts_.forEach(jwe), e.drafts_ = null;
}
function DM(e) {
  e === cg && (cg = e.parent_);
}
function qF(e) {
  return cg = Twe(cg, e);
}
function jwe(e) {
  const t = e[na];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function XF(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[na].modified_ && (MM(t), us(4)), Fp(e) && (e = I0(t, e), t.parent_ || B0(t, e)), t.patches_ && zp("Patches").generateReplacementPatches_(
    n[na].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = I0(t, n, []), MM(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== wne ? e : void 0;
}
function I0(e, t, n) {
  if (HO(t))
    return t;
  const r = t[na];
  if (!r)
    return A0(
      t,
      (o, i) => KF(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return B0(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), A0(
      i,
      (s, l) => KF(e, r, o, s, l, n, a)
    ), B0(e, o, !1), n && e.patches_ && zp("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function KF(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && us(5), Rp(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !PM(t.assigned_, r) ? i.concat(r) : void 0, l = I0(e, o, s);
    if (Cne(n, r, l), Rp(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Fp(o) && !HO(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    I0(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && B0(e, o);
  }
}
function B0(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && sj(t, n);
}
function Awe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : xne(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = aj;
  n && (o = [r], i = pg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var aj = {
  get(e, t) {
    if (t === na)
      return e;
    const n = Qc(e);
    if (!PM(n, t))
      return Iwe(e, n, t);
    const r = n[t];
    return e.finalized_ || !Fp(r) ? r : r === ZL(e.base_, t) ? (qL(e), e.copy_[t] = TM(r, e)) : r;
  },
  has(e, t) {
    return t in Qc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Qc(e));
  },
  set(e, t, n) {
    const r = Lne(Qc(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = ZL(Qc(e), t), i = o == null ? void 0 : o[na];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Mwe(n, o) && (n !== void 0 || PM(e.base_, t)))
        return !0;
      qL(e), _M(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return ZL(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, qL(e), _M(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Qc(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    us(11);
  },
  getPrototypeOf(e) {
    return wd(e.base_);
  },
  setPrototypeOf() {
    us(12);
  }
}, pg = {};
A0(aj, (e, t) => {
  pg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
pg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && us(13), pg.set.call(this, e, t, void 0);
};
pg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && us(14), aj.set.call(this, e[0], t, n, e[0]);
};
function ZL(e, t) {
  const n = e[na];
  return (n ? Qc(n) : e)[t];
}
function Iwe(e, t, n) {
  var r;
  const o = Lne(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function Lne(e, t) {
  if (!(t in e))
    return;
  let n = wd(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = wd(n);
  }
}
function _M(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && _M(e.parent_));
}
function qL(e) {
  e.copy_ || (e.copy_ = SM(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Bwe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && us(6), r !== void 0 && typeof r != "function" && us(7);
      let o;
      if (Fp(t)) {
        const i = qF(this), a = TM(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? MM(i) : DM(i);
        }
        return ZF(i, r), XF(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === wne && (o = void 0), this.autoFreeze_ && sj(o, !0), r) {
          const i = [], a = [];
          zp("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        us(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Fp(e) || us(8), Rp(e) && (e = Nwe(e));
    const t = qF(this), n = TM(e, void 0);
    return n[na].isManual_ = !0, DM(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[na];
    (!n || !n.isManual_) && us(9);
    const { scope_: r } = n;
    return ZF(r, t), XF(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = zp("Patches").applyPatches_;
    return Rp(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function TM(e, t) {
  const n = UO(e) ? zp("MapSet").proxyMap_(e, t) : WO(e) ? zp("MapSet").proxySet_(e, t) : Awe(e, t);
  return (t ? t.scope_ : xne()).drafts_.push(n), n;
}
function Nwe(e) {
  return Rp(e) || us(10, e), Ene(e);
}
function Ene(e) {
  if (!Fp(e) || HO(e))
    return e;
  const t = e[na];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = SM(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = SM(e, !0);
  return A0(n, (r, o) => {
    Cne(n, r, Ene(o));
  }), t && (t.finalized_ = !1), n;
}
var ra = new Bwe(), lj = ra.produce;
ra.produceWithPatches.bind(
  ra
);
ra.setAutoFreeze.bind(ra);
ra.setUseStrictShallowCopy.bind(ra);
ra.applyPatches.bind(ra);
var GF = ra.createDraft.bind(ra), YF = ra.finishDraft.bind(ra), Ye = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ye.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ye.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ye.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ye.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ye.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ye.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ye.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ye.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ye.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ye.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ye.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ye.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ye.isAncestor(t, e) && !Ye.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ye.equals(i, r) || Ye.endsBefore(i, r) || Ye.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ye.equals(a, r) || Ye.isAncestor(a, r))
          return null;
        Ye.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ye.equals(s, r) || Ye.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ye.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ye.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ye.endsBefore(u, r) ? r[u.length - 1] += 1 : Ye.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ye.equals(p, d))
          return r;
        if (Ye.isAncestor(p, r) || Ye.equals(p, r)) {
          var y = d.slice();
          return Ye.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else Ye.isSibling(p, d) && (Ye.isAncestor(d, r) || Ye.equals(d, r)) ? Ye.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ye.endsBefore(d, r) || Ye.equals(d, r) || Ye.isAncestor(d, r) ? (Ye.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ye.endsBefore(p, r) && (Ye.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function dg(e) {
  "@babel/helpers - typeof";
  return dg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, dg(e);
}
function Rwe(e, t) {
  if (dg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (dg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Fwe(e) {
  var t = Rwe(e, "string");
  return dg(t) === "symbol" ? t : String(t);
}
function _d(e, t, n) {
  return t = Fwe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function JF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JF(Object(n), !0).forEach(function(r) {
      _d(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zwe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = At.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Qt.points(t))
          t[l] = Xr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = At.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of Qt.points(t))
          t[b] = Xr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = At.get(e, L), D = Ye.previous(L), x = At.get(e, D), m = At.parent(e, L), C = L[L.length - 1];
      if (Ko.isText(w) && Ko.isText(x))
        x.text += w.text;
      else if (!Ko.isText(w) && !Ko.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(As.stringify(w), " ").concat(As.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of Qt.points(t))
          t[U] = Xr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: R
      } = n;
      if (Ye.isAncestor(k, R))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(R, "] because the destination is inside itself."));
      var N = At.get(e, k), V = At.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var H = Ye.transform(k, n), X = At.get(e, Ye.parent(H)), G = H[H.length - 1];
      if (X.children.splice(G, 0, N), t)
        for (var [Y, Q] of Qt.points(t))
          t[Q] = Xr.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = At.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of Qt.points(t)) {
          var W = Xr.transform(z, n);
          if (t != null && W != null)
            t[M] = W;
          else {
            var O = void 0, I = void 0;
            for (var [F, j] of At.texts(e))
              if (Ye.compare(j, J) === -1)
                O = [F, j];
              else {
                I = [F, j];
                break;
              }
            var q = !1;
            O && I && (Ye.equals(I[1], J) ? q = !Ye.hasPrevious(I[1]) : q = Ye.common(O[1], J).length < Ye.common(I[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : I ? (z.path = I[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: K,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = At.leaf(e, A), he = le.text.slice(0, K), re = le.text.slice(K + B.length);
      if (le.text = he + re, t)
        for (var [Se, We] of Qt.points(t))
          t[We] = Xr.transform(Se, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: Me,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = At.get(e, Ze);
      for (var be in rt) {
        if (be === "children" || be === "text")
          throw new Error('Cannot set the "'.concat(be, '" property of nodes!'));
        var qe = rt[be];
        qe == null ? delete Ve[be] : Ve[be] = qe;
      }
      for (var ct in Me)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!Qt.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(As.stringify(ye), " when there is no current selection."));
          t = cf({}, ye);
        }
        for (var xe in ye) {
          var Ee = ye[xe];
          if (Ee == null) {
            if (xe === "anchor" || xe === "focus")
              throw new Error('Cannot remove the "'.concat(xe, '" selection property'));
            delete t[xe];
          } else
            t[xe] = Ee;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ue,
        position: De,
        properties: st
      } = n;
      if (Ue.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ue, "] because the root node cannot be split."));
      var ve = At.get(e, Ue), wt = At.parent(e, Ue), at = Ue[Ue.length - 1], lt;
      if (Ko.isText(ve)) {
        var pt = ve.text.slice(0, De), Ot = ve.text.slice(De);
        ve.text = pt, lt = cf(cf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = ve.children.slice(0, De), Ct = ve.children.slice(De);
        ve.children = dt, lt = cf(cf({}, st), {}, {
          children: Ct
        });
      }
      if (wt.children.splice(at + 1, 0, lt), t)
        for (var [Xe, ht] of Qt.points(t))
          t[ht] = Xr.transform(Xe, n);
      break;
    }
  }
  return t;
}, Uwe = {
  transform(e, t) {
    e.children = GF(e.children);
    var n = e.selection && GF(e.selection);
    try {
      n = zwe(e, n, t);
    } finally {
      e.children = YF(e.children), n ? e.selection = Rp(n) ? YF(n) : n : e.selection = null;
    }
  }
}, Wwe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Hwe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, kne = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Ui(r) && Ui(o)) {
      if (!kne(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Vwe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function fg(e, t) {
  if (e == null) return {};
  var n = Vwe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var $we = ["anchor", "focus"];
function QF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zwe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QF(Object(n), !0).forEach(function(r) {
      _d(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Qt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Qt.edges(e);
    return t;
  },
  equals(e, t) {
    return Xr.equals(e.anchor, t.anchor) && Xr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Qt.isRange(t)) {
      if (Qt.includes(e, t.anchor) || Qt.includes(e, t.focus))
        return !0;
      var [n, r] = Qt.edges(e), [o, i] = Qt.edges(t);
      return Xr.isBefore(n, o) && Xr.isAfter(r, i);
    }
    var [a, s] = Qt.edges(e), l = !1, u = !1;
    return Xr.isPoint(t) ? (l = Xr.compare(t, a) >= 0, u = Xr.compare(t, s) <= 0) : (l = Ye.compare(t, a.path) >= 0, u = Ye.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = fg(e, $we), [r, o] = Qt.edges(e), [i, a] = Qt.edges(t), s = Xr.isBefore(r, i) ? i : r, l = Xr.isBefore(o, a) ? o : a;
    return Xr.isBefore(l, s) ? null : Zwe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Xr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Xr.equals(t, n);
  },
  isExpanded(e) {
    return !Qt.isCollapsed(e);
  },
  isForward(e) {
    return !Qt.isBackward(e);
  },
  isRange(e) {
    return Ui(e) && Xr.isPoint(e.anchor) && Xr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Qt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return lj(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Qt.isCollapsed(r);
        Qt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Qt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Xr.transform(r.anchor, t, {
        affinity: i
      }), u = Xr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, ez = (e) => Ui(e) && At.isNodeList(e.children) && !Or.isEditor(e), Tl = {
  isAncestor(e) {
    return Ui(e) && At.isNodeList(e.children);
  },
  isElement: ez,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Tl.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return ez(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, qwe = ["children"], Xwe = ["text"], tz = /* @__PURE__ */ new WeakMap(), At = {
  ancestor(e, t) {
    var n = At.get(e, t);
    if (Ko.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(As.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ye.ancestors(t, n)) {
        var o = At.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Ko.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(As.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(As.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = At.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = At.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ye.common(t, n), o = At.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = At.get(e, t);
    if (Or.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(As.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of At.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of At.nodes(e, t))
        Tl.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Tl.isAncestor(e)) {
      var t = fg(e, qwe);
      return t;
    } else {
      var t = fg(e, Xwe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = At.get(e, n); r && !(Ko.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Ko.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(As.stringify(e)));
    var n = lj({
      children: e.children
    }, (r) => {
      var [o, i] = Qt.edges(t), a = At.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Qt.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Qt.includes(t, s)) {
          var l = At.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ye.equals(s, i.path)) {
          var c = At.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ye.equals(s, o.path)) {
          var p = At.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Or.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ko.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(As.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ko.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Ko.isText(e) || Tl.isElement(e) || Or.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = tz.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => At.isNode(r));
    return tz.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = At.get(e, n); r && !(Ko.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = At.get(e, t);
    if (!Ko.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(As.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ye.levels(t, n)) {
        var o = At.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Tl.isElement(e) && Tl.isElementProps(t) && Tl.matches(e, t) || Ko.isText(e) && Ko.isTextProps(t) && Ko.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ye.isBefore(s, i) : Ye.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Ko.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ye.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = At.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ye.next(s);
          if (At.has(e, c)) {
            s = c, l = At.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ye.previous(s);
          s = p, l = At.get(e, s);
          continue;
        }
        s = Ye.parent(s), l = At.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ye.parent(t), r = At.get(e, n);
    if (Ko.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Ko.isText(e) ? e.text : e.children.map(At.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of At.nodes(e, t))
        Ko.isText(n) && (yield [n, r]);
    }();
  }
};
function nz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ro(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nz(Object(n), !0).forEach(function(r) {
      _d(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var th = {
  isNodeOperation(e) {
    return th.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Ui(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ye.isPath(e.path) && At.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ye.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ye.isPath(e.path) && Ui(e.properties);
      case "move_node":
        return Ye.isPath(e.path) && Ye.isPath(e.newPath);
      case "remove_node":
        return Ye.isPath(e.path) && At.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ye.isPath(e.path);
      case "set_node":
        return Ye.isPath(e.path) && Ui(e.properties) && Ui(e.newProperties);
      case "set_selection":
        return e.properties === null && Qt.isRange(e.newProperties) || e.newProperties === null && Qt.isRange(e.properties) || Ui(e.properties) && Ui(e.newProperties);
      case "split_node":
        return Ye.isPath(e.path) && typeof e.position == "number" && Ui(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => th.isOperation(t));
  },
  isSelectionOperation(e) {
    return th.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return th.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return ro(ro({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return ro(ro({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return ro(ro({}, e), {}, {
          type: "split_node",
          path: Ye.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ye.equals(t, n))
          return e;
        if (Ye.isSibling(n, t))
          return ro(ro({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ye.transform(n, e), o = Ye.transform(Ye.next(n), e);
        return ro(ro({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return ro(ro({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return ro(ro({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return ro(ro({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? ro(ro({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? ro(ro({}, e), {}, {
          properties: null,
          newProperties: s
        }) : ro(ro({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return ro(ro({}, e), {}, {
          type: "merge_node",
          path: Ye.next(e.path)
        });
    }
  }
}, rz = /* @__PURE__ */ new WeakMap(), Kwe = (e) => {
  var t = rz.get(e);
  if (t !== void 0)
    return t;
  if (!Ui(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Ui(e.marks)) && (e.selection === null || Qt.isRange(e.selection)) && At.isNodeList(e.children) && th.isOperationList(e.operations);
  return rz.set(e, n), n;
}, Or = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Kwe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function oz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oz(Object(n), !0).forEach(function(r) {
      _d(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xr = {
  compare(e, t) {
    var n = Ye.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Xr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Xr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ye.equals(e.path, t.path);
  },
  isPoint(e) {
    return Ui(e) && typeof e.offset == "number" && Ye.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return lj(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ye.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ye.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ye.equals(t.path, i) && (r.offset += t.position), r.path = Ye.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ye.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ye.equals(t.path, i) || Ye.isAncestor(t.path, i))
            return null;
          r.path = Ye.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ye.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ye.transform(i, t, iz(iz({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ye.transform(i, t, n);
          break;
        }
      }
    });
  }
}, sz = void 0, As = {
  setScrubber(e) {
    sz = e;
  },
  stringify(e) {
    return JSON.stringify(e, sz);
  }
}, Gwe = ["text"], Ywe = ["anchor", "focus"];
function az(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? az(Object(n), !0).forEach(function(r) {
      _d(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : az(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ko = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = fg(i, Gwe);
      return a;
    }
    return kne(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Ui(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Ko.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [gl({}, e)];
    for (var r of t) {
      var o = fg(r, Ywe), [i, a] = Qt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = gl(gl({}, f), {}, {
            text: f.text.slice(L)
          }), f = gl(gl({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = gl(gl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = gl(gl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, Jwe = (e) => e.selection ? e.selection : e.children.length > 0 ? Or.end(e, []) : [0], zr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(zr || (zr = {}));
zr.L, zr.L | zr.V | zr.LV | zr.LVT, zr.LV | zr.V, zr.V | zr.T, zr.LVT | zr.T, zr.T, zr.Any, zr.Extend | zr.ZWJ, zr.Any, zr.SpacingMark, zr.Prepend, zr.Any, zr.ZWJ, zr.ExtPict, zr.RI, zr.RI;
var Qwe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Or.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Jwe(e)
      } = n;
      if (Ye.isPath(o) && (o = Or.range(e, o)), Qt.isRange(o))
        if (Qt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Qt.end(o);
          if (!r && Or.void(e, {
            at: i
          }))
            return;
          var a = Qt.start(o), s = Or.pointRef(e, a), l = Or.pointRef(e, i);
          N0.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, N0.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Or.void(e, {
        at: o
      }) || Or.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function lz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lz(Object(n), !0).forEach(function(r) {
      _d(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var N0 = Mv(Mv(Mv(Mv({}, Uwe), Wwe), Hwe), Qwe), Pne = {}, uj = {}, cj = {};
Object.defineProperty(cj, "__esModule", { value: !0 });
cj.default = r1e;
var uz = "html", cz = "head", Dv = "body", e1e = /<([a-zA-Z]+[0-9]?)/, pz = /<head[^]*>/i, dz = /<body[^]*>/i, R0 = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, jM = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, fz = typeof window == "object" && window.DOMParser;
if (typeof fz == "function") {
  var t1e = new fz(), n1e = "text/html";
  jM = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), t1e.parseFromString(e, n1e);
  }, R0 = jM;
}
if (typeof document == "object" && document.implementation) {
  var _v = document.implementation.createHTMLDocument();
  R0 = function(e, t) {
    if (t) {
      var n = _v.documentElement.querySelector(t);
      return n && (n.innerHTML = e), _v;
    }
    return _v.documentElement.innerHTML = e, _v;
  };
}
var Tv = typeof document == "object" && document.createElement("template"), AM;
Tv && Tv.content && (AM = function(e) {
  return Tv.innerHTML = e, Tv.content.childNodes;
});
function r1e(e) {
  var t, n, r = e.match(e1e), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case uz: {
      var i = jM(e);
      if (!pz.test(e)) {
        var a = i.querySelector(cz);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!dz.test(e)) {
        var a = i.querySelector(Dv);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(uz);
    }
    case cz:
    case Dv: {
      var s = R0(e).querySelectorAll(o);
      return dz.test(e) && pz.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (AM)
        return AM(e);
      var a = R0(e, Dv).querySelector(Dv);
      return a.childNodes;
    }
  }
}
var VO = {}, pj = {}, dj = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(dj);
var cn = {}, uc = Dr && Dr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), wh = Dr && Dr.__assign || function() {
  return wh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, wh.apply(this, arguments);
};
Object.defineProperty(cn, "__esModule", { value: !0 });
cn.cloneNode = cn.hasChildren = cn.isDocument = cn.isDirective = cn.isComment = cn.isText = cn.isCDATA = cn.isTag = cn.Element = cn.Document = cn.CDATA = cn.NodeWithChildren = cn.ProcessingInstruction = cn.Comment = cn.Text = cn.DataNode = cn.Node = void 0;
var Es = dj, fj = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), hj(this, t);
    }, e;
  }()
);
cn.Node = fj;
var $O = (
  /** @class */
  function(e) {
    uc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(fj)
);
cn.DataNode = $O;
var Sne = (
  /** @class */
  function(e) {
    uc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Es.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }($O)
);
cn.Text = Sne;
var Mne = (
  /** @class */
  function(e) {
    uc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Es.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }($O)
);
cn.Comment = Mne;
var Dne = (
  /** @class */
  function(e) {
    uc(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Es.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }($O)
);
cn.ProcessingInstruction = Dne;
var ZO = (
  /** @class */
  function(e) {
    uc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(fj)
);
cn.NodeWithChildren = ZO;
var _ne = (
  /** @class */
  function(e) {
    uc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Es.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ZO)
);
cn.CDATA = _ne;
var Tne = (
  /** @class */
  function(e) {
    uc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Es.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ZO)
);
cn.Document = Tne;
var jne = (
  /** @class */
  function(e) {
    uc(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Es.ElementType.Script : n === "style" ? Es.ElementType.Style : Es.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ZO)
);
cn.Element = jne;
function Ane(e) {
  return (0, Es.isTag)(e);
}
cn.isTag = Ane;
function Ine(e) {
  return e.type === Es.ElementType.CDATA;
}
cn.isCDATA = Ine;
function Bne(e) {
  return e.type === Es.ElementType.Text;
}
cn.isText = Bne;
function Nne(e) {
  return e.type === Es.ElementType.Comment;
}
cn.isComment = Nne;
function Rne(e) {
  return e.type === Es.ElementType.Directive;
}
cn.isDirective = Rne;
function Fne(e) {
  return e.type === Es.ElementType.Root;
}
cn.isDocument = Fne;
function o1e(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
cn.hasChildren = o1e;
function hj(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (Bne(e))
    n = new Sne(e.data);
  else if (Nne(e))
    n = new Mne(e.data);
  else if (Ane(e)) {
    var r = t ? XL(e.children) : [], o = new jne(e.name, wh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = wh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = wh({}, e["x-attribsPrefix"])), n = o;
  } else if (Ine(e)) {
    var r = t ? XL(e.children) : [], i = new _ne(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (Fne(e)) {
    var r = t ? XL(e.children) : [], a = new Tne(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (Rne(e)) {
    var s = new Dne(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
cn.cloneNode = hj;
function XL(e) {
  for (var t = e.map(function(r) {
    return hj(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Dr && Dr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Dr && Dr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = dj, o = cn;
  n(cn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(pj);
var zne = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(zne);
Object.defineProperty(VO, "__esModule", { value: !0 });
VO.formatAttributes = Une;
VO.formatDOM = Wne;
var jv = pj, i1e = zne;
function s1e(e) {
  return i1e.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function Une(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function a1e(e) {
  e = e.toLowerCase();
  var t = s1e(e);
  return t || e;
}
function Wne(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = a1e(s.nodeName);
        o = new jv.Element(l, Une(s.attributes)), o.children = Wne(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new jv.Text(s.nodeValue);
        break;
      case 8:
        o = new jv.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new jv.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var l1e = Dr && Dr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(uj, "__esModule", { value: !0 });
uj.default = d1e;
var u1e = l1e(cj), c1e = VO, p1e = /<(![a-zA-Z\s]+)>/;
function d1e(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(p1e), n = t ? t[1] : void 0;
  return (0, c1e.formatDOM)((0, u1e.default)(e), null, n);
}
var qO = {}, Da = {}, XO = {}, f1e = 0;
XO.SAME = f1e;
var h1e = 1;
XO.CAMELCASE = h1e;
XO.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const Hne = 0, cc = 1, KO = 2, GO = 3, gj = 4, Vne = 5, $ne = 6;
function g1e(e) {
  return Ti.hasOwnProperty(e) ? Ti[e] : null;
}
function Qi(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === KO || t === GO || t === gj, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Ti = {}, m1e = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
m1e.forEach((e) => {
  Ti[e] = new Qi(
    e,
    Hne,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Ti[e] = new Qi(
    e,
    cc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Ti[e] = new Qi(
    e,
    KO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Ti[e] = new Qi(
    e,
    KO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Ti[e] = new Qi(
    e,
    GO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ti[e] = new Qi(
    e,
    GO,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ti[e] = new Qi(
    e,
    gj,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ti[e] = new Qi(
    e,
    $ne,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Ti[e] = new Qi(
    e,
    Vne,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const mj = /[\-\:]([a-z])/g, vj = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(mj, vj);
  Ti[t] = new Qi(
    t,
    cc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(mj, vj);
  Ti[t] = new Qi(
    t,
    cc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(mj, vj);
  Ti[t] = new Qi(
    t,
    cc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Ti[e] = new Qi(
    e,
    cc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const v1e = "xlinkHref";
Ti[v1e] = new Qi(
  "xlinkHref",
  cc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Ti[e] = new Qi(
    e,
    cc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: y1e,
  SAME: b1e,
  possibleStandardNames: hz
} = XO, w1e = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", O1e = w1e + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", C1e = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + O1e + "]*$")
), x1e = Object.keys(
  hz
).reduce((e, t) => {
  const n = hz[t];
  return n === b1e ? e[t] = t : n === y1e ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Da.BOOLEAN = GO;
Da.BOOLEANISH_STRING = KO;
Da.NUMERIC = Vne;
Da.OVERLOADED_BOOLEAN = gj;
Da.POSITIVE_NUMERIC = $ne;
Da.RESERVED = Hne;
Da.STRING = cc;
Da.getPropertyInfo = g1e;
Da.isCustomAttribute = C1e;
Da.possibleStandardNames = x1e;
var yj = {}, bj = {}, gz = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, L1e = /\n/g, E1e = /^\s*/, k1e = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, P1e = /^:\s*/, S1e = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, M1e = /^[;\s]*/, D1e = /^\s+|\s+$/g, _1e = `
`, mz = "/", vz = "*", up = "", T1e = "comment", j1e = "declaration", A1e = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(L1e);
    v && (n += v.length);
    var b = f.lastIndexOf(_1e);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(E1e);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(mz != e.charAt(0) || vz != e.charAt(1))) {
      for (var v = 2; up != e.charAt(v) && (vz != e.charAt(v) || mz != e.charAt(v + 1)); )
        ++v;
      if (v += 2, up === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: T1e,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(k1e);
    if (v) {
      if (p(), !l(P1e)) return s("property missing ':'");
      var b = l(S1e), L = f({
        type: j1e,
        property: yz(v[0].replace(gz, up)),
        value: b ? yz(b[0].replace(gz, up)) : up
      });
      return l(M1e), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function yz(e) {
  return e ? e.replace(D1e, up) : up;
}
var I1e = Dr && Dr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(bj, "__esModule", { value: !0 });
bj.default = N1e;
var B1e = I1e(A1e);
function N1e(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, B1e.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var YO = {};
Object.defineProperty(YO, "__esModule", { value: !0 });
YO.camelCase = void 0;
var R1e = /^--[a-zA-Z0-9_-]+$/, F1e = /-([a-z])/g, z1e = /^[^-]+$/, U1e = /^-(webkit|moz|ms|o|khtml)-/, W1e = /^-(ms)-/, H1e = function(e) {
  return !e || z1e.test(e) || R1e.test(e);
}, V1e = function(e, t) {
  return t.toUpperCase();
}, bz = function(e, t) {
  return "".concat(t, "-");
}, $1e = function(e, t) {
  return t === void 0 && (t = {}), H1e(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(W1e, bz) : e = e.replace(U1e, bz), e.replace(F1e, V1e));
};
YO.camelCase = $1e;
var Z1e = Dr && Dr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, q1e = Z1e(bj), X1e = YO;
function IM(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, q1e.default)(e, function(r, o) {
    r && o && (n[(0, X1e.camelCase)(r, t)] = o);
  }), n;
}
IM.default = IM;
var K1e = IM;
(function(e) {
  var t = Dr && Dr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Oe, r = t(K1e), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(yj);
Object.defineProperty(qO, "__esModule", { value: !0 });
qO.default = Q1e;
var nh = Da, wz = yj, G1e = ["checked", "value"], Y1e = ["input", "select", "textarea"], J1e = {
  reset: !0,
  submit: !0
};
function Q1e(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && J1e[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, nh.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = Oz(a);
    if (s) {
      var l = (0, nh.getPropertyInfo)(s);
      switch (G1e.includes(s) && Y1e.includes(t) && !r && (s = Oz("default" + a)), n[s] = i, l && l.type) {
        case nh.BOOLEAN:
          n[s] = !0;
          break;
        case nh.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    wz.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, wz.setStyleProp)(e.style, n), n;
}
function Oz(e) {
  return nh.possibleStandardNames[e];
}
var wj = {}, eOe = Dr && Dr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(wj, "__esModule", { value: !0 });
wj.default = Zne;
var KL = Oe, tOe = eOe(qO), Oh = yj, nOe = {
  cloneElement: KL.cloneElement,
  createElement: KL.createElement,
  isValidElement: KL.isValidElement
};
function Zne(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Oh.returnFirstArg, i = t.library || nOe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, Oh.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    rOe(f) ? ((0, Oh.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, tOe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = Zne(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function rOe(e) {
  return Oh.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Oh.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Dr && Dr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(uj);
  e.htmlToDOM = n.default;
  var r = t(qO);
  e.attributesToProps = r.default;
  var o = t(wj);
  e.domToReact = o.default;
  var i = pj;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(Pne);
const oOe = /* @__PURE__ */ Lwe(Pne);
oOe.default;
var _r = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function iOe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var BM = { exports: {} }, pf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cz;
function sOe() {
  if (Cz) return pf;
  Cz = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return pf.Fragment = n, pf.jsx = a, pf.jsxs = a, pf;
}
var Av = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xz;
function aOe() {
  return xz || (xz = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var T = f && g[f] || g[v];
      return typeof T == "function" ? T : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var T = arguments.length, Z = new Array(T > 1 ? T - 1 : 0), ee = 1; ee < T; ee++)
          Z[ee - 1] = arguments[ee];
        D("error", g, Z);
      }
    }
    function D(g, T, Z) {
      {
        var ee = L.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (T += "%s", Z = Z.concat([ae]));
        var ue = Z.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + T), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function R(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function N(g, T, Z) {
      var ee = g.displayName;
      if (ee)
        return ee;
      var ae = T.displayName || T.name || "";
      return ae !== "" ? Z + "(" + ae + ")" : Z;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var T = g;
            return V(T) + ".Consumer";
          case a:
            var Z = g;
            return V(Z._context) + ".Provider";
          case l:
            return N(g, g.render, "ForwardRef");
          case p:
            var ee = g.displayName || null;
            return ee !== null ? ee : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, X = 0, G, Y, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function W() {
      {
        if (X === 0) {
          G = console.log, Y = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        X++;
      }
    }
    function O() {
      {
        if (X--, X === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, g, {
              value: G
            }),
            info: H({}, g, {
              value: Y
            }),
            warn: H({}, g, {
              value: Q
            }),
            error: H({}, g, {
              value: J
            }),
            group: H({}, g, {
              value: P
            }),
            groupCollapsed: H({}, g, {
              value: _
            }),
            groupEnd: H({}, g, {
              value: z
            })
          });
        }
        X < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = L.ReactCurrentDispatcher, F;
    function j(g, T, Z) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            F = ee && ee[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, A;
    {
      var K = typeof WeakMap == "function" ? WeakMap : Map;
      A = new K();
    }
    function B(g, T) {
      if (!g || q)
        return "";
      {
        var Z = A.get(g);
        if (Z !== void 0)
          return Z;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (T) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Le) {
              ee = Le;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (Le) {
              ee = Le;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Le) {
            ee = Le;
          }
          g();
        }
      } catch (Le) {
        if (Le && ee && typeof Le.stack == "string") {
          for (var ie = Le.stack.split(`
`), we = ee.stack.split(`
`), de = ie.length - 1, fe = we.length - 1; de >= 1 && fe >= 0 && ie[de] !== we[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== we[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== we[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", g.displayName)), typeof g == "function" && A.set(g, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var kt = g ? g.displayName || g.name : "", mt = kt ? j(kt) : "";
      return typeof g == "function" && A.set(g, mt), mt;
    }
    function le(g, T, Z) {
      return B(g, !1);
    }
    function he(g) {
      var T = g.prototype;
      return !!(T && T.isReactComponent);
    }
    function re(g, T, Z) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return B(g, he(g));
      if (typeof g == "string")
        return j(g);
      switch (g) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return re(g.type, T, Z);
          case d: {
            var ee = g, ae = ee._payload, ue = ee._init;
            try {
              return re(ue(ae), T, Z);
            } catch {
            }
          }
        }
      return "";
    }
    var Se = Object.prototype.hasOwnProperty, We = {}, Ze = L.ReactDebugCurrentFrame;
    function Me(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        Ze.setExtraStackFrame(Z);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(g, T, Z, ee, ae) {
      {
        var ue = Function.call.bind(Se);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var we = Error((ee || "React class") + ": " + Z + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw we.name = "Invariant Violation", we;
              }
              ie = g[se](T, se, ee, Z, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Me(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", Z, se, typeof ie), Me(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Me(ae), w("Failed %s type: %s", Z, ie.message), Me(null));
          }
      }
    }
    var Ve = Array.isArray;
    function be(g) {
      return Ve(g);
    }
    function qe(g) {
      {
        var T = typeof Symbol == "function" && Symbol.toStringTag, Z = T && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return Z;
      }
    }
    function ct(g) {
      try {
        return ye(g), !1;
      } catch {
        return !0;
      }
    }
    function ye(g) {
      return "" + g;
    }
    function xe(g) {
      if (ct(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qe(g)), ye(g);
    }
    var Ee = L.ReactCurrentOwner, Ue = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, De, st, ve;
    ve = {};
    function wt(g) {
      if (Se.call(g, "ref")) {
        var T = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function at(g) {
      if (Se.call(g, "key")) {
        var T = Object.getOwnPropertyDescriptor(g, "key").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function lt(g, T) {
      if (typeof g.ref == "string" && Ee.current && T && Ee.current.stateNode !== T) {
        var Z = $(Ee.current.type);
        ve[Z] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ee.current.type), g.ref), ve[Z] = !0);
      }
    }
    function pt(g, T) {
      {
        var Z = function() {
          De || (De = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: Z,
          configurable: !0
        });
      }
    }
    function Ot(g, T) {
      {
        var Z = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: Z,
          configurable: !0
        });
      }
    }
    var dt = function(g, T, Z, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: T,
        ref: Z,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function Ct(g, T, Z, ee, ae) {
      {
        var ue, se = {}, ie = null, we = null;
        Z !== void 0 && (xe(Z), ie = "" + Z), at(T) && (xe(T.key), ie = "" + T.key), wt(T) && (we = T.ref, lt(T, ae));
        for (ue in T)
          Se.call(T, ue) && !Ue.hasOwnProperty(ue) && (se[ue] = T[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || we) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && pt(se, fe), we && Ot(se, fe);
        }
        return dt(g, ie, we, ae, ee, Ee.current, se);
      }
    }
    var Xe = L.ReactCurrentOwner, ht = L.ReactDebugCurrentFrame;
    function ot(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        ht.setExtraStackFrame(Z);
      } else
        ht.setExtraStackFrame(null);
    }
    var xt;
    xt = !1;
    function ft(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Pt() {
      {
        if (Xe.current) {
          var g = $(Xe.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Lt(g) {
      return "";
    }
    var St = {};
    function Et(g) {
      {
        var T = Pt();
        if (!T) {
          var Z = typeof g == "string" ? g : g.displayName || g.name;
          Z && (T = `

Check the top-level render call using <` + Z + ">.");
        }
        return T;
      }
    }
    function Mt(g, T) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var Z = Et(T);
        if (St[Z])
          return;
        St[Z] = !0;
        var ee = "";
        g && g._owner && g._owner !== Xe.current && (ee = " It was passed a child from " + $(g._owner.type) + "."), ot(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Z, ee), ot(null);
      }
    }
    function _t(g, T) {
      {
        if (typeof g != "object")
          return;
        if (be(g))
          for (var Z = 0; Z < g.length; Z++) {
            var ee = g[Z];
            ft(ee) && Mt(ee, T);
          }
        else if (ft(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              ft(se.value) && Mt(se.value, T);
        }
      }
    }
    function gt(g) {
      {
        var T = g.type;
        if (T == null || typeof T == "string")
          return;
        var Z;
        if (typeof T == "function")
          Z = T.propTypes;
        else if (typeof T == "object" && (T.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        T.$$typeof === p))
          Z = T.propTypes;
        else
          return;
        if (Z) {
          var ee = $(T);
          rt(Z, g.props, "prop", ee, g);
        } else if (T.PropTypes !== void 0 && !xt) {
          xt = !0;
          var ae = $(T);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof T.getDefaultProps == "function" && !T.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function te(g) {
      {
        for (var T = Object.keys(g.props), Z = 0; Z < T.length; Z++) {
          var ee = T[Z];
          if (ee !== "children" && ee !== "key") {
            ot(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), ot(null);
            break;
          }
        }
        g.ref !== null && (ot(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), ot(null));
      }
    }
    var Br = {};
    function Nr(g, T, Z, ee, ae, ue) {
      {
        var se = R(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var we = Lt();
          we ? ie += we : ie += Pt();
          var de;
          g === null ? de = "null" : be(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = Ct(g, T, Z, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = T.children;
          if (ze !== void 0)
            if (ee)
              if (be(ze)) {
                for (var kt = 0; kt < ze.length; kt++)
                  _t(ze[kt], g);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              _t(ze, g);
        }
        if (Se.call(T, "key")) {
          var mt = $(g), Le = Object.keys(T).filter(function(Si) {
            return Si !== "key";
          }), In = Le.length > 0 ? "{key: someKey, " + Le.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Br[mt + In]) {
            var Pi = Le.length > 0 ? "{" + Le.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, In, mt, Pi, mt), Br[mt + In] = !0;
          }
        }
        return g === r ? te(fe) : gt(fe), fe;
      }
    }
    function xi(g, T, Z) {
      return Nr(g, T, Z, !0);
    }
    function Li(g, T, Z) {
      return Nr(g, T, Z, !1);
    }
    var Ei = Li, ki = xi;
    Av.Fragment = r, Av.jsx = Ei, Av.jsxs = ki;
  }()), Av;
}
process.env.NODE_ENV === "production" ? BM.exports = sOe() : BM.exports = aOe();
var vs = BM.exports;
He({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Lz(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Wi(e) {
  var t, n;
  return Lz(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(Lz(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var qne = Symbol.for("immer-nothing"), Ez = Symbol.for("immer-draftable"), oa = Symbol.for("immer-state"), lOe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function cs(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = lOe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Od = Object.getPrototypeOf;
function Up(e) {
  return !!e && !!e[oa];
}
function Wp(e) {
  var t;
  return e ? Xne(e) || Array.isArray(e) || !!e[Ez] || !!((t = e.constructor) != null && t[Ez]) || QO(e) || eC(e) : !1;
}
var uOe = Object.prototype.constructor.toString();
function Xne(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Od(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === uOe;
}
function F0(e, t) {
  JO(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function JO(e) {
  const t = e[oa];
  return t ? t.type_ : Array.isArray(e) ? 1 : QO(e) ? 2 : eC(e) ? 3 : 0;
}
function NM(e, t) {
  return JO(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Kne(e, t, n) {
  const r = JO(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function cOe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function QO(e) {
  return e instanceof Map;
}
function eC(e) {
  return e instanceof Set;
}
function ep(e) {
  return e.copy_ || e.base_;
}
function RM(e, t) {
  if (QO(e))
    return new Map(e);
  if (eC(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Xne(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[oa];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Od(e), r);
  } else {
    const r = Od(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Oj(e, t = !1) {
  return tC(e) || Up(e) || !Wp(e) || (JO(e) > 1 && (e.set = e.add = e.clear = e.delete = pOe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Oj(r, !0))), e;
}
function pOe() {
  cs(2);
}
function tC(e) {
  return Object.isFrozen(e);
}
var dOe = {};
function Hp(e) {
  const t = dOe[e];
  return t || cs(0, e), t;
}
var hg;
function Gne() {
  return hg;
}
function fOe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function kz(e, t) {
  t && (Hp("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function FM(e) {
  zM(e), e.drafts_.forEach(hOe), e.drafts_ = null;
}
function zM(e) {
  e === hg && (hg = e.parent_);
}
function Pz(e) {
  return hg = fOe(hg, e);
}
function hOe(e) {
  const t = e[oa];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function Sz(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[oa].modified_ && (FM(t), cs(4)), Wp(e) && (e = z0(t, e), t.parent_ || U0(t, e)), t.patches_ && Hp("Patches").generateReplacementPatches_(
    n[oa].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = z0(t, n, []), FM(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== qne ? e : void 0;
}
function z0(e, t, n) {
  if (tC(t))
    return t;
  const r = t[oa];
  if (!r)
    return F0(
      t,
      (o, i) => Mz(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return U0(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), F0(
      i,
      (s, l) => Mz(e, r, o, s, l, n, a)
    ), U0(e, o, !1), n && e.patches_ && Hp("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Mz(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && cs(5), Up(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !NM(t.assigned_, r) ? i.concat(r) : void 0, l = z0(e, o, s);
    if (Kne(n, r, l), Up(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Wp(o) && !tC(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    z0(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && U0(e, o);
  }
}
function U0(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Oj(t, n);
}
function gOe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : Gne(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Cj;
  n && (o = [r], i = gg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var Cj = {
  get(e, t) {
    if (t === oa)
      return e;
    const n = ep(e);
    if (!NM(n, t))
      return mOe(e, n, t);
    const r = n[t];
    return e.finalized_ || !Wp(r) ? r : r === GL(e.base_, t) ? (YL(e), e.copy_[t] = WM(r, e)) : r;
  },
  has(e, t) {
    return t in ep(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(ep(e));
  },
  set(e, t, n) {
    const r = Yne(ep(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = GL(ep(e), t), i = o == null ? void 0 : o[oa];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (cOe(n, o) && (n !== void 0 || NM(e.base_, t)))
        return !0;
      YL(e), UM(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return GL(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, YL(e), UM(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = ep(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    cs(11);
  },
  getPrototypeOf(e) {
    return Od(e.base_);
  },
  setPrototypeOf() {
    cs(12);
  }
}, gg = {};
F0(Cj, (e, t) => {
  gg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
gg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && cs(13), gg.set.call(this, e, t, void 0);
};
gg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && cs(14), Cj.set.call(this, e[0], t, n, e[0]);
};
function GL(e, t) {
  const n = e[oa];
  return (n ? ep(n) : e)[t];
}
function mOe(e, t, n) {
  var r;
  const o = Yne(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function Yne(e, t) {
  if (!(t in e))
    return;
  let n = Od(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Od(n);
  }
}
function UM(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && UM(e.parent_));
}
function YL(e) {
  e.copy_ || (e.copy_ = RM(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var vOe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && cs(6), r !== void 0 && typeof r != "function" && cs(7);
      let o;
      if (Wp(t)) {
        const i = Pz(this), a = WM(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? FM(i) : zM(i);
        }
        return kz(i, r), Sz(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === qne && (o = void 0), this.autoFreeze_ && Oj(o, !0), r) {
          const i = [], a = [];
          Hp("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        cs(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Wp(e) || cs(8), Up(e) && (e = yOe(e));
    const t = Pz(this), n = WM(e, void 0);
    return n[oa].isManual_ = !0, zM(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[oa];
    (!n || !n.isManual_) && cs(9);
    const { scope_: r } = n;
    return kz(r, t), Sz(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Hp("Patches").applyPatches_;
    return Up(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function WM(e, t) {
  const n = QO(e) ? Hp("MapSet").proxyMap_(e, t) : eC(e) ? Hp("MapSet").proxySet_(e, t) : gOe(e, t);
  return (t ? t.scope_ : Gne()).drafts_.push(n), n;
}
function yOe(e) {
  return Up(e) || cs(10, e), Jne(e);
}
function Jne(e) {
  if (!Wp(e) || tC(e))
    return e;
  const t = e[oa];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = RM(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = RM(e, !0);
  return F0(n, (r, o) => {
    Kne(n, r, Jne(o));
  }), t && (t.finalized_ = !1), n;
}
var ia = new vOe(), xj = ia.produce;
ia.produceWithPatches.bind(
  ia
);
ia.setAutoFreeze.bind(ia);
ia.setUseStrictShallowCopy.bind(ia);
ia.applyPatches.bind(ia);
var Dz = ia.createDraft.bind(ia), _z = ia.finishDraft.bind(ia), Je = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Je.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Je.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Je.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Je.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Je.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Je.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Je.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Je.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Je.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Je.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Je.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Je.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Je.isAncestor(t, e) && !Je.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Je.equals(i, r) || Je.endsBefore(i, r) || Je.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Je.equals(a, r) || Je.isAncestor(a, r))
          return null;
        Je.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Je.equals(s, r) || Je.endsBefore(s, r) ? r[s.length - 1] -= 1 : Je.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Je.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Je.endsBefore(u, r) ? r[u.length - 1] += 1 : Je.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Je.equals(p, d))
          return r;
        if (Je.isAncestor(p, r) || Je.equals(p, r)) {
          var y = d.slice();
          return Je.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else Je.isSibling(p, d) && (Je.isAncestor(d, r) || Je.equals(d, r)) ? Je.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Je.endsBefore(d, r) || Je.equals(d, r) || Je.isAncestor(d, r) ? (Je.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Je.endsBefore(p, r) && (Je.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function mg(e) {
  "@babel/helpers - typeof";
  return mg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, mg(e);
}
function bOe(e, t) {
  if (mg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (mg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function wOe(e) {
  var t = bOe(e, "string");
  return mg(t) === "symbol" ? t : String(t);
}
function Td(e, t, n) {
  return t = wOe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Tz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function df(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Tz(Object(n), !0).forEach(function(r) {
      Td(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var OOe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = It.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of en.points(t))
          t[l] = Kr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = It.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of en.points(t))
          t[b] = Kr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = It.get(e, L), D = Je.previous(L), x = It.get(e, D), m = It.parent(e, L), C = L[L.length - 1];
      if (Go.isText(w) && Go.isText(x))
        x.text += w.text;
      else if (!Go.isText(w) && !Go.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(Is.stringify(w), " ").concat(Is.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of en.points(t))
          t[U] = Kr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: R
      } = n;
      if (Je.isAncestor(k, R))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(R, "] because the destination is inside itself."));
      var N = It.get(e, k), V = It.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var H = Je.transform(k, n), X = It.get(e, Je.parent(H)), G = H[H.length - 1];
      if (X.children.splice(G, 0, N), t)
        for (var [Y, Q] of en.points(t))
          t[Q] = Kr.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = It.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of en.points(t)) {
          var W = Kr.transform(z, n);
          if (t != null && W != null)
            t[M] = W;
          else {
            var O = void 0, I = void 0;
            for (var [F, j] of It.texts(e))
              if (Je.compare(j, J) === -1)
                O = [F, j];
              else {
                I = [F, j];
                break;
              }
            var q = !1;
            O && I && (Je.equals(I[1], J) ? q = !Je.hasPrevious(I[1]) : q = Je.common(O[1], J).length < Je.common(I[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : I ? (z.path = I[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: K,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = It.leaf(e, A), he = le.text.slice(0, K), re = le.text.slice(K + B.length);
      if (le.text = he + re, t)
        for (var [Se, We] of en.points(t))
          t[We] = Kr.transform(Se, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: Me,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = It.get(e, Ze);
      for (var be in rt) {
        if (be === "children" || be === "text")
          throw new Error('Cannot set the "'.concat(be, '" property of nodes!'));
        var qe = rt[be];
        qe == null ? delete Ve[be] : Ve[be] = qe;
      }
      for (var ct in Me)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!en.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Is.stringify(ye), " when there is no current selection."));
          t = df({}, ye);
        }
        for (var xe in ye) {
          var Ee = ye[xe];
          if (Ee == null) {
            if (xe === "anchor" || xe === "focus")
              throw new Error('Cannot remove the "'.concat(xe, '" selection property'));
            delete t[xe];
          } else
            t[xe] = Ee;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ue,
        position: De,
        properties: st
      } = n;
      if (Ue.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ue, "] because the root node cannot be split."));
      var ve = It.get(e, Ue), wt = It.parent(e, Ue), at = Ue[Ue.length - 1], lt;
      if (Go.isText(ve)) {
        var pt = ve.text.slice(0, De), Ot = ve.text.slice(De);
        ve.text = pt, lt = df(df({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = ve.children.slice(0, De), Ct = ve.children.slice(De);
        ve.children = dt, lt = df(df({}, st), {}, {
          children: Ct
        });
      }
      if (wt.children.splice(at + 1, 0, lt), t)
        for (var [Xe, ht] of en.points(t))
          t[ht] = Kr.transform(Xe, n);
      break;
    }
  }
  return t;
}, COe = {
  transform(e, t) {
    e.children = Dz(e.children);
    var n = e.selection && Dz(e.selection);
    try {
      n = OOe(e, n, t);
    } finally {
      e.children = _z(e.children), n ? e.selection = Up(n) ? _z(n) : n : e.selection = null;
    }
  }
}, xOe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, LOe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Qne = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Wi(r) && Wi(o)) {
      if (!Qne(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function EOe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function vg(e, t) {
  if (e == null) return {};
  var n = EOe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var kOe = ["anchor", "focus"];
function jz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function POe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jz(Object(n), !0).forEach(function(r) {
      Td(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var en = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return en.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = en.edges(e);
    return t;
  },
  equals(e, t) {
    return Kr.equals(e.anchor, t.anchor) && Kr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (en.isRange(t)) {
      if (en.includes(e, t.anchor) || en.includes(e, t.focus))
        return !0;
      var [n, r] = en.edges(e), [o, i] = en.edges(t);
      return Kr.isBefore(n, o) && Kr.isAfter(r, i);
    }
    var [a, s] = en.edges(e), l = !1, u = !1;
    return Kr.isPoint(t) ? (l = Kr.compare(t, a) >= 0, u = Kr.compare(t, s) <= 0) : (l = Je.compare(t, a.path) >= 0, u = Je.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = vg(e, kOe), [r, o] = en.edges(e), [i, a] = en.edges(t), s = Kr.isBefore(r, i) ? i : r, l = Kr.isBefore(o, a) ? o : a;
    return Kr.isBefore(l, s) ? null : POe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Kr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Kr.equals(t, n);
  },
  isExpanded(e) {
    return !en.isCollapsed(e);
  },
  isForward(e) {
    return !en.isBackward(e);
  },
  isRange(e) {
    return Wi(e) && Kr.isPoint(e.anchor) && Kr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = en.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return xj(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = en.isCollapsed(r);
        en.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? en.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Kr.transform(r.anchor, t, {
        affinity: i
      }), u = Kr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, Az = (e) => Wi(e) && It.isNodeList(e.children) && !Cr.isEditor(e), jl = {
  isAncestor(e) {
    return Wi(e) && It.isNodeList(e.children);
  },
  isElement: Az,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => jl.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return Az(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, SOe = ["children"], MOe = ["text"], Iz = /* @__PURE__ */ new WeakMap(), It = {
  ancestor(e, t) {
    var n = It.get(e, t);
    if (Go.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Is.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Je.ancestors(t, n)) {
        var o = It.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Go.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Is.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Is.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = It.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = It.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Je.common(t, n), o = It.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = It.get(e, t);
    if (Cr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Is.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of It.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of It.nodes(e, t))
        jl.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (jl.isAncestor(e)) {
      var t = vg(e, SOe);
      return t;
    } else {
      var t = vg(e, MOe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = It.get(e, n); r && !(Go.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Go.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Is.stringify(e)));
    var n = xj({
      children: e.children
    }, (r) => {
      var [o, i] = en.edges(t), a = It.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !en.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!en.includes(t, s)) {
          var l = It.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Je.equals(s, i.path)) {
          var c = It.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Je.equals(s, o.path)) {
          var p = It.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Cr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Go.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Is.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Go.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Go.isText(e) || jl.isElement(e) || Cr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = Iz.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => It.isNode(r));
    return Iz.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = It.get(e, n); r && !(Go.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = It.get(e, t);
    if (!Go.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Is.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Je.levels(t, n)) {
        var o = It.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return jl.isElement(e) && jl.isElementProps(t) && jl.matches(e, t) || Go.isText(e) && Go.isTextProps(t) && Go.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Je.isBefore(s, i) : Je.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Go.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Je.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = It.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Je.next(s);
          if (It.has(e, c)) {
            s = c, l = It.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Je.previous(s);
          s = p, l = It.get(e, s);
          continue;
        }
        s = Je.parent(s), l = It.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Je.parent(t), r = It.get(e, n);
    if (Go.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Go.isText(e) ? e.text : e.children.map(It.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of It.nodes(e, t))
        Go.isText(n) && (yield [n, r]);
    }();
  }
};
function Bz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Bz(Object(n), !0).forEach(function(r) {
      Td(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Bz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rh = {
  isNodeOperation(e) {
    return rh.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Wi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Je.isPath(e.path) && It.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Je.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Je.isPath(e.path) && Wi(e.properties);
      case "move_node":
        return Je.isPath(e.path) && Je.isPath(e.newPath);
      case "remove_node":
        return Je.isPath(e.path) && It.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Je.isPath(e.path);
      case "set_node":
        return Je.isPath(e.path) && Wi(e.properties) && Wi(e.newProperties);
      case "set_selection":
        return e.properties === null && en.isRange(e.newProperties) || e.newProperties === null && en.isRange(e.properties) || Wi(e.properties) && Wi(e.newProperties);
      case "split_node":
        return Je.isPath(e.path) && typeof e.position == "number" && Wi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => rh.isOperation(t));
  },
  isSelectionOperation(e) {
    return rh.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return rh.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return oo(oo({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return oo(oo({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return oo(oo({}, e), {}, {
          type: "split_node",
          path: Je.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Je.equals(t, n))
          return e;
        if (Je.isSibling(n, t))
          return oo(oo({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Je.transform(n, e), o = Je.transform(Je.next(n), e);
        return oo(oo({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return oo(oo({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return oo(oo({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return oo(oo({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? oo(oo({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? oo(oo({}, e), {}, {
          properties: null,
          newProperties: s
        }) : oo(oo({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return oo(oo({}, e), {}, {
          type: "merge_node",
          path: Je.next(e.path)
        });
    }
  }
}, Nz = /* @__PURE__ */ new WeakMap(), DOe = (e) => {
  var t = Nz.get(e);
  if (t !== void 0)
    return t;
  if (!Wi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Wi(e.marks)) && (e.selection === null || en.isRange(e.selection)) && It.isNodeList(e.children) && rh.isOperationList(e.operations);
  return Nz.set(e, n), n;
}, Cr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return DOe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function Rz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Rz(Object(n), !0).forEach(function(r) {
      Td(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Kr = {
  compare(e, t) {
    var n = Je.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Kr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Kr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Je.equals(e.path, t.path);
  },
  isPoint(e) {
    return Wi(e) && typeof e.offset == "number" && Je.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return xj(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Je.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Je.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Je.equals(t.path, i) && (r.offset += t.position), r.path = Je.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Je.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Je.equals(t.path, i) || Je.isAncestor(t.path, i))
            return null;
          r.path = Je.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Je.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Je.transform(i, t, Fz(Fz({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Je.transform(i, t, n);
          break;
        }
      }
    });
  }
}, zz = void 0, Is = {
  setScrubber(e) {
    zz = e;
  },
  stringify(e) {
    return JSON.stringify(e, zz);
  }
}, _Oe = ["text"], TOe = ["anchor", "focus"];
function Uz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ml(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Uz(Object(n), !0).forEach(function(r) {
      Td(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Uz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Go = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = vg(i, _Oe);
      return a;
    }
    return Qne(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Wi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Go.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [ml({}, e)];
    for (var r of t) {
      var o = vg(r, TOe), [i, a] = en.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = ml(ml({}, f), {}, {
            text: f.text.slice(L)
          }), f = ml(ml({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = ml(ml({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = ml(ml({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, jOe = (e) => e.selection ? e.selection : e.children.length > 0 ? Cr.end(e, []) : [0], Ur;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Ur || (Ur = {}));
Ur.L, Ur.L | Ur.V | Ur.LV | Ur.LVT, Ur.LV | Ur.V, Ur.V | Ur.T, Ur.LVT | Ur.T, Ur.T, Ur.Any, Ur.Extend | Ur.ZWJ, Ur.Any, Ur.SpacingMark, Ur.Prepend, Ur.Any, Ur.ZWJ, Ur.ExtPict, Ur.RI, Ur.RI;
var AOe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Cr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = jOe(e)
      } = n;
      if (Je.isPath(o) && (o = Cr.range(e, o)), en.isRange(o))
        if (en.isCollapsed(o))
          o = o.anchor;
        else {
          var i = en.end(o);
          if (!r && Cr.void(e, {
            at: i
          }))
            return;
          var a = en.start(o), s = Cr.pointRef(e, a), l = Cr.pointRef(e, i);
          W0.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, W0.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Cr.void(e, {
        at: o
      }) || Cr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function Wz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Iv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Wz(Object(n), !0).forEach(function(r) {
      Td(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Wz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var W0 = Iv(Iv(Iv(Iv({}, COe), xOe), LOe), AOe), ere = {}, Lj = {}, Ej = {};
Object.defineProperty(Ej, "__esModule", { value: !0 });
Ej.default = ROe;
var Hz = "html", Vz = "head", Bv = "body", IOe = /<([a-zA-Z]+[0-9]?)/, $z = /<head[^]*>/i, Zz = /<body[^]*>/i, H0 = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, HM = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, qz = typeof window == "object" && window.DOMParser;
if (typeof qz == "function") {
  var BOe = new qz(), NOe = "text/html";
  HM = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), BOe.parseFromString(e, NOe);
  }, H0 = HM;
}
if (typeof document == "object" && document.implementation) {
  var Nv = document.implementation.createHTMLDocument();
  H0 = function(e, t) {
    if (t) {
      var n = Nv.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Nv;
    }
    return Nv.documentElement.innerHTML = e, Nv;
  };
}
var Rv = typeof document == "object" && document.createElement("template"), VM;
Rv && Rv.content && (VM = function(e) {
  return Rv.innerHTML = e, Rv.content.childNodes;
});
function ROe(e) {
  var t, n, r = e.match(IOe), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case Hz: {
      var i = HM(e);
      if (!$z.test(e)) {
        var a = i.querySelector(Vz);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!Zz.test(e)) {
        var a = i.querySelector(Bv);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(Hz);
    }
    case Vz:
    case Bv: {
      var s = H0(e).querySelectorAll(o);
      return Zz.test(e) && $z.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (VM)
        return VM(e);
      var a = H0(e, Bv).querySelector(Bv);
      return a.childNodes;
    }
  }
}
var nC = {}, kj = {}, Pj = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Pj);
var pn = {}, pc = _r && _r.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Ch = _r && _r.__assign || function() {
  return Ch = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ch.apply(this, arguments);
};
Object.defineProperty(pn, "__esModule", { value: !0 });
pn.cloneNode = pn.hasChildren = pn.isDocument = pn.isDirective = pn.isComment = pn.isText = pn.isCDATA = pn.isTag = pn.Element = pn.Document = pn.CDATA = pn.NodeWithChildren = pn.ProcessingInstruction = pn.Comment = pn.Text = pn.DataNode = pn.Node = void 0;
var ks = Pj, Sj = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), Mj(this, t);
    }, e;
  }()
);
pn.Node = Sj;
var rC = (
  /** @class */
  function(e) {
    pc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Sj)
);
pn.DataNode = rC;
var tre = (
  /** @class */
  function(e) {
    pc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ks.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rC)
);
pn.Text = tre;
var nre = (
  /** @class */
  function(e) {
    pc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ks.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rC)
);
pn.Comment = nre;
var rre = (
  /** @class */
  function(e) {
    pc(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = ks.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rC)
);
pn.ProcessingInstruction = rre;
var oC = (
  /** @class */
  function(e) {
    pc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Sj)
);
pn.NodeWithChildren = oC;
var ore = (
  /** @class */
  function(e) {
    pc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ks.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(oC)
);
pn.CDATA = ore;
var ire = (
  /** @class */
  function(e) {
    pc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ks.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(oC)
);
pn.Document = ire;
var sre = (
  /** @class */
  function(e) {
    pc(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? ks.ElementType.Script : n === "style" ? ks.ElementType.Style : ks.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(oC)
);
pn.Element = sre;
function are(e) {
  return (0, ks.isTag)(e);
}
pn.isTag = are;
function lre(e) {
  return e.type === ks.ElementType.CDATA;
}
pn.isCDATA = lre;
function ure(e) {
  return e.type === ks.ElementType.Text;
}
pn.isText = ure;
function cre(e) {
  return e.type === ks.ElementType.Comment;
}
pn.isComment = cre;
function pre(e) {
  return e.type === ks.ElementType.Directive;
}
pn.isDirective = pre;
function dre(e) {
  return e.type === ks.ElementType.Root;
}
pn.isDocument = dre;
function FOe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
pn.hasChildren = FOe;
function Mj(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (ure(e))
    n = new tre(e.data);
  else if (cre(e))
    n = new nre(e.data);
  else if (are(e)) {
    var r = t ? JL(e.children) : [], o = new sre(e.name, Ch({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Ch({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Ch({}, e["x-attribsPrefix"])), n = o;
  } else if (lre(e)) {
    var r = t ? JL(e.children) : [], i = new ore(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (dre(e)) {
    var r = t ? JL(e.children) : [], a = new ire(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (pre(e)) {
    var s = new rre(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
pn.cloneNode = Mj;
function JL(e) {
  for (var t = e.map(function(r) {
    return Mj(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = _r && _r.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = _r && _r.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Pj, o = pn;
  n(pn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(kj);
var fre = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(fre);
Object.defineProperty(nC, "__esModule", { value: !0 });
nC.formatAttributes = hre;
nC.formatDOM = gre;
var Fv = kj, zOe = fre;
function UOe(e) {
  return zOe.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function hre(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function WOe(e) {
  e = e.toLowerCase();
  var t = UOe(e);
  return t || e;
}
function gre(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = WOe(s.nodeName);
        o = new Fv.Element(l, hre(s.attributes)), o.children = gre(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Fv.Text(s.nodeValue);
        break;
      case 8:
        o = new Fv.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Fv.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var HOe = _r && _r.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Lj, "__esModule", { value: !0 });
Lj.default = qOe;
var VOe = HOe(Ej), $Oe = nC, ZOe = /<(![a-zA-Z\s]+)>/;
function qOe(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(ZOe), n = t ? t[1] : void 0;
  return (0, $Oe.formatDOM)((0, VOe.default)(e), null, n);
}
var iC = {}, _a = {}, sC = {}, XOe = 0;
sC.SAME = XOe;
var KOe = 1;
sC.CAMELCASE = KOe;
sC.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const mre = 0, dc = 1, aC = 2, lC = 3, Dj = 4, vre = 5, yre = 6;
function GOe(e) {
  return ji.hasOwnProperty(e) ? ji[e] : null;
}
function es(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === aC || t === lC || t === Dj, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const ji = {}, YOe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
YOe.forEach((e) => {
  ji[e] = new es(
    e,
    mre,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ji[e] = new es(
    e,
    dc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ji[e] = new es(
    e,
    aC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ji[e] = new es(
    e,
    aC,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ji[e] = new es(
    e,
    lC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ji[e] = new es(
    e,
    lC,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ji[e] = new es(
    e,
    Dj,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ji[e] = new es(
    e,
    yre,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ji[e] = new es(
    e,
    vre,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const _j = /[\-\:]([a-z])/g, Tj = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(_j, Tj);
  ji[t] = new es(
    t,
    dc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(_j, Tj);
  ji[t] = new es(
    t,
    dc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(_j, Tj);
  ji[t] = new es(
    t,
    dc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ji[e] = new es(
    e,
    dc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const JOe = "xlinkHref";
ji[JOe] = new es(
  "xlinkHref",
  dc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ji[e] = new es(
    e,
    dc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: QOe,
  SAME: eCe,
  possibleStandardNames: Xz
} = sC, tCe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", nCe = tCe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", rCe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + nCe + "]*$")
), oCe = Object.keys(
  Xz
).reduce((e, t) => {
  const n = Xz[t];
  return n === eCe ? e[t] = t : n === QOe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
_a.BOOLEAN = lC;
_a.BOOLEANISH_STRING = aC;
_a.NUMERIC = vre;
_a.OVERLOADED_BOOLEAN = Dj;
_a.POSITIVE_NUMERIC = yre;
_a.RESERVED = mre;
_a.STRING = dc;
_a.getPropertyInfo = GOe;
_a.isCustomAttribute = rCe;
_a.possibleStandardNames = oCe;
var jj = {}, Aj = {}, Kz = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, iCe = /\n/g, sCe = /^\s*/, aCe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, lCe = /^:\s*/, uCe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, cCe = /^[;\s]*/, pCe = /^\s+|\s+$/g, dCe = `
`, Gz = "/", Yz = "*", cp = "", fCe = "comment", hCe = "declaration", gCe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(iCe);
    v && (n += v.length);
    var b = f.lastIndexOf(dCe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(sCe);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(Gz != e.charAt(0) || Yz != e.charAt(1))) {
      for (var v = 2; cp != e.charAt(v) && (Yz != e.charAt(v) || Gz != e.charAt(v + 1)); )
        ++v;
      if (v += 2, cp === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: fCe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(aCe);
    if (v) {
      if (p(), !l(lCe)) return s("property missing ':'");
      var b = l(uCe), L = f({
        type: hCe,
        property: Jz(v[0].replace(Kz, cp)),
        value: b ? Jz(b[0].replace(Kz, cp)) : cp
      });
      return l(cCe), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function Jz(e) {
  return e ? e.replace(pCe, cp) : cp;
}
var mCe = _r && _r.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Aj, "__esModule", { value: !0 });
Aj.default = yCe;
var vCe = mCe(gCe);
function yCe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, vCe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var uC = {};
Object.defineProperty(uC, "__esModule", { value: !0 });
uC.camelCase = void 0;
var bCe = /^--[a-zA-Z0-9_-]+$/, wCe = /-([a-z])/g, OCe = /^[^-]+$/, CCe = /^-(webkit|moz|ms|o|khtml)-/, xCe = /^-(ms)-/, LCe = function(e) {
  return !e || OCe.test(e) || bCe.test(e);
}, ECe = function(e, t) {
  return t.toUpperCase();
}, Qz = function(e, t) {
  return "".concat(t, "-");
}, kCe = function(e, t) {
  return t === void 0 && (t = {}), LCe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(xCe, Qz) : e = e.replace(CCe, Qz), e.replace(wCe, ECe));
};
uC.camelCase = kCe;
var PCe = _r && _r.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, SCe = PCe(Aj), MCe = uC;
function $M(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, SCe.default)(e, function(r, o) {
    r && o && (n[(0, MCe.camelCase)(r, t)] = o);
  }), n;
}
$M.default = $M;
var DCe = $M;
(function(e) {
  var t = _r && _r.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Oe, r = t(DCe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(jj);
Object.defineProperty(iC, "__esModule", { value: !0 });
iC.default = ACe;
var oh = _a, e2 = jj, _Ce = ["checked", "value"], TCe = ["input", "select", "textarea"], jCe = {
  reset: !0,
  submit: !0
};
function ACe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && jCe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, oh.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = t2(a);
    if (s) {
      var l = (0, oh.getPropertyInfo)(s);
      switch (_Ce.includes(s) && TCe.includes(t) && !r && (s = t2("default" + a)), n[s] = i, l && l.type) {
        case oh.BOOLEAN:
          n[s] = !0;
          break;
        case oh.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    e2.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, e2.setStyleProp)(e.style, n), n;
}
function t2(e) {
  return oh.possibleStandardNames[e];
}
var Ij = {}, ICe = _r && _r.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ij, "__esModule", { value: !0 });
Ij.default = bre;
var QL = Oe, BCe = ICe(iC), xh = jj, NCe = {
  cloneElement: QL.cloneElement,
  createElement: QL.createElement,
  isValidElement: QL.isValidElement
};
function bre(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || xh.returnFirstArg, i = t.library || NCe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, xh.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    RCe(f) ? ((0, xh.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, BCe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = bre(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function RCe(e) {
  return xh.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, xh.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = _r && _r.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(Lj);
  e.htmlToDOM = n.default;
  var r = t(iC);
  e.attributesToProps = r.default;
  var o = t(Ij);
  e.domToReact = o.default;
  var i = kj;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(ere);
const FCe = /* @__PURE__ */ iOe(ere);
FCe.default;
var Tr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function zCe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ZM = { exports: {} }, ff = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var n2;
function UCe() {
  if (n2) return ff;
  n2 = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return ff.Fragment = n, ff.jsx = a, ff.jsxs = a, ff;
}
var zv = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var r2;
function WCe() {
  return r2 || (r2 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var T = f && g[f] || g[v];
      return typeof T == "function" ? T : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var T = arguments.length, Z = new Array(T > 1 ? T - 1 : 0), ee = 1; ee < T; ee++)
          Z[ee - 1] = arguments[ee];
        D("error", g, Z);
      }
    }
    function D(g, T, Z) {
      {
        var ee = L.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (T += "%s", Z = Z.concat([ae]));
        var ue = Z.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + T), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function R(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function N(g, T, Z) {
      var ee = g.displayName;
      if (ee)
        return ee;
      var ae = T.displayName || T.name || "";
      return ae !== "" ? Z + "(" + ae + ")" : Z;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var T = g;
            return V(T) + ".Consumer";
          case a:
            var Z = g;
            return V(Z._context) + ".Provider";
          case l:
            return N(g, g.render, "ForwardRef");
          case p:
            var ee = g.displayName || null;
            return ee !== null ? ee : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, X = 0, G, Y, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function W() {
      {
        if (X === 0) {
          G = console.log, Y = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        X++;
      }
    }
    function O() {
      {
        if (X--, X === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, g, {
              value: G
            }),
            info: H({}, g, {
              value: Y
            }),
            warn: H({}, g, {
              value: Q
            }),
            error: H({}, g, {
              value: J
            }),
            group: H({}, g, {
              value: P
            }),
            groupCollapsed: H({}, g, {
              value: _
            }),
            groupEnd: H({}, g, {
              value: z
            })
          });
        }
        X < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = L.ReactCurrentDispatcher, F;
    function j(g, T, Z) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            F = ee && ee[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, A;
    {
      var K = typeof WeakMap == "function" ? WeakMap : Map;
      A = new K();
    }
    function B(g, T) {
      if (!g || q)
        return "";
      {
        var Z = A.get(g);
        if (Z !== void 0)
          return Z;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (T) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Le) {
              ee = Le;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (Le) {
              ee = Le;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Le) {
            ee = Le;
          }
          g();
        }
      } catch (Le) {
        if (Le && ee && typeof Le.stack == "string") {
          for (var ie = Le.stack.split(`
`), we = ee.stack.split(`
`), de = ie.length - 1, fe = we.length - 1; de >= 1 && fe >= 0 && ie[de] !== we[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== we[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== we[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", g.displayName)), typeof g == "function" && A.set(g, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var kt = g ? g.displayName || g.name : "", mt = kt ? j(kt) : "";
      return typeof g == "function" && A.set(g, mt), mt;
    }
    function le(g, T, Z) {
      return B(g, !1);
    }
    function he(g) {
      var T = g.prototype;
      return !!(T && T.isReactComponent);
    }
    function re(g, T, Z) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return B(g, he(g));
      if (typeof g == "string")
        return j(g);
      switch (g) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return re(g.type, T, Z);
          case d: {
            var ee = g, ae = ee._payload, ue = ee._init;
            try {
              return re(ue(ae), T, Z);
            } catch {
            }
          }
        }
      return "";
    }
    var Se = Object.prototype.hasOwnProperty, We = {}, Ze = L.ReactDebugCurrentFrame;
    function Me(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        Ze.setExtraStackFrame(Z);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(g, T, Z, ee, ae) {
      {
        var ue = Function.call.bind(Se);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var we = Error((ee || "React class") + ": " + Z + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw we.name = "Invariant Violation", we;
              }
              ie = g[se](T, se, ee, Z, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Me(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", Z, se, typeof ie), Me(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Me(ae), w("Failed %s type: %s", Z, ie.message), Me(null));
          }
      }
    }
    var Ve = Array.isArray;
    function be(g) {
      return Ve(g);
    }
    function qe(g) {
      {
        var T = typeof Symbol == "function" && Symbol.toStringTag, Z = T && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return Z;
      }
    }
    function ct(g) {
      try {
        return ye(g), !1;
      } catch {
        return !0;
      }
    }
    function ye(g) {
      return "" + g;
    }
    function xe(g) {
      if (ct(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qe(g)), ye(g);
    }
    var Ee = L.ReactCurrentOwner, Ue = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, De, st, ve;
    ve = {};
    function wt(g) {
      if (Se.call(g, "ref")) {
        var T = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function at(g) {
      if (Se.call(g, "key")) {
        var T = Object.getOwnPropertyDescriptor(g, "key").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function lt(g, T) {
      if (typeof g.ref == "string" && Ee.current && T && Ee.current.stateNode !== T) {
        var Z = $(Ee.current.type);
        ve[Z] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ee.current.type), g.ref), ve[Z] = !0);
      }
    }
    function pt(g, T) {
      {
        var Z = function() {
          De || (De = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: Z,
          configurable: !0
        });
      }
    }
    function Ot(g, T) {
      {
        var Z = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: Z,
          configurable: !0
        });
      }
    }
    var dt = function(g, T, Z, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: T,
        ref: Z,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function Ct(g, T, Z, ee, ae) {
      {
        var ue, se = {}, ie = null, we = null;
        Z !== void 0 && (xe(Z), ie = "" + Z), at(T) && (xe(T.key), ie = "" + T.key), wt(T) && (we = T.ref, lt(T, ae));
        for (ue in T)
          Se.call(T, ue) && !Ue.hasOwnProperty(ue) && (se[ue] = T[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || we) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && pt(se, fe), we && Ot(se, fe);
        }
        return dt(g, ie, we, ae, ee, Ee.current, se);
      }
    }
    var Xe = L.ReactCurrentOwner, ht = L.ReactDebugCurrentFrame;
    function ot(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        ht.setExtraStackFrame(Z);
      } else
        ht.setExtraStackFrame(null);
    }
    var xt;
    xt = !1;
    function ft(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Pt() {
      {
        if (Xe.current) {
          var g = $(Xe.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Lt(g) {
      return "";
    }
    var St = {};
    function Et(g) {
      {
        var T = Pt();
        if (!T) {
          var Z = typeof g == "string" ? g : g.displayName || g.name;
          Z && (T = `

Check the top-level render call using <` + Z + ">.");
        }
        return T;
      }
    }
    function Mt(g, T) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var Z = Et(T);
        if (St[Z])
          return;
        St[Z] = !0;
        var ee = "";
        g && g._owner && g._owner !== Xe.current && (ee = " It was passed a child from " + $(g._owner.type) + "."), ot(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Z, ee), ot(null);
      }
    }
    function _t(g, T) {
      {
        if (typeof g != "object")
          return;
        if (be(g))
          for (var Z = 0; Z < g.length; Z++) {
            var ee = g[Z];
            ft(ee) && Mt(ee, T);
          }
        else if (ft(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              ft(se.value) && Mt(se.value, T);
        }
      }
    }
    function gt(g) {
      {
        var T = g.type;
        if (T == null || typeof T == "string")
          return;
        var Z;
        if (typeof T == "function")
          Z = T.propTypes;
        else if (typeof T == "object" && (T.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        T.$$typeof === p))
          Z = T.propTypes;
        else
          return;
        if (Z) {
          var ee = $(T);
          rt(Z, g.props, "prop", ee, g);
        } else if (T.PropTypes !== void 0 && !xt) {
          xt = !0;
          var ae = $(T);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof T.getDefaultProps == "function" && !T.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function te(g) {
      {
        for (var T = Object.keys(g.props), Z = 0; Z < T.length; Z++) {
          var ee = T[Z];
          if (ee !== "children" && ee !== "key") {
            ot(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), ot(null);
            break;
          }
        }
        g.ref !== null && (ot(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), ot(null));
      }
    }
    var Br = {};
    function Nr(g, T, Z, ee, ae, ue) {
      {
        var se = R(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var we = Lt();
          we ? ie += we : ie += Pt();
          var de;
          g === null ? de = "null" : be(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = Ct(g, T, Z, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = T.children;
          if (ze !== void 0)
            if (ee)
              if (be(ze)) {
                for (var kt = 0; kt < ze.length; kt++)
                  _t(ze[kt], g);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              _t(ze, g);
        }
        if (Se.call(T, "key")) {
          var mt = $(g), Le = Object.keys(T).filter(function(Si) {
            return Si !== "key";
          }), In = Le.length > 0 ? "{key: someKey, " + Le.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Br[mt + In]) {
            var Pi = Le.length > 0 ? "{" + Le.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, In, mt, Pi, mt), Br[mt + In] = !0;
          }
        }
        return g === r ? te(fe) : gt(fe), fe;
      }
    }
    function xi(g, T, Z) {
      return Nr(g, T, Z, !0);
    }
    function Li(g, T, Z) {
      return Nr(g, T, Z, !1);
    }
    var Ei = Li, ki = xi;
    zv.Fragment = r, zv.jsx = Ei, zv.jsxs = ki;
  }()), zv;
}
process.env.NODE_ENV === "production" ? ZM.exports = UCe() : ZM.exports = WCe();
var ys = ZM.exports;
He({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function o2(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Hi(e) {
  var t, n;
  return o2(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(o2(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var wre = Symbol.for("immer-nothing"), i2 = Symbol.for("immer-draftable"), sa = Symbol.for("immer-state"), HCe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ps(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = HCe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Cd = Object.getPrototypeOf;
function Vp(e) {
  return !!e && !!e[sa];
}
function $p(e) {
  var t;
  return e ? Ore(e) || Array.isArray(e) || !!e[i2] || !!((t = e.constructor) != null && t[i2]) || pC(e) || dC(e) : !1;
}
var VCe = Object.prototype.constructor.toString();
function Ore(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Cd(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === VCe;
}
function V0(e, t) {
  cC(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function cC(e) {
  const t = e[sa];
  return t ? t.type_ : Array.isArray(e) ? 1 : pC(e) ? 2 : dC(e) ? 3 : 0;
}
function qM(e, t) {
  return cC(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Cre(e, t, n) {
  const r = cC(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function $Ce(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function pC(e) {
  return e instanceof Map;
}
function dC(e) {
  return e instanceof Set;
}
function tp(e) {
  return e.copy_ || e.base_;
}
function XM(e, t) {
  if (pC(e))
    return new Map(e);
  if (dC(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Ore(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[sa];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Cd(e), r);
  } else {
    const r = Cd(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Bj(e, t = !1) {
  return fC(e) || Vp(e) || !$p(e) || (cC(e) > 1 && (e.set = e.add = e.clear = e.delete = ZCe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Bj(r, !0))), e;
}
function ZCe() {
  ps(2);
}
function fC(e) {
  return Object.isFrozen(e);
}
var qCe = {};
function Zp(e) {
  const t = qCe[e];
  return t || ps(0, e), t;
}
var yg;
function xre() {
  return yg;
}
function XCe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function s2(e, t) {
  t && (Zp("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function KM(e) {
  GM(e), e.drafts_.forEach(KCe), e.drafts_ = null;
}
function GM(e) {
  e === yg && (yg = e.parent_);
}
function a2(e) {
  return yg = XCe(yg, e);
}
function KCe(e) {
  const t = e[sa];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function l2(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[sa].modified_ && (KM(t), ps(4)), $p(e) && (e = $0(t, e), t.parent_ || Z0(t, e)), t.patches_ && Zp("Patches").generateReplacementPatches_(
    n[sa].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = $0(t, n, []), KM(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== wre ? e : void 0;
}
function $0(e, t, n) {
  if (fC(t))
    return t;
  const r = t[sa];
  if (!r)
    return V0(
      t,
      (o, i) => u2(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Z0(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), V0(
      i,
      (s, l) => u2(e, r, o, s, l, n, a)
    ), Z0(e, o, !1), n && e.patches_ && Zp("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function u2(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ps(5), Vp(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !qM(t.assigned_, r) ? i.concat(r) : void 0, l = $0(e, o, s);
    if (Cre(n, r, l), Vp(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if ($p(o) && !fC(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    $0(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Z0(e, o);
  }
}
function Z0(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Bj(t, n);
}
function GCe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : xre(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Nj;
  n && (o = [r], i = bg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var Nj = {
  get(e, t) {
    if (t === sa)
      return e;
    const n = tp(e);
    if (!qM(n, t))
      return YCe(e, n, t);
    const r = n[t];
    return e.finalized_ || !$p(r) ? r : r === eE(e.base_, t) ? (tE(e), e.copy_[t] = JM(r, e)) : r;
  },
  has(e, t) {
    return t in tp(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(tp(e));
  },
  set(e, t, n) {
    const r = Lre(tp(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = eE(tp(e), t), i = o == null ? void 0 : o[sa];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if ($Ce(n, o) && (n !== void 0 || qM(e.base_, t)))
        return !0;
      tE(e), YM(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return eE(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, tE(e), YM(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = tp(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ps(11);
  },
  getPrototypeOf(e) {
    return Cd(e.base_);
  },
  setPrototypeOf() {
    ps(12);
  }
}, bg = {};
V0(Nj, (e, t) => {
  bg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
bg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ps(13), bg.set.call(this, e, t, void 0);
};
bg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ps(14), Nj.set.call(this, e[0], t, n, e[0]);
};
function eE(e, t) {
  const n = e[sa];
  return (n ? tp(n) : e)[t];
}
function YCe(e, t, n) {
  var r;
  const o = Lre(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function Lre(e, t) {
  if (!(t in e))
    return;
  let n = Cd(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Cd(n);
  }
}
function YM(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && YM(e.parent_));
}
function tE(e) {
  e.copy_ || (e.copy_ = XM(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var JCe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ps(6), r !== void 0 && typeof r != "function" && ps(7);
      let o;
      if ($p(t)) {
        const i = a2(this), a = JM(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? KM(i) : GM(i);
        }
        return s2(i, r), l2(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === wre && (o = void 0), this.autoFreeze_ && Bj(o, !0), r) {
          const i = [], a = [];
          Zp("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ps(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    $p(e) || ps(8), Vp(e) && (e = QCe(e));
    const t = a2(this), n = JM(e, void 0);
    return n[sa].isManual_ = !0, GM(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[sa];
    (!n || !n.isManual_) && ps(9);
    const { scope_: r } = n;
    return s2(r, t), l2(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Zp("Patches").applyPatches_;
    return Vp(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function JM(e, t) {
  const n = pC(e) ? Zp("MapSet").proxyMap_(e, t) : dC(e) ? Zp("MapSet").proxySet_(e, t) : GCe(e, t);
  return (t ? t.scope_ : xre()).drafts_.push(n), n;
}
function QCe(e) {
  return Vp(e) || ps(10, e), Ere(e);
}
function Ere(e) {
  if (!$p(e) || fC(e))
    return e;
  const t = e[sa];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = XM(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = XM(e, !0);
  return V0(n, (r, o) => {
    Cre(n, r, Ere(o));
  }), t && (t.finalized_ = !1), n;
}
var aa = new JCe(), Rj = aa.produce;
aa.produceWithPatches.bind(
  aa
);
aa.setAutoFreeze.bind(aa);
aa.setUseStrictShallowCopy.bind(aa);
aa.applyPatches.bind(aa);
var c2 = aa.createDraft.bind(aa), p2 = aa.finishDraft.bind(aa), Qe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Qe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Qe.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Qe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Qe.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Qe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Qe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Qe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Qe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Qe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Qe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Qe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Qe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Qe.isAncestor(t, e) && !Qe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Qe.equals(i, r) || Qe.endsBefore(i, r) || Qe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Qe.equals(a, r) || Qe.isAncestor(a, r))
          return null;
        Qe.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Qe.equals(s, r) || Qe.endsBefore(s, r) ? r[s.length - 1] -= 1 : Qe.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Qe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Qe.endsBefore(u, r) ? r[u.length - 1] += 1 : Qe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Qe.equals(p, d))
          return r;
        if (Qe.isAncestor(p, r) || Qe.equals(p, r)) {
          var y = d.slice();
          return Qe.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else Qe.isSibling(p, d) && (Qe.isAncestor(d, r) || Qe.equals(d, r)) ? Qe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Qe.endsBefore(d, r) || Qe.equals(d, r) || Qe.isAncestor(d, r) ? (Qe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Qe.endsBefore(p, r) && (Qe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function wg(e) {
  "@babel/helpers - typeof";
  return wg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, wg(e);
}
function exe(e, t) {
  if (wg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (wg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function txe(e) {
  var t = exe(e, "string");
  return wg(t) === "symbol" ? t : String(t);
}
function jd(e, t, n) {
  return t = txe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function d2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? d2(Object(n), !0).forEach(function(r) {
      jd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : d2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nxe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Bt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of tn.points(t))
          t[l] = Gr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Bt.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of tn.points(t))
          t[b] = Gr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = Bt.get(e, L), D = Qe.previous(L), x = Bt.get(e, D), m = Bt.parent(e, L), C = L[L.length - 1];
      if (Yo.isText(w) && Yo.isText(x))
        x.text += w.text;
      else if (!Yo.isText(w) && !Yo.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(Bs.stringify(w), " ").concat(Bs.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of tn.points(t))
          t[U] = Gr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: R
      } = n;
      if (Qe.isAncestor(k, R))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(R, "] because the destination is inside itself."));
      var N = Bt.get(e, k), V = Bt.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var H = Qe.transform(k, n), X = Bt.get(e, Qe.parent(H)), G = H[H.length - 1];
      if (X.children.splice(G, 0, N), t)
        for (var [Y, Q] of tn.points(t))
          t[Q] = Gr.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = Bt.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of tn.points(t)) {
          var W = Gr.transform(z, n);
          if (t != null && W != null)
            t[M] = W;
          else {
            var O = void 0, I = void 0;
            for (var [F, j] of Bt.texts(e))
              if (Qe.compare(j, J) === -1)
                O = [F, j];
              else {
                I = [F, j];
                break;
              }
            var q = !1;
            O && I && (Qe.equals(I[1], J) ? q = !Qe.hasPrevious(I[1]) : q = Qe.common(O[1], J).length < Qe.common(I[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : I ? (z.path = I[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: K,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = Bt.leaf(e, A), he = le.text.slice(0, K), re = le.text.slice(K + B.length);
      if (le.text = he + re, t)
        for (var [Se, We] of tn.points(t))
          t[We] = Gr.transform(Se, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: Me,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = Bt.get(e, Ze);
      for (var be in rt) {
        if (be === "children" || be === "text")
          throw new Error('Cannot set the "'.concat(be, '" property of nodes!'));
        var qe = rt[be];
        qe == null ? delete Ve[be] : Ve[be] = qe;
      }
      for (var ct in Me)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!tn.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Bs.stringify(ye), " when there is no current selection."));
          t = hf({}, ye);
        }
        for (var xe in ye) {
          var Ee = ye[xe];
          if (Ee == null) {
            if (xe === "anchor" || xe === "focus")
              throw new Error('Cannot remove the "'.concat(xe, '" selection property'));
            delete t[xe];
          } else
            t[xe] = Ee;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ue,
        position: De,
        properties: st
      } = n;
      if (Ue.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ue, "] because the root node cannot be split."));
      var ve = Bt.get(e, Ue), wt = Bt.parent(e, Ue), at = Ue[Ue.length - 1], lt;
      if (Yo.isText(ve)) {
        var pt = ve.text.slice(0, De), Ot = ve.text.slice(De);
        ve.text = pt, lt = hf(hf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = ve.children.slice(0, De), Ct = ve.children.slice(De);
        ve.children = dt, lt = hf(hf({}, st), {}, {
          children: Ct
        });
      }
      if (wt.children.splice(at + 1, 0, lt), t)
        for (var [Xe, ht] of tn.points(t))
          t[ht] = Gr.transform(Xe, n);
      break;
    }
  }
  return t;
}, rxe = {
  transform(e, t) {
    e.children = c2(e.children);
    var n = e.selection && c2(e.selection);
    try {
      n = nxe(e, n, t);
    } finally {
      e.children = p2(e.children), n ? e.selection = Vp(n) ? p2(n) : n : e.selection = null;
    }
  }
}, oxe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, ixe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, kre = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Hi(r) && Hi(o)) {
      if (!kre(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function sxe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Og(e, t) {
  if (e == null) return {};
  var n = sxe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var axe = ["anchor", "focus"];
function f2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lxe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? f2(Object(n), !0).forEach(function(r) {
      jd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : f2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tn = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return tn.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = tn.edges(e);
    return t;
  },
  equals(e, t) {
    return Gr.equals(e.anchor, t.anchor) && Gr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (tn.isRange(t)) {
      if (tn.includes(e, t.anchor) || tn.includes(e, t.focus))
        return !0;
      var [n, r] = tn.edges(e), [o, i] = tn.edges(t);
      return Gr.isBefore(n, o) && Gr.isAfter(r, i);
    }
    var [a, s] = tn.edges(e), l = !1, u = !1;
    return Gr.isPoint(t) ? (l = Gr.compare(t, a) >= 0, u = Gr.compare(t, s) <= 0) : (l = Qe.compare(t, a.path) >= 0, u = Qe.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Og(e, axe), [r, o] = tn.edges(e), [i, a] = tn.edges(t), s = Gr.isBefore(r, i) ? i : r, l = Gr.isBefore(o, a) ? o : a;
    return Gr.isBefore(l, s) ? null : lxe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Gr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Gr.equals(t, n);
  },
  isExpanded(e) {
    return !tn.isCollapsed(e);
  },
  isForward(e) {
    return !tn.isBackward(e);
  },
  isRange(e) {
    return Hi(e) && Gr.isPoint(e.anchor) && Gr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = tn.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Rj(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = tn.isCollapsed(r);
        tn.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? tn.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Gr.transform(r.anchor, t, {
        affinity: i
      }), u = Gr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, h2 = (e) => Hi(e) && Bt.isNodeList(e.children) && !xr.isEditor(e), Al = {
  isAncestor(e) {
    return Hi(e) && Bt.isNodeList(e.children);
  },
  isElement: h2,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Al.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return h2(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, uxe = ["children"], cxe = ["text"], g2 = /* @__PURE__ */ new WeakMap(), Bt = {
  ancestor(e, t) {
    var n = Bt.get(e, t);
    if (Yo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Bs.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Qe.ancestors(t, n)) {
        var o = Bt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Yo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Bs.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Bs.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Bt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Bt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Qe.common(t, n), o = Bt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Bt.get(e, t);
    if (xr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Bs.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Bt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Bt.nodes(e, t))
        Al.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Al.isAncestor(e)) {
      var t = Og(e, uxe);
      return t;
    } else {
      var t = Og(e, cxe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Bt.get(e, n); r && !(Yo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Yo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Bs.stringify(e)));
    var n = Rj({
      children: e.children
    }, (r) => {
      var [o, i] = tn.edges(t), a = Bt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !tn.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!tn.includes(t, s)) {
          var l = Bt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Qe.equals(s, i.path)) {
          var c = Bt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Qe.equals(s, o.path)) {
          var p = Bt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      xr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Yo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Bs.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Yo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Yo.isText(e) || Al.isElement(e) || xr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = g2.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Bt.isNode(r));
    return g2.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Bt.get(e, n); r && !(Yo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Bt.get(e, t);
    if (!Yo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Bs.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Qe.levels(t, n)) {
        var o = Bt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Al.isElement(e) && Al.isElementProps(t) && Al.matches(e, t) || Yo.isText(e) && Yo.isTextProps(t) && Yo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Qe.isBefore(s, i) : Qe.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Yo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Qe.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Bt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Qe.next(s);
          if (Bt.has(e, c)) {
            s = c, l = Bt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Qe.previous(s);
          s = p, l = Bt.get(e, s);
          continue;
        }
        s = Qe.parent(s), l = Bt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Qe.parent(t), r = Bt.get(e, n);
    if (Yo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Yo.isText(e) ? e.text : e.children.map(Bt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Bt.nodes(e, t))
        Yo.isText(n) && (yield [n, r]);
    }();
  }
};
function m2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function io(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? m2(Object(n), !0).forEach(function(r) {
      jd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : m2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ih = {
  isNodeOperation(e) {
    return ih.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Hi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Qe.isPath(e.path) && Bt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Qe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Qe.isPath(e.path) && Hi(e.properties);
      case "move_node":
        return Qe.isPath(e.path) && Qe.isPath(e.newPath);
      case "remove_node":
        return Qe.isPath(e.path) && Bt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Qe.isPath(e.path);
      case "set_node":
        return Qe.isPath(e.path) && Hi(e.properties) && Hi(e.newProperties);
      case "set_selection":
        return e.properties === null && tn.isRange(e.newProperties) || e.newProperties === null && tn.isRange(e.properties) || Hi(e.properties) && Hi(e.newProperties);
      case "split_node":
        return Qe.isPath(e.path) && typeof e.position == "number" && Hi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => ih.isOperation(t));
  },
  isSelectionOperation(e) {
    return ih.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return ih.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return io(io({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return io(io({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return io(io({}, e), {}, {
          type: "split_node",
          path: Qe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Qe.equals(t, n))
          return e;
        if (Qe.isSibling(n, t))
          return io(io({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Qe.transform(n, e), o = Qe.transform(Qe.next(n), e);
        return io(io({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return io(io({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return io(io({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return io(io({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? io(io({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? io(io({}, e), {}, {
          properties: null,
          newProperties: s
        }) : io(io({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return io(io({}, e), {}, {
          type: "merge_node",
          path: Qe.next(e.path)
        });
    }
  }
}, v2 = /* @__PURE__ */ new WeakMap(), pxe = (e) => {
  var t = v2.get(e);
  if (t !== void 0)
    return t;
  if (!Hi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Hi(e.marks)) && (e.selection === null || tn.isRange(e.selection)) && Bt.isNodeList(e.children) && ih.isOperationList(e.operations);
  return v2.set(e, n), n;
}, xr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return pxe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function y2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function b2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? y2(Object(n), !0).forEach(function(r) {
      jd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : y2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Gr = {
  compare(e, t) {
    var n = Qe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Gr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Gr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Qe.equals(e.path, t.path);
  },
  isPoint(e) {
    return Hi(e) && typeof e.offset == "number" && Qe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Rj(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Qe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Qe.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Qe.equals(t.path, i) && (r.offset += t.position), r.path = Qe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Qe.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Qe.equals(t.path, i) || Qe.isAncestor(t.path, i))
            return null;
          r.path = Qe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Qe.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Qe.transform(i, t, b2(b2({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Qe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, w2 = void 0, Bs = {
  setScrubber(e) {
    w2 = e;
  },
  stringify(e) {
    return JSON.stringify(e, w2);
  }
}, dxe = ["text"], fxe = ["anchor", "focus"];
function O2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? O2(Object(n), !0).forEach(function(r) {
      jd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : O2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Og(i, dxe);
      return a;
    }
    return kre(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Hi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Yo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [vl({}, e)];
    for (var r of t) {
      var o = Og(r, fxe), [i, a] = tn.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = vl(vl({}, f), {}, {
            text: f.text.slice(L)
          }), f = vl(vl({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = vl(vl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = vl(vl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, hxe = (e) => e.selection ? e.selection : e.children.length > 0 ? xr.end(e, []) : [0], Wr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Wr || (Wr = {}));
Wr.L, Wr.L | Wr.V | Wr.LV | Wr.LVT, Wr.LV | Wr.V, Wr.V | Wr.T, Wr.LVT | Wr.T, Wr.T, Wr.Any, Wr.Extend | Wr.ZWJ, Wr.Any, Wr.SpacingMark, Wr.Prepend, Wr.Any, Wr.ZWJ, Wr.ExtPict, Wr.RI, Wr.RI;
var gxe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    xr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = hxe(e)
      } = n;
      if (Qe.isPath(o) && (o = xr.range(e, o)), tn.isRange(o))
        if (tn.isCollapsed(o))
          o = o.anchor;
        else {
          var i = tn.end(o);
          if (!r && xr.void(e, {
            at: i
          }))
            return;
          var a = tn.start(o), s = xr.pointRef(e, a), l = xr.pointRef(e, i);
          q0.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, q0.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && xr.void(e, {
        at: o
      }) || xr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function C2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? C2(Object(n), !0).forEach(function(r) {
      jd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : C2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var q0 = Uv(Uv(Uv(Uv({}, rxe), oxe), ixe), gxe), Pre = {}, Fj = {}, zj = {};
Object.defineProperty(zj, "__esModule", { value: !0 });
zj.default = bxe;
var x2 = "html", L2 = "head", Wv = "body", mxe = /<([a-zA-Z]+[0-9]?)/, E2 = /<head[^]*>/i, k2 = /<body[^]*>/i, X0 = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, QM = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, P2 = typeof window == "object" && window.DOMParser;
if (typeof P2 == "function") {
  var vxe = new P2(), yxe = "text/html";
  QM = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), vxe.parseFromString(e, yxe);
  }, X0 = QM;
}
if (typeof document == "object" && document.implementation) {
  var Hv = document.implementation.createHTMLDocument();
  X0 = function(e, t) {
    if (t) {
      var n = Hv.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Hv;
    }
    return Hv.documentElement.innerHTML = e, Hv;
  };
}
var Vv = typeof document == "object" && document.createElement("template"), eD;
Vv && Vv.content && (eD = function(e) {
  return Vv.innerHTML = e, Vv.content.childNodes;
});
function bxe(e) {
  var t, n, r = e.match(mxe), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case x2: {
      var i = QM(e);
      if (!E2.test(e)) {
        var a = i.querySelector(L2);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!k2.test(e)) {
        var a = i.querySelector(Wv);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(x2);
    }
    case L2:
    case Wv: {
      var s = X0(e).querySelectorAll(o);
      return k2.test(e) && E2.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (eD)
        return eD(e);
      var a = X0(e, Wv).querySelector(Wv);
      return a.childNodes;
    }
  }
}
var hC = {}, Uj = {}, Wj = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Wj);
var dn = {}, fc = Tr && Tr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Lh = Tr && Tr.__assign || function() {
  return Lh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Lh.apply(this, arguments);
};
Object.defineProperty(dn, "__esModule", { value: !0 });
dn.cloneNode = dn.hasChildren = dn.isDocument = dn.isDirective = dn.isComment = dn.isText = dn.isCDATA = dn.isTag = dn.Element = dn.Document = dn.CDATA = dn.NodeWithChildren = dn.ProcessingInstruction = dn.Comment = dn.Text = dn.DataNode = dn.Node = void 0;
var Ps = Wj, Hj = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), Vj(this, t);
    }, e;
  }()
);
dn.Node = Hj;
var gC = (
  /** @class */
  function(e) {
    fc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Hj)
);
dn.DataNode = gC;
var Sre = (
  /** @class */
  function(e) {
    fc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ps.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gC)
);
dn.Text = Sre;
var Mre = (
  /** @class */
  function(e) {
    fc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ps.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gC)
);
dn.Comment = Mre;
var Dre = (
  /** @class */
  function(e) {
    fc(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ps.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gC)
);
dn.ProcessingInstruction = Dre;
var mC = (
  /** @class */
  function(e) {
    fc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Hj)
);
dn.NodeWithChildren = mC;
var _re = (
  /** @class */
  function(e) {
    fc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ps.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(mC)
);
dn.CDATA = _re;
var Tre = (
  /** @class */
  function(e) {
    fc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ps.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(mC)
);
dn.Document = Tre;
var jre = (
  /** @class */
  function(e) {
    fc(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ps.ElementType.Script : n === "style" ? Ps.ElementType.Style : Ps.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(mC)
);
dn.Element = jre;
function Are(e) {
  return (0, Ps.isTag)(e);
}
dn.isTag = Are;
function Ire(e) {
  return e.type === Ps.ElementType.CDATA;
}
dn.isCDATA = Ire;
function Bre(e) {
  return e.type === Ps.ElementType.Text;
}
dn.isText = Bre;
function Nre(e) {
  return e.type === Ps.ElementType.Comment;
}
dn.isComment = Nre;
function Rre(e) {
  return e.type === Ps.ElementType.Directive;
}
dn.isDirective = Rre;
function Fre(e) {
  return e.type === Ps.ElementType.Root;
}
dn.isDocument = Fre;
function wxe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
dn.hasChildren = wxe;
function Vj(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (Bre(e))
    n = new Sre(e.data);
  else if (Nre(e))
    n = new Mre(e.data);
  else if (Are(e)) {
    var r = t ? nE(e.children) : [], o = new jre(e.name, Lh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Lh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Lh({}, e["x-attribsPrefix"])), n = o;
  } else if (Ire(e)) {
    var r = t ? nE(e.children) : [], i = new _re(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (Fre(e)) {
    var r = t ? nE(e.children) : [], a = new Tre(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (Rre(e)) {
    var s = new Dre(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
dn.cloneNode = Vj;
function nE(e) {
  for (var t = e.map(function(r) {
    return Vj(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Tr && Tr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Tr && Tr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Wj, o = dn;
  n(dn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(Uj);
var zre = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(zre);
Object.defineProperty(hC, "__esModule", { value: !0 });
hC.formatAttributes = Ure;
hC.formatDOM = Wre;
var $v = Uj, Oxe = zre;
function Cxe(e) {
  return Oxe.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function Ure(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function xxe(e) {
  e = e.toLowerCase();
  var t = Cxe(e);
  return t || e;
}
function Wre(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = xxe(s.nodeName);
        o = new $v.Element(l, Ure(s.attributes)), o.children = Wre(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new $v.Text(s.nodeValue);
        break;
      case 8:
        o = new $v.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new $v.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var Lxe = Tr && Tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Fj, "__esModule", { value: !0 });
Fj.default = Sxe;
var Exe = Lxe(zj), kxe = hC, Pxe = /<(![a-zA-Z\s]+)>/;
function Sxe(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Pxe), n = t ? t[1] : void 0;
  return (0, kxe.formatDOM)((0, Exe.default)(e), null, n);
}
var vC = {}, Ta = {}, yC = {}, Mxe = 0;
yC.SAME = Mxe;
var Dxe = 1;
yC.CAMELCASE = Dxe;
yC.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const Hre = 0, hc = 1, bC = 2, wC = 3, $j = 4, Vre = 5, $re = 6;
function _xe(e) {
  return Ai.hasOwnProperty(e) ? Ai[e] : null;
}
function ts(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === bC || t === wC || t === $j, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Ai = {}, Txe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Txe.forEach((e) => {
  Ai[e] = new ts(
    e,
    Hre,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Ai[e] = new ts(
    e,
    hc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Ai[e] = new ts(
    e,
    bC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Ai[e] = new ts(
    e,
    bC,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Ai[e] = new ts(
    e,
    wC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ai[e] = new ts(
    e,
    wC,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ai[e] = new ts(
    e,
    $j,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ai[e] = new ts(
    e,
    $re,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Ai[e] = new ts(
    e,
    Vre,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Zj = /[\-\:]([a-z])/g, qj = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Zj, qj);
  Ai[t] = new ts(
    t,
    hc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Zj, qj);
  Ai[t] = new ts(
    t,
    hc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Zj, qj);
  Ai[t] = new ts(
    t,
    hc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Ai[e] = new ts(
    e,
    hc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const jxe = "xlinkHref";
Ai[jxe] = new ts(
  "xlinkHref",
  hc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Ai[e] = new ts(
    e,
    hc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Axe,
  SAME: Ixe,
  possibleStandardNames: S2
} = yC, Bxe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Nxe = Bxe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Rxe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Nxe + "]*$")
), Fxe = Object.keys(
  S2
).reduce((e, t) => {
  const n = S2[t];
  return n === Ixe ? e[t] = t : n === Axe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Ta.BOOLEAN = wC;
Ta.BOOLEANISH_STRING = bC;
Ta.NUMERIC = Vre;
Ta.OVERLOADED_BOOLEAN = $j;
Ta.POSITIVE_NUMERIC = $re;
Ta.RESERVED = Hre;
Ta.STRING = hc;
Ta.getPropertyInfo = _xe;
Ta.isCustomAttribute = Rxe;
Ta.possibleStandardNames = Fxe;
var Xj = {}, Kj = {}, M2 = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, zxe = /\n/g, Uxe = /^\s*/, Wxe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Hxe = /^:\s*/, Vxe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, $xe = /^[;\s]*/, Zxe = /^\s+|\s+$/g, qxe = `
`, D2 = "/", _2 = "*", pp = "", Xxe = "comment", Kxe = "declaration", Gxe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(zxe);
    v && (n += v.length);
    var b = f.lastIndexOf(qxe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(Uxe);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(D2 != e.charAt(0) || _2 != e.charAt(1))) {
      for (var v = 2; pp != e.charAt(v) && (_2 != e.charAt(v) || D2 != e.charAt(v + 1)); )
        ++v;
      if (v += 2, pp === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: Xxe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(Wxe);
    if (v) {
      if (p(), !l(Hxe)) return s("property missing ':'");
      var b = l(Vxe), L = f({
        type: Kxe,
        property: T2(v[0].replace(M2, pp)),
        value: b ? T2(b[0].replace(M2, pp)) : pp
      });
      return l($xe), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function T2(e) {
  return e ? e.replace(Zxe, pp) : pp;
}
var Yxe = Tr && Tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Kj, "__esModule", { value: !0 });
Kj.default = Qxe;
var Jxe = Yxe(Gxe);
function Qxe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Jxe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var OC = {};
Object.defineProperty(OC, "__esModule", { value: !0 });
OC.camelCase = void 0;
var eLe = /^--[a-zA-Z0-9_-]+$/, tLe = /-([a-z])/g, nLe = /^[^-]+$/, rLe = /^-(webkit|moz|ms|o|khtml)-/, oLe = /^-(ms)-/, iLe = function(e) {
  return !e || nLe.test(e) || eLe.test(e);
}, sLe = function(e, t) {
  return t.toUpperCase();
}, j2 = function(e, t) {
  return "".concat(t, "-");
}, aLe = function(e, t) {
  return t === void 0 && (t = {}), iLe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(oLe, j2) : e = e.replace(rLe, j2), e.replace(tLe, sLe));
};
OC.camelCase = aLe;
var lLe = Tr && Tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, uLe = lLe(Kj), cLe = OC;
function tD(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, uLe.default)(e, function(r, o) {
    r && o && (n[(0, cLe.camelCase)(r, t)] = o);
  }), n;
}
tD.default = tD;
var pLe = tD;
(function(e) {
  var t = Tr && Tr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Oe, r = t(pLe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Xj);
Object.defineProperty(vC, "__esModule", { value: !0 });
vC.default = gLe;
var sh = Ta, A2 = Xj, dLe = ["checked", "value"], fLe = ["input", "select", "textarea"], hLe = {
  reset: !0,
  submit: !0
};
function gLe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && hLe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, sh.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = I2(a);
    if (s) {
      var l = (0, sh.getPropertyInfo)(s);
      switch (dLe.includes(s) && fLe.includes(t) && !r && (s = I2("default" + a)), n[s] = i, l && l.type) {
        case sh.BOOLEAN:
          n[s] = !0;
          break;
        case sh.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    A2.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, A2.setStyleProp)(e.style, n), n;
}
function I2(e) {
  return sh.possibleStandardNames[e];
}
var Gj = {}, mLe = Tr && Tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Gj, "__esModule", { value: !0 });
Gj.default = Zre;
var rE = Oe, vLe = mLe(vC), Eh = Xj, yLe = {
  cloneElement: rE.cloneElement,
  createElement: rE.createElement,
  isValidElement: rE.isValidElement
};
function Zre(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Eh.returnFirstArg, i = t.library || yLe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, Eh.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    bLe(f) ? ((0, Eh.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, vLe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = Zre(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function bLe(e) {
  return Eh.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Eh.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Tr && Tr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(Fj);
  e.htmlToDOM = n.default;
  var r = t(vC);
  e.attributesToProps = r.default;
  var o = t(Gj);
  e.domToReact = o.default;
  var i = Uj;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(Pre);
const wLe = /* @__PURE__ */ zCe(Pre);
wLe.default;
var jr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function OLe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var nD = { exports: {} }, gf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var B2;
function CLe() {
  if (B2) return gf;
  B2 = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return gf.Fragment = n, gf.jsx = a, gf.jsxs = a, gf;
}
var Zv = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var N2;
function xLe() {
  return N2 || (N2 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var T = f && g[f] || g[v];
      return typeof T == "function" ? T : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var T = arguments.length, Z = new Array(T > 1 ? T - 1 : 0), ee = 1; ee < T; ee++)
          Z[ee - 1] = arguments[ee];
        D("error", g, Z);
      }
    }
    function D(g, T, Z) {
      {
        var ee = L.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (T += "%s", Z = Z.concat([ae]));
        var ue = Z.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + T), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function R(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function N(g, T, Z) {
      var ee = g.displayName;
      if (ee)
        return ee;
      var ae = T.displayName || T.name || "";
      return ae !== "" ? Z + "(" + ae + ")" : Z;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var T = g;
            return V(T) + ".Consumer";
          case a:
            var Z = g;
            return V(Z._context) + ".Provider";
          case l:
            return N(g, g.render, "ForwardRef");
          case p:
            var ee = g.displayName || null;
            return ee !== null ? ee : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, X = 0, G, Y, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function W() {
      {
        if (X === 0) {
          G = console.log, Y = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        X++;
      }
    }
    function O() {
      {
        if (X--, X === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, g, {
              value: G
            }),
            info: H({}, g, {
              value: Y
            }),
            warn: H({}, g, {
              value: Q
            }),
            error: H({}, g, {
              value: J
            }),
            group: H({}, g, {
              value: P
            }),
            groupCollapsed: H({}, g, {
              value: _
            }),
            groupEnd: H({}, g, {
              value: z
            })
          });
        }
        X < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = L.ReactCurrentDispatcher, F;
    function j(g, T, Z) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            F = ee && ee[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, A;
    {
      var K = typeof WeakMap == "function" ? WeakMap : Map;
      A = new K();
    }
    function B(g, T) {
      if (!g || q)
        return "";
      {
        var Z = A.get(g);
        if (Z !== void 0)
          return Z;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (T) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Le) {
              ee = Le;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (Le) {
              ee = Le;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Le) {
            ee = Le;
          }
          g();
        }
      } catch (Le) {
        if (Le && ee && typeof Le.stack == "string") {
          for (var ie = Le.stack.split(`
`), we = ee.stack.split(`
`), de = ie.length - 1, fe = we.length - 1; de >= 1 && fe >= 0 && ie[de] !== we[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== we[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== we[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", g.displayName)), typeof g == "function" && A.set(g, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var kt = g ? g.displayName || g.name : "", mt = kt ? j(kt) : "";
      return typeof g == "function" && A.set(g, mt), mt;
    }
    function le(g, T, Z) {
      return B(g, !1);
    }
    function he(g) {
      var T = g.prototype;
      return !!(T && T.isReactComponent);
    }
    function re(g, T, Z) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return B(g, he(g));
      if (typeof g == "string")
        return j(g);
      switch (g) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return re(g.type, T, Z);
          case d: {
            var ee = g, ae = ee._payload, ue = ee._init;
            try {
              return re(ue(ae), T, Z);
            } catch {
            }
          }
        }
      return "";
    }
    var Se = Object.prototype.hasOwnProperty, We = {}, Ze = L.ReactDebugCurrentFrame;
    function Me(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        Ze.setExtraStackFrame(Z);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(g, T, Z, ee, ae) {
      {
        var ue = Function.call.bind(Se);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var we = Error((ee || "React class") + ": " + Z + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw we.name = "Invariant Violation", we;
              }
              ie = g[se](T, se, ee, Z, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Me(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", Z, se, typeof ie), Me(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Me(ae), w("Failed %s type: %s", Z, ie.message), Me(null));
          }
      }
    }
    var Ve = Array.isArray;
    function be(g) {
      return Ve(g);
    }
    function qe(g) {
      {
        var T = typeof Symbol == "function" && Symbol.toStringTag, Z = T && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return Z;
      }
    }
    function ct(g) {
      try {
        return ye(g), !1;
      } catch {
        return !0;
      }
    }
    function ye(g) {
      return "" + g;
    }
    function xe(g) {
      if (ct(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qe(g)), ye(g);
    }
    var Ee = L.ReactCurrentOwner, Ue = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, De, st, ve;
    ve = {};
    function wt(g) {
      if (Se.call(g, "ref")) {
        var T = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function at(g) {
      if (Se.call(g, "key")) {
        var T = Object.getOwnPropertyDescriptor(g, "key").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function lt(g, T) {
      if (typeof g.ref == "string" && Ee.current && T && Ee.current.stateNode !== T) {
        var Z = $(Ee.current.type);
        ve[Z] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ee.current.type), g.ref), ve[Z] = !0);
      }
    }
    function pt(g, T) {
      {
        var Z = function() {
          De || (De = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: Z,
          configurable: !0
        });
      }
    }
    function Ot(g, T) {
      {
        var Z = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: Z,
          configurable: !0
        });
      }
    }
    var dt = function(g, T, Z, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: T,
        ref: Z,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function Ct(g, T, Z, ee, ae) {
      {
        var ue, se = {}, ie = null, we = null;
        Z !== void 0 && (xe(Z), ie = "" + Z), at(T) && (xe(T.key), ie = "" + T.key), wt(T) && (we = T.ref, lt(T, ae));
        for (ue in T)
          Se.call(T, ue) && !Ue.hasOwnProperty(ue) && (se[ue] = T[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || we) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && pt(se, fe), we && Ot(se, fe);
        }
        return dt(g, ie, we, ae, ee, Ee.current, se);
      }
    }
    var Xe = L.ReactCurrentOwner, ht = L.ReactDebugCurrentFrame;
    function ot(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        ht.setExtraStackFrame(Z);
      } else
        ht.setExtraStackFrame(null);
    }
    var xt;
    xt = !1;
    function ft(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Pt() {
      {
        if (Xe.current) {
          var g = $(Xe.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Lt(g) {
      return "";
    }
    var St = {};
    function Et(g) {
      {
        var T = Pt();
        if (!T) {
          var Z = typeof g == "string" ? g : g.displayName || g.name;
          Z && (T = `

Check the top-level render call using <` + Z + ">.");
        }
        return T;
      }
    }
    function Mt(g, T) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var Z = Et(T);
        if (St[Z])
          return;
        St[Z] = !0;
        var ee = "";
        g && g._owner && g._owner !== Xe.current && (ee = " It was passed a child from " + $(g._owner.type) + "."), ot(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Z, ee), ot(null);
      }
    }
    function _t(g, T) {
      {
        if (typeof g != "object")
          return;
        if (be(g))
          for (var Z = 0; Z < g.length; Z++) {
            var ee = g[Z];
            ft(ee) && Mt(ee, T);
          }
        else if (ft(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              ft(se.value) && Mt(se.value, T);
        }
      }
    }
    function gt(g) {
      {
        var T = g.type;
        if (T == null || typeof T == "string")
          return;
        var Z;
        if (typeof T == "function")
          Z = T.propTypes;
        else if (typeof T == "object" && (T.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        T.$$typeof === p))
          Z = T.propTypes;
        else
          return;
        if (Z) {
          var ee = $(T);
          rt(Z, g.props, "prop", ee, g);
        } else if (T.PropTypes !== void 0 && !xt) {
          xt = !0;
          var ae = $(T);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof T.getDefaultProps == "function" && !T.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function te(g) {
      {
        for (var T = Object.keys(g.props), Z = 0; Z < T.length; Z++) {
          var ee = T[Z];
          if (ee !== "children" && ee !== "key") {
            ot(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), ot(null);
            break;
          }
        }
        g.ref !== null && (ot(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), ot(null));
      }
    }
    var Br = {};
    function Nr(g, T, Z, ee, ae, ue) {
      {
        var se = R(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var we = Lt();
          we ? ie += we : ie += Pt();
          var de;
          g === null ? de = "null" : be(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = Ct(g, T, Z, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = T.children;
          if (ze !== void 0)
            if (ee)
              if (be(ze)) {
                for (var kt = 0; kt < ze.length; kt++)
                  _t(ze[kt], g);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              _t(ze, g);
        }
        if (Se.call(T, "key")) {
          var mt = $(g), Le = Object.keys(T).filter(function(Si) {
            return Si !== "key";
          }), In = Le.length > 0 ? "{key: someKey, " + Le.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Br[mt + In]) {
            var Pi = Le.length > 0 ? "{" + Le.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, In, mt, Pi, mt), Br[mt + In] = !0;
          }
        }
        return g === r ? te(fe) : gt(fe), fe;
      }
    }
    function xi(g, T, Z) {
      return Nr(g, T, Z, !0);
    }
    function Li(g, T, Z) {
      return Nr(g, T, Z, !1);
    }
    var Ei = Li, ki = xi;
    Zv.Fragment = r, Zv.jsx = Ei, Zv.jsxs = ki;
  }()), Zv;
}
process.env.NODE_ENV === "production" ? nD.exports = CLe() : nD.exports = xLe();
var bs = nD.exports;
He({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function R2(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Vi(e) {
  var t, n;
  return R2(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(R2(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var qre = Symbol.for("immer-nothing"), F2 = Symbol.for("immer-draftable"), la = Symbol.for("immer-state"), LLe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ds(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = LLe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var xd = Object.getPrototypeOf;
function qp(e) {
  return !!e && !!e[la];
}
function Xp(e) {
  var t;
  return e ? Xre(e) || Array.isArray(e) || !!e[F2] || !!((t = e.constructor) != null && t[F2]) || xC(e) || LC(e) : !1;
}
var ELe = Object.prototype.constructor.toString();
function Xre(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = xd(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === ELe;
}
function K0(e, t) {
  CC(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function CC(e) {
  const t = e[la];
  return t ? t.type_ : Array.isArray(e) ? 1 : xC(e) ? 2 : LC(e) ? 3 : 0;
}
function rD(e, t) {
  return CC(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Kre(e, t, n) {
  const r = CC(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function kLe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function xC(e) {
  return e instanceof Map;
}
function LC(e) {
  return e instanceof Set;
}
function np(e) {
  return e.copy_ || e.base_;
}
function oD(e, t) {
  if (xC(e))
    return new Map(e);
  if (LC(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Xre(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[la];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(xd(e), r);
  } else {
    const r = xd(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Yj(e, t = !1) {
  return EC(e) || qp(e) || !Xp(e) || (CC(e) > 1 && (e.set = e.add = e.clear = e.delete = PLe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Yj(r, !0))), e;
}
function PLe() {
  ds(2);
}
function EC(e) {
  return Object.isFrozen(e);
}
var SLe = {};
function Kp(e) {
  const t = SLe[e];
  return t || ds(0, e), t;
}
var Cg;
function Gre() {
  return Cg;
}
function MLe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function z2(e, t) {
  t && (Kp("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function iD(e) {
  sD(e), e.drafts_.forEach(DLe), e.drafts_ = null;
}
function sD(e) {
  e === Cg && (Cg = e.parent_);
}
function U2(e) {
  return Cg = MLe(Cg, e);
}
function DLe(e) {
  const t = e[la];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function W2(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[la].modified_ && (iD(t), ds(4)), Xp(e) && (e = G0(t, e), t.parent_ || Y0(t, e)), t.patches_ && Kp("Patches").generateReplacementPatches_(
    n[la].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = G0(t, n, []), iD(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== qre ? e : void 0;
}
function G0(e, t, n) {
  if (EC(t))
    return t;
  const r = t[la];
  if (!r)
    return K0(
      t,
      (o, i) => H2(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Y0(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), K0(
      i,
      (s, l) => H2(e, r, o, s, l, n, a)
    ), Y0(e, o, !1), n && e.patches_ && Kp("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function H2(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ds(5), qp(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !rD(t.assigned_, r) ? i.concat(r) : void 0, l = G0(e, o, s);
    if (Kre(n, r, l), qp(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Xp(o) && !EC(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    G0(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Y0(e, o);
  }
}
function Y0(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Yj(t, n);
}
function _Le(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : Gre(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Jj;
  n && (o = [r], i = xg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var Jj = {
  get(e, t) {
    if (t === la)
      return e;
    const n = np(e);
    if (!rD(n, t))
      return TLe(e, n, t);
    const r = n[t];
    return e.finalized_ || !Xp(r) ? r : r === oE(e.base_, t) ? (iE(e), e.copy_[t] = lD(r, e)) : r;
  },
  has(e, t) {
    return t in np(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(np(e));
  },
  set(e, t, n) {
    const r = Yre(np(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = oE(np(e), t), i = o == null ? void 0 : o[la];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (kLe(n, o) && (n !== void 0 || rD(e.base_, t)))
        return !0;
      iE(e), aD(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return oE(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, iE(e), aD(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = np(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ds(11);
  },
  getPrototypeOf(e) {
    return xd(e.base_);
  },
  setPrototypeOf() {
    ds(12);
  }
}, xg = {};
K0(Jj, (e, t) => {
  xg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
xg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ds(13), xg.set.call(this, e, t, void 0);
};
xg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ds(14), Jj.set.call(this, e[0], t, n, e[0]);
};
function oE(e, t) {
  const n = e[la];
  return (n ? np(n) : e)[t];
}
function TLe(e, t, n) {
  var r;
  const o = Yre(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function Yre(e, t) {
  if (!(t in e))
    return;
  let n = xd(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = xd(n);
  }
}
function aD(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && aD(e.parent_));
}
function iE(e) {
  e.copy_ || (e.copy_ = oD(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var jLe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ds(6), r !== void 0 && typeof r != "function" && ds(7);
      let o;
      if (Xp(t)) {
        const i = U2(this), a = lD(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? iD(i) : sD(i);
        }
        return z2(i, r), W2(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === qre && (o = void 0), this.autoFreeze_ && Yj(o, !0), r) {
          const i = [], a = [];
          Kp("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ds(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Xp(e) || ds(8), qp(e) && (e = ALe(e));
    const t = U2(this), n = lD(e, void 0);
    return n[la].isManual_ = !0, sD(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[la];
    (!n || !n.isManual_) && ds(9);
    const { scope_: r } = n;
    return z2(r, t), W2(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Kp("Patches").applyPatches_;
    return qp(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function lD(e, t) {
  const n = xC(e) ? Kp("MapSet").proxyMap_(e, t) : LC(e) ? Kp("MapSet").proxySet_(e, t) : _Le(e, t);
  return (t ? t.scope_ : Gre()).drafts_.push(n), n;
}
function ALe(e) {
  return qp(e) || ds(10, e), Jre(e);
}
function Jre(e) {
  if (!Xp(e) || EC(e))
    return e;
  const t = e[la];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = oD(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = oD(e, !0);
  return K0(n, (r, o) => {
    Kre(n, r, Jre(o));
  }), t && (t.finalized_ = !1), n;
}
var ua = new jLe(), Qj = ua.produce;
ua.produceWithPatches.bind(
  ua
);
ua.setAutoFreeze.bind(ua);
ua.setUseStrictShallowCopy.bind(ua);
ua.applyPatches.bind(ua);
var V2 = ua.createDraft.bind(ua), $2 = ua.finishDraft.bind(ua), et = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = et.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return et.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return et.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return et.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return et.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && et.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return et.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && et.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && et.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && et.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && et.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && et.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!et.isAncestor(t, e) && !et.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (et.equals(i, r) || et.endsBefore(i, r) || et.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (et.equals(a, r) || et.isAncestor(a, r))
          return null;
        et.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        et.equals(s, r) || et.endsBefore(s, r) ? r[s.length - 1] -= 1 : et.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (et.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else et.endsBefore(u, r) ? r[u.length - 1] += 1 : et.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (et.equals(p, d))
          return r;
        if (et.isAncestor(p, r) || et.equals(p, r)) {
          var y = d.slice();
          return et.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else et.isSibling(p, d) && (et.isAncestor(d, r) || et.equals(d, r)) ? et.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : et.endsBefore(d, r) || et.equals(d, r) || et.isAncestor(d, r) ? (et.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : et.endsBefore(p, r) && (et.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Lg(e) {
  "@babel/helpers - typeof";
  return Lg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Lg(e);
}
function ILe(e, t) {
  if (Lg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Lg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function BLe(e) {
  var t = ILe(e, "string");
  return Lg(t) === "symbol" ? t : String(t);
}
function Ad(e, t, n) {
  return t = BLe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Z2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Z2(Object(n), !0).forEach(function(r) {
      Ad(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Z2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var NLe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Nt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of nn.points(t))
          t[l] = Yr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Nt.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of nn.points(t))
          t[b] = Yr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = Nt.get(e, L), D = et.previous(L), x = Nt.get(e, D), m = Nt.parent(e, L), C = L[L.length - 1];
      if (Jo.isText(w) && Jo.isText(x))
        x.text += w.text;
      else if (!Jo.isText(w) && !Jo.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(Ns.stringify(w), " ").concat(Ns.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of nn.points(t))
          t[U] = Yr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: R
      } = n;
      if (et.isAncestor(k, R))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(R, "] because the destination is inside itself."));
      var N = Nt.get(e, k), V = Nt.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var H = et.transform(k, n), X = Nt.get(e, et.parent(H)), G = H[H.length - 1];
      if (X.children.splice(G, 0, N), t)
        for (var [Y, Q] of nn.points(t))
          t[Q] = Yr.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = Nt.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of nn.points(t)) {
          var W = Yr.transform(z, n);
          if (t != null && W != null)
            t[M] = W;
          else {
            var O = void 0, I = void 0;
            for (var [F, j] of Nt.texts(e))
              if (et.compare(j, J) === -1)
                O = [F, j];
              else {
                I = [F, j];
                break;
              }
            var q = !1;
            O && I && (et.equals(I[1], J) ? q = !et.hasPrevious(I[1]) : q = et.common(O[1], J).length < et.common(I[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : I ? (z.path = I[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: K,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = Nt.leaf(e, A), he = le.text.slice(0, K), re = le.text.slice(K + B.length);
      if (le.text = he + re, t)
        for (var [Se, We] of nn.points(t))
          t[We] = Yr.transform(Se, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: Me,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = Nt.get(e, Ze);
      for (var be in rt) {
        if (be === "children" || be === "text")
          throw new Error('Cannot set the "'.concat(be, '" property of nodes!'));
        var qe = rt[be];
        qe == null ? delete Ve[be] : Ve[be] = qe;
      }
      for (var ct in Me)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!nn.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Ns.stringify(ye), " when there is no current selection."));
          t = mf({}, ye);
        }
        for (var xe in ye) {
          var Ee = ye[xe];
          if (Ee == null) {
            if (xe === "anchor" || xe === "focus")
              throw new Error('Cannot remove the "'.concat(xe, '" selection property'));
            delete t[xe];
          } else
            t[xe] = Ee;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ue,
        position: De,
        properties: st
      } = n;
      if (Ue.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ue, "] because the root node cannot be split."));
      var ve = Nt.get(e, Ue), wt = Nt.parent(e, Ue), at = Ue[Ue.length - 1], lt;
      if (Jo.isText(ve)) {
        var pt = ve.text.slice(0, De), Ot = ve.text.slice(De);
        ve.text = pt, lt = mf(mf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = ve.children.slice(0, De), Ct = ve.children.slice(De);
        ve.children = dt, lt = mf(mf({}, st), {}, {
          children: Ct
        });
      }
      if (wt.children.splice(at + 1, 0, lt), t)
        for (var [Xe, ht] of nn.points(t))
          t[ht] = Yr.transform(Xe, n);
      break;
    }
  }
  return t;
}, RLe = {
  transform(e, t) {
    e.children = V2(e.children);
    var n = e.selection && V2(e.selection);
    try {
      n = NLe(e, n, t);
    } finally {
      e.children = $2(e.children), n ? e.selection = qp(n) ? $2(n) : n : e.selection = null;
    }
  }
}, FLe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, zLe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Qre = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Vi(r) && Vi(o)) {
      if (!Qre(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function ULe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Eg(e, t) {
  if (e == null) return {};
  var n = ULe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var WLe = ["anchor", "focus"];
function q2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function HLe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? q2(Object(n), !0).forEach(function(r) {
      Ad(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : q2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nn = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return nn.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = nn.edges(e);
    return t;
  },
  equals(e, t) {
    return Yr.equals(e.anchor, t.anchor) && Yr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (nn.isRange(t)) {
      if (nn.includes(e, t.anchor) || nn.includes(e, t.focus))
        return !0;
      var [n, r] = nn.edges(e), [o, i] = nn.edges(t);
      return Yr.isBefore(n, o) && Yr.isAfter(r, i);
    }
    var [a, s] = nn.edges(e), l = !1, u = !1;
    return Yr.isPoint(t) ? (l = Yr.compare(t, a) >= 0, u = Yr.compare(t, s) <= 0) : (l = et.compare(t, a.path) >= 0, u = et.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Eg(e, WLe), [r, o] = nn.edges(e), [i, a] = nn.edges(t), s = Yr.isBefore(r, i) ? i : r, l = Yr.isBefore(o, a) ? o : a;
    return Yr.isBefore(l, s) ? null : HLe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Yr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Yr.equals(t, n);
  },
  isExpanded(e) {
    return !nn.isCollapsed(e);
  },
  isForward(e) {
    return !nn.isBackward(e);
  },
  isRange(e) {
    return Vi(e) && Yr.isPoint(e.anchor) && Yr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = nn.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Qj(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = nn.isCollapsed(r);
        nn.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? nn.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Yr.transform(r.anchor, t, {
        affinity: i
      }), u = Yr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, X2 = (e) => Vi(e) && Nt.isNodeList(e.children) && !Lr.isEditor(e), Il = {
  isAncestor(e) {
    return Vi(e) && Nt.isNodeList(e.children);
  },
  isElement: X2,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Il.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return X2(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, VLe = ["children"], $Le = ["text"], K2 = /* @__PURE__ */ new WeakMap(), Nt = {
  ancestor(e, t) {
    var n = Nt.get(e, t);
    if (Jo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Ns.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of et.ancestors(t, n)) {
        var o = Nt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Jo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Ns.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Ns.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Nt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Nt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = et.common(t, n), o = Nt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Nt.get(e, t);
    if (Lr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Ns.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Nt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Nt.nodes(e, t))
        Il.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Il.isAncestor(e)) {
      var t = Eg(e, VLe);
      return t;
    } else {
      var t = Eg(e, $Le);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Nt.get(e, n); r && !(Jo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Jo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Ns.stringify(e)));
    var n = Qj({
      children: e.children
    }, (r) => {
      var [o, i] = nn.edges(t), a = Nt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !nn.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!nn.includes(t, s)) {
          var l = Nt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (et.equals(s, i.path)) {
          var c = Nt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (et.equals(s, o.path)) {
          var p = Nt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Lr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Jo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Ns.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Jo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Jo.isText(e) || Il.isElement(e) || Lr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = K2.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Nt.isNode(r));
    return K2.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Nt.get(e, n); r && !(Jo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Nt.get(e, t);
    if (!Jo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Ns.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of et.levels(t, n)) {
        var o = Nt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Il.isElement(e) && Il.isElementProps(t) && Il.matches(e, t) || Jo.isText(e) && Jo.isTextProps(t) && Jo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? et.isBefore(s, i) : et.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Jo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          et.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Nt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = et.next(s);
          if (Nt.has(e, c)) {
            s = c, l = Nt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = et.previous(s);
          s = p, l = Nt.get(e, s);
          continue;
        }
        s = et.parent(s), l = Nt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = et.parent(t), r = Nt.get(e, n);
    if (Jo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Jo.isText(e) ? e.text : e.children.map(Nt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Nt.nodes(e, t))
        Jo.isText(n) && (yield [n, r]);
    }();
  }
};
function G2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function so(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G2(Object(n), !0).forEach(function(r) {
      Ad(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ah = {
  isNodeOperation(e) {
    return ah.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Vi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return et.isPath(e.path) && Nt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && et.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && et.isPath(e.path) && Vi(e.properties);
      case "move_node":
        return et.isPath(e.path) && et.isPath(e.newPath);
      case "remove_node":
        return et.isPath(e.path) && Nt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && et.isPath(e.path);
      case "set_node":
        return et.isPath(e.path) && Vi(e.properties) && Vi(e.newProperties);
      case "set_selection":
        return e.properties === null && nn.isRange(e.newProperties) || e.newProperties === null && nn.isRange(e.properties) || Vi(e.properties) && Vi(e.newProperties);
      case "split_node":
        return et.isPath(e.path) && typeof e.position == "number" && Vi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => ah.isOperation(t));
  },
  isSelectionOperation(e) {
    return ah.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return ah.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return so(so({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return so(so({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return so(so({}, e), {}, {
          type: "split_node",
          path: et.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (et.equals(t, n))
          return e;
        if (et.isSibling(n, t))
          return so(so({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = et.transform(n, e), o = et.transform(et.next(n), e);
        return so(so({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return so(so({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return so(so({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return so(so({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? so(so({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? so(so({}, e), {}, {
          properties: null,
          newProperties: s
        }) : so(so({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return so(so({}, e), {}, {
          type: "merge_node",
          path: et.next(e.path)
        });
    }
  }
}, Y2 = /* @__PURE__ */ new WeakMap(), ZLe = (e) => {
  var t = Y2.get(e);
  if (t !== void 0)
    return t;
  if (!Vi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Vi(e.marks)) && (e.selection === null || nn.isRange(e.selection)) && Nt.isNodeList(e.children) && ah.isOperationList(e.operations);
  return Y2.set(e, n), n;
}, Lr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return ZLe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function J2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Q2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? J2(Object(n), !0).forEach(function(r) {
      Ad(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : J2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yr = {
  compare(e, t) {
    var n = et.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Yr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Yr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && et.equals(e.path, t.path);
  },
  isPoint(e) {
    return Vi(e) && typeof e.offset == "number" && et.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Qj(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = et.transform(i, t, n);
          break;
        }
        case "insert_text": {
          et.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          et.equals(t.path, i) && (r.offset += t.position), r.path = et.transform(i, t, n);
          break;
        }
        case "remove_text": {
          et.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (et.equals(t.path, i) || et.isAncestor(t.path, i))
            return null;
          r.path = et.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (et.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = et.transform(i, t, Q2(Q2({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = et.transform(i, t, n);
          break;
        }
      }
    });
  }
}, eU = void 0, Ns = {
  setScrubber(e) {
    eU = e;
  },
  stringify(e) {
    return JSON.stringify(e, eU);
  }
}, qLe = ["text"], XLe = ["anchor", "focus"];
function tU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tU(Object(n), !0).forEach(function(r) {
      Ad(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Eg(i, qLe);
      return a;
    }
    return Qre(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Vi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Jo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [yl({}, e)];
    for (var r of t) {
      var o = Eg(r, XLe), [i, a] = nn.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = yl(yl({}, f), {}, {
            text: f.text.slice(L)
          }), f = yl(yl({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = yl(yl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = yl(yl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, KLe = (e) => e.selection ? e.selection : e.children.length > 0 ? Lr.end(e, []) : [0], Hr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Hr || (Hr = {}));
Hr.L, Hr.L | Hr.V | Hr.LV | Hr.LVT, Hr.LV | Hr.V, Hr.V | Hr.T, Hr.LVT | Hr.T, Hr.T, Hr.Any, Hr.Extend | Hr.ZWJ, Hr.Any, Hr.SpacingMark, Hr.Prepend, Hr.Any, Hr.ZWJ, Hr.ExtPict, Hr.RI, Hr.RI;
var GLe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Lr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = KLe(e)
      } = n;
      if (et.isPath(o) && (o = Lr.range(e, o)), nn.isRange(o))
        if (nn.isCollapsed(o))
          o = o.anchor;
        else {
          var i = nn.end(o);
          if (!r && Lr.void(e, {
            at: i
          }))
            return;
          var a = nn.start(o), s = Lr.pointRef(e, a), l = Lr.pointRef(e, i);
          J0.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, J0.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Lr.void(e, {
        at: o
      }) || Lr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function nU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nU(Object(n), !0).forEach(function(r) {
      Ad(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var J0 = qv(qv(qv(qv({}, RLe), FLe), zLe), GLe), eoe = {}, eA = {}, tA = {};
Object.defineProperty(tA, "__esModule", { value: !0 });
tA.default = eEe;
var rU = "html", oU = "head", Xv = "body", YLe = /<([a-zA-Z]+[0-9]?)/, iU = /<head[^]*>/i, sU = /<body[^]*>/i, Q0 = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, uD = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, aU = typeof window == "object" && window.DOMParser;
if (typeof aU == "function") {
  var JLe = new aU(), QLe = "text/html";
  uD = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), JLe.parseFromString(e, QLe);
  }, Q0 = uD;
}
if (typeof document == "object" && document.implementation) {
  var Kv = document.implementation.createHTMLDocument();
  Q0 = function(e, t) {
    if (t) {
      var n = Kv.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Kv;
    }
    return Kv.documentElement.innerHTML = e, Kv;
  };
}
var Gv = typeof document == "object" && document.createElement("template"), cD;
Gv && Gv.content && (cD = function(e) {
  return Gv.innerHTML = e, Gv.content.childNodes;
});
function eEe(e) {
  var t, n, r = e.match(YLe), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case rU: {
      var i = uD(e);
      if (!iU.test(e)) {
        var a = i.querySelector(oU);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!sU.test(e)) {
        var a = i.querySelector(Xv);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(rU);
    }
    case oU:
    case Xv: {
      var s = Q0(e).querySelectorAll(o);
      return sU.test(e) && iU.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (cD)
        return cD(e);
      var a = Q0(e, Xv).querySelector(Xv);
      return a.childNodes;
    }
  }
}
var kC = {}, nA = {}, rA = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(rA);
var fn = {}, gc = jr && jr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), kh = jr && jr.__assign || function() {
  return kh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, kh.apply(this, arguments);
};
Object.defineProperty(fn, "__esModule", { value: !0 });
fn.cloneNode = fn.hasChildren = fn.isDocument = fn.isDirective = fn.isComment = fn.isText = fn.isCDATA = fn.isTag = fn.Element = fn.Document = fn.CDATA = fn.NodeWithChildren = fn.ProcessingInstruction = fn.Comment = fn.Text = fn.DataNode = fn.Node = void 0;
var Ss = rA, oA = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), iA(this, t);
    }, e;
  }()
);
fn.Node = oA;
var PC = (
  /** @class */
  function(e) {
    gc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(oA)
);
fn.DataNode = PC;
var toe = (
  /** @class */
  function(e) {
    gc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ss.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(PC)
);
fn.Text = toe;
var noe = (
  /** @class */
  function(e) {
    gc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ss.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(PC)
);
fn.Comment = noe;
var roe = (
  /** @class */
  function(e) {
    gc(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ss.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(PC)
);
fn.ProcessingInstruction = roe;
var SC = (
  /** @class */
  function(e) {
    gc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(oA)
);
fn.NodeWithChildren = SC;
var ooe = (
  /** @class */
  function(e) {
    gc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ss.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(SC)
);
fn.CDATA = ooe;
var ioe = (
  /** @class */
  function(e) {
    gc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ss.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(SC)
);
fn.Document = ioe;
var soe = (
  /** @class */
  function(e) {
    gc(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ss.ElementType.Script : n === "style" ? Ss.ElementType.Style : Ss.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(SC)
);
fn.Element = soe;
function aoe(e) {
  return (0, Ss.isTag)(e);
}
fn.isTag = aoe;
function loe(e) {
  return e.type === Ss.ElementType.CDATA;
}
fn.isCDATA = loe;
function uoe(e) {
  return e.type === Ss.ElementType.Text;
}
fn.isText = uoe;
function coe(e) {
  return e.type === Ss.ElementType.Comment;
}
fn.isComment = coe;
function poe(e) {
  return e.type === Ss.ElementType.Directive;
}
fn.isDirective = poe;
function doe(e) {
  return e.type === Ss.ElementType.Root;
}
fn.isDocument = doe;
function tEe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
fn.hasChildren = tEe;
function iA(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (uoe(e))
    n = new toe(e.data);
  else if (coe(e))
    n = new noe(e.data);
  else if (aoe(e)) {
    var r = t ? sE(e.children) : [], o = new soe(e.name, kh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = kh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = kh({}, e["x-attribsPrefix"])), n = o;
  } else if (loe(e)) {
    var r = t ? sE(e.children) : [], i = new ooe(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (doe(e)) {
    var r = t ? sE(e.children) : [], a = new ioe(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (poe(e)) {
    var s = new roe(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
fn.cloneNode = iA;
function sE(e) {
  for (var t = e.map(function(r) {
    return iA(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = jr && jr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = jr && jr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = rA, o = fn;
  n(fn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(nA);
var foe = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(foe);
Object.defineProperty(kC, "__esModule", { value: !0 });
kC.formatAttributes = hoe;
kC.formatDOM = goe;
var Yv = nA, nEe = foe;
function rEe(e) {
  return nEe.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function hoe(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function oEe(e) {
  e = e.toLowerCase();
  var t = rEe(e);
  return t || e;
}
function goe(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = oEe(s.nodeName);
        o = new Yv.Element(l, hoe(s.attributes)), o.children = goe(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Yv.Text(s.nodeValue);
        break;
      case 8:
        o = new Yv.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Yv.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var iEe = jr && jr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(eA, "__esModule", { value: !0 });
eA.default = uEe;
var sEe = iEe(tA), aEe = kC, lEe = /<(![a-zA-Z\s]+)>/;
function uEe(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(lEe), n = t ? t[1] : void 0;
  return (0, aEe.formatDOM)((0, sEe.default)(e), null, n);
}
var MC = {}, ja = {}, DC = {}, cEe = 0;
DC.SAME = cEe;
var pEe = 1;
DC.CAMELCASE = pEe;
DC.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const moe = 0, mc = 1, _C = 2, TC = 3, sA = 4, voe = 5, yoe = 6;
function dEe(e) {
  return Ii.hasOwnProperty(e) ? Ii[e] : null;
}
function ns(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === _C || t === TC || t === sA, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Ii = {}, fEe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
fEe.forEach((e) => {
  Ii[e] = new ns(
    e,
    moe,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Ii[e] = new ns(
    e,
    mc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Ii[e] = new ns(
    e,
    _C,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Ii[e] = new ns(
    e,
    _C,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Ii[e] = new ns(
    e,
    TC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ii[e] = new ns(
    e,
    TC,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ii[e] = new ns(
    e,
    sA,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ii[e] = new ns(
    e,
    yoe,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Ii[e] = new ns(
    e,
    voe,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const aA = /[\-\:]([a-z])/g, lA = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(aA, lA);
  Ii[t] = new ns(
    t,
    mc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(aA, lA);
  Ii[t] = new ns(
    t,
    mc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(aA, lA);
  Ii[t] = new ns(
    t,
    mc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Ii[e] = new ns(
    e,
    mc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const hEe = "xlinkHref";
Ii[hEe] = new ns(
  "xlinkHref",
  mc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Ii[e] = new ns(
    e,
    mc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: gEe,
  SAME: mEe,
  possibleStandardNames: lU
} = DC, vEe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", yEe = vEe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", bEe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + yEe + "]*$")
), wEe = Object.keys(
  lU
).reduce((e, t) => {
  const n = lU[t];
  return n === mEe ? e[t] = t : n === gEe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
ja.BOOLEAN = TC;
ja.BOOLEANISH_STRING = _C;
ja.NUMERIC = voe;
ja.OVERLOADED_BOOLEAN = sA;
ja.POSITIVE_NUMERIC = yoe;
ja.RESERVED = moe;
ja.STRING = mc;
ja.getPropertyInfo = dEe;
ja.isCustomAttribute = bEe;
ja.possibleStandardNames = wEe;
var uA = {}, cA = {}, uU = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, OEe = /\n/g, CEe = /^\s*/, xEe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, LEe = /^:\s*/, EEe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, kEe = /^[;\s]*/, PEe = /^\s+|\s+$/g, SEe = `
`, cU = "/", pU = "*", dp = "", MEe = "comment", DEe = "declaration", _Ee = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(OEe);
    v && (n += v.length);
    var b = f.lastIndexOf(SEe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(CEe);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(cU != e.charAt(0) || pU != e.charAt(1))) {
      for (var v = 2; dp != e.charAt(v) && (pU != e.charAt(v) || cU != e.charAt(v + 1)); )
        ++v;
      if (v += 2, dp === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: MEe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(xEe);
    if (v) {
      if (p(), !l(LEe)) return s("property missing ':'");
      var b = l(EEe), L = f({
        type: DEe,
        property: dU(v[0].replace(uU, dp)),
        value: b ? dU(b[0].replace(uU, dp)) : dp
      });
      return l(kEe), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function dU(e) {
  return e ? e.replace(PEe, dp) : dp;
}
var TEe = jr && jr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(cA, "__esModule", { value: !0 });
cA.default = AEe;
var jEe = TEe(_Ee);
function AEe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, jEe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var jC = {};
Object.defineProperty(jC, "__esModule", { value: !0 });
jC.camelCase = void 0;
var IEe = /^--[a-zA-Z0-9_-]+$/, BEe = /-([a-z])/g, NEe = /^[^-]+$/, REe = /^-(webkit|moz|ms|o|khtml)-/, FEe = /^-(ms)-/, zEe = function(e) {
  return !e || NEe.test(e) || IEe.test(e);
}, UEe = function(e, t) {
  return t.toUpperCase();
}, fU = function(e, t) {
  return "".concat(t, "-");
}, WEe = function(e, t) {
  return t === void 0 && (t = {}), zEe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(FEe, fU) : e = e.replace(REe, fU), e.replace(BEe, UEe));
};
jC.camelCase = WEe;
var HEe = jr && jr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, VEe = HEe(cA), $Ee = jC;
function pD(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, VEe.default)(e, function(r, o) {
    r && o && (n[(0, $Ee.camelCase)(r, t)] = o);
  }), n;
}
pD.default = pD;
var ZEe = pD;
(function(e) {
  var t = jr && jr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Oe, r = t(ZEe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(uA);
Object.defineProperty(MC, "__esModule", { value: !0 });
MC.default = GEe;
var lh = ja, hU = uA, qEe = ["checked", "value"], XEe = ["input", "select", "textarea"], KEe = {
  reset: !0,
  submit: !0
};
function GEe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && KEe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, lh.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = gU(a);
    if (s) {
      var l = (0, lh.getPropertyInfo)(s);
      switch (qEe.includes(s) && XEe.includes(t) && !r && (s = gU("default" + a)), n[s] = i, l && l.type) {
        case lh.BOOLEAN:
          n[s] = !0;
          break;
        case lh.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    hU.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, hU.setStyleProp)(e.style, n), n;
}
function gU(e) {
  return lh.possibleStandardNames[e];
}
var pA = {}, YEe = jr && jr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(pA, "__esModule", { value: !0 });
pA.default = boe;
var aE = Oe, JEe = YEe(MC), Ph = uA, QEe = {
  cloneElement: aE.cloneElement,
  createElement: aE.createElement,
  isValidElement: aE.isValidElement
};
function boe(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Ph.returnFirstArg, i = t.library || QEe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, Ph.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    eke(f) ? ((0, Ph.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, JEe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = boe(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function eke(e) {
  return Ph.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Ph.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = jr && jr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(eA);
  e.htmlToDOM = n.default;
  var r = t(MC);
  e.attributesToProps = r.default;
  var o = t(pA);
  e.domToReact = o.default;
  var i = nA;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(eoe);
const tke = /* @__PURE__ */ OLe(eoe);
tke.default;
var Ar = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function nke(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var dD = { exports: {} }, vf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mU;
function rke() {
  if (mU) return vf;
  mU = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return vf.Fragment = n, vf.jsx = a, vf.jsxs = a, vf;
}
var Jv = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vU;
function oke() {
  return vU || (vU = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var T = f && g[f] || g[v];
      return typeof T == "function" ? T : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var T = arguments.length, Z = new Array(T > 1 ? T - 1 : 0), ee = 1; ee < T; ee++)
          Z[ee - 1] = arguments[ee];
        D("error", g, Z);
      }
    }
    function D(g, T, Z) {
      {
        var ee = L.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (T += "%s", Z = Z.concat([ae]));
        var ue = Z.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + T), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function R(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function N(g, T, Z) {
      var ee = g.displayName;
      if (ee)
        return ee;
      var ae = T.displayName || T.name || "";
      return ae !== "" ? Z + "(" + ae + ")" : Z;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var T = g;
            return V(T) + ".Consumer";
          case a:
            var Z = g;
            return V(Z._context) + ".Provider";
          case l:
            return N(g, g.render, "ForwardRef");
          case p:
            var ee = g.displayName || null;
            return ee !== null ? ee : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, X = 0, G, Y, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function W() {
      {
        if (X === 0) {
          G = console.log, Y = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        X++;
      }
    }
    function O() {
      {
        if (X--, X === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, g, {
              value: G
            }),
            info: H({}, g, {
              value: Y
            }),
            warn: H({}, g, {
              value: Q
            }),
            error: H({}, g, {
              value: J
            }),
            group: H({}, g, {
              value: P
            }),
            groupCollapsed: H({}, g, {
              value: _
            }),
            groupEnd: H({}, g, {
              value: z
            })
          });
        }
        X < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = L.ReactCurrentDispatcher, F;
    function j(g, T, Z) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            F = ee && ee[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, A;
    {
      var K = typeof WeakMap == "function" ? WeakMap : Map;
      A = new K();
    }
    function B(g, T) {
      if (!g || q)
        return "";
      {
        var Z = A.get(g);
        if (Z !== void 0)
          return Z;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (T) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Le) {
              ee = Le;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (Le) {
              ee = Le;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Le) {
            ee = Le;
          }
          g();
        }
      } catch (Le) {
        if (Le && ee && typeof Le.stack == "string") {
          for (var ie = Le.stack.split(`
`), we = ee.stack.split(`
`), de = ie.length - 1, fe = we.length - 1; de >= 1 && fe >= 0 && ie[de] !== we[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== we[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== we[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", g.displayName)), typeof g == "function" && A.set(g, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var kt = g ? g.displayName || g.name : "", mt = kt ? j(kt) : "";
      return typeof g == "function" && A.set(g, mt), mt;
    }
    function le(g, T, Z) {
      return B(g, !1);
    }
    function he(g) {
      var T = g.prototype;
      return !!(T && T.isReactComponent);
    }
    function re(g, T, Z) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return B(g, he(g));
      if (typeof g == "string")
        return j(g);
      switch (g) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return re(g.type, T, Z);
          case d: {
            var ee = g, ae = ee._payload, ue = ee._init;
            try {
              return re(ue(ae), T, Z);
            } catch {
            }
          }
        }
      return "";
    }
    var Se = Object.prototype.hasOwnProperty, We = {}, Ze = L.ReactDebugCurrentFrame;
    function Me(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        Ze.setExtraStackFrame(Z);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(g, T, Z, ee, ae) {
      {
        var ue = Function.call.bind(Se);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var we = Error((ee || "React class") + ": " + Z + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw we.name = "Invariant Violation", we;
              }
              ie = g[se](T, se, ee, Z, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Me(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", Z, se, typeof ie), Me(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Me(ae), w("Failed %s type: %s", Z, ie.message), Me(null));
          }
      }
    }
    var Ve = Array.isArray;
    function be(g) {
      return Ve(g);
    }
    function qe(g) {
      {
        var T = typeof Symbol == "function" && Symbol.toStringTag, Z = T && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return Z;
      }
    }
    function ct(g) {
      try {
        return ye(g), !1;
      } catch {
        return !0;
      }
    }
    function ye(g) {
      return "" + g;
    }
    function xe(g) {
      if (ct(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qe(g)), ye(g);
    }
    var Ee = L.ReactCurrentOwner, Ue = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, De, st, ve;
    ve = {};
    function wt(g) {
      if (Se.call(g, "ref")) {
        var T = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function at(g) {
      if (Se.call(g, "key")) {
        var T = Object.getOwnPropertyDescriptor(g, "key").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function lt(g, T) {
      if (typeof g.ref == "string" && Ee.current && T && Ee.current.stateNode !== T) {
        var Z = $(Ee.current.type);
        ve[Z] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ee.current.type), g.ref), ve[Z] = !0);
      }
    }
    function pt(g, T) {
      {
        var Z = function() {
          De || (De = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: Z,
          configurable: !0
        });
      }
    }
    function Ot(g, T) {
      {
        var Z = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: Z,
          configurable: !0
        });
      }
    }
    var dt = function(g, T, Z, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: T,
        ref: Z,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function Ct(g, T, Z, ee, ae) {
      {
        var ue, se = {}, ie = null, we = null;
        Z !== void 0 && (xe(Z), ie = "" + Z), at(T) && (xe(T.key), ie = "" + T.key), wt(T) && (we = T.ref, lt(T, ae));
        for (ue in T)
          Se.call(T, ue) && !Ue.hasOwnProperty(ue) && (se[ue] = T[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || we) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && pt(se, fe), we && Ot(se, fe);
        }
        return dt(g, ie, we, ae, ee, Ee.current, se);
      }
    }
    var Xe = L.ReactCurrentOwner, ht = L.ReactDebugCurrentFrame;
    function ot(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        ht.setExtraStackFrame(Z);
      } else
        ht.setExtraStackFrame(null);
    }
    var xt;
    xt = !1;
    function ft(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Pt() {
      {
        if (Xe.current) {
          var g = $(Xe.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Lt(g) {
      return "";
    }
    var St = {};
    function Et(g) {
      {
        var T = Pt();
        if (!T) {
          var Z = typeof g == "string" ? g : g.displayName || g.name;
          Z && (T = `

Check the top-level render call using <` + Z + ">.");
        }
        return T;
      }
    }
    function Mt(g, T) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var Z = Et(T);
        if (St[Z])
          return;
        St[Z] = !0;
        var ee = "";
        g && g._owner && g._owner !== Xe.current && (ee = " It was passed a child from " + $(g._owner.type) + "."), ot(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Z, ee), ot(null);
      }
    }
    function _t(g, T) {
      {
        if (typeof g != "object")
          return;
        if (be(g))
          for (var Z = 0; Z < g.length; Z++) {
            var ee = g[Z];
            ft(ee) && Mt(ee, T);
          }
        else if (ft(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              ft(se.value) && Mt(se.value, T);
        }
      }
    }
    function gt(g) {
      {
        var T = g.type;
        if (T == null || typeof T == "string")
          return;
        var Z;
        if (typeof T == "function")
          Z = T.propTypes;
        else if (typeof T == "object" && (T.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        T.$$typeof === p))
          Z = T.propTypes;
        else
          return;
        if (Z) {
          var ee = $(T);
          rt(Z, g.props, "prop", ee, g);
        } else if (T.PropTypes !== void 0 && !xt) {
          xt = !0;
          var ae = $(T);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof T.getDefaultProps == "function" && !T.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function te(g) {
      {
        for (var T = Object.keys(g.props), Z = 0; Z < T.length; Z++) {
          var ee = T[Z];
          if (ee !== "children" && ee !== "key") {
            ot(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), ot(null);
            break;
          }
        }
        g.ref !== null && (ot(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), ot(null));
      }
    }
    var Br = {};
    function Nr(g, T, Z, ee, ae, ue) {
      {
        var se = R(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var we = Lt();
          we ? ie += we : ie += Pt();
          var de;
          g === null ? de = "null" : be(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = Ct(g, T, Z, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = T.children;
          if (ze !== void 0)
            if (ee)
              if (be(ze)) {
                for (var kt = 0; kt < ze.length; kt++)
                  _t(ze[kt], g);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              _t(ze, g);
        }
        if (Se.call(T, "key")) {
          var mt = $(g), Le = Object.keys(T).filter(function(Si) {
            return Si !== "key";
          }), In = Le.length > 0 ? "{key: someKey, " + Le.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Br[mt + In]) {
            var Pi = Le.length > 0 ? "{" + Le.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, In, mt, Pi, mt), Br[mt + In] = !0;
          }
        }
        return g === r ? te(fe) : gt(fe), fe;
      }
    }
    function xi(g, T, Z) {
      return Nr(g, T, Z, !0);
    }
    function Li(g, T, Z) {
      return Nr(g, T, Z, !1);
    }
    var Ei = Li, ki = xi;
    Jv.Fragment = r, Jv.jsx = Ei, Jv.jsxs = ki;
  }()), Jv;
}
process.env.NODE_ENV === "production" ? dD.exports = rke() : dD.exports = oke();
var ws = dD.exports;
He({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function yU(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function $i(e) {
  var t, n;
  return yU(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(yU(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var woe = Symbol.for("immer-nothing"), bU = Symbol.for("immer-draftable"), ca = Symbol.for("immer-state"), ike = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function fs(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = ike[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Ld = Object.getPrototypeOf;
function Gp(e) {
  return !!e && !!e[ca];
}
function Yp(e) {
  var t;
  return e ? Ooe(e) || Array.isArray(e) || !!e[bU] || !!((t = e.constructor) != null && t[bU]) || IC(e) || BC(e) : !1;
}
var ske = Object.prototype.constructor.toString();
function Ooe(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Ld(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === ske;
}
function ew(e, t) {
  AC(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function AC(e) {
  const t = e[ca];
  return t ? t.type_ : Array.isArray(e) ? 1 : IC(e) ? 2 : BC(e) ? 3 : 0;
}
function fD(e, t) {
  return AC(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Coe(e, t, n) {
  const r = AC(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function ake(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function IC(e) {
  return e instanceof Map;
}
function BC(e) {
  return e instanceof Set;
}
function rp(e) {
  return e.copy_ || e.base_;
}
function hD(e, t) {
  if (IC(e))
    return new Map(e);
  if (BC(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Ooe(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ca];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Ld(e), r);
  } else {
    const r = Ld(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function dA(e, t = !1) {
  return NC(e) || Gp(e) || !Yp(e) || (AC(e) > 1 && (e.set = e.add = e.clear = e.delete = lke), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => dA(r, !0))), e;
}
function lke() {
  fs(2);
}
function NC(e) {
  return Object.isFrozen(e);
}
var uke = {};
function Jp(e) {
  const t = uke[e];
  return t || fs(0, e), t;
}
var kg;
function xoe() {
  return kg;
}
function cke(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function wU(e, t) {
  t && (Jp("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function gD(e) {
  mD(e), e.drafts_.forEach(pke), e.drafts_ = null;
}
function mD(e) {
  e === kg && (kg = e.parent_);
}
function OU(e) {
  return kg = cke(kg, e);
}
function pke(e) {
  const t = e[ca];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function CU(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ca].modified_ && (gD(t), fs(4)), Yp(e) && (e = tw(t, e), t.parent_ || nw(t, e)), t.patches_ && Jp("Patches").generateReplacementPatches_(
    n[ca].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = tw(t, n, []), gD(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== woe ? e : void 0;
}
function tw(e, t, n) {
  if (NC(t))
    return t;
  const r = t[ca];
  if (!r)
    return ew(
      t,
      (o, i) => xU(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return nw(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), ew(
      i,
      (s, l) => xU(e, r, o, s, l, n, a)
    ), nw(e, o, !1), n && e.patches_ && Jp("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function xU(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && fs(5), Gp(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !fD(t.assigned_, r) ? i.concat(r) : void 0, l = tw(e, o, s);
    if (Coe(n, r, l), Gp(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Yp(o) && !NC(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    tw(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && nw(e, o);
  }
}
function nw(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && dA(t, n);
}
function dke(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : xoe(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = fA;
  n && (o = [r], i = Pg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var fA = {
  get(e, t) {
    if (t === ca)
      return e;
    const n = rp(e);
    if (!fD(n, t))
      return fke(e, n, t);
    const r = n[t];
    return e.finalized_ || !Yp(r) ? r : r === lE(e.base_, t) ? (uE(e), e.copy_[t] = yD(r, e)) : r;
  },
  has(e, t) {
    return t in rp(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(rp(e));
  },
  set(e, t, n) {
    const r = Loe(rp(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = lE(rp(e), t), i = o == null ? void 0 : o[ca];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (ake(n, o) && (n !== void 0 || fD(e.base_, t)))
        return !0;
      uE(e), vD(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return lE(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, uE(e), vD(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = rp(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    fs(11);
  },
  getPrototypeOf(e) {
    return Ld(e.base_);
  },
  setPrototypeOf() {
    fs(12);
  }
}, Pg = {};
ew(fA, (e, t) => {
  Pg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Pg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && fs(13), Pg.set.call(this, e, t, void 0);
};
Pg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && fs(14), fA.set.call(this, e[0], t, n, e[0]);
};
function lE(e, t) {
  const n = e[ca];
  return (n ? rp(n) : e)[t];
}
function fke(e, t, n) {
  var r;
  const o = Loe(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function Loe(e, t) {
  if (!(t in e))
    return;
  let n = Ld(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Ld(n);
  }
}
function vD(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && vD(e.parent_));
}
function uE(e) {
  e.copy_ || (e.copy_ = hD(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var hke = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && fs(6), r !== void 0 && typeof r != "function" && fs(7);
      let o;
      if (Yp(t)) {
        const i = OU(this), a = yD(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? gD(i) : mD(i);
        }
        return wU(i, r), CU(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === woe && (o = void 0), this.autoFreeze_ && dA(o, !0), r) {
          const i = [], a = [];
          Jp("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        fs(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Yp(e) || fs(8), Gp(e) && (e = gke(e));
    const t = OU(this), n = yD(e, void 0);
    return n[ca].isManual_ = !0, mD(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ca];
    (!n || !n.isManual_) && fs(9);
    const { scope_: r } = n;
    return wU(r, t), CU(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Jp("Patches").applyPatches_;
    return Gp(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function yD(e, t) {
  const n = IC(e) ? Jp("MapSet").proxyMap_(e, t) : BC(e) ? Jp("MapSet").proxySet_(e, t) : dke(e, t);
  return (t ? t.scope_ : xoe()).drafts_.push(n), n;
}
function gke(e) {
  return Gp(e) || fs(10, e), Eoe(e);
}
function Eoe(e) {
  if (!Yp(e) || NC(e))
    return e;
  const t = e[ca];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = hD(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = hD(e, !0);
  return ew(n, (r, o) => {
    Coe(n, r, Eoe(o));
  }), t && (t.finalized_ = !1), n;
}
var pa = new hke(), hA = pa.produce;
pa.produceWithPatches.bind(
  pa
);
pa.setAutoFreeze.bind(pa);
pa.setUseStrictShallowCopy.bind(pa);
pa.applyPatches.bind(pa);
var LU = pa.createDraft.bind(pa), EU = pa.finishDraft.bind(pa), tt = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = tt.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return tt.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return tt.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return tt.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return tt.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && tt.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return tt.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && tt.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && tt.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && tt.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && tt.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && tt.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!tt.isAncestor(t, e) && !tt.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (tt.equals(i, r) || tt.endsBefore(i, r) || tt.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (tt.equals(a, r) || tt.isAncestor(a, r))
          return null;
        tt.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        tt.equals(s, r) || tt.endsBefore(s, r) ? r[s.length - 1] -= 1 : tt.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (tt.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else tt.endsBefore(u, r) ? r[u.length - 1] += 1 : tt.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (tt.equals(p, d))
          return r;
        if (tt.isAncestor(p, r) || tt.equals(p, r)) {
          var y = d.slice();
          return tt.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else tt.isSibling(p, d) && (tt.isAncestor(d, r) || tt.equals(d, r)) ? tt.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : tt.endsBefore(d, r) || tt.equals(d, r) || tt.isAncestor(d, r) ? (tt.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : tt.endsBefore(p, r) && (tt.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Sg(e) {
  "@babel/helpers - typeof";
  return Sg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Sg(e);
}
function mke(e, t) {
  if (Sg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Sg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function vke(e) {
  var t = mke(e, "string");
  return Sg(t) === "symbol" ? t : String(t);
}
function Id(e, t, n) {
  return t = vke(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function kU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kU(Object(n), !0).forEach(function(r) {
      Id(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yke = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Rt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of rn.points(t))
          t[l] = Jr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Rt.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of rn.points(t))
          t[b] = Jr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = Rt.get(e, L), D = tt.previous(L), x = Rt.get(e, D), m = Rt.parent(e, L), C = L[L.length - 1];
      if (Qo.isText(w) && Qo.isText(x))
        x.text += w.text;
      else if (!Qo.isText(w) && !Qo.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(Rs.stringify(w), " ").concat(Rs.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of rn.points(t))
          t[U] = Jr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: R
      } = n;
      if (tt.isAncestor(k, R))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(R, "] because the destination is inside itself."));
      var N = Rt.get(e, k), V = Rt.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var H = tt.transform(k, n), X = Rt.get(e, tt.parent(H)), G = H[H.length - 1];
      if (X.children.splice(G, 0, N), t)
        for (var [Y, Q] of rn.points(t))
          t[Q] = Jr.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = Rt.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of rn.points(t)) {
          var W = Jr.transform(z, n);
          if (t != null && W != null)
            t[M] = W;
          else {
            var O = void 0, I = void 0;
            for (var [F, j] of Rt.texts(e))
              if (tt.compare(j, J) === -1)
                O = [F, j];
              else {
                I = [F, j];
                break;
              }
            var q = !1;
            O && I && (tt.equals(I[1], J) ? q = !tt.hasPrevious(I[1]) : q = tt.common(O[1], J).length < tt.common(I[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : I ? (z.path = I[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: K,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = Rt.leaf(e, A), he = le.text.slice(0, K), re = le.text.slice(K + B.length);
      if (le.text = he + re, t)
        for (var [Se, We] of rn.points(t))
          t[We] = Jr.transform(Se, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: Me,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = Rt.get(e, Ze);
      for (var be in rt) {
        if (be === "children" || be === "text")
          throw new Error('Cannot set the "'.concat(be, '" property of nodes!'));
        var qe = rt[be];
        qe == null ? delete Ve[be] : Ve[be] = qe;
      }
      for (var ct in Me)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!rn.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Rs.stringify(ye), " when there is no current selection."));
          t = yf({}, ye);
        }
        for (var xe in ye) {
          var Ee = ye[xe];
          if (Ee == null) {
            if (xe === "anchor" || xe === "focus")
              throw new Error('Cannot remove the "'.concat(xe, '" selection property'));
            delete t[xe];
          } else
            t[xe] = Ee;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ue,
        position: De,
        properties: st
      } = n;
      if (Ue.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ue, "] because the root node cannot be split."));
      var ve = Rt.get(e, Ue), wt = Rt.parent(e, Ue), at = Ue[Ue.length - 1], lt;
      if (Qo.isText(ve)) {
        var pt = ve.text.slice(0, De), Ot = ve.text.slice(De);
        ve.text = pt, lt = yf(yf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = ve.children.slice(0, De), Ct = ve.children.slice(De);
        ve.children = dt, lt = yf(yf({}, st), {}, {
          children: Ct
        });
      }
      if (wt.children.splice(at + 1, 0, lt), t)
        for (var [Xe, ht] of rn.points(t))
          t[ht] = Jr.transform(Xe, n);
      break;
    }
  }
  return t;
}, bke = {
  transform(e, t) {
    e.children = LU(e.children);
    var n = e.selection && LU(e.selection);
    try {
      n = yke(e, n, t);
    } finally {
      e.children = EU(e.children), n ? e.selection = Gp(n) ? EU(n) : n : e.selection = null;
    }
  }
}, wke = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Oke = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, koe = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if ($i(r) && $i(o)) {
      if (!koe(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Cke(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Mg(e, t) {
  if (e == null) return {};
  var n = Cke(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var xke = ["anchor", "focus"];
function PU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lke(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PU(Object(n), !0).forEach(function(r) {
      Id(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rn = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return rn.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = rn.edges(e);
    return t;
  },
  equals(e, t) {
    return Jr.equals(e.anchor, t.anchor) && Jr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (rn.isRange(t)) {
      if (rn.includes(e, t.anchor) || rn.includes(e, t.focus))
        return !0;
      var [n, r] = rn.edges(e), [o, i] = rn.edges(t);
      return Jr.isBefore(n, o) && Jr.isAfter(r, i);
    }
    var [a, s] = rn.edges(e), l = !1, u = !1;
    return Jr.isPoint(t) ? (l = Jr.compare(t, a) >= 0, u = Jr.compare(t, s) <= 0) : (l = tt.compare(t, a.path) >= 0, u = tt.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Mg(e, xke), [r, o] = rn.edges(e), [i, a] = rn.edges(t), s = Jr.isBefore(r, i) ? i : r, l = Jr.isBefore(o, a) ? o : a;
    return Jr.isBefore(l, s) ? null : Lke({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Jr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Jr.equals(t, n);
  },
  isExpanded(e) {
    return !rn.isCollapsed(e);
  },
  isForward(e) {
    return !rn.isBackward(e);
  },
  isRange(e) {
    return $i(e) && Jr.isPoint(e.anchor) && Jr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = rn.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return hA(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = rn.isCollapsed(r);
        rn.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? rn.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Jr.transform(r.anchor, t, {
        affinity: i
      }), u = Jr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, SU = (e) => $i(e) && Rt.isNodeList(e.children) && !Er.isEditor(e), Bl = {
  isAncestor(e) {
    return $i(e) && Rt.isNodeList(e.children);
  },
  isElement: SU,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Bl.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return SU(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Eke = ["children"], kke = ["text"], MU = /* @__PURE__ */ new WeakMap(), Rt = {
  ancestor(e, t) {
    var n = Rt.get(e, t);
    if (Qo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Rs.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of tt.ancestors(t, n)) {
        var o = Rt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Qo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Rs.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Rs.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Rt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Rt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = tt.common(t, n), o = Rt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Rt.get(e, t);
    if (Er.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Rs.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Rt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Rt.nodes(e, t))
        Bl.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Bl.isAncestor(e)) {
      var t = Mg(e, Eke);
      return t;
    } else {
      var t = Mg(e, kke);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Rt.get(e, n); r && !(Qo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Qo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Rs.stringify(e)));
    var n = hA({
      children: e.children
    }, (r) => {
      var [o, i] = rn.edges(t), a = Rt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !rn.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!rn.includes(t, s)) {
          var l = Rt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (tt.equals(s, i.path)) {
          var c = Rt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (tt.equals(s, o.path)) {
          var p = Rt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Er.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Qo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Rs.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Qo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Qo.isText(e) || Bl.isElement(e) || Er.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = MU.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Rt.isNode(r));
    return MU.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Rt.get(e, n); r && !(Qo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Rt.get(e, t);
    if (!Qo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Rs.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of tt.levels(t, n)) {
        var o = Rt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Bl.isElement(e) && Bl.isElementProps(t) && Bl.matches(e, t) || Qo.isText(e) && Qo.isTextProps(t) && Qo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? tt.isBefore(s, i) : tt.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Qo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          tt.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Rt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = tt.next(s);
          if (Rt.has(e, c)) {
            s = c, l = Rt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = tt.previous(s);
          s = p, l = Rt.get(e, s);
          continue;
        }
        s = tt.parent(s), l = Rt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = tt.parent(t), r = Rt.get(e, n);
    if (Qo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Qo.isText(e) ? e.text : e.children.map(Rt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Rt.nodes(e, t))
        Qo.isText(n) && (yield [n, r]);
    }();
  }
};
function DU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ao(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DU(Object(n), !0).forEach(function(r) {
      Id(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var uh = {
  isNodeOperation(e) {
    return uh.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!$i(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return tt.isPath(e.path) && Rt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && tt.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && tt.isPath(e.path) && $i(e.properties);
      case "move_node":
        return tt.isPath(e.path) && tt.isPath(e.newPath);
      case "remove_node":
        return tt.isPath(e.path) && Rt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && tt.isPath(e.path);
      case "set_node":
        return tt.isPath(e.path) && $i(e.properties) && $i(e.newProperties);
      case "set_selection":
        return e.properties === null && rn.isRange(e.newProperties) || e.newProperties === null && rn.isRange(e.properties) || $i(e.properties) && $i(e.newProperties);
      case "split_node":
        return tt.isPath(e.path) && typeof e.position == "number" && $i(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => uh.isOperation(t));
  },
  isSelectionOperation(e) {
    return uh.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return uh.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return ao(ao({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return ao(ao({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return ao(ao({}, e), {}, {
          type: "split_node",
          path: tt.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (tt.equals(t, n))
          return e;
        if (tt.isSibling(n, t))
          return ao(ao({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = tt.transform(n, e), o = tt.transform(tt.next(n), e);
        return ao(ao({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return ao(ao({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return ao(ao({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return ao(ao({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? ao(ao({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? ao(ao({}, e), {}, {
          properties: null,
          newProperties: s
        }) : ao(ao({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return ao(ao({}, e), {}, {
          type: "merge_node",
          path: tt.next(e.path)
        });
    }
  }
}, _U = /* @__PURE__ */ new WeakMap(), Pke = (e) => {
  var t = _U.get(e);
  if (t !== void 0)
    return t;
  if (!$i(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || $i(e.marks)) && (e.selection === null || rn.isRange(e.selection)) && Rt.isNodeList(e.children) && uh.isOperationList(e.operations);
  return _U.set(e, n), n;
}, Er = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Pke(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function TU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TU(Object(n), !0).forEach(function(r) {
      Id(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jr = {
  compare(e, t) {
    var n = tt.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Jr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Jr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && tt.equals(e.path, t.path);
  },
  isPoint(e) {
    return $i(e) && typeof e.offset == "number" && tt.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return hA(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = tt.transform(i, t, n);
          break;
        }
        case "insert_text": {
          tt.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          tt.equals(t.path, i) && (r.offset += t.position), r.path = tt.transform(i, t, n);
          break;
        }
        case "remove_text": {
          tt.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (tt.equals(t.path, i) || tt.isAncestor(t.path, i))
            return null;
          r.path = tt.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (tt.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = tt.transform(i, t, jU(jU({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = tt.transform(i, t, n);
          break;
        }
      }
    });
  }
}, AU = void 0, Rs = {
  setScrubber(e) {
    AU = e;
  },
  stringify(e) {
    return JSON.stringify(e, AU);
  }
}, Ske = ["text"], Mke = ["anchor", "focus"];
function IU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IU(Object(n), !0).forEach(function(r) {
      Id(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Mg(i, Ske);
      return a;
    }
    return koe(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return $i(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Qo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [bl({}, e)];
    for (var r of t) {
      var o = Mg(r, Mke), [i, a] = rn.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = bl(bl({}, f), {}, {
            text: f.text.slice(L)
          }), f = bl(bl({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = bl(bl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = bl(bl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, Dke = (e) => e.selection ? e.selection : e.children.length > 0 ? Er.end(e, []) : [0], Vr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Vr || (Vr = {}));
Vr.L, Vr.L | Vr.V | Vr.LV | Vr.LVT, Vr.LV | Vr.V, Vr.V | Vr.T, Vr.LVT | Vr.T, Vr.T, Vr.Any, Vr.Extend | Vr.ZWJ, Vr.Any, Vr.SpacingMark, Vr.Prepend, Vr.Any, Vr.ZWJ, Vr.ExtPict, Vr.RI, Vr.RI;
var _ke = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Er.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Dke(e)
      } = n;
      if (tt.isPath(o) && (o = Er.range(e, o)), rn.isRange(o))
        if (rn.isCollapsed(o))
          o = o.anchor;
        else {
          var i = rn.end(o);
          if (!r && Er.void(e, {
            at: i
          }))
            return;
          var a = rn.start(o), s = Er.pointRef(e, a), l = Er.pointRef(e, i);
          rw.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, rw.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Er.void(e, {
        at: o
      }) || Er.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function BU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BU(Object(n), !0).forEach(function(r) {
      Id(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rw = Qv(Qv(Qv(Qv({}, bke), wke), Oke), _ke), Poe = {}, gA = {}, mA = {};
Object.defineProperty(mA, "__esModule", { value: !0 });
mA.default = Ike;
var NU = "html", RU = "head", ey = "body", Tke = /<([a-zA-Z]+[0-9]?)/, FU = /<head[^]*>/i, zU = /<body[^]*>/i, ow = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, bD = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, UU = typeof window == "object" && window.DOMParser;
if (typeof UU == "function") {
  var jke = new UU(), Ake = "text/html";
  bD = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), jke.parseFromString(e, Ake);
  }, ow = bD;
}
if (typeof document == "object" && document.implementation) {
  var ty = document.implementation.createHTMLDocument();
  ow = function(e, t) {
    if (t) {
      var n = ty.documentElement.querySelector(t);
      return n && (n.innerHTML = e), ty;
    }
    return ty.documentElement.innerHTML = e, ty;
  };
}
var ny = typeof document == "object" && document.createElement("template"), wD;
ny && ny.content && (wD = function(e) {
  return ny.innerHTML = e, ny.content.childNodes;
});
function Ike(e) {
  var t, n, r = e.match(Tke), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case NU: {
      var i = bD(e);
      if (!FU.test(e)) {
        var a = i.querySelector(RU);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!zU.test(e)) {
        var a = i.querySelector(ey);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(NU);
    }
    case RU:
    case ey: {
      var s = ow(e).querySelectorAll(o);
      return zU.test(e) && FU.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (wD)
        return wD(e);
      var a = ow(e, ey).querySelector(ey);
      return a.childNodes;
    }
  }
}
var RC = {}, vA = {}, yA = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(yA);
var hn = {}, vc = Ar && Ar.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Sh = Ar && Ar.__assign || function() {
  return Sh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Sh.apply(this, arguments);
};
Object.defineProperty(hn, "__esModule", { value: !0 });
hn.cloneNode = hn.hasChildren = hn.isDocument = hn.isDirective = hn.isComment = hn.isText = hn.isCDATA = hn.isTag = hn.Element = hn.Document = hn.CDATA = hn.NodeWithChildren = hn.ProcessingInstruction = hn.Comment = hn.Text = hn.DataNode = hn.Node = void 0;
var Ms = yA, bA = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), wA(this, t);
    }, e;
  }()
);
hn.Node = bA;
var FC = (
  /** @class */
  function(e) {
    vc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bA)
);
hn.DataNode = FC;
var Soe = (
  /** @class */
  function(e) {
    vc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ms.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(FC)
);
hn.Text = Soe;
var Moe = (
  /** @class */
  function(e) {
    vc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ms.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(FC)
);
hn.Comment = Moe;
var Doe = (
  /** @class */
  function(e) {
    vc(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ms.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(FC)
);
hn.ProcessingInstruction = Doe;
var zC = (
  /** @class */
  function(e) {
    vc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bA)
);
hn.NodeWithChildren = zC;
var _oe = (
  /** @class */
  function(e) {
    vc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ms.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(zC)
);
hn.CDATA = _oe;
var Toe = (
  /** @class */
  function(e) {
    vc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ms.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(zC)
);
hn.Document = Toe;
var joe = (
  /** @class */
  function(e) {
    vc(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ms.ElementType.Script : n === "style" ? Ms.ElementType.Style : Ms.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(zC)
);
hn.Element = joe;
function Aoe(e) {
  return (0, Ms.isTag)(e);
}
hn.isTag = Aoe;
function Ioe(e) {
  return e.type === Ms.ElementType.CDATA;
}
hn.isCDATA = Ioe;
function Boe(e) {
  return e.type === Ms.ElementType.Text;
}
hn.isText = Boe;
function Noe(e) {
  return e.type === Ms.ElementType.Comment;
}
hn.isComment = Noe;
function Roe(e) {
  return e.type === Ms.ElementType.Directive;
}
hn.isDirective = Roe;
function Foe(e) {
  return e.type === Ms.ElementType.Root;
}
hn.isDocument = Foe;
function Bke(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
hn.hasChildren = Bke;
function wA(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (Boe(e))
    n = new Soe(e.data);
  else if (Noe(e))
    n = new Moe(e.data);
  else if (Aoe(e)) {
    var r = t ? cE(e.children) : [], o = new joe(e.name, Sh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Sh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Sh({}, e["x-attribsPrefix"])), n = o;
  } else if (Ioe(e)) {
    var r = t ? cE(e.children) : [], i = new _oe(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (Foe(e)) {
    var r = t ? cE(e.children) : [], a = new Toe(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (Roe(e)) {
    var s = new Doe(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
hn.cloneNode = wA;
function cE(e) {
  for (var t = e.map(function(r) {
    return wA(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Ar && Ar.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Ar && Ar.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = yA, o = hn;
  n(hn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(vA);
var zoe = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(zoe);
Object.defineProperty(RC, "__esModule", { value: !0 });
RC.formatAttributes = Uoe;
RC.formatDOM = Woe;
var ry = vA, Nke = zoe;
function Rke(e) {
  return Nke.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function Uoe(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Fke(e) {
  e = e.toLowerCase();
  var t = Rke(e);
  return t || e;
}
function Woe(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Fke(s.nodeName);
        o = new ry.Element(l, Uoe(s.attributes)), o.children = Woe(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new ry.Text(s.nodeValue);
        break;
      case 8:
        o = new ry.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new ry.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var zke = Ar && Ar.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(gA, "__esModule", { value: !0 });
gA.default = Vke;
var Uke = zke(mA), Wke = RC, Hke = /<(![a-zA-Z\s]+)>/;
function Vke(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Hke), n = t ? t[1] : void 0;
  return (0, Wke.formatDOM)((0, Uke.default)(e), null, n);
}
var UC = {}, Aa = {}, WC = {}, $ke = 0;
WC.SAME = $ke;
var Zke = 1;
WC.CAMELCASE = Zke;
WC.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const Hoe = 0, yc = 1, HC = 2, VC = 3, OA = 4, Voe = 5, $oe = 6;
function qke(e) {
  return Bi.hasOwnProperty(e) ? Bi[e] : null;
}
function rs(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === HC || t === VC || t === OA, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Bi = {}, Xke = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Xke.forEach((e) => {
  Bi[e] = new rs(
    e,
    Hoe,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Bi[e] = new rs(
    e,
    yc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Bi[e] = new rs(
    e,
    HC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Bi[e] = new rs(
    e,
    HC,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Bi[e] = new rs(
    e,
    VC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Bi[e] = new rs(
    e,
    VC,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Bi[e] = new rs(
    e,
    OA,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Bi[e] = new rs(
    e,
    $oe,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Bi[e] = new rs(
    e,
    Voe,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const CA = /[\-\:]([a-z])/g, xA = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(CA, xA);
  Bi[t] = new rs(
    t,
    yc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(CA, xA);
  Bi[t] = new rs(
    t,
    yc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(CA, xA);
  Bi[t] = new rs(
    t,
    yc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Bi[e] = new rs(
    e,
    yc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Kke = "xlinkHref";
Bi[Kke] = new rs(
  "xlinkHref",
  yc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Bi[e] = new rs(
    e,
    yc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Gke,
  SAME: Yke,
  possibleStandardNames: WU
} = WC, Jke = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Qke = Jke + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", ePe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Qke + "]*$")
), tPe = Object.keys(
  WU
).reduce((e, t) => {
  const n = WU[t];
  return n === Yke ? e[t] = t : n === Gke ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Aa.BOOLEAN = VC;
Aa.BOOLEANISH_STRING = HC;
Aa.NUMERIC = Voe;
Aa.OVERLOADED_BOOLEAN = OA;
Aa.POSITIVE_NUMERIC = $oe;
Aa.RESERVED = Hoe;
Aa.STRING = yc;
Aa.getPropertyInfo = qke;
Aa.isCustomAttribute = ePe;
Aa.possibleStandardNames = tPe;
var LA = {}, EA = {}, HU = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, nPe = /\n/g, rPe = /^\s*/, oPe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, iPe = /^:\s*/, sPe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, aPe = /^[;\s]*/, lPe = /^\s+|\s+$/g, uPe = `
`, VU = "/", $U = "*", fp = "", cPe = "comment", pPe = "declaration", dPe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(nPe);
    v && (n += v.length);
    var b = f.lastIndexOf(uPe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(rPe);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(VU != e.charAt(0) || $U != e.charAt(1))) {
      for (var v = 2; fp != e.charAt(v) && ($U != e.charAt(v) || VU != e.charAt(v + 1)); )
        ++v;
      if (v += 2, fp === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: cPe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(oPe);
    if (v) {
      if (p(), !l(iPe)) return s("property missing ':'");
      var b = l(sPe), L = f({
        type: pPe,
        property: ZU(v[0].replace(HU, fp)),
        value: b ? ZU(b[0].replace(HU, fp)) : fp
      });
      return l(aPe), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function ZU(e) {
  return e ? e.replace(lPe, fp) : fp;
}
var fPe = Ar && Ar.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(EA, "__esModule", { value: !0 });
EA.default = gPe;
var hPe = fPe(dPe);
function gPe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, hPe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var $C = {};
Object.defineProperty($C, "__esModule", { value: !0 });
$C.camelCase = void 0;
var mPe = /^--[a-zA-Z0-9_-]+$/, vPe = /-([a-z])/g, yPe = /^[^-]+$/, bPe = /^-(webkit|moz|ms|o|khtml)-/, wPe = /^-(ms)-/, OPe = function(e) {
  return !e || yPe.test(e) || mPe.test(e);
}, CPe = function(e, t) {
  return t.toUpperCase();
}, qU = function(e, t) {
  return "".concat(t, "-");
}, xPe = function(e, t) {
  return t === void 0 && (t = {}), OPe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(wPe, qU) : e = e.replace(bPe, qU), e.replace(vPe, CPe));
};
$C.camelCase = xPe;
var LPe = Ar && Ar.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, EPe = LPe(EA), kPe = $C;
function OD(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, EPe.default)(e, function(r, o) {
    r && o && (n[(0, kPe.camelCase)(r, t)] = o);
  }), n;
}
OD.default = OD;
var PPe = OD;
(function(e) {
  var t = Ar && Ar.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Oe, r = t(PPe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(LA);
Object.defineProperty(UC, "__esModule", { value: !0 });
UC.default = _Pe;
var ch = Aa, XU = LA, SPe = ["checked", "value"], MPe = ["input", "select", "textarea"], DPe = {
  reset: !0,
  submit: !0
};
function _Pe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && DPe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, ch.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = KU(a);
    if (s) {
      var l = (0, ch.getPropertyInfo)(s);
      switch (SPe.includes(s) && MPe.includes(t) && !r && (s = KU("default" + a)), n[s] = i, l && l.type) {
        case ch.BOOLEAN:
          n[s] = !0;
          break;
        case ch.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    XU.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, XU.setStyleProp)(e.style, n), n;
}
function KU(e) {
  return ch.possibleStandardNames[e];
}
var kA = {}, TPe = Ar && Ar.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(kA, "__esModule", { value: !0 });
kA.default = Zoe;
var pE = Oe, jPe = TPe(UC), Mh = LA, APe = {
  cloneElement: pE.cloneElement,
  createElement: pE.createElement,
  isValidElement: pE.isValidElement
};
function Zoe(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Mh.returnFirstArg, i = t.library || APe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, Mh.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    IPe(f) ? ((0, Mh.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, jPe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = Zoe(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function IPe(e) {
  return Mh.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Mh.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Ar && Ar.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(gA);
  e.htmlToDOM = n.default;
  var r = t(UC);
  e.attributesToProps = r.default;
  var o = t(kA);
  e.domToReact = o.default;
  var i = vA;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(Poe);
const BPe = /* @__PURE__ */ nke(Poe);
BPe.default;
var Ir = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function NPe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var CD = { exports: {} }, bf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var GU;
function RPe() {
  if (GU) return bf;
  GU = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return bf.Fragment = n, bf.jsx = a, bf.jsxs = a, bf;
}
var oy = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var YU;
function FPe() {
  return YU || (YU = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var T = f && g[f] || g[v];
      return typeof T == "function" ? T : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var T = arguments.length, Z = new Array(T > 1 ? T - 1 : 0), ee = 1; ee < T; ee++)
          Z[ee - 1] = arguments[ee];
        D("error", g, Z);
      }
    }
    function D(g, T, Z) {
      {
        var ee = L.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (T += "%s", Z = Z.concat([ae]));
        var ue = Z.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + T), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function R(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function N(g, T, Z) {
      var ee = g.displayName;
      if (ee)
        return ee;
      var ae = T.displayName || T.name || "";
      return ae !== "" ? Z + "(" + ae + ")" : Z;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var T = g;
            return V(T) + ".Consumer";
          case a:
            var Z = g;
            return V(Z._context) + ".Provider";
          case l:
            return N(g, g.render, "ForwardRef");
          case p:
            var ee = g.displayName || null;
            return ee !== null ? ee : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, X = 0, G, Y, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function W() {
      {
        if (X === 0) {
          G = console.log, Y = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        X++;
      }
    }
    function O() {
      {
        if (X--, X === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, g, {
              value: G
            }),
            info: H({}, g, {
              value: Y
            }),
            warn: H({}, g, {
              value: Q
            }),
            error: H({}, g, {
              value: J
            }),
            group: H({}, g, {
              value: P
            }),
            groupCollapsed: H({}, g, {
              value: _
            }),
            groupEnd: H({}, g, {
              value: z
            })
          });
        }
        X < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = L.ReactCurrentDispatcher, F;
    function j(g, T, Z) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            F = ee && ee[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, A;
    {
      var K = typeof WeakMap == "function" ? WeakMap : Map;
      A = new K();
    }
    function B(g, T) {
      if (!g || q)
        return "";
      {
        var Z = A.get(g);
        if (Z !== void 0)
          return Z;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (T) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Le) {
              ee = Le;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (Le) {
              ee = Le;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Le) {
            ee = Le;
          }
          g();
        }
      } catch (Le) {
        if (Le && ee && typeof Le.stack == "string") {
          for (var ie = Le.stack.split(`
`), we = ee.stack.split(`
`), de = ie.length - 1, fe = we.length - 1; de >= 1 && fe >= 0 && ie[de] !== we[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== we[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== we[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", g.displayName)), typeof g == "function" && A.set(g, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var kt = g ? g.displayName || g.name : "", mt = kt ? j(kt) : "";
      return typeof g == "function" && A.set(g, mt), mt;
    }
    function le(g, T, Z) {
      return B(g, !1);
    }
    function he(g) {
      var T = g.prototype;
      return !!(T && T.isReactComponent);
    }
    function re(g, T, Z) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return B(g, he(g));
      if (typeof g == "string")
        return j(g);
      switch (g) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return re(g.type, T, Z);
          case d: {
            var ee = g, ae = ee._payload, ue = ee._init;
            try {
              return re(ue(ae), T, Z);
            } catch {
            }
          }
        }
      return "";
    }
    var Se = Object.prototype.hasOwnProperty, We = {}, Ze = L.ReactDebugCurrentFrame;
    function Me(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        Ze.setExtraStackFrame(Z);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(g, T, Z, ee, ae) {
      {
        var ue = Function.call.bind(Se);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var we = Error((ee || "React class") + ": " + Z + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw we.name = "Invariant Violation", we;
              }
              ie = g[se](T, se, ee, Z, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Me(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", Z, se, typeof ie), Me(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Me(ae), w("Failed %s type: %s", Z, ie.message), Me(null));
          }
      }
    }
    var Ve = Array.isArray;
    function be(g) {
      return Ve(g);
    }
    function qe(g) {
      {
        var T = typeof Symbol == "function" && Symbol.toStringTag, Z = T && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return Z;
      }
    }
    function ct(g) {
      try {
        return ye(g), !1;
      } catch {
        return !0;
      }
    }
    function ye(g) {
      return "" + g;
    }
    function xe(g) {
      if (ct(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qe(g)), ye(g);
    }
    var Ee = L.ReactCurrentOwner, Ue = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, De, st, ve;
    ve = {};
    function wt(g) {
      if (Se.call(g, "ref")) {
        var T = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function at(g) {
      if (Se.call(g, "key")) {
        var T = Object.getOwnPropertyDescriptor(g, "key").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function lt(g, T) {
      if (typeof g.ref == "string" && Ee.current && T && Ee.current.stateNode !== T) {
        var Z = $(Ee.current.type);
        ve[Z] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ee.current.type), g.ref), ve[Z] = !0);
      }
    }
    function pt(g, T) {
      {
        var Z = function() {
          De || (De = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: Z,
          configurable: !0
        });
      }
    }
    function Ot(g, T) {
      {
        var Z = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        Z.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: Z,
          configurable: !0
        });
      }
    }
    var dt = function(g, T, Z, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: T,
        ref: Z,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function Ct(g, T, Z, ee, ae) {
      {
        var ue, se = {}, ie = null, we = null;
        Z !== void 0 && (xe(Z), ie = "" + Z), at(T) && (xe(T.key), ie = "" + T.key), wt(T) && (we = T.ref, lt(T, ae));
        for (ue in T)
          Se.call(T, ue) && !Ue.hasOwnProperty(ue) && (se[ue] = T[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || we) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && pt(se, fe), we && Ot(se, fe);
        }
        return dt(g, ie, we, ae, ee, Ee.current, se);
      }
    }
    var Xe = L.ReactCurrentOwner, ht = L.ReactDebugCurrentFrame;
    function ot(g) {
      if (g) {
        var T = g._owner, Z = re(g.type, g._source, T ? T.type : null);
        ht.setExtraStackFrame(Z);
      } else
        ht.setExtraStackFrame(null);
    }
    var xt;
    xt = !1;
    function ft(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Pt() {
      {
        if (Xe.current) {
          var g = $(Xe.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Lt(g) {
      return "";
    }
    var St = {};
    function Et(g) {
      {
        var T = Pt();
        if (!T) {
          var Z = typeof g == "string" ? g : g.displayName || g.name;
          Z && (T = `

Check the top-level render call using <` + Z + ">.");
        }
        return T;
      }
    }
    function Mt(g, T) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var Z = Et(T);
        if (St[Z])
          return;
        St[Z] = !0;
        var ee = "";
        g && g._owner && g._owner !== Xe.current && (ee = " It was passed a child from " + $(g._owner.type) + "."), ot(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Z, ee), ot(null);
      }
    }
    function _t(g, T) {
      {
        if (typeof g != "object")
          return;
        if (be(g))
          for (var Z = 0; Z < g.length; Z++) {
            var ee = g[Z];
            ft(ee) && Mt(ee, T);
          }
        else if (ft(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              ft(se.value) && Mt(se.value, T);
        }
      }
    }
    function gt(g) {
      {
        var T = g.type;
        if (T == null || typeof T == "string")
          return;
        var Z;
        if (typeof T == "function")
          Z = T.propTypes;
        else if (typeof T == "object" && (T.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        T.$$typeof === p))
          Z = T.propTypes;
        else
          return;
        if (Z) {
          var ee = $(T);
          rt(Z, g.props, "prop", ee, g);
        } else if (T.PropTypes !== void 0 && !xt) {
          xt = !0;
          var ae = $(T);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof T.getDefaultProps == "function" && !T.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function te(g) {
      {
        for (var T = Object.keys(g.props), Z = 0; Z < T.length; Z++) {
          var ee = T[Z];
          if (ee !== "children" && ee !== "key") {
            ot(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), ot(null);
            break;
          }
        }
        g.ref !== null && (ot(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), ot(null));
      }
    }
    var Br = {};
    function Nr(g, T, Z, ee, ae, ue) {
      {
        var se = R(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var we = Lt();
          we ? ie += we : ie += Pt();
          var de;
          g === null ? de = "null" : be(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = Ct(g, T, Z, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = T.children;
          if (ze !== void 0)
            if (ee)
              if (be(ze)) {
                for (var kt = 0; kt < ze.length; kt++)
                  _t(ze[kt], g);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              _t(ze, g);
        }
        if (Se.call(T, "key")) {
          var mt = $(g), Le = Object.keys(T).filter(function(Si) {
            return Si !== "key";
          }), In = Le.length > 0 ? "{key: someKey, " + Le.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Br[mt + In]) {
            var Pi = Le.length > 0 ? "{" + Le.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, In, mt, Pi, mt), Br[mt + In] = !0;
          }
        }
        return g === r ? te(fe) : gt(fe), fe;
      }
    }
    function xi(g, T, Z) {
      return Nr(g, T, Z, !0);
    }
    function Li(g, T, Z) {
      return Nr(g, T, Z, !1);
    }
    var Ei = Li, ki = xi;
    oy.Fragment = r, oy.jsx = Ei, oy.jsxs = ki;
  }()), oy;
}
process.env.NODE_ENV === "production" ? CD.exports = RPe() : CD.exports = FPe();
var Os = CD.exports;
He({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function JU(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Zi(e) {
  var t, n;
  return JU(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(JU(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var qoe = Symbol.for("immer-nothing"), QU = Symbol.for("immer-draftable"), da = Symbol.for("immer-state"), zPe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function hs(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = zPe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Ed = Object.getPrototypeOf;
function Qp(e) {
  return !!e && !!e[da];
}
function ed(e) {
  var t;
  return e ? Xoe(e) || Array.isArray(e) || !!e[QU] || !!((t = e.constructor) != null && t[QU]) || qC(e) || XC(e) : !1;
}
var UPe = Object.prototype.constructor.toString();
function Xoe(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Ed(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === UPe;
}
function iw(e, t) {
  ZC(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function ZC(e) {
  const t = e[da];
  return t ? t.type_ : Array.isArray(e) ? 1 : qC(e) ? 2 : XC(e) ? 3 : 0;
}
function xD(e, t) {
  return ZC(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Koe(e, t, n) {
  const r = ZC(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function WPe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function qC(e) {
  return e instanceof Map;
}
function XC(e) {
  return e instanceof Set;
}
function op(e) {
  return e.copy_ || e.base_;
}
function LD(e, t) {
  if (qC(e))
    return new Map(e);
  if (XC(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Xoe(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[da];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Ed(e), r);
  } else {
    const r = Ed(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function PA(e, t = !1) {
  return KC(e) || Qp(e) || !ed(e) || (ZC(e) > 1 && (e.set = e.add = e.clear = e.delete = HPe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => PA(r, !0))), e;
}
function HPe() {
  hs(2);
}
function KC(e) {
  return Object.isFrozen(e);
}
var VPe = {};
function td(e) {
  const t = VPe[e];
  return t || hs(0, e), t;
}
var Dg;
function Goe() {
  return Dg;
}
function $Pe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function eW(e, t) {
  t && (td("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function ED(e) {
  kD(e), e.drafts_.forEach(ZPe), e.drafts_ = null;
}
function kD(e) {
  e === Dg && (Dg = e.parent_);
}
function tW(e) {
  return Dg = $Pe(Dg, e);
}
function ZPe(e) {
  const t = e[da];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function nW(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[da].modified_ && (ED(t), hs(4)), ed(e) && (e = sw(t, e), t.parent_ || aw(t, e)), t.patches_ && td("Patches").generateReplacementPatches_(
    n[da].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = sw(t, n, []), ED(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== qoe ? e : void 0;
}
function sw(e, t, n) {
  if (KC(t))
    return t;
  const r = t[da];
  if (!r)
    return iw(
      t,
      (o, i) => rW(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return aw(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), iw(
      i,
      (s, l) => rW(e, r, o, s, l, n, a)
    ), aw(e, o, !1), n && e.patches_ && td("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function rW(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && hs(5), Qp(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !xD(t.assigned_, r) ? i.concat(r) : void 0, l = sw(e, o, s);
    if (Koe(n, r, l), Qp(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (ed(o) && !KC(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    sw(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && aw(e, o);
  }
}
function aw(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && PA(t, n);
}
function qPe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : Goe(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = SA;
  n && (o = [r], i = _g);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var SA = {
  get(e, t) {
    if (t === da)
      return e;
    const n = op(e);
    if (!xD(n, t))
      return XPe(e, n, t);
    const r = n[t];
    return e.finalized_ || !ed(r) ? r : r === dE(e.base_, t) ? (fE(e), e.copy_[t] = SD(r, e)) : r;
  },
  has(e, t) {
    return t in op(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(op(e));
  },
  set(e, t, n) {
    const r = Yoe(op(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = dE(op(e), t), i = o == null ? void 0 : o[da];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (WPe(n, o) && (n !== void 0 || xD(e.base_, t)))
        return !0;
      fE(e), PD(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return dE(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, fE(e), PD(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = op(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    hs(11);
  },
  getPrototypeOf(e) {
    return Ed(e.base_);
  },
  setPrototypeOf() {
    hs(12);
  }
}, _g = {};
iw(SA, (e, t) => {
  _g[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
_g.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && hs(13), _g.set.call(this, e, t, void 0);
};
_g.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && hs(14), SA.set.call(this, e[0], t, n, e[0]);
};
function dE(e, t) {
  const n = e[da];
  return (n ? op(n) : e)[t];
}
function XPe(e, t, n) {
  var r;
  const o = Yoe(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function Yoe(e, t) {
  if (!(t in e))
    return;
  let n = Ed(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Ed(n);
  }
}
function PD(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && PD(e.parent_));
}
function fE(e) {
  e.copy_ || (e.copy_ = LD(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var KPe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && hs(6), r !== void 0 && typeof r != "function" && hs(7);
      let o;
      if (ed(t)) {
        const i = tW(this), a = SD(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? ED(i) : kD(i);
        }
        return eW(i, r), nW(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === qoe && (o = void 0), this.autoFreeze_ && PA(o, !0), r) {
          const i = [], a = [];
          td("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        hs(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ed(e) || hs(8), Qp(e) && (e = GPe(e));
    const t = tW(this), n = SD(e, void 0);
    return n[da].isManual_ = !0, kD(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[da];
    (!n || !n.isManual_) && hs(9);
    const { scope_: r } = n;
    return eW(r, t), nW(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = td("Patches").applyPatches_;
    return Qp(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function SD(e, t) {
  const n = qC(e) ? td("MapSet").proxyMap_(e, t) : XC(e) ? td("MapSet").proxySet_(e, t) : qPe(e, t);
  return (t ? t.scope_ : Goe()).drafts_.push(n), n;
}
function GPe(e) {
  return Qp(e) || hs(10, e), Joe(e);
}
function Joe(e) {
  if (!ed(e) || KC(e))
    return e;
  const t = e[da];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = LD(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = LD(e, !0);
  return iw(n, (r, o) => {
    Koe(n, r, Joe(o));
  }), t && (t.finalized_ = !1), n;
}
var fa = new KPe(), MA = fa.produce;
fa.produceWithPatches.bind(
  fa
);
fa.setAutoFreeze.bind(fa);
fa.setUseStrictShallowCopy.bind(fa);
fa.applyPatches.bind(fa);
var oW = fa.createDraft.bind(fa), iW = fa.finishDraft.bind(fa), nt = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = nt.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return nt.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return nt.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return nt.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return nt.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && nt.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return nt.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && nt.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && nt.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && nt.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && nt.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && nt.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!nt.isAncestor(t, e) && !nt.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (nt.equals(i, r) || nt.endsBefore(i, r) || nt.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (nt.equals(a, r) || nt.isAncestor(a, r))
          return null;
        nt.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        nt.equals(s, r) || nt.endsBefore(s, r) ? r[s.length - 1] -= 1 : nt.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (nt.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else nt.endsBefore(u, r) ? r[u.length - 1] += 1 : nt.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (nt.equals(p, d))
          return r;
        if (nt.isAncestor(p, r) || nt.equals(p, r)) {
          var y = d.slice();
          return nt.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else nt.isSibling(p, d) && (nt.isAncestor(d, r) || nt.equals(d, r)) ? nt.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : nt.endsBefore(d, r) || nt.equals(d, r) || nt.isAncestor(d, r) ? (nt.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : nt.endsBefore(p, r) && (nt.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Tg(e) {
  "@babel/helpers - typeof";
  return Tg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Tg(e);
}
function YPe(e, t) {
  if (Tg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Tg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function JPe(e) {
  var t = YPe(e, "string");
  return Tg(t) === "symbol" ? t : String(t);
}
function Bd(e, t, n) {
  return t = JPe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function sW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sW(Object(n), !0).forEach(function(r) {
      Bd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var QPe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Ft.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of on.points(t))
          t[l] = Qr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Ft.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of on.points(t))
          t[b] = Qr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = Ft.get(e, L), D = nt.previous(L), x = Ft.get(e, D), m = Ft.parent(e, L), C = L[L.length - 1];
      if (ei.isText(w) && ei.isText(x))
        x.text += w.text;
      else if (!ei.isText(w) && !ei.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(Fs.stringify(w), " ").concat(Fs.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of on.points(t))
          t[U] = Qr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: R
      } = n;
      if (nt.isAncestor(k, R))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(R, "] because the destination is inside itself."));
      var N = Ft.get(e, k), V = Ft.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var H = nt.transform(k, n), X = Ft.get(e, nt.parent(H)), G = H[H.length - 1];
      if (X.children.splice(G, 0, N), t)
        for (var [Y, Q] of on.points(t))
          t[Q] = Qr.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = Ft.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of on.points(t)) {
          var W = Qr.transform(z, n);
          if (t != null && W != null)
            t[M] = W;
          else {
            var O = void 0, I = void 0;
            for (var [F, j] of Ft.texts(e))
              if (nt.compare(j, J) === -1)
                O = [F, j];
              else {
                I = [F, j];
                break;
              }
            var q = !1;
            O && I && (nt.equals(I[1], J) ? q = !nt.hasPrevious(I[1]) : q = nt.common(O[1], J).length < nt.common(I[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : I ? (z.path = I[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: K,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = Ft.leaf(e, A), he = le.text.slice(0, K), re = le.text.slice(K + B.length);
      if (le.text = he + re, t)
        for (var [Se, We] of on.points(t))
          t[We] = Qr.transform(Se, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: Me,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = Ft.get(e, Ze);
      for (var be in rt) {
        if (be === "children" || be === "text")
          throw new Error('Cannot set the "'.concat(be, '" property of nodes!'));
        var qe = rt[be];
        qe == null ? delete Ve[be] : Ve[be] = qe;
      }
      for (var ct in Me)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!on.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Fs.stringify(ye), " when there is no current selection."));
          t = wf({}, ye);
        }
        for (var xe in ye) {
          var Ee = ye[xe];
          if (Ee == null) {
            if (xe === "anchor" || xe === "focus")
              throw new Error('Cannot remove the "'.concat(xe, '" selection property'));
            delete t[xe];
          } else
            t[xe] = Ee;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ue,
        position: De,
        properties: st
      } = n;
      if (Ue.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ue, "] because the root node cannot be split."));
      var ve = Ft.get(e, Ue), wt = Ft.parent(e, Ue), at = Ue[Ue.length - 1], lt;
      if (ei.isText(ve)) {
        var pt = ve.text.slice(0, De), Ot = ve.text.slice(De);
        ve.text = pt, lt = wf(wf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = ve.children.slice(0, De), Ct = ve.children.slice(De);
        ve.children = dt, lt = wf(wf({}, st), {}, {
          children: Ct
        });
      }
      if (wt.children.splice(at + 1, 0, lt), t)
        for (var [Xe, ht] of on.points(t))
          t[ht] = Qr.transform(Xe, n);
      break;
    }
  }
  return t;
}, eSe = {
  transform(e, t) {
    e.children = oW(e.children);
    var n = e.selection && oW(e.selection);
    try {
      n = QPe(e, n, t);
    } finally {
      e.children = iW(e.children), n ? e.selection = Qp(n) ? iW(n) : n : e.selection = null;
    }
  }
}, tSe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, nSe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Qoe = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Zi(r) && Zi(o)) {
      if (!Qoe(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function rSe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function jg(e, t) {
  if (e == null) return {};
  var n = rSe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var oSe = ["anchor", "focus"];
function aW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iSe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aW(Object(n), !0).forEach(function(r) {
      Bd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var on = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return on.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = on.edges(e);
    return t;
  },
  equals(e, t) {
    return Qr.equals(e.anchor, t.anchor) && Qr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (on.isRange(t)) {
      if (on.includes(e, t.anchor) || on.includes(e, t.focus))
        return !0;
      var [n, r] = on.edges(e), [o, i] = on.edges(t);
      return Qr.isBefore(n, o) && Qr.isAfter(r, i);
    }
    var [a, s] = on.edges(e), l = !1, u = !1;
    return Qr.isPoint(t) ? (l = Qr.compare(t, a) >= 0, u = Qr.compare(t, s) <= 0) : (l = nt.compare(t, a.path) >= 0, u = nt.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = jg(e, oSe), [r, o] = on.edges(e), [i, a] = on.edges(t), s = Qr.isBefore(r, i) ? i : r, l = Qr.isBefore(o, a) ? o : a;
    return Qr.isBefore(l, s) ? null : iSe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Qr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Qr.equals(t, n);
  },
  isExpanded(e) {
    return !on.isCollapsed(e);
  },
  isForward(e) {
    return !on.isBackward(e);
  },
  isRange(e) {
    return Zi(e) && Qr.isPoint(e.anchor) && Qr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = on.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return MA(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = on.isCollapsed(r);
        on.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? on.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Qr.transform(r.anchor, t, {
        affinity: i
      }), u = Qr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, lW = (e) => Zi(e) && Ft.isNodeList(e.children) && !kr.isEditor(e), Nl = {
  isAncestor(e) {
    return Zi(e) && Ft.isNodeList(e.children);
  },
  isElement: lW,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Nl.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return lW(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, sSe = ["children"], aSe = ["text"], uW = /* @__PURE__ */ new WeakMap(), Ft = {
  ancestor(e, t) {
    var n = Ft.get(e, t);
    if (ei.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Fs.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of nt.ancestors(t, n)) {
        var o = Ft.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (ei.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Fs.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Fs.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Ft.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Ft.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = nt.common(t, n), o = Ft.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Ft.get(e, t);
    if (kr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Fs.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ft.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ft.nodes(e, t))
        Nl.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Nl.isAncestor(e)) {
      var t = jg(e, sSe);
      return t;
    } else {
      var t = jg(e, aSe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Ft.get(e, n); r && !(ei.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (ei.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Fs.stringify(e)));
    var n = MA({
      children: e.children
    }, (r) => {
      var [o, i] = on.edges(t), a = Ft.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !on.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!on.includes(t, s)) {
          var l = Ft.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (nt.equals(s, i.path)) {
          var c = Ft.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (nt.equals(s, o.path)) {
          var p = Ft.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      kr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ei.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Fs.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ei.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return ei.isText(e) || Nl.isElement(e) || kr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = uW.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Ft.isNode(r));
    return uW.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Ft.get(e, n); r && !(ei.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Ft.get(e, t);
    if (!ei.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Fs.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of nt.levels(t, n)) {
        var o = Ft.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Nl.isElement(e) && Nl.isElementProps(t) && Nl.matches(e, t) || ei.isText(e) && ei.isTextProps(t) && ei.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? nt.isBefore(s, i) : nt.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !ei.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          nt.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Ft.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = nt.next(s);
          if (Ft.has(e, c)) {
            s = c, l = Ft.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = nt.previous(s);
          s = p, l = Ft.get(e, s);
          continue;
        }
        s = nt.parent(s), l = Ft.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = nt.parent(t), r = Ft.get(e, n);
    if (ei.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return ei.isText(e) ? e.text : e.children.map(Ft.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ft.nodes(e, t))
        ei.isText(n) && (yield [n, r]);
    }();
  }
};
function cW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cW(Object(n), !0).forEach(function(r) {
      Bd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ph = {
  isNodeOperation(e) {
    return ph.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Zi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return nt.isPath(e.path) && Ft.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && nt.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && nt.isPath(e.path) && Zi(e.properties);
      case "move_node":
        return nt.isPath(e.path) && nt.isPath(e.newPath);
      case "remove_node":
        return nt.isPath(e.path) && Ft.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && nt.isPath(e.path);
      case "set_node":
        return nt.isPath(e.path) && Zi(e.properties) && Zi(e.newProperties);
      case "set_selection":
        return e.properties === null && on.isRange(e.newProperties) || e.newProperties === null && on.isRange(e.properties) || Zi(e.properties) && Zi(e.newProperties);
      case "split_node":
        return nt.isPath(e.path) && typeof e.position == "number" && Zi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => ph.isOperation(t));
  },
  isSelectionOperation(e) {
    return ph.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return ph.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return lo(lo({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return lo(lo({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return lo(lo({}, e), {}, {
          type: "split_node",
          path: nt.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (nt.equals(t, n))
          return e;
        if (nt.isSibling(n, t))
          return lo(lo({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = nt.transform(n, e), o = nt.transform(nt.next(n), e);
        return lo(lo({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return lo(lo({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return lo(lo({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return lo(lo({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? lo(lo({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? lo(lo({}, e), {}, {
          properties: null,
          newProperties: s
        }) : lo(lo({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return lo(lo({}, e), {}, {
          type: "merge_node",
          path: nt.next(e.path)
        });
    }
  }
}, pW = /* @__PURE__ */ new WeakMap(), lSe = (e) => {
  var t = pW.get(e);
  if (t !== void 0)
    return t;
  if (!Zi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Zi(e.marks)) && (e.selection === null || on.isRange(e.selection)) && Ft.isNodeList(e.children) && ph.isOperationList(e.operations);
  return pW.set(e, n), n;
}, kr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return lSe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function dW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fW(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dW(Object(n), !0).forEach(function(r) {
      Bd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qr = {
  compare(e, t) {
    var n = nt.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Qr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Qr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && nt.equals(e.path, t.path);
  },
  isPoint(e) {
    return Zi(e) && typeof e.offset == "number" && nt.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return MA(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = nt.transform(i, t, n);
          break;
        }
        case "insert_text": {
          nt.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          nt.equals(t.path, i) && (r.offset += t.position), r.path = nt.transform(i, t, n);
          break;
        }
        case "remove_text": {
          nt.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (nt.equals(t.path, i) || nt.isAncestor(t.path, i))
            return null;
          r.path = nt.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (nt.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = nt.transform(i, t, fW(fW({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = nt.transform(i, t, n);
          break;
        }
      }
    });
  }
}, hW = void 0, Fs = {
  setScrubber(e) {
    hW = e;
  },
  stringify(e) {
    return JSON.stringify(e, hW);
  }
}, uSe = ["text"], cSe = ["anchor", "focus"];
function gW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gW(Object(n), !0).forEach(function(r) {
      Bd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ei = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = jg(i, uSe);
      return a;
    }
    return Qoe(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Zi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => ei.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [wl({}, e)];
    for (var r of t) {
      var o = jg(r, cSe), [i, a] = on.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = wl(wl({}, f), {}, {
            text: f.text.slice(L)
          }), f = wl(wl({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = wl(wl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = wl(wl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, pSe = (e) => e.selection ? e.selection : e.children.length > 0 ? kr.end(e, []) : [0], $r;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})($r || ($r = {}));
$r.L, $r.L | $r.V | $r.LV | $r.LVT, $r.LV | $r.V, $r.V | $r.T, $r.LVT | $r.T, $r.T, $r.Any, $r.Extend | $r.ZWJ, $r.Any, $r.SpacingMark, $r.Prepend, $r.Any, $r.ZWJ, $r.ExtPict, $r.RI, $r.RI;
var dSe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    kr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = pSe(e)
      } = n;
      if (nt.isPath(o) && (o = kr.range(e, o)), on.isRange(o))
        if (on.isCollapsed(o))
          o = o.anchor;
        else {
          var i = on.end(o);
          if (!r && kr.void(e, {
            at: i
          }))
            return;
          var a = on.start(o), s = kr.pointRef(e, a), l = kr.pointRef(e, i);
          lw.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, lw.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && kr.void(e, {
        at: o
      }) || kr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function mW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mW(Object(n), !0).forEach(function(r) {
      Bd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lw = iy(iy(iy(iy({}, eSe), tSe), nSe), dSe), eie = {}, DA = {}, _A = {};
Object.defineProperty(_A, "__esModule", { value: !0 });
_A.default = mSe;
var vW = "html", yW = "head", sy = "body", fSe = /<([a-zA-Z]+[0-9]?)/, bW = /<head[^]*>/i, wW = /<body[^]*>/i, uw = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, MD = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, OW = typeof window == "object" && window.DOMParser;
if (typeof OW == "function") {
  var hSe = new OW(), gSe = "text/html";
  MD = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), hSe.parseFromString(e, gSe);
  }, uw = MD;
}
if (typeof document == "object" && document.implementation) {
  var ay = document.implementation.createHTMLDocument();
  uw = function(e, t) {
    if (t) {
      var n = ay.documentElement.querySelector(t);
      return n && (n.innerHTML = e), ay;
    }
    return ay.documentElement.innerHTML = e, ay;
  };
}
var ly = typeof document == "object" && document.createElement("template"), DD;
ly && ly.content && (DD = function(e) {
  return ly.innerHTML = e, ly.content.childNodes;
});
function mSe(e) {
  var t, n, r = e.match(fSe), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case vW: {
      var i = MD(e);
      if (!bW.test(e)) {
        var a = i.querySelector(yW);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!wW.test(e)) {
        var a = i.querySelector(sy);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(vW);
    }
    case yW:
    case sy: {
      var s = uw(e).querySelectorAll(o);
      return wW.test(e) && bW.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (DD)
        return DD(e);
      var a = uw(e, sy).querySelector(sy);
      return a.childNodes;
    }
  }
}
var GC = {}, TA = {}, jA = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(jA);
var gn = {}, bc = Ir && Ir.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Dh = Ir && Ir.__assign || function() {
  return Dh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Dh.apply(this, arguments);
};
Object.defineProperty(gn, "__esModule", { value: !0 });
gn.cloneNode = gn.hasChildren = gn.isDocument = gn.isDirective = gn.isComment = gn.isText = gn.isCDATA = gn.isTag = gn.Element = gn.Document = gn.CDATA = gn.NodeWithChildren = gn.ProcessingInstruction = gn.Comment = gn.Text = gn.DataNode = gn.Node = void 0;
var Ds = jA, AA = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), IA(this, t);
    }, e;
  }()
);
gn.Node = AA;
var YC = (
  /** @class */
  function(e) {
    bc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(AA)
);
gn.DataNode = YC;
var tie = (
  /** @class */
  function(e) {
    bc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ds.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(YC)
);
gn.Text = tie;
var nie = (
  /** @class */
  function(e) {
    bc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ds.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(YC)
);
gn.Comment = nie;
var rie = (
  /** @class */
  function(e) {
    bc(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ds.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(YC)
);
gn.ProcessingInstruction = rie;
var JC = (
  /** @class */
  function(e) {
    bc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(AA)
);
gn.NodeWithChildren = JC;
var oie = (
  /** @class */
  function(e) {
    bc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ds.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(JC)
);
gn.CDATA = oie;
var iie = (
  /** @class */
  function(e) {
    bc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ds.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(JC)
);
gn.Document = iie;
var sie = (
  /** @class */
  function(e) {
    bc(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ds.ElementType.Script : n === "style" ? Ds.ElementType.Style : Ds.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(JC)
);
gn.Element = sie;
function aie(e) {
  return (0, Ds.isTag)(e);
}
gn.isTag = aie;
function lie(e) {
  return e.type === Ds.ElementType.CDATA;
}
gn.isCDATA = lie;
function uie(e) {
  return e.type === Ds.ElementType.Text;
}
gn.isText = uie;
function cie(e) {
  return e.type === Ds.ElementType.Comment;
}
gn.isComment = cie;
function pie(e) {
  return e.type === Ds.ElementType.Directive;
}
gn.isDirective = pie;
function die(e) {
  return e.type === Ds.ElementType.Root;
}
gn.isDocument = die;
function vSe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
gn.hasChildren = vSe;
function IA(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (uie(e))
    n = new tie(e.data);
  else if (cie(e))
    n = new nie(e.data);
  else if (aie(e)) {
    var r = t ? hE(e.children) : [], o = new sie(e.name, Dh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Dh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Dh({}, e["x-attribsPrefix"])), n = o;
  } else if (lie(e)) {
    var r = t ? hE(e.children) : [], i = new oie(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (die(e)) {
    var r = t ? hE(e.children) : [], a = new iie(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (pie(e)) {
    var s = new rie(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
gn.cloneNode = IA;
function hE(e) {
  for (var t = e.map(function(r) {
    return IA(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Ir && Ir.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Ir && Ir.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = jA, o = gn;
  n(gn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(TA);
var fie = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(fie);
Object.defineProperty(GC, "__esModule", { value: !0 });
GC.formatAttributes = hie;
GC.formatDOM = gie;
var uy = TA, ySe = fie;
function bSe(e) {
  return ySe.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function hie(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function wSe(e) {
  e = e.toLowerCase();
  var t = bSe(e);
  return t || e;
}
function gie(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = wSe(s.nodeName);
        o = new uy.Element(l, hie(s.attributes)), o.children = gie(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new uy.Text(s.nodeValue);
        break;
      case 8:
        o = new uy.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new uy.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var OSe = Ir && Ir.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(DA, "__esModule", { value: !0 });
DA.default = ESe;
var CSe = OSe(_A), xSe = GC, LSe = /<(![a-zA-Z\s]+)>/;
function ESe(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(LSe), n = t ? t[1] : void 0;
  return (0, xSe.formatDOM)((0, CSe.default)(e), null, n);
}
var QC = {}, Ia = {}, ex = {}, kSe = 0;
ex.SAME = kSe;
var PSe = 1;
ex.CAMELCASE = PSe;
ex.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const mie = 0, wc = 1, tx = 2, nx = 3, BA = 4, vie = 5, yie = 6;
function SSe(e) {
  return Ni.hasOwnProperty(e) ? Ni[e] : null;
}
function os(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === tx || t === nx || t === BA, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Ni = {}, MSe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
MSe.forEach((e) => {
  Ni[e] = new os(
    e,
    mie,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Ni[e] = new os(
    e,
    wc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Ni[e] = new os(
    e,
    tx,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Ni[e] = new os(
    e,
    tx,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Ni[e] = new os(
    e,
    nx,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ni[e] = new os(
    e,
    nx,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ni[e] = new os(
    e,
    BA,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ni[e] = new os(
    e,
    yie,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Ni[e] = new os(
    e,
    vie,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const NA = /[\-\:]([a-z])/g, RA = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(NA, RA);
  Ni[t] = new os(
    t,
    wc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(NA, RA);
  Ni[t] = new os(
    t,
    wc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(NA, RA);
  Ni[t] = new os(
    t,
    wc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Ni[e] = new os(
    e,
    wc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const DSe = "xlinkHref";
Ni[DSe] = new os(
  "xlinkHref",
  wc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Ni[e] = new os(
    e,
    wc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: _Se,
  SAME: TSe,
  possibleStandardNames: CW
} = ex, jSe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ASe = jSe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", ISe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + ASe + "]*$")
), BSe = Object.keys(
  CW
).reduce((e, t) => {
  const n = CW[t];
  return n === TSe ? e[t] = t : n === _Se ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Ia.BOOLEAN = nx;
Ia.BOOLEANISH_STRING = tx;
Ia.NUMERIC = vie;
Ia.OVERLOADED_BOOLEAN = BA;
Ia.POSITIVE_NUMERIC = yie;
Ia.RESERVED = mie;
Ia.STRING = wc;
Ia.getPropertyInfo = SSe;
Ia.isCustomAttribute = ISe;
Ia.possibleStandardNames = BSe;
var FA = {}, zA = {}, xW = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, NSe = /\n/g, RSe = /^\s*/, FSe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, zSe = /^:\s*/, USe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, WSe = /^[;\s]*/, HSe = /^\s+|\s+$/g, VSe = `
`, LW = "/", EW = "*", hp = "", $Se = "comment", ZSe = "declaration", qSe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(NSe);
    v && (n += v.length);
    var b = f.lastIndexOf(VSe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(RSe);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(LW != e.charAt(0) || EW != e.charAt(1))) {
      for (var v = 2; hp != e.charAt(v) && (EW != e.charAt(v) || LW != e.charAt(v + 1)); )
        ++v;
      if (v += 2, hp === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: $Se,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(FSe);
    if (v) {
      if (p(), !l(zSe)) return s("property missing ':'");
      var b = l(USe), L = f({
        type: ZSe,
        property: kW(v[0].replace(xW, hp)),
        value: b ? kW(b[0].replace(xW, hp)) : hp
      });
      return l(WSe), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function kW(e) {
  return e ? e.replace(HSe, hp) : hp;
}
var XSe = Ir && Ir.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(zA, "__esModule", { value: !0 });
zA.default = GSe;
var KSe = XSe(qSe);
function GSe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, KSe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var rx = {};
Object.defineProperty(rx, "__esModule", { value: !0 });
rx.camelCase = void 0;
var YSe = /^--[a-zA-Z0-9_-]+$/, JSe = /-([a-z])/g, QSe = /^[^-]+$/, eMe = /^-(webkit|moz|ms|o|khtml)-/, tMe = /^-(ms)-/, nMe = function(e) {
  return !e || QSe.test(e) || YSe.test(e);
}, rMe = function(e, t) {
  return t.toUpperCase();
}, PW = function(e, t) {
  return "".concat(t, "-");
}, oMe = function(e, t) {
  return t === void 0 && (t = {}), nMe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(tMe, PW) : e = e.replace(eMe, PW), e.replace(JSe, rMe));
};
rx.camelCase = oMe;
var iMe = Ir && Ir.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, sMe = iMe(zA), aMe = rx;
function _D(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, sMe.default)(e, function(r, o) {
    r && o && (n[(0, aMe.camelCase)(r, t)] = o);
  }), n;
}
_D.default = _D;
var lMe = _D;
(function(e) {
  var t = Ir && Ir.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Oe, r = t(lMe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(FA);
Object.defineProperty(QC, "__esModule", { value: !0 });
QC.default = dMe;
var dh = Ia, SW = FA, uMe = ["checked", "value"], cMe = ["input", "select", "textarea"], pMe = {
  reset: !0,
  submit: !0
};
function dMe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && pMe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, dh.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = MW(a);
    if (s) {
      var l = (0, dh.getPropertyInfo)(s);
      switch (uMe.includes(s) && cMe.includes(t) && !r && (s = MW("default" + a)), n[s] = i, l && l.type) {
        case dh.BOOLEAN:
          n[s] = !0;
          break;
        case dh.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    SW.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, SW.setStyleProp)(e.style, n), n;
}
function MW(e) {
  return dh.possibleStandardNames[e];
}
var UA = {}, fMe = Ir && Ir.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(UA, "__esModule", { value: !0 });
UA.default = bie;
var gE = Oe, hMe = fMe(QC), _h = FA, gMe = {
  cloneElement: gE.cloneElement,
  createElement: gE.createElement,
  isValidElement: gE.isValidElement
};
function bie(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || _h.returnFirstArg, i = t.library || gMe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, _h.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    mMe(f) ? ((0, _h.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, hMe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = bie(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function mMe(e) {
  return _h.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, _h.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Ir && Ir.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(DA);
  e.htmlToDOM = n.default;
  var r = t(QC);
  e.attributesToProps = r.default;
  var o = t(UA);
  e.domToReact = o.default;
  var i = TA;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(eie);
const vMe = /* @__PURE__ */ NPe(eie);
vMe.default;
He({});
function yMe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const bMe = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
yMe(bMe.CNPJ).length;
ka((e, t) => /* @__PURE__ */ Os.jsx("input", { ref: t, ...e }));
He({});
var Gl = {};
Object.defineProperty(Gl, "__esModule", {
  value: !0
});
var wMe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), mE = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, wie = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: wMe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, WA = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var cy = 1; cy < 20; cy++)
  WA["f" + cy] = 111 + cy;
function ox(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Oie(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Cie(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function OMe(e, t) {
  return ox(e, t);
}
function CMe(e, t) {
  return ox(e, { byKey: !0 }, t);
}
function Oie(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in mE)
    r[mE[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = HA(d), v = mE[f];
      if (d.length > 1 && !v && !wie[d] && !WA[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = xie(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Cie(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function xie(e) {
  e = HA(e);
  var t = WA[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function HA(e) {
  return e = e.toLowerCase(), e = wie[e] || e, e;
}
Gl.default = ox;
var vE = Gl.isHotkey = ox;
Gl.isCodeHotkey = OMe;
Gl.isKeyHotkey = CMe;
Gl.parseHotkey = Oie;
Gl.compareHotkey = Cie;
Gl.toKeyCode = xie;
Gl.toKeyName = HA;
var xMe = typeof Ir == "object" && Ir && Ir.Object === Object && Ir, LMe = xMe, EMe = LMe, kMe = typeof self == "object" && self && self.Object === Object && self, PMe = EMe || kMe || Function("return this")(), SMe = PMe, MMe = SMe, DMe = MMe.Symbol, Lie = DMe, DW = Lie;
DW && DW.toStringTag;
var _W = Lie;
_W && _W.toStringTag;
var TW;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(TW || (TW = {}));
var VA = function(e) {
  return Object.freeze(e);
}, _Me = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, VA(this);
  }
  return e;
}(), TMe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, VA(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), jW = typeof window < "u" ? window : {};
/msie|trident/i.test(jW.navigator && jW.navigator.userAgent);
var yE = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new _Me((n ? t : e) || 0, (n ? e : t) || 0);
};
VA({
  devicePixelContentBoxSize: yE(),
  borderBoxSize: yE(),
  contentBoxSize: yE(),
  contentRect: new TMe(0, 0, 0, 0)
});
function Ag(e) {
  "@babel/helpers - typeof";
  return Ag = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ag(e);
}
function jMe(e, t) {
  if (Ag(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ag(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function AMe(e) {
  var t = jMe(e, "string");
  return Ag(t) === "symbol" ? t : String(t);
}
function Th(e, t, n) {
  return t = AMe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var IMe = /* @__PURE__ */ He(null), bE, wE;
parseInt(Oe.version.split(".")[0], 10);
var AW = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), OE = typeof navigator < "u" && /Android/.test(navigator.userAgent), py = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), BMe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (bE = navigator.userAgent.match(/Version\/(\d+)/)) !== null && bE !== void 0 && bE[1] && parseInt((wE = navigator.userAgent.match(/Version\/(\d+)/)) === null || wE === void 0 ? void 0 : wE[1], 10) < 17;
var NMe = /* @__PURE__ */ new WeakMap(), RMe = /* @__PURE__ */ new WeakMap(), FMe = /* @__PURE__ */ new WeakMap(), zMe = /* @__PURE__ */ new WeakMap(), UMe = /* @__PURE__ */ new WeakMap(), IW = /* @__PURE__ */ new WeakMap(), WMe = /* @__PURE__ */ new WeakMap(), BW = /* @__PURE__ */ new WeakMap(), dy = /* @__PURE__ */ new WeakMap(), HMe = /* @__PURE__ */ new WeakMap(), VMe = /* @__PURE__ */ new WeakMap(), $Me = /* @__PURE__ */ new WeakMap(), Eie = globalThis.Node, ZMe = globalThis.Text, kie = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, qMe = (e) => cw(e) && e.nodeType === 8, qa = (e) => cw(e) && e.nodeType === 1, cw = (e) => {
  var t = kie(e);
  return !!t && e instanceof t.Node;
}, NW = (e) => {
  var t = e && e.anchorNode && kie(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, XMe = (e) => {
  var [t, n] = e;
  if (qa(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Pie(t, o, r ? "backward" : "forward"), r = o < n; qa(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = GMe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, KMe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Pie = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (qMe(o) || qa(o) && o.childNodes.length === 0 || qa(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, GMe = (e, t, n) => {
  var [r] = Pie(e, t, n);
  return r;
}, RW = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Sie = (e, t, n) => {
  var {
    target: r
  } = t;
  if (qa(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = vn.getWindow(e);
  if (o.contains(r))
    return vn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Sie(e, i, n);
}, FW = (e, t) => !!(e.compareDocumentPosition(t) & Eie.DOCUMENT_POSITION_PRECEDING), YMe = (e, t) => !!(e.compareDocumentPosition(t) & Eie.DOCUMENT_POSITION_FOLLOWING), JMe = 0;
class QMe {
  constructor() {
    Th(this, "id", void 0), this.id = "".concat(JMe++);
  }
}
var vn = {
  androidPendingDiffs: (e) => $Me.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = VMe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = vn.toDOMNode(e, e), n = vn.findDocumentOrShadowRoot(e);
    dy.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = vn.findDocumentOrShadowRoot(e), r = RW(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && lw.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = vn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = vn.toSlateNode(e, t.target), a = vn.findPath(e, i);
    if (Nl.isElement(i) && kr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = kr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? kr.before(e, u) : kr.after(e, u);
      if (c) {
        var p = kr.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = vn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = vn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = IW.get(t);
    return n || (n = new QMe(), IW.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = RMe.get(r);
      if (o == null) {
        if (kr.isEditor(r))
          return n;
        break;
      }
      var i = NMe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Fs.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!dy.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          vn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = vn.toDOMNode(e, e), r = vn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = RW(r), i = vn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || lw.select(e, kr.start(e, [])), dy.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = FMe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = vn.toDOMNode(e, e), i;
    try {
      i = qa(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => cw(t) && vn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return kr.hasPath(e, n.path) && kr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => vn.hasEditableTarget(e, t) || vn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => cw(t) && vn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!HMe.get(e),
  isFocused: (e) => !!dy.get(e),
  isReadOnly: (e) => !!BW.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (BW.get(e)) return !1;
    var n = vn.hasTarget(e, t) && vn.toSlateNode(e, t);
    return Nl.isElement(n) && kr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = WMe.get(e), r = kr.isEditor(t) ? zMe.get(e) : n == null ? void 0 : n.get(vn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Fs.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = kr.node(e, t.path), r = vn.toDOMNode(e, n), o;
    kr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof ZMe ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Fs.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = on.isBackward(t), i = vn.toDOMPoint(e, n), a = on.isCollapsed(t) ? i : vn.toDOMPoint(e, r), s = vn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = qa(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = qa(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = qa(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? UMe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : XMe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = vn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = vn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (OE && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var R = U[k];
          if (vn.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var N = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, H = [...N(V), ...N(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = H.find((M) => YMe(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var X, G = [...N(V == null ? void 0 : V.previousElementSibling), ...N(V)];
          w = (X = G.findLast((M) => FW(L, M))) !== null && X !== void 0 ? X : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      OE && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      py && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (OE && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && vn.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = vn.toSlateNode(e, Y), {
          path: J,
          offset: P
        } = kr.start(e, vn.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = vn.toSlateNode(e, u), z = vn.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = NW(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (NW(t)) {
        if (py && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        BMe && KMe(s) || py ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    py && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = vn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = FW(s, u) || s === u && c < l, x = p ? w : vn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return on.isExpanded(m) && on.isForward(m) && qa(u) && kr.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = kr.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, eDe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, tDe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, nDe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, uo = (e) => {
  var t = eDe[e], n = tDe[e], r = nDe[e], o = t && vE(t), i = n && vE(n), a = r && vE(r);
  return (s) => !!(o && o(s) || AW && i && i(s) || !AW && a && a(s));
};
uo("bold"), uo("compose"), uo("moveBackward"), uo("moveForward"), uo("deleteBackward"), uo("deleteForward"), uo("deleteLineBackward"), uo("deleteLineForward"), uo("deleteWordBackward"), uo("deleteWordForward"), uo("extendBackward"), uo("extendForward"), uo("extendLineBackward"), uo("extendLineForward"), uo("italic"), uo("moveLineBackward"), uo("moveLineForward"), uo("moveWordBackward"), uo("moveWordForward"), uo("redo"), uo("insertSoftBreak"), uo("splitBlock"), uo("transposeCharacter"), uo("undo");
var rDe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Sie(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, oDe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class iDe extends Kl {
  constructor() {
    super(...arguments), Th(this, "context", null), Th(this, "manager", null), Th(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, oDe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = rDe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Th(iDe, "contextType", IMe);
He({});
He({});
He({});
var ti = {}, $A = {}, tm = {}, nm = {}, Mie = "Expected a function", zW = NaN, sDe = "[object Symbol]", aDe = /^\s+|\s+$/g, lDe = /^[-+]0x[0-9a-f]+$/i, uDe = /^0b[01]+$/i, cDe = /^0o[0-7]+$/i, pDe = parseInt, dDe = typeof Ir == "object" && Ir && Ir.Object === Object && Ir, fDe = typeof self == "object" && self && self.Object === Object && self, hDe = dDe || fDe || Function("return this")(), gDe = Object.prototype, mDe = gDe.toString, vDe = Math.max, yDe = Math.min, CE = function() {
  return hDe.Date.now();
};
function bDe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Mie);
  t = UW(t) || 0, pw(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? vDe(UW(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? yDe(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = CE();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(CE());
  }
  function m() {
    var C = CE(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function wDe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Mie);
  return pw(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), bDe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function pw(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function ODe(e) {
  return !!e && typeof e == "object";
}
function CDe(e) {
  return typeof e == "symbol" || ODe(e) && mDe.call(e) == sDe;
}
function UW(e) {
  if (typeof e == "number")
    return e;
  if (CDe(e))
    return zW;
  if (pw(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = pw(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(aDe, "");
  var n = uDe.test(e);
  return n || cDe.test(e) ? pDe(e.slice(2), n ? 2 : 8) : lDe.test(e) ? zW : +e;
}
var xDe = wDe, rm = {};
Object.defineProperty(rm, "__esModule", {
  value: !0
});
rm.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), t0.has(t) || t0.set(t, /* @__PURE__ */ new Set());
  var o = t0.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
rm.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), t0.get(t).delete(n.name || t);
};
var t0 = /* @__PURE__ */ new Map();
Object.defineProperty(nm, "__esModule", {
  value: !0
});
var LDe = xDe, EDe = PDe(LDe), kDe = rm;
function PDe(e) {
  return e && e.__esModule ? e : { default: e };
}
var SDe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, EDe.default)(e, t);
}, Mo = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = SDe(function(r) {
        Mo.scrollHandler(e);
      }, t);
      Mo.scrollSpyContainers.push(e), (0, kDe.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return Mo.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Mo.scrollSpyContainers[Mo.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Mo.currentPositionX(e), Mo.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Mo.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Mo.scrollSpyContainers[Mo.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(Mo.currentPositionX(t), Mo.currentPositionY(t));
  },
  updateStates: function() {
    Mo.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Mo.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Mo.spySetState && Mo.spySetState.length && Mo.spySetState.indexOf(e) > -1 && Mo.spySetState.splice(Mo.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Mo.scrollHandler);
  },
  update: function() {
    return Mo.scrollSpyContainers.forEach(function(e) {
      return Mo.scrollHandler(e);
    });
  }
};
nm.default = Mo;
var Nd = {}, om = {};
Object.defineProperty(om, "__esModule", {
  value: !0
});
var MDe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, DDe = function() {
  return window.location.hash.replace(/^#/, "");
}, _De = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, TDe = function(e) {
  return getComputedStyle(e).position !== "static";
}, xE = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, jDe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (TDe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = xE(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return xE(t, s).offsetTop - xE(e, s).offsetTop;
};
om.default = {
  updateHash: MDe,
  getHash: DDe,
  filterElementInContainer: _De,
  scrollOffset: jDe
};
var ix = {}, ZA = {};
Object.defineProperty(ZA, "__esModule", {
  value: !0
});
ZA.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var qA = {};
Object.defineProperty(qA, "__esModule", {
  value: !0
});
var ADe = rm, IDe = ["mousedown", "mousewheel", "touchmove", "keydown"];
qA.default = {
  subscribe: function(e) {
    return typeof document < "u" && IDe.forEach(function(t) {
      return (0, ADe.addPassiveEventListener)(document, t, e);
    });
  }
};
var im = {};
Object.defineProperty(im, "__esModule", {
  value: !0
});
var TD = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      TD.registered[e] = t;
    },
    remove: function(e) {
      TD.registered[e] = null;
    }
  }
};
im.default = TD;
Object.defineProperty(ix, "__esModule", {
  value: !0
});
var BDe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, NDe = om;
sx(NDe);
var RDe = ZA, WW = sx(RDe), FDe = qA, zDe = sx(FDe), UDe = im, Ra = sx(UDe);
function sx(e) {
  return e && e.__esModule ? e : { default: e };
}
var Die = function(e) {
  return WW.default[e.smooth] || WW.default.defaultEasing;
}, WDe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, HDe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, jD = function() {
  return HDe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), _ie = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Tie = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, jie = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, VDe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, $De = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, ZDe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Ra.default.registered.end && Ra.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    jD.call(window, i);
    return;
  }
  Ra.default.registered.end && Ra.default.registered.end(o.to, o.target, o.currentPosition);
}, XA = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, sm = function(e, t, n, r) {
  t.data = t.data || _ie(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (zDe.default.subscribe(o), XA(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Tie(t) : jie(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Ra.default.registered.end && Ra.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = WDe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Die(t), a = ZDe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Ra.default.registered.begin && Ra.default.registered.begin(t.data.to, t.data.target), jD.call(window, a);
    }, t.delay);
    return;
  }
  Ra.default.registered.begin && Ra.default.registered.begin(t.data.to, t.data.target), jD.call(window, a);
}, ax = function(e) {
  return e = BDe({}, e), e.data = e.data || _ie(), e.absolute = !0, e;
}, qDe = function(e) {
  sm(0, ax(e));
}, XDe = function(e, t) {
  sm(e, ax(t));
}, KDe = function(e) {
  e = ax(e), XA(e), sm(e.horizontal ? VDe(e) : $De(e), e);
}, GDe = function(e, t) {
  t = ax(t), XA(t);
  var n = t.horizontal ? Tie(t) : jie(t);
  sm(e + n, t);
};
ix.default = {
  animateTopScroll: sm,
  getAnimationType: Die,
  scrollToTop: qDe,
  scrollToBottom: KDe,
  scrollTo: XDe,
  scrollMore: GDe
};
Object.defineProperty(Nd, "__esModule", {
  value: !0
});
var YDe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, JDe = om, QDe = KA(JDe), e_e = ix, t_e = KA(e_e), n_e = im, fy = KA(n_e);
function KA(e) {
  return e && e.__esModule ? e : { default: e };
}
var hy = {}, HW = void 0;
Nd.default = {
  unmount: function() {
    hy = {};
  },
  register: function(e, t) {
    hy[e] = t;
  },
  unregister: function(e) {
    delete hy[e];
  },
  get: function(e) {
    return hy[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return HW = e;
  },
  getActiveLink: function() {
    return HW;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = YDe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = QDe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      fy.default.registered.begin && fy.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, fy.default.registered.end && fy.default.registered.end(e, n);
      return;
    }
    t_e.default.animateTopScroll(s, t, e, n);
  }
};
var AD = { exports: {} }, LE = { exports: {} }, Qn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VW;
function r_e() {
  if (VW) return Qn;
  VW = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return Qn.AsyncMode = l, Qn.ConcurrentMode = u, Qn.ContextConsumer = s, Qn.ContextProvider = a, Qn.Element = t, Qn.ForwardRef = c, Qn.Fragment = r, Qn.Lazy = f, Qn.Memo = y, Qn.Portal = n, Qn.Profiler = i, Qn.StrictMode = o, Qn.Suspense = p, Qn.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, Qn.isConcurrentMode = x, Qn.isContextConsumer = function(m) {
    return D(m) === s;
  }, Qn.isContextProvider = function(m) {
    return D(m) === a;
  }, Qn.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, Qn.isForwardRef = function(m) {
    return D(m) === c;
  }, Qn.isFragment = function(m) {
    return D(m) === r;
  }, Qn.isLazy = function(m) {
    return D(m) === f;
  }, Qn.isMemo = function(m) {
    return D(m) === y;
  }, Qn.isPortal = function(m) {
    return D(m) === n;
  }, Qn.isProfiler = function(m) {
    return D(m) === i;
  }, Qn.isStrictMode = function(m) {
    return D(m) === o;
  }, Qn.isSuspense = function(m) {
    return D(m) === p;
  }, Qn.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, Qn.typeOf = D, Qn;
}
var cr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $W;
function o_e() {
  return $W || ($W = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === y || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === L || B.$$typeof === w || B.$$typeof === v);
    }
    function x(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var re = he && he.$$typeof;
                switch (re) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return re;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, R = c, N = r, V = f, $ = y, H = n, X = i, G = o, Y = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || x(B) === l;
    }
    function P(B) {
      return x(B) === u;
    }
    function _(B) {
      return x(B) === s;
    }
    function z(B) {
      return x(B) === a;
    }
    function M(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return x(B) === c;
    }
    function O(B) {
      return x(B) === r;
    }
    function I(B) {
      return x(B) === f;
    }
    function F(B) {
      return x(B) === y;
    }
    function j(B) {
      return x(B) === n;
    }
    function q(B) {
      return x(B) === i;
    }
    function A(B) {
      return x(B) === o;
    }
    function K(B) {
      return x(B) === p;
    }
    cr.AsyncMode = m, cr.ConcurrentMode = C, cr.ContextConsumer = S, cr.ContextProvider = U, cr.Element = k, cr.ForwardRef = R, cr.Fragment = N, cr.Lazy = V, cr.Memo = $, cr.Portal = H, cr.Profiler = X, cr.StrictMode = G, cr.Suspense = Y, cr.isAsyncMode = J, cr.isConcurrentMode = P, cr.isContextConsumer = _, cr.isContextProvider = z, cr.isElement = M, cr.isForwardRef = W, cr.isFragment = O, cr.isLazy = I, cr.isMemo = F, cr.isPortal = j, cr.isProfiler = q, cr.isStrictMode = A, cr.isSuspense = K, cr.isValidElementType = D, cr.typeOf = x;
  }()), cr;
}
var ZW;
function Aie() {
  return ZW || (ZW = 1, process.env.NODE_ENV === "production" ? LE.exports = r_e() : LE.exports = o_e()), LE.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var EE, qW;
function i_e() {
  if (qW) return EE;
  qW = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return EE = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, EE;
}
var kE, XW;
function GA() {
  if (XW) return kE;
  XW = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return kE = e, kE;
}
var KW, GW;
function Iie() {
  return GW || (GW = 1, KW = Function.call.bind(Object.prototype.hasOwnProperty)), KW;
}
var PE, YW;
function s_e() {
  if (YW) return PE;
  YW = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = GA(), n = {}, r = Iie();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, PE = o, PE;
}
var SE, JW;
function a_e() {
  if (JW) return SE;
  JW = 1;
  var e = Aie(), t = i_e(), n = GA(), r = Iie(), o = s_e(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return SE = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, I, F, j, q, A, K) {
        if (j = j || d, A = A || F, K !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = j + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return I[F] == null ? O ? I[F] === null ? new v("The " + q + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new v("The " + q + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : P(I, F, j, q, A);
      }
      var W = M.bind(null, !1);
      return W.isRequired = M.bind(null, !0), W;
    }
    function L(P) {
      function _(z, M, W, O, I, F) {
        var j = z[M], q = G(j);
        if (q !== P) {
          var A = Y(j);
          return new v(
            "Invalid " + O + " `" + I + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var j = G(F);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var A = P(F, q, W, O, I + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!s(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!e.isValidElementType(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, W, O, I) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, j = J(z[M]);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, W, O, I) {
        for (var F = z[M], j = 0; j < P.length; j++)
          if (f(F, P[j]))
            return null;
        var q = JSON.stringify(P, function(A, K) {
          var B = Y(K);
          return B === "symbol" ? String(K) : K;
        });
        return new v("Invalid " + O + " `" + I + "` of value `" + String(F) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var A = P(F, q, W, O, I + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(W, O, I, F, j) {
        for (var q = [], A = 0; A < P.length; A++) {
          var K = P[A], B = K(W, O, I, F, j, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + j + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(M);
    }
    function R() {
      function P(_, z, M, W, O) {
        return H(_[z]) ? null : new v("Invalid " + W + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function N(P, _, z, M, W) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return N(W, O, I, q, Y(A));
          var K = A(F, q, W, O, I + "." + q, n);
          if (K)
            return K;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var A in q) {
          var K = P[A];
          if (r(P, A) && typeof K != "function")
            return N(W, O, I, A, Y(K));
          if (!K)
            return new v(
              "Invalid " + O + " `" + I + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = K(F, A, W, O, I + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!H(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var W = M.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function X(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function G(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : X(_, P) ? "symbol" : _;
    }
    function Y(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = G(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = Y(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, SE;
}
var ME, QW;
function l_e() {
  if (QW) return ME;
  QW = 1;
  var e = GA();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, ME = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, ME;
}
if (process.env.NODE_ENV !== "production") {
  var u_e = Aie(), c_e = !0;
  AD.exports = a_e()(u_e.isElement, c_e);
} else
  AD.exports = l_e()();
var lx = AD.exports, ux = {};
Object.defineProperty(ux, "__esModule", {
  value: !0
});
var p_e = om, DE = d_e(p_e);
function d_e(e) {
  return e && e.__esModule ? e : { default: e };
}
var f_e = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return DE.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && DE.default.getHash() !== e && DE.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
ux.default = f_e;
Object.defineProperty(tm, "__esModule", {
  value: !0
});
var gy = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, h_e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), g_e = Oe, eH = am(g_e), m_e = nm, my = am(m_e), v_e = Nd, y_e = am(v_e), b_e = lx, co = am(b_e), w_e = ux, iu = am(w_e);
function am(e) {
  return e && e.__esModule ? e : { default: e };
}
function O_e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function C_e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function x_e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var tH = {
  to: co.default.string.isRequired,
  containerId: co.default.string,
  container: co.default.object,
  activeClass: co.default.string,
  activeStyle: co.default.object,
  spy: co.default.bool,
  horizontal: co.default.bool,
  smooth: co.default.oneOfType([co.default.bool, co.default.string]),
  offset: co.default.number,
  delay: co.default.number,
  isDynamic: co.default.bool,
  onClick: co.default.func,
  duration: co.default.oneOfType([co.default.number, co.default.func]),
  absolute: co.default.bool,
  onSetActive: co.default.func,
  onSetInactive: co.default.func,
  ignoreCancelEvents: co.default.bool,
  hashSpy: co.default.bool,
  saveHashHistory: co.default.bool,
  spyThrottle: co.default.number
};
tm.default = function(e, t) {
  var n = t || y_e.default, r = function(i) {
    x_e(a, i);
    function a(s) {
      O_e(this, a);
      var l = C_e(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return h_e(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          my.default.isMounted(s) || my.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (iu.default.isMounted() || iu.default.mount(n), iu.default.mapContainer(this.props.to, s)), my.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        my.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = gy({}, this.props.style, this.props.activeStyle) : l = gy({}, this.props.style);
        var u = gy({}, this.props);
        for (var c in tH)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, eH.default.createElement(e, u);
      }
    }]), a;
  }(eH.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, gy({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(iu.default.isMounted() && !iu.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var R = n.getActiveLink();
        if (y) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && iu.default.getHash() === c) {
            var N = i.props.saveHashHistory, V = N === void 0 ? !1 : N;
            iu.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, H = $ === void 0 ? !1 : $;
          i.props.hashSpy && iu.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = tH, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty($A, "__esModule", {
  value: !0
});
var L_e = Oe, nH = Bie(L_e), E_e = tm, k_e = Bie(E_e);
function Bie(e) {
  return e && e.__esModule ? e : { default: e };
}
function P_e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function rH(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function S_e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var M_e = function(e) {
  S_e(t, e);
  function t() {
    var n, r, o, i;
    P_e(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = rH(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return nH.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), rH(o, i);
  }
  return t;
}(nH.default.Component);
$A.default = (0, k_e.default)(M_e);
var YA = {};
Object.defineProperty(YA, "__esModule", {
  value: !0
});
var D_e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), __e = Oe, oH = Nie(__e), T_e = tm, j_e = Nie(T_e);
function Nie(e) {
  return e && e.__esModule ? e : { default: e };
}
function A_e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function I_e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function B_e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var N_e = function(e) {
  B_e(t, e);
  function t() {
    return A_e(this, t), I_e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return D_e(t, [{
    key: "render",
    value: function() {
      return oH.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(oH.default.Component);
YA.default = (0, j_e.default)(N_e);
var JA = {}, cx = {};
Object.defineProperty(cx, "__esModule", {
  value: !0
});
var R_e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, F_e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), z_e = Oe, iH = px(z_e), U_e = nl;
px(U_e);
var W_e = Nd, sH = px(W_e), H_e = lx, aH = px(H_e);
function px(e) {
  return e && e.__esModule ? e : { default: e };
}
function V_e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function $_e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Z_e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
cx.default = function(e) {
  var t = function(n) {
    Z_e(r, n);
    function r(o) {
      V_e(this, r);
      var i = $_e(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return F_e(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        sH.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        sH.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return iH.default.createElement(e, R_e({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(iH.default.Component);
  return t.propTypes = {
    name: aH.default.string,
    id: aH.default.string
  }, t;
};
Object.defineProperty(JA, "__esModule", {
  value: !0
});
var lH = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, q_e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), X_e = Oe, uH = QA(X_e), K_e = cx, G_e = QA(K_e), Y_e = lx, cH = QA(Y_e);
function QA(e) {
  return e && e.__esModule ? e : { default: e };
}
function J_e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Q_e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function eTe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Rie = function(e) {
  eTe(t, e);
  function t() {
    return J_e(this, t), Q_e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return q_e(t, [{
    key: "render",
    value: function() {
      var n = this, r = lH({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, uH.default.createElement(
        "div",
        lH({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(uH.default.Component);
Rie.propTypes = {
  name: cH.default.string,
  id: cH.default.string
};
JA.default = (0, G_e.default)(Rie);
var _E = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, pH = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function dH(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function fH(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function hH(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var vy = Oe, _c = nm, TE = Nd, Ro = lx, su = ux, gH = {
  to: Ro.string.isRequired,
  containerId: Ro.string,
  container: Ro.object,
  activeClass: Ro.string,
  spy: Ro.bool,
  smooth: Ro.oneOfType([Ro.bool, Ro.string]),
  offset: Ro.number,
  delay: Ro.number,
  isDynamic: Ro.bool,
  onClick: Ro.func,
  duration: Ro.oneOfType([Ro.number, Ro.func]),
  absolute: Ro.bool,
  onSetActive: Ro.func,
  onSetInactive: Ro.func,
  ignoreCancelEvents: Ro.bool,
  hashSpy: Ro.bool,
  spyThrottle: Ro.number
}, tTe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || TE, r = function(i) {
      hH(a, i);
      function a(s) {
        dH(this, a);
        var l = fH(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return pH(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            _c.isMounted(s) || _c.mount(s, this.props.spyThrottle), this.props.hashSpy && (su.isMounted() || su.mount(n), su.mapContainer(this.props.to, s)), this.props.spy && _c.addStateHandler(this.stateHandler), _c.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          _c.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = _E({}, this.props);
          for (var u in gH)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, vy.createElement(e, l);
        }
      }]), a;
    }(vy.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, _E({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(su.isMounted() && !su.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && su.getHash() === l && su.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), _c.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && su.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), _c.updateStates();
        }
      };
    };
    return r.propTypes = gH, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      hH(r, n);
      function r(o) {
        dH(this, r);
        var i = fH(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return pH(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          TE.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          TE.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return vy.createElement(e, _E({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(vy.Component);
    return t.propTypes = {
      name: Ro.string,
      id: Ro.string
    }, t;
  }
}, nTe = tTe;
Object.defineProperty(ti, "__esModule", {
  value: !0
});
ti.Helpers = ti.ScrollElement = ti.ScrollLink = ti.animateScroll = ti.scrollSpy = ti.Events = ti.scroller = ti.Element = ti.Button = ti.Link = void 0;
var rTe = $A, Fie = rl(rTe), oTe = YA, zie = rl(oTe), iTe = JA, Uie = rl(iTe), sTe = Nd, Wie = rl(sTe), aTe = im, Hie = rl(aTe), lTe = nm, Vie = rl(lTe), uTe = ix, $ie = rl(uTe), cTe = tm, Zie = rl(cTe), pTe = cx, qie = rl(pTe), dTe = nTe, Xie = rl(dTe);
function rl(e) {
  return e && e.__esModule ? e : { default: e };
}
ti.Link = Fie.default;
ti.Button = zie.default;
ti.Element = Uie.default;
ti.scroller = Wie.default;
ti.Events = Hie.default;
ti.scrollSpy = Vie.default;
ti.animateScroll = $ie.default;
ti.ScrollLink = Zie.default;
ti.ScrollElement = qie.default;
ti.Helpers = Xie.default;
ti.default = { Link: Fie.default, Button: zie.default, Element: Uie.default, scroller: Wie.default, Events: Hie.default, scrollSpy: Vie.default, animateScroll: $ie.default, ScrollLink: Zie.default, ScrollElement: qie.default, Helpers: Xie.default };
He({});
He({});
He({});
function Ig(e) {
  "@babel/helpers - typeof";
  return Ig = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ig(e);
}
function fTe(e, t) {
  if (Ig(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ig(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function hTe(e) {
  var t = fTe(e, "string");
  return Ig(t) == "symbol" ? t : t + "";
}
function Te(e, t, n) {
  return (t = hTe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Kie(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var jE, mH;
function gTe() {
  if (mH) return jE;
  mH = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return jE = t, jE;
}
var mTe = gTe(), ci = /* @__PURE__ */ Kie(mTe), Wt = He(null);
function vTe() {
  ci(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Wt);
  return ci(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function yTe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function bTe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function wTe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return bTe(e, i), o;
}
function OTe(e, t, n) {
  var r = yTe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function CTe(e) {
  google.maps.event.removeListener(e);
}
function Bn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(CTe);
}
function En(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = OTe(o, i, n);
  return wTe(t, r, o, i), a;
}
function xTe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = vt(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null), [A, K] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), K(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var B = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(B), B !== null && D && D(B), () => {
      B !== null && x && x(B);
    };
  }, []), Os.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: Os.jsx(Wt.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(xTe);
function vH(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Gie(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        vH(i, r, o, a, s, "next", l);
      }
      function s(l) {
        vH(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Yie(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return ci(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var gp = typeof document < "u";
function Jie(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return gp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function yH(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Qie() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return yH(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return yH(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Of = !1;
function ese() {
  return Os.jsx("div", {
    children: "Loading..."
  });
}
var ID = {
  id: "script-loader",
  version: "weekly"
};
class LTe extends pe {
  constructor() {
    super(...arguments), Te(this, "check", jn()), Te(this, "state", {
      loaded: !1
    }), Te(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Te(this, "isCleaningUp", /* @__PURE__ */ Gie(function* () {
      function t(n) {
        if (!Of)
          n();
        else if (gp)
          var r = window.setInterval(function() {
            Of || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Te(this, "cleanup", () => {
      Of = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Te(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Qie(), ci(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Yie(this.props)
      };
      Jie(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (gp) {
      if (window.google && window.google.maps && !Of) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), gp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (gp) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Of = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Os.jsxs(Os.Fragment, {
      children: [Os.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Os.jsx(ese, {})]
    });
  }
}
Te(LTe, "defaultProps", ID);
function ETe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function eI(e, t) {
  if (e == null) return {};
  var n, r, o = ETe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var bH;
function kTe(e) {
  var {
    id: t = ID.id,
    version: n = ID.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = vt(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    gp && u && Qie();
  }, [u]), h(function() {
    f && ci(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Yie({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!gp)
      return;
    function x() {
      y.current && (v(!0), bH = w);
    }
    if (window.google && window.google.maps && bH === w) {
      x();
      return;
    }
    Jie({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = vt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var PTe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], STe = Os.jsx(ese, {});
function MTe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = eI(e, PTe), {
    isLoaded: s,
    loadError: l
  } = kTe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || STe;
}
me(MTe);
var wH;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(wH || (wH = {}));
function OH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OH(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var CH = {}, xH = {
  options(e, t) {
    e.setOptions(t);
  }
};
function DTe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Wt), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(dw(dw({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(DTe);
class _Te extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      trafficLayer: null
    }), Te(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Te(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(dw(dw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: xH,
      eventMap: CH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: xH,
      eventMap: CH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Bn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(_Te, "contextType", Wt);
function TTe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Wt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(TTe);
class jTe extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      bicyclingLayer: null
    }), Te(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(jTe, "contextType", Wt);
function ATe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Wt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(ATe);
class ITe extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      transitLayer: null
    }), Te(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(ITe, "contextType", Wt);
function LH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LH(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var EH = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, kH = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function BTe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Wt), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    ci(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(fw(fw({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && L(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && k(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(BTe);
class NTe extends pe {
  constructor(t) {
    super(t), Te(this, "registeredEvents", []), Te(this, "state", {
      drawingManager: null
    }), Te(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), ci(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(fw(fw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: kH,
      eventMap: EH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: kH,
      eventMap: EH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Bn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Te(NTe, "contextType", Wt);
function PH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PH(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var SH = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, MH = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, hw = {};
function RTe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: R,
    onClickableChanged: N,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: H,
    onFlatChanged: X,
    onIconChanged: G,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, W = ge(Wt), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null), [re, Se] = E(null), [We, Ze] = E(null), [Me, rt] = E(null), [Ve, be] = E(null), [qe, ct] = E(null), [ye, xe] = E(null), [Ee, Ue] = E(null), [De, st] = E(null), [ve, wt] = E(null), [at, lt] = E(null), [pt, Ot] = E(null), [dt, Ct] = E(null), [Xe, ht] = E(null), [ot, xt] = E(null), [ft, Pt] = E(null), [Lt, St] = E(null), [Et, Mt] = E(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (re !== null && google.maps.event.removeListener(re), Se(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), Ze(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Me !== null && google.maps.event.removeListener(Me), rt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && R && (Ve !== null && google.maps.event.removeListener(Ve), be(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && L && (qe !== null && google.maps.event.removeListener(qe), ct(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (ye !== null && google.maps.event.removeListener(ye), xe(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && N && (Ee !== null && google.maps.event.removeListener(Ee), Ue(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && V && (De !== null && google.maps.event.removeListener(De), st(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), wt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && X && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(O, "flat_changed", X)));
  }, [X]), h(() => {
    O && G && (dt !== null && google.maps.event.removeListener(dt), Ct(google.maps.event.addListener(O, "icon_changed", G)));
  }, [G]), h(() => {
    O && Y && (Xe !== null && google.maps.event.removeListener(Xe), ht(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (ot !== null && google.maps.event.removeListener(ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (ft !== null && google.maps.event.removeListener(ft), Pt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Lt !== null && google.maps.event.removeListener(Lt), St(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (Et !== null && google.maps.event.removeListener(Et), Mt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var gt = sd(sd(sd({}, n || hw), r ? hw : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(gt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof y < "u" && te.setOpacity(y), f && te.setShape(f), typeof v == "string" && te.setTitle(v), typeof b == "number" && te.setZIndex(b), w && j(google.maps.event.addListener(te, "dblclick", w)), x && A(google.maps.event.addListener(te, "dragend", x)), m && B(google.maps.event.addListener(te, "dragstart", m)), k && he(google.maps.event.addListener(te, "mousedown", k)), C && Se(google.maps.event.addListener(te, "mouseout", C)), S && Ze(google.maps.event.addListener(te, "mouseover", S)), U && rt(google.maps.event.addListener(te, "mouseup", U)), R && be(google.maps.event.addListener(te, "rightclick", R)), L && ct(google.maps.event.addListener(te, "click", L)), D && xe(google.maps.event.addListener(te, "drag", D)), N && Ue(google.maps.event.addListener(te, "clickable_changed", N)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), $ && wt(google.maps.event.addListener(te, "animation_changed", $)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), X && Ot(google.maps.event.addListener(te, "flat_changed", X)), G && Ct(google.maps.event.addListener(te, "icon_changed", G)), Y && ht(google.maps.event.addListener(te, "position_changed", Y)), Q && xt(google.maps.event.addListener(te, "shape_changed", Q)), J && Pt(google.maps.event.addListener(te, "title_changed", J)), P && St(google.maps.event.addListener(te, "visible_changed", P)), _ && Mt(google.maps.event.addListener(te, "zindex_changed", _)), I(te), z && z(te), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), re !== null && google.maps.event.removeListener(re), We !== null && google.maps.event.removeListener(We), Me !== null && google.maps.event.removeListener(Me), Ve !== null && google.maps.event.removeListener(Ve), qe !== null && google.maps.event.removeListener(qe), Ee !== null && google.maps.event.removeListener(Ee), De !== null && google.maps.event.removeListener(De), ve !== null && google.maps.event.removeListener(ve), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), Xe !== null && google.maps.event.removeListener(Xe), ft !== null && google.maps.event.removeListener(ft), Lt !== null && google.maps.event.removeListener(Lt), Et !== null && google.maps.event.removeListener(Et), M && M(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var _t = zt(() => i ? ut.map(i, (gt) => {
    if (!wi(gt))
      return gt;
    var te = gt;
    return Oi(te, {
      anchor: O
    });
  }) : null, [i, O]);
  return Os.jsx(Os.Fragment, {
    children: _t
  }) || null;
}
me(RTe);
class FTe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Gie(function* () {
      var n = sd(sd(sd({}, t.props.options || hw), t.props.clusterer ? hw : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = En({
        updaterMap: MH,
        eventMap: SH,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: MH,
      eventMap: SH,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Bn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Oi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Te(FTe, "contextType", Wt);
var zTe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), UTe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new zTe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function WTe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var HTe = 2e3, VTe = 500, $Te = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", ZTe = "png", qTe = [53, 56, 66, 78, 90], XTe = "cluster", tse = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || $Te, this.imageExtension = r.imageExtension || ZTe, this.imageSizes = r.imageSizes || qTe, this.calculator = r.calculator || WTe, this.batchSize = r.batchSize || HTe, this.batchSizeIE = r.batchSizeIE || VTe, this.clusterClass = r.clusterClass || XTe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new UTe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function DH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function KTe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DH(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ha = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Vn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, GTe = {};
function YTe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, R] = E(null), N = ge(Wt), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, ha.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, ha.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, ha.onClick, w)));
  }, [w]), h(() => {
    k && D && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(k, ha.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (G !== null && google.maps.event.removeListener(G), X(google.maps.event.addListener(k, ha.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && Vn.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && Vn.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && Vn.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && Vn.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && Vn.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && Vn.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && Vn.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && Vn.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && Vn.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && Vn.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && Vn.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && Vn.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && Vn.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && Vn.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && Vn.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (N) {
      var z = KTe({}, n || GTe), M = new tse(N, [], z);
      return r && Vn.averageCenter(M, r), o && Vn.batchSizeIE(M, o), i && Vn.calculator(M, i), a && Vn.clusterClass(M, a), s && Vn.enableRetinaIcons(M, s), l && Vn.gridSize(M, l), u && Vn.ignoreHidden(M, u), c && Vn.imageExtension(M, c), p && Vn.imagePath(M, p), d && Vn.imageSizes(M, d), y && Vn.maxZoom(M, y), f && Vn.minimumClusterSize(M, f), v && Vn.styles(M, v), b && Vn.title(M, b), L && Vn.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, ha.onMouseOut, C)), m && _(google.maps.event.addListener(M, ha.onMouseOver, m)), w && $(google.maps.event.addListener(M, ha.onClick, w)), D && X(google.maps.event.addListener(M, ha.onClusteringBegin, D)), x && Y(google.maps.event.addListener(M, ha.onClusteringEnd, x)), R(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(YTe);
class JTe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      markerClusterer: null
    }), Te(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new tse(this.context, [], this.props.options);
      this.registeredEvents = En({
        updaterMap: Vn,
        eventMap: ha,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: Vn,
      eventMap: ha,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Bn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Te(JTe, "contextType", Wt);
function _H(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var nse = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || _H(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, _H));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), QTe = ["position"], eje = ["position"];
function TH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TH(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jH = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, AH = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, tje = {};
function nje(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Wt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var N = r || tje, {
        position: V
      } = N, $ = eI(N, QTe), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var X = new nse(gw(gw({}, $), H ? {
        position: H
      } : {}));
      R.current = document.createElement("div"), v(X), a && L(google.maps.event.addListener(X, "closeclick", a)), s && D(google.maps.event.addListener(X, "domready", s)), l && m(google.maps.event.addListener(X, "content_changed", l)), u && S(google.maps.event.addListener(X, "position_changed", u)), c && k(google.maps.event.addListener(X, "zindex_changed", c)), X.setContent(R.current), n ? X.open(y, n) : X.getPosition() ? X.open(y) : ci(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(X);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(nje);
class rje extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", null), Te(this, "state", {
      infoBox: null
    }), Te(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : ci(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Te(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = eI(t, eje), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new nse(gw(gw({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = En({
      updaterMap: AH,
      eventMap: jH,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: AH,
      eventMap: jH,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Bn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
Te(rje, "contextType", Wt);
var IH, BH;
function oje() {
  return BH || (BH = 1, IH = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), IH;
}
var ije = oje(), NH = /* @__PURE__ */ Kie(ije), RH = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], AE = 1, Cf = 8;
class tI {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== AE)
      throw new Error("Got v".concat(o, " data when expected v").concat(AE, "."));
    var i = RH[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new tI(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = RH.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Cf, t), this.coords = new this.ArrayType(this.data, Cf + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Cf + a + s + l), this.ids = new this.IndexArrayType(this.data, Cf, t), this.coords = new this.ArrayType(this.data, Cf + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (AE << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return BD(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          FH(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      FH(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function BD(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    rse(e, t, a, r, o, i), BD(e, t, n, r, a - 1, 1 - i), BD(e, t, n, a + 1, o, 1 - i);
  }
}
function rse(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      rse(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (xf(e, t, r, n), t[2 * o + i] > y && xf(e, t, r, o); f < v; ) {
      for (xf(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? xf(e, t, r, v) : (v++, xf(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function xf(e, t, n, r) {
  IE(e, n, r), IE(t, 2 * n, 2 * r), IE(t, 2 * n + 1, 2 * r + 1);
}
function IE(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function FH(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var sje = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, zH = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Tc = 2, ju = 3, BE = 4, Lu = 5, ose = 6;
class aje {
  constructor(t) {
    this.options = Object.assign(Object.create(sje), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = zH(yy(u)), d = zH(by(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(yy(r), by(a), yy(i), by(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Lu] > 1 ? UH(p, f, this.clusterProps) : this.points[p[f + ju]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + BE] === t && p.push(a[y + Lu] > 1 ? UH(a, y, this.clusterProps) : this.points[a[y + ju]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new tI(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Lu] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = ise(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + ju]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = yy(f), d = by(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + ju] : L = this.points[n[l + ju]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Tc] <= n)) {
        l[p + Tc] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Lu], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + Tc] > n && (b += l[w + Lu]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + Tc] <= n)) {
              l[k + Tc] = n;
              var R = l[k + Lu];
              D += l[k] * R, x += l[k + 1] * R, l[k + BE] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + BE] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + Tc] <= n)) {
                l[$ + Tc] = n;
                for (var H = 0; H < c; H++) u.push(l[$ + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Lu] > 1) {
      var o = this.clusterProps[t[n + ose]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + ju]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function UH(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ju],
    properties: ise(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [lje(e[t]), uje(e[t + 1])]
    }
  };
}
function ise(e, t, n) {
  var r = e[t + Lu], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + ose], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + ju],
    point_count: r,
    point_count_abbreviated: o
  });
}
function yy(e) {
  return e / 360 + 0.5;
}
function by(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function lje(e) {
  return (e - 0.5) * 360;
}
function uje(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function cje(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class zs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class ND {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(zs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => zs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (zs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class pje {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return dje(n);
  }
}
var dje = (e) => {
  var t = e.map((n) => new ND({
    position: zs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class fje extends pje {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = cje(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new aje(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!NH(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = zs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !NH(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new ND({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new ND({
      markers: [i],
      position: zs.getPosition(i)
    });
  }
}
class hje {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class gje {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (zs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function mje(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class nI {
  constructor() {
    mje(nI, google.maps.OverlayView);
  }
}
var jh;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(jh || (jh = {}));
var vje = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class yje extends nI {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new fje(o),
      renderer: a = new gje(),
      onClusterClick: s = vje
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (zs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, jh.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || zs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => zs.setMap(l, null)));
      }
      google.maps.event.trigger(this, jh.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => zs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new hje(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => zs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, jh.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), zs.setMap(r.marker, n);
    });
  }
}
function WH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function HH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WH(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function bje(e) {
  var t = vTe(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new yje(HH(HH({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function wje(e) {
  var {
    children: t,
    options: n
  } = e, r = bje(n);
  return r !== null ? t(r) : null;
}
me(wje);
var VH = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, $H = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Oje(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Wt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return v(N), R.current = document.createElement("div"), a && L(google.maps.event.addListener(N, "closeclick", a)), s && D(google.maps.event.addListener(N, "domready", s)), l && m(google.maps.event.addListener(N, "content_changed", l)), u && S(google.maps.event.addListener(N, "position_changed", u)), c && k(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(R.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(y, n) : N.getPosition() ? N.open(y) : ci(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(N), N.close();
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(Oje);
class Cje extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", null), Te(this, "state", {
      infoWindow: null
    }), Te(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : ci(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Te(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = En({
      updaterMap: $H,
      eventMap: VH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: $H,
      eventMap: VH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Bn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
Te(Cje, "contextType", Wt);
function ZH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZH(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qH = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, XH = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, xje = {};
function Lje(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(Wt), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var j = new google.maps.Polyline(mw(mw({}, t || xje), {}, {
      map: D
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && S(google.maps.event.addListener(j, "dblclick", a)), s && k(google.maps.event.addListener(j, "dragend", s)), l && N(google.maps.event.addListener(j, "dragstart", l)), u && $(google.maps.event.addListener(j, "mousedown", u)), c && X(google.maps.event.addListener(j, "mousemove", c)), p && Y(google.maps.event.addListener(j, "mouseout", p)), d && J(google.maps.event.addListener(j, "mouseover", d)), y && _(google.maps.event.addListener(j, "mouseup", y)), f && M(google.maps.event.addListener(j, "rightclick", f)), v && O(google.maps.event.addListener(j, "click", v)), b && F(google.maps.event.addListener(j, "drag", b)), m(j), L && L(j), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
me(Lje);
class Eje extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      polyline: null
    }), Te(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(mw(mw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: XH,
      eventMap: qH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: XH,
      eventMap: qH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Bn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Te(Eje, "contextType", Wt);
function KH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function GH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KH(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var YH = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, JH = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function kje(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Wt), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var A = new google.maps.Polygon(GH(GH({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && k(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && $(google.maps.event.addListener(A, "dragstart", u)), c && X(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), b && F(google.maps.event.addListener(A, "click", b)), L && q(google.maps.event.addListener(A, "drag", L)), S(A), w && w(A), () => {
      U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), D && D(A), A.setMap(null);
    };
  }, []), null;
}
me(kje);
class Pje extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = En({
      updaterMap: JH,
      eventMap: YH,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: JH,
      eventMap: YH,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Bn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Te(Pje, "contextType", Wt);
function QH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QH(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var eV = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, tV = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Sje(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Wt), [m, C] = E(null), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var K = new google.maps.Rectangle(vw(vw({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && K.setVisible(i), typeof o < "u" && K.setEditable(o), typeof r < "u" && K.setDraggable(r), typeof n < "u" && K.setBounds(n), a && U(google.maps.event.addListener(K, "dblclick", a)), s && R(google.maps.event.addListener(K, "dragend", s)), l && V(google.maps.event.addListener(K, "dragstart", l)), u && H(google.maps.event.addListener(K, "mousedown", u)), c && G(google.maps.event.addListener(K, "mousemove", c)), p && Q(google.maps.event.addListener(K, "mouseout", p)), d && P(google.maps.event.addListener(K, "mouseover", d)), y && z(google.maps.event.addListener(K, "mouseup", y)), f && W(google.maps.event.addListener(K, "rightclick", f)), v && I(google.maps.event.addListener(K, "click", v)), b && j(google.maps.event.addListener(K, "drag", b)), L && A(google.maps.event.addListener(K, "bounds_changed", L)), C(K), w && w(K), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(K), K.setMap(null);
    };
  }, []), null;
}
me(Sje);
class Mje extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      rectangle: null
    }), Te(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(vw(vw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: tV,
      eventMap: eV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: tV,
      eventMap: eV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Bn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Te(Mje, "contextType", Wt);
function nV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nV(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rV = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, oV = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Dje = {};
function _je(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Wt), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var re = new google.maps.Circle(yw(yw({}, t || Dje), {}, {
      map: C
    }));
    return typeof r == "number" && re.setRadius(r), typeof n < "u" && re.setCenter(n), typeof r == "number" && re.setRadius(r), typeof a < "u" && re.setVisible(a), typeof i < "u" && re.setEditable(i), typeof o < "u" && re.setDraggable(o), s && R(google.maps.event.addListener(re, "dblclick", s)), l && V(google.maps.event.addListener(re, "dragend", l)), u && H(google.maps.event.addListener(re, "dragstart", u)), c && G(google.maps.event.addListener(re, "mousedown", c)), p && Q(google.maps.event.addListener(re, "mousemove", p)), d && P(google.maps.event.addListener(re, "mouseout", d)), y && z(google.maps.event.addListener(re, "mouseover", y)), f && W(google.maps.event.addListener(re, "mouseup", f)), v && I(google.maps.event.addListener(re, "rightclick", v)), b && j(google.maps.event.addListener(re, "click", b)), L && A(google.maps.event.addListener(re, "drag", L)), w && B(google.maps.event.addListener(re, "center_changed", w)), D && he(google.maps.event.addListener(re, "radius_changed", D)), U(re), x && x(re), () => {
      k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), m && m(re), re.setMap(null);
    };
  }, []), null;
}
me(_je);
class Tje extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      circle: null
    }), Te(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(yw(yw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: oV,
      eventMap: rV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: oV,
      eventMap: rV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Bn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Te(Tje, "contextType", Wt);
function iV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iV(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sV = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, aV = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function jje(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(Wt), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var A = new google.maps.Data(bw(bw({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && k(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && $(google.maps.event.addListener(A, "mouseover", s)), l && X(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && q(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), j !== null && google.maps.event.removeListener(j), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(jje);
class Aje extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      data: null
    }), Te(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(bw(bw({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = En({
        updaterMap: aV,
        eventMap: sV,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: aV,
      eventMap: sV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Bn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Te(Aje, "contextType", Wt);
function lV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uV(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lV(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cV = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, pV = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class Ije extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      kmlLayer: null
    }), Te(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(uV(uV({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: pV,
      eventMap: cV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: pV,
      eventMap: cV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Bn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(Ije, "contextType", Wt);
function sse(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Bje(e, t) {
  return new t(e.lat, e.lng);
}
function Nje(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Rje(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Fje(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function zje(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Uje(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function ase(e, t, n, r) {
  return n !== void 0 ? zje(e, t, Fje(n, google.maps.LatLngBounds, Nje)) : Uje(e, t, Rje(r, google.maps.LatLng, Bje));
}
function Wje(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function dV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hje(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dV(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Vje(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = Hje({}, this.container ? sse(this.container, o) : {
        x: 0,
        y: 0
      }), u = ase(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function fV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $je(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fV(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function hV(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function gV(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Zje(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Wt), c = zt(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = zt(() => Vje(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
me(Zje);
class Rd extends pe {
  constructor(t) {
    super(t), Te(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Te(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      ci(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Te(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Te(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = $je({
        x: 0,
        y: 0
      }, this.containerRef.current ? sse(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = ase(r, o, this.props.bounds, this.props.position);
      if (!Wje(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Te(this, "draw", () => {
      this.onPositionElement();
    }), Te(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = jn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = hV(t.position), r = hV(this.props.position), o = gV(t.bounds), i = gV(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(Os.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
Te(Rd, "FLOAT_PANE", "floatPane");
Te(Rd, "MAP_PANE", "mapPane");
Te(Rd, "MARKER_LAYER", "markerLayer");
Te(Rd, "OVERLAY_LAYER", "overlayLayer");
Te(Rd, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Te(Rd, "contextType", Wt);
function qje() {
}
function mV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vV(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mV(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yV = {
  onDblClick: "dblclick",
  onClick: "click"
}, bV = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Xje(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Wt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = zt(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(Xje);
class lse extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      groundOverlay: null
    }), Te(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    ci(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, vV(vV({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: bV,
      eventMap: yV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: bV,
      eventMap: yV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Te(lse, "defaultProps", {
  onLoad: qje
});
Te(lse, "contextType", Wt);
function wV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ww(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wV(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var OV = {}, CV = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Kje(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Wt), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || ci(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    ci(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(ww(ww({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(Kje);
class Gje extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      heatmapLayer: null
    }), Te(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    ci(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), ci(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(ww(ww({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: CV,
      eventMap: OV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: CV,
      eventMap: OV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Bn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(Gje, "contextType", Wt);
var xV = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, LV = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Yje extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      streetViewPanorama: null
    }), Te(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = En({
      updaterMap: LV,
      eventMap: xV,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: LV,
      eventMap: xV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Bn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Te(Yje, "contextType", Wt);
class Jje extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      streetViewService: null
    }), Te(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Te(Jje, "contextType", Wt);
var EV = {
  onDirectionsChanged: "directions_changed"
}, kV = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Qje extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      directionsRenderer: null
    }), Te(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = En({
      updaterMap: kV,
      eventMap: EV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: kV,
      eventMap: EV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Bn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(Qje, "contextType", Wt);
var PV = {
  onPlacesChanged: "places_changed"
}, SV = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class eAe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", jn()), Te(this, "state", {
      searchBox: null
    }), Te(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (ci(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = En({
          updaterMap: SV,
          eventMap: PV,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: SV,
      eventMap: PV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Bn(this.registeredEvents));
  }
  render() {
    return Os.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
Te(eAe, "contextType", Wt);
var MV = {
  onPlaceChanged: "place_changed"
}, DV = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class use extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", jn()), Te(this, "state", {
      autocomplete: null
    }), Te(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    ci(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = En({
        updaterMap: DV,
        eventMap: MV,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Bn(this.registeredEvents), this.registeredEvents = En({
      updaterMap: DV,
      eventMap: MV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Bn(this.registeredEvents);
  }
  render() {
    return Os.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
Te(use, "defaultProps", {
  className: ""
});
Te(use, "contextType", Wt);
let tAe = { data: "" }, nAe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || tAe, rAe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, oAe = /\/\*[^]*?\*\/|  +/g, _V = /\n+/g, Vu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Vu(a, i) : i + "{" + Vu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Vu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Vu.p ? Vu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ol = {}, cse = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + cse(e[n]);
    return t;
  }
  return e;
}, iAe = (e, t, n, r, o) => {
  let i = cse(e), a = Ol[i] || (Ol[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ol[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = rAe.exec(u.replace(oAe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(_V, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(_V, " ").trim();
      return d[0];
    })(e);
    Ol[a] = Vu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ol.g ? Ol.g : null;
  return n && (Ol.g = Ol[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ol[a], t, r, s), a;
}, sAe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Vu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function dx(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return iAe(n.unshift ? n.raw ? sAe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, nAe(t.target), t.g, t.o, t.k);
}
let pse, RD, FD;
dx.bind({ g: 1 });
let zl = dx.bind({ k: 1 });
function aAe(e, t, n, r) {
  Vu.p = t, pse = e, RD = n, FD = r;
}
function Oc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: RD && RD() }, s), n.o = / *go\d+/.test(l), s.className = dx.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), FD && u[0] && FD(s), pse(u, s);
    }
    return o;
  };
}
var lAe = (e) => typeof e == "function", uAe = (e, t) => lAe(e) ? e(t) : e, cAe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), pAe = zl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, dAe = zl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, fAe = zl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, hAe = Oc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${pAe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${dAe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${fAe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, gAe = zl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, mAe = Oc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${gAe} 1s linear infinite;
`, vAe = zl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, yAe = zl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, bAe = Oc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${vAe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${yAe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, wAe = Oc("div")`
  position: absolute;
`, OAe = Oc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, CAe = zl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, xAe = Oc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${CAe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, LAe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? _e.createElement(xAe, null, t) : t : n === "blank" ? null : _e.createElement(OAe, null, _e.createElement(mAe, { ...r }), n !== "loading" && _e.createElement(wAe, null, n === "error" ? _e.createElement(hAe, { ...r }) : _e.createElement(bAe, { ...r })));
}, EAe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, kAe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, PAe = "0%{opacity:0;} 100%{opacity:1;}", SAe = "0%{opacity:1;} 100%{opacity:0;}", MAe = Oc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, DAe = Oc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, _Ae = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = cAe() ? [PAe, SAe] : [EAe(n), kAe(n)];
  return { animation: t ? `${zl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${zl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
_e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? _Ae(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = _e.createElement(LAe, { toast: e }), a = _e.createElement(DAe, { ...e.ariaProps }, uAe(e.message, e));
  return _e.createElement(MAe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : _e.createElement(_e.Fragment, null, i, a));
});
aAe(_e.createElement);
dx`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
He({});
function TAe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const jAe = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
TAe(jAe.CNPJ).length;
ka((e, t) => /* @__PURE__ */ ws.jsx("input", { ref: t, ...e }));
He({});
var Yl = {};
Object.defineProperty(Yl, "__esModule", {
  value: !0
});
var AAe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), NE = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, dse = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: AAe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, rI = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var wy = 1; wy < 20; wy++)
  rI["f" + wy] = 111 + wy;
function fx(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return fse(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return hse(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function IAe(e, t) {
  return fx(e, t);
}
function BAe(e, t) {
  return fx(e, { byKey: !0 }, t);
}
function fse(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in NE)
    r[NE[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = oI(d), v = NE[f];
      if (d.length > 1 && !v && !dse[d] && !rI[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = gse(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function hse(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function gse(e) {
  e = oI(e);
  var t = rI[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function oI(e) {
  return e = e.toLowerCase(), e = dse[e] || e, e;
}
Yl.default = fx;
var RE = Yl.isHotkey = fx;
Yl.isCodeHotkey = IAe;
Yl.isKeyHotkey = BAe;
Yl.parseHotkey = fse;
Yl.compareHotkey = hse;
Yl.toKeyCode = gse;
Yl.toKeyName = oI;
var NAe = typeof Ar == "object" && Ar && Ar.Object === Object && Ar, RAe = NAe, FAe = RAe, zAe = typeof self == "object" && self && self.Object === Object && self, UAe = FAe || zAe || Function("return this")(), WAe = UAe, HAe = WAe, VAe = HAe.Symbol, mse = VAe, TV = mse;
TV && TV.toStringTag;
var jV = mse;
jV && jV.toStringTag;
var AV;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(AV || (AV = {}));
var iI = function(e) {
  return Object.freeze(e);
}, $Ae = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, iI(this);
  }
  return e;
}(), ZAe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, iI(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), IV = typeof window < "u" ? window : {};
/msie|trident/i.test(IV.navigator && IV.navigator.userAgent);
var FE = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new $Ae((n ? t : e) || 0, (n ? e : t) || 0);
};
iI({
  devicePixelContentBoxSize: FE(),
  borderBoxSize: FE(),
  contentBoxSize: FE(),
  contentRect: new ZAe(0, 0, 0, 0)
});
function Bg(e) {
  "@babel/helpers - typeof";
  return Bg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Bg(e);
}
function qAe(e, t) {
  if (Bg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Bg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function XAe(e) {
  var t = qAe(e, "string");
  return Bg(t) === "symbol" ? t : String(t);
}
function Ah(e, t, n) {
  return t = XAe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var KAe = /* @__PURE__ */ He(null), zE, UE;
parseInt(Oe.version.split(".")[0], 10);
var BV = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), WE = typeof navigator < "u" && /Android/.test(navigator.userAgent), Oy = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), GAe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (zE = navigator.userAgent.match(/Version\/(\d+)/)) !== null && zE !== void 0 && zE[1] && parseInt((UE = navigator.userAgent.match(/Version\/(\d+)/)) === null || UE === void 0 ? void 0 : UE[1], 10) < 17;
var YAe = /* @__PURE__ */ new WeakMap(), JAe = /* @__PURE__ */ new WeakMap(), QAe = /* @__PURE__ */ new WeakMap(), eIe = /* @__PURE__ */ new WeakMap(), tIe = /* @__PURE__ */ new WeakMap(), NV = /* @__PURE__ */ new WeakMap(), nIe = /* @__PURE__ */ new WeakMap(), RV = /* @__PURE__ */ new WeakMap(), Cy = /* @__PURE__ */ new WeakMap(), rIe = /* @__PURE__ */ new WeakMap(), oIe = /* @__PURE__ */ new WeakMap(), iIe = /* @__PURE__ */ new WeakMap(), vse = globalThis.Node, sIe = globalThis.Text, yse = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, aIe = (e) => Ow(e) && e.nodeType === 8, Xa = (e) => Ow(e) && e.nodeType === 1, Ow = (e) => {
  var t = yse(e);
  return !!t && e instanceof t.Node;
}, FV = (e) => {
  var t = e && e.anchorNode && yse(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, lIe = (e) => {
  var [t, n] = e;
  if (Xa(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = bse(t, o, r ? "backward" : "forward"), r = o < n; Xa(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = cIe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, uIe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, bse = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (aIe(o) || Xa(o) && o.childNodes.length === 0 || Xa(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, cIe = (e, t, n) => {
  var [r] = bse(e, t, n);
  return r;
}, zV = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), wse = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Xa(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = yn.getWindow(e);
  if (o.contains(r))
    return yn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : wse(e, i, n);
}, UV = (e, t) => !!(e.compareDocumentPosition(t) & vse.DOCUMENT_POSITION_PRECEDING), pIe = (e, t) => !!(e.compareDocumentPosition(t) & vse.DOCUMENT_POSITION_FOLLOWING), dIe = 0;
class fIe {
  constructor() {
    Ah(this, "id", void 0), this.id = "".concat(dIe++);
  }
}
var yn = {
  androidPendingDiffs: (e) => iIe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = oIe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = yn.toDOMNode(e, e), n = yn.findDocumentOrShadowRoot(e);
    Cy.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = yn.findDocumentOrShadowRoot(e), r = zV(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && rw.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = yn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = yn.toSlateNode(e, t.target), a = yn.findPath(e, i);
    if (Bl.isElement(i) && Er.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Er.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Er.before(e, u) : Er.after(e, u);
      if (c) {
        var p = Er.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = yn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = yn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = NV.get(t);
    return n || (n = new fIe(), NV.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = JAe.get(r);
      if (o == null) {
        if (Er.isEditor(r))
          return n;
        break;
      }
      var i = YAe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Rs.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Cy.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          yn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = yn.toDOMNode(e, e), r = yn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = zV(r), i = yn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || rw.select(e, Er.start(e, [])), Cy.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = QAe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = yn.toDOMNode(e, e), i;
    try {
      i = Xa(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Ow(t) && yn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Er.hasPath(e, n.path) && Er.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => yn.hasEditableTarget(e, t) || yn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Ow(t) && yn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!rIe.get(e),
  isFocused: (e) => !!Cy.get(e),
  isReadOnly: (e) => !!RV.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (RV.get(e)) return !1;
    var n = yn.hasTarget(e, t) && yn.toSlateNode(e, t);
    return Bl.isElement(n) && Er.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = nIe.get(e), r = Er.isEditor(t) ? eIe.get(e) : n == null ? void 0 : n.get(yn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Rs.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Er.node(e, t.path), r = yn.toDOMNode(e, n), o;
    Er.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof sIe ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Rs.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = rn.isBackward(t), i = yn.toDOMPoint(e, n), a = rn.isCollapsed(t) ? i : yn.toDOMPoint(e, r), s = yn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = Xa(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = Xa(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Xa(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? tIe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : lIe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = yn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = yn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (WE && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var R = U[k];
          if (yn.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var N = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, H = [...N(V), ...N(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = H.find((M) => pIe(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var X, G = [...N(V == null ? void 0 : V.previousElementSibling), ...N(V)];
          w = (X = G.findLast((M) => UV(L, M))) !== null && X !== void 0 ? X : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      WE && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Oy && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (WE && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && yn.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = yn.toSlateNode(e, Y), {
          path: J,
          offset: P
        } = Er.start(e, yn.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = yn.toSlateNode(e, u), z = yn.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = FV(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (FV(t)) {
        if (Oy && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        GAe && uIe(s) || Oy ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Oy && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = yn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = UV(s, u) || s === u && c < l, x = p ? w : yn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return rn.isExpanded(m) && rn.isForward(m) && Xa(u) && Er.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = Er.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, hIe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, gIe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, mIe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, po = (e) => {
  var t = hIe[e], n = gIe[e], r = mIe[e], o = t && RE(t), i = n && RE(n), a = r && RE(r);
  return (s) => !!(o && o(s) || BV && i && i(s) || !BV && a && a(s));
};
po("bold"), po("compose"), po("moveBackward"), po("moveForward"), po("deleteBackward"), po("deleteForward"), po("deleteLineBackward"), po("deleteLineForward"), po("deleteWordBackward"), po("deleteWordForward"), po("extendBackward"), po("extendForward"), po("extendLineBackward"), po("extendLineForward"), po("italic"), po("moveLineBackward"), po("moveLineForward"), po("moveWordBackward"), po("moveWordForward"), po("redo"), po("insertSoftBreak"), po("splitBlock"), po("transposeCharacter"), po("undo");
var vIe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => wse(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, yIe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class bIe extends Kl {
  constructor() {
    super(...arguments), Ah(this, "context", null), Ah(this, "manager", null), Ah(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, yIe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = vIe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Ah(bIe, "contextType", KAe);
He({});
He({});
He({});
var ni = {}, sI = {}, lm = {}, um = {}, Ose = "Expected a function", WV = NaN, wIe = "[object Symbol]", OIe = /^\s+|\s+$/g, CIe = /^[-+]0x[0-9a-f]+$/i, xIe = /^0b[01]+$/i, LIe = /^0o[0-7]+$/i, EIe = parseInt, kIe = typeof Ar == "object" && Ar && Ar.Object === Object && Ar, PIe = typeof self == "object" && self && self.Object === Object && self, SIe = kIe || PIe || Function("return this")(), MIe = Object.prototype, DIe = MIe.toString, _Ie = Math.max, TIe = Math.min, HE = function() {
  return SIe.Date.now();
};
function jIe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Ose);
  t = HV(t) || 0, Cw(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? _Ie(HV(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? TIe(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = HE();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(HE());
  }
  function m() {
    var C = HE(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function AIe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Ose);
  return Cw(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), jIe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Cw(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function IIe(e) {
  return !!e && typeof e == "object";
}
function BIe(e) {
  return typeof e == "symbol" || IIe(e) && DIe.call(e) == wIe;
}
function HV(e) {
  if (typeof e == "number")
    return e;
  if (BIe(e))
    return WV;
  if (Cw(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Cw(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(OIe, "");
  var n = xIe.test(e);
  return n || LIe.test(e) ? EIe(e.slice(2), n ? 2 : 8) : CIe.test(e) ? WV : +e;
}
var NIe = AIe, cm = {};
Object.defineProperty(cm, "__esModule", {
  value: !0
});
cm.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), n0.has(t) || n0.set(t, /* @__PURE__ */ new Set());
  var o = n0.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
cm.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), n0.get(t).delete(n.name || t);
};
var n0 = /* @__PURE__ */ new Map();
Object.defineProperty(um, "__esModule", {
  value: !0
});
var RIe = NIe, FIe = UIe(RIe), zIe = cm;
function UIe(e) {
  return e && e.__esModule ? e : { default: e };
}
var WIe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, FIe.default)(e, t);
}, Do = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = WIe(function(r) {
        Do.scrollHandler(e);
      }, t);
      Do.scrollSpyContainers.push(e), (0, zIe.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return Do.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Do.scrollSpyContainers[Do.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Do.currentPositionX(e), Do.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Do.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Do.scrollSpyContainers[Do.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(Do.currentPositionX(t), Do.currentPositionY(t));
  },
  updateStates: function() {
    Do.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Do.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Do.spySetState && Do.spySetState.length && Do.spySetState.indexOf(e) > -1 && Do.spySetState.splice(Do.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Do.scrollHandler);
  },
  update: function() {
    return Do.scrollSpyContainers.forEach(function(e) {
      return Do.scrollHandler(e);
    });
  }
};
um.default = Do;
var Fd = {}, pm = {};
Object.defineProperty(pm, "__esModule", {
  value: !0
});
var HIe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, VIe = function() {
  return window.location.hash.replace(/^#/, "");
}, $Ie = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, ZIe = function(e) {
  return getComputedStyle(e).position !== "static";
}, VE = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, qIe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (ZIe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = VE(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return VE(t, s).offsetTop - VE(e, s).offsetTop;
};
pm.default = {
  updateHash: HIe,
  getHash: VIe,
  filterElementInContainer: $Ie,
  scrollOffset: qIe
};
var hx = {}, aI = {};
Object.defineProperty(aI, "__esModule", {
  value: !0
});
aI.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var lI = {};
Object.defineProperty(lI, "__esModule", {
  value: !0
});
var XIe = cm, KIe = ["mousedown", "mousewheel", "touchmove", "keydown"];
lI.default = {
  subscribe: function(e) {
    return typeof document < "u" && KIe.forEach(function(t) {
      return (0, XIe.addPassiveEventListener)(document, t, e);
    });
  }
};
var dm = {};
Object.defineProperty(dm, "__esModule", {
  value: !0
});
var zD = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      zD.registered[e] = t;
    },
    remove: function(e) {
      zD.registered[e] = null;
    }
  }
};
dm.default = zD;
Object.defineProperty(hx, "__esModule", {
  value: !0
});
var GIe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, YIe = pm;
gx(YIe);
var JIe = aI, VV = gx(JIe), QIe = lI, eBe = gx(QIe), tBe = dm, Fa = gx(tBe);
function gx(e) {
  return e && e.__esModule ? e : { default: e };
}
var Cse = function(e) {
  return VV.default[e.smooth] || VV.default.defaultEasing;
}, nBe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, rBe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, UD = function() {
  return rBe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), xse = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Lse = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Ese = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, oBe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, iBe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, sBe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Fa.default.registered.end && Fa.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    UD.call(window, i);
    return;
  }
  Fa.default.registered.end && Fa.default.registered.end(o.to, o.target, o.currentPosition);
}, uI = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, fm = function(e, t, n, r) {
  t.data = t.data || xse(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (eBe.default.subscribe(o), uI(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Lse(t) : Ese(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Fa.default.registered.end && Fa.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = nBe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Cse(t), a = sBe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Fa.default.registered.begin && Fa.default.registered.begin(t.data.to, t.data.target), UD.call(window, a);
    }, t.delay);
    return;
  }
  Fa.default.registered.begin && Fa.default.registered.begin(t.data.to, t.data.target), UD.call(window, a);
}, mx = function(e) {
  return e = GIe({}, e), e.data = e.data || xse(), e.absolute = !0, e;
}, aBe = function(e) {
  fm(0, mx(e));
}, lBe = function(e, t) {
  fm(e, mx(t));
}, uBe = function(e) {
  e = mx(e), uI(e), fm(e.horizontal ? oBe(e) : iBe(e), e);
}, cBe = function(e, t) {
  t = mx(t), uI(t);
  var n = t.horizontal ? Lse(t) : Ese(t);
  fm(e + n, t);
};
hx.default = {
  animateTopScroll: fm,
  getAnimationType: Cse,
  scrollToTop: aBe,
  scrollToBottom: uBe,
  scrollTo: lBe,
  scrollMore: cBe
};
Object.defineProperty(Fd, "__esModule", {
  value: !0
});
var pBe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, dBe = pm, fBe = cI(dBe), hBe = hx, gBe = cI(hBe), mBe = dm, xy = cI(mBe);
function cI(e) {
  return e && e.__esModule ? e : { default: e };
}
var Ly = {}, $V = void 0;
Fd.default = {
  unmount: function() {
    Ly = {};
  },
  register: function(e, t) {
    Ly[e] = t;
  },
  unregister: function(e) {
    delete Ly[e];
  },
  get: function(e) {
    return Ly[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return $V = e;
  },
  getActiveLink: function() {
    return $V;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = pBe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = fBe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      xy.default.registered.begin && xy.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, xy.default.registered.end && xy.default.registered.end(e, n);
      return;
    }
    gBe.default.animateTopScroll(s, t, e, n);
  }
};
var WD = { exports: {} }, $E = { exports: {} }, er = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZV;
function vBe() {
  if (ZV) return er;
  ZV = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return er.AsyncMode = l, er.ConcurrentMode = u, er.ContextConsumer = s, er.ContextProvider = a, er.Element = t, er.ForwardRef = c, er.Fragment = r, er.Lazy = f, er.Memo = y, er.Portal = n, er.Profiler = i, er.StrictMode = o, er.Suspense = p, er.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, er.isConcurrentMode = x, er.isContextConsumer = function(m) {
    return D(m) === s;
  }, er.isContextProvider = function(m) {
    return D(m) === a;
  }, er.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, er.isForwardRef = function(m) {
    return D(m) === c;
  }, er.isFragment = function(m) {
    return D(m) === r;
  }, er.isLazy = function(m) {
    return D(m) === f;
  }, er.isMemo = function(m) {
    return D(m) === y;
  }, er.isPortal = function(m) {
    return D(m) === n;
  }, er.isProfiler = function(m) {
    return D(m) === i;
  }, er.isStrictMode = function(m) {
    return D(m) === o;
  }, er.isSuspense = function(m) {
    return D(m) === p;
  }, er.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, er.typeOf = D, er;
}
var pr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qV;
function yBe() {
  return qV || (qV = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === y || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === L || B.$$typeof === w || B.$$typeof === v);
    }
    function x(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var re = he && he.$$typeof;
                switch (re) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return re;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, R = c, N = r, V = f, $ = y, H = n, X = i, G = o, Y = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || x(B) === l;
    }
    function P(B) {
      return x(B) === u;
    }
    function _(B) {
      return x(B) === s;
    }
    function z(B) {
      return x(B) === a;
    }
    function M(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return x(B) === c;
    }
    function O(B) {
      return x(B) === r;
    }
    function I(B) {
      return x(B) === f;
    }
    function F(B) {
      return x(B) === y;
    }
    function j(B) {
      return x(B) === n;
    }
    function q(B) {
      return x(B) === i;
    }
    function A(B) {
      return x(B) === o;
    }
    function K(B) {
      return x(B) === p;
    }
    pr.AsyncMode = m, pr.ConcurrentMode = C, pr.ContextConsumer = S, pr.ContextProvider = U, pr.Element = k, pr.ForwardRef = R, pr.Fragment = N, pr.Lazy = V, pr.Memo = $, pr.Portal = H, pr.Profiler = X, pr.StrictMode = G, pr.Suspense = Y, pr.isAsyncMode = J, pr.isConcurrentMode = P, pr.isContextConsumer = _, pr.isContextProvider = z, pr.isElement = M, pr.isForwardRef = W, pr.isFragment = O, pr.isLazy = I, pr.isMemo = F, pr.isPortal = j, pr.isProfiler = q, pr.isStrictMode = A, pr.isSuspense = K, pr.isValidElementType = D, pr.typeOf = x;
  }()), pr;
}
var XV;
function kse() {
  return XV || (XV = 1, process.env.NODE_ENV === "production" ? $E.exports = vBe() : $E.exports = yBe()), $E.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var ZE, KV;
function bBe() {
  if (KV) return ZE;
  KV = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return ZE = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, ZE;
}
var qE, GV;
function pI() {
  if (GV) return qE;
  GV = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return qE = e, qE;
}
var YV, JV;
function Pse() {
  return JV || (JV = 1, YV = Function.call.bind(Object.prototype.hasOwnProperty)), YV;
}
var XE, QV;
function wBe() {
  if (QV) return XE;
  QV = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = pI(), n = {}, r = Pse();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, XE = o, XE;
}
var KE, e$;
function OBe() {
  if (e$) return KE;
  e$ = 1;
  var e = kse(), t = bBe(), n = pI(), r = Pse(), o = wBe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return KE = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, I, F, j, q, A, K) {
        if (j = j || d, A = A || F, K !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = j + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return I[F] == null ? O ? I[F] === null ? new v("The " + q + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new v("The " + q + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : P(I, F, j, q, A);
      }
      var W = M.bind(null, !1);
      return W.isRequired = M.bind(null, !0), W;
    }
    function L(P) {
      function _(z, M, W, O, I, F) {
        var j = z[M], q = G(j);
        if (q !== P) {
          var A = Y(j);
          return new v(
            "Invalid " + O + " `" + I + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var j = G(F);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var A = P(F, q, W, O, I + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!s(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!e.isValidElementType(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, W, O, I) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, j = J(z[M]);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, W, O, I) {
        for (var F = z[M], j = 0; j < P.length; j++)
          if (f(F, P[j]))
            return null;
        var q = JSON.stringify(P, function(A, K) {
          var B = Y(K);
          return B === "symbol" ? String(K) : K;
        });
        return new v("Invalid " + O + " `" + I + "` of value `" + String(F) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var A = P(F, q, W, O, I + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(W, O, I, F, j) {
        for (var q = [], A = 0; A < P.length; A++) {
          var K = P[A], B = K(W, O, I, F, j, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + j + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(M);
    }
    function R() {
      function P(_, z, M, W, O) {
        return H(_[z]) ? null : new v("Invalid " + W + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function N(P, _, z, M, W) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return N(W, O, I, q, Y(A));
          var K = A(F, q, W, O, I + "." + q, n);
          if (K)
            return K;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var A in q) {
          var K = P[A];
          if (r(P, A) && typeof K != "function")
            return N(W, O, I, A, Y(K));
          if (!K)
            return new v(
              "Invalid " + O + " `" + I + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = K(F, A, W, O, I + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!H(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var W = M.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function X(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function G(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : X(_, P) ? "symbol" : _;
    }
    function Y(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = G(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = Y(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, KE;
}
var GE, t$;
function CBe() {
  if (t$) return GE;
  t$ = 1;
  var e = pI();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, GE = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, GE;
}
if (process.env.NODE_ENV !== "production") {
  var xBe = kse(), LBe = !0;
  WD.exports = OBe()(xBe.isElement, LBe);
} else
  WD.exports = CBe()();
var vx = WD.exports, yx = {};
Object.defineProperty(yx, "__esModule", {
  value: !0
});
var EBe = pm, YE = kBe(EBe);
function kBe(e) {
  return e && e.__esModule ? e : { default: e };
}
var PBe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return YE.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && YE.default.getHash() !== e && YE.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
yx.default = PBe;
Object.defineProperty(lm, "__esModule", {
  value: !0
});
var Ey = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, SBe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), MBe = Oe, n$ = hm(MBe), DBe = um, ky = hm(DBe), _Be = Fd, TBe = hm(_Be), jBe = vx, fo = hm(jBe), ABe = yx, au = hm(ABe);
function hm(e) {
  return e && e.__esModule ? e : { default: e };
}
function IBe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function BBe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function NBe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var r$ = {
  to: fo.default.string.isRequired,
  containerId: fo.default.string,
  container: fo.default.object,
  activeClass: fo.default.string,
  activeStyle: fo.default.object,
  spy: fo.default.bool,
  horizontal: fo.default.bool,
  smooth: fo.default.oneOfType([fo.default.bool, fo.default.string]),
  offset: fo.default.number,
  delay: fo.default.number,
  isDynamic: fo.default.bool,
  onClick: fo.default.func,
  duration: fo.default.oneOfType([fo.default.number, fo.default.func]),
  absolute: fo.default.bool,
  onSetActive: fo.default.func,
  onSetInactive: fo.default.func,
  ignoreCancelEvents: fo.default.bool,
  hashSpy: fo.default.bool,
  saveHashHistory: fo.default.bool,
  spyThrottle: fo.default.number
};
lm.default = function(e, t) {
  var n = t || TBe.default, r = function(i) {
    NBe(a, i);
    function a(s) {
      IBe(this, a);
      var l = BBe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return SBe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          ky.default.isMounted(s) || ky.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (au.default.isMounted() || au.default.mount(n), au.default.mapContainer(this.props.to, s)), ky.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        ky.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Ey({}, this.props.style, this.props.activeStyle) : l = Ey({}, this.props.style);
        var u = Ey({}, this.props);
        for (var c in r$)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, n$.default.createElement(e, u);
      }
    }]), a;
  }(n$.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Ey({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(au.default.isMounted() && !au.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var R = n.getActiveLink();
        if (y) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && au.default.getHash() === c) {
            var N = i.props.saveHashHistory, V = N === void 0 ? !1 : N;
            au.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, H = $ === void 0 ? !1 : $;
          i.props.hashSpy && au.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = r$, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(sI, "__esModule", {
  value: !0
});
var RBe = Oe, o$ = Sse(RBe), FBe = lm, zBe = Sse(FBe);
function Sse(e) {
  return e && e.__esModule ? e : { default: e };
}
function UBe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function i$(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function WBe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var HBe = function(e) {
  WBe(t, e);
  function t() {
    var n, r, o, i;
    UBe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = i$(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return o$.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), i$(o, i);
  }
  return t;
}(o$.default.Component);
sI.default = (0, zBe.default)(HBe);
var dI = {};
Object.defineProperty(dI, "__esModule", {
  value: !0
});
var VBe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), $Be = Oe, s$ = Mse($Be), ZBe = lm, qBe = Mse(ZBe);
function Mse(e) {
  return e && e.__esModule ? e : { default: e };
}
function XBe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function KBe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function GBe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var YBe = function(e) {
  GBe(t, e);
  function t() {
    return XBe(this, t), KBe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return VBe(t, [{
    key: "render",
    value: function() {
      return s$.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(s$.default.Component);
dI.default = (0, qBe.default)(YBe);
var fI = {}, bx = {};
Object.defineProperty(bx, "__esModule", {
  value: !0
});
var JBe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, QBe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), eNe = Oe, a$ = wx(eNe), tNe = nl;
wx(tNe);
var nNe = Fd, l$ = wx(nNe), rNe = vx, u$ = wx(rNe);
function wx(e) {
  return e && e.__esModule ? e : { default: e };
}
function oNe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function iNe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function sNe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
bx.default = function(e) {
  var t = function(n) {
    sNe(r, n);
    function r(o) {
      oNe(this, r);
      var i = iNe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return QBe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        l$.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        l$.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return a$.default.createElement(e, JBe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(a$.default.Component);
  return t.propTypes = {
    name: u$.default.string,
    id: u$.default.string
  }, t;
};
Object.defineProperty(fI, "__esModule", {
  value: !0
});
var c$ = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, aNe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), lNe = Oe, p$ = hI(lNe), uNe = bx, cNe = hI(uNe), pNe = vx, d$ = hI(pNe);
function hI(e) {
  return e && e.__esModule ? e : { default: e };
}
function dNe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function fNe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function hNe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Dse = function(e) {
  hNe(t, e);
  function t() {
    return dNe(this, t), fNe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return aNe(t, [{
    key: "render",
    value: function() {
      var n = this, r = c$({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, p$.default.createElement(
        "div",
        c$({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(p$.default.Component);
Dse.propTypes = {
  name: d$.default.string,
  id: d$.default.string
};
fI.default = (0, cNe.default)(Dse);
var JE = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, f$ = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function h$(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function g$(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function m$(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Py = Oe, jc = um, QE = Fd, Fo = vx, lu = yx, v$ = {
  to: Fo.string.isRequired,
  containerId: Fo.string,
  container: Fo.object,
  activeClass: Fo.string,
  spy: Fo.bool,
  smooth: Fo.oneOfType([Fo.bool, Fo.string]),
  offset: Fo.number,
  delay: Fo.number,
  isDynamic: Fo.bool,
  onClick: Fo.func,
  duration: Fo.oneOfType([Fo.number, Fo.func]),
  absolute: Fo.bool,
  onSetActive: Fo.func,
  onSetInactive: Fo.func,
  ignoreCancelEvents: Fo.bool,
  hashSpy: Fo.bool,
  spyThrottle: Fo.number
}, gNe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || QE, r = function(i) {
      m$(a, i);
      function a(s) {
        h$(this, a);
        var l = g$(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return f$(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            jc.isMounted(s) || jc.mount(s, this.props.spyThrottle), this.props.hashSpy && (lu.isMounted() || lu.mount(n), lu.mapContainer(this.props.to, s)), this.props.spy && jc.addStateHandler(this.stateHandler), jc.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          jc.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = JE({}, this.props);
          for (var u in v$)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Py.createElement(e, l);
        }
      }]), a;
    }(Py.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, JE({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(lu.isMounted() && !lu.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && lu.getHash() === l && lu.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), jc.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && lu.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), jc.updateStates();
        }
      };
    };
    return r.propTypes = v$, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      m$(r, n);
      function r(o) {
        h$(this, r);
        var i = g$(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return f$(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          QE.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          QE.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Py.createElement(e, JE({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Py.Component);
    return t.propTypes = {
      name: Fo.string,
      id: Fo.string
    }, t;
  }
}, mNe = gNe;
Object.defineProperty(ni, "__esModule", {
  value: !0
});
ni.Helpers = ni.ScrollElement = ni.ScrollLink = ni.animateScroll = ni.scrollSpy = ni.Events = ni.scroller = ni.Element = ni.Button = ni.Link = void 0;
var vNe = sI, _se = ol(vNe), yNe = dI, Tse = ol(yNe), bNe = fI, jse = ol(bNe), wNe = Fd, Ase = ol(wNe), ONe = dm, Ise = ol(ONe), CNe = um, Bse = ol(CNe), xNe = hx, Nse = ol(xNe), LNe = lm, Rse = ol(LNe), ENe = bx, Fse = ol(ENe), kNe = mNe, zse = ol(kNe);
function ol(e) {
  return e && e.__esModule ? e : { default: e };
}
ni.Link = _se.default;
ni.Button = Tse.default;
ni.Element = jse.default;
ni.scroller = Ase.default;
ni.Events = Ise.default;
ni.scrollSpy = Bse.default;
ni.animateScroll = Nse.default;
ni.ScrollLink = Rse.default;
ni.ScrollElement = Fse.default;
ni.Helpers = zse.default;
ni.default = { Link: _se.default, Button: Tse.default, Element: jse.default, scroller: Ase.default, Events: Ise.default, scrollSpy: Bse.default, animateScroll: Nse.default, ScrollLink: Rse.default, ScrollElement: Fse.default, Helpers: zse.default };
He({});
He({});
He({});
function Ng(e) {
  "@babel/helpers - typeof";
  return Ng = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ng(e);
}
function PNe(e, t) {
  if (Ng(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ng(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function SNe(e) {
  var t = PNe(e, "string");
  return Ng(t) == "symbol" ? t : t + "";
}
function je(e, t, n) {
  return (t = SNe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Use(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ek, y$;
function MNe() {
  if (y$) return ek;
  y$ = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return ek = t, ek;
}
var DNe = MNe(), pi = /* @__PURE__ */ Use(DNe), Ht = He(null);
function _Ne() {
  pi(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Ht);
  return pi(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function TNe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function jNe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function ANe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return jNe(e, i), o;
}
function INe(e, t, n) {
  var r = TNe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function BNe(e) {
  google.maps.event.removeListener(e);
}
function Nn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(BNe);
}
function kn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = INe(o, i, n);
  return ANe(t, r, o, i), a;
}
function NNe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = vt(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null), [A, K] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), K(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var B = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(B), B !== null && D && D(B), () => {
      B !== null && x && x(B);
    };
  }, []), ws.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: ws.jsx(Ht.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(NNe);
function b$(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Wse(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        b$(i, r, o, a, s, "next", l);
      }
      function s(l) {
        b$(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Hse(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return pi(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var mp = typeof document < "u";
function Vse(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return mp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function w$(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function $se() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return w$(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return w$(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Lf = !1;
function Zse() {
  return ws.jsx("div", {
    children: "Loading..."
  });
}
var HD = {
  id: "script-loader",
  version: "weekly"
};
class RNe extends pe {
  constructor() {
    super(...arguments), je(this, "check", jn()), je(this, "state", {
      loaded: !1
    }), je(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), je(this, "isCleaningUp", /* @__PURE__ */ Wse(function* () {
      function t(n) {
        if (!Lf)
          n();
        else if (mp)
          var r = window.setInterval(function() {
            Lf || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), je(this, "cleanup", () => {
      Lf = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), je(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && $se(), pi(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Hse(this.props)
      };
      Vse(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (mp) {
      if (window.google && window.google.maps && !Lf) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), mp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (mp) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Lf = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return ws.jsxs(ws.Fragment, {
      children: [ws.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || ws.jsx(Zse, {})]
    });
  }
}
je(RNe, "defaultProps", HD);
function FNe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function gI(e, t) {
  if (e == null) return {};
  var n, r, o = FNe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var O$;
function zNe(e) {
  var {
    id: t = HD.id,
    version: n = HD.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = vt(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    mp && u && $se();
  }, [u]), h(function() {
    f && pi(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Hse({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!mp)
      return;
    function x() {
      y.current && (v(!0), O$ = w);
    }
    if (window.google && window.google.maps && O$ === w) {
      x();
      return;
    }
    Vse({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = vt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var UNe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], WNe = ws.jsx(Zse, {});
function HNe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = gI(e, UNe), {
    isLoaded: s,
    loadError: l
  } = zNe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || WNe;
}
me(HNe);
var C$;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(C$ || (C$ = {}));
function x$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? x$(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : x$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var L$ = {}, E$ = {
  options(e, t) {
    e.setOptions(t);
  }
};
function VNe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Ht), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(xw(xw({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(VNe);
class $Ne extends pe {
  constructor() {
    super(...arguments), je(this, "state", {
      trafficLayer: null
    }), je(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), je(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(xw(xw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: E$,
      eventMap: L$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: E$,
      eventMap: L$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Nn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
je($Ne, "contextType", Ht);
function ZNe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ht), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(ZNe);
class qNe extends pe {
  constructor() {
    super(...arguments), je(this, "state", {
      bicyclingLayer: null
    }), je(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
je(qNe, "contextType", Ht);
function XNe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ht), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(XNe);
class KNe extends pe {
  constructor() {
    super(...arguments), je(this, "state", {
      transitLayer: null
    }), je(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
je(KNe, "contextType", Ht);
function k$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? k$(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : k$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var P$ = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, S$ = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function GNe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Ht), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    pi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(Lw(Lw({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && L(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && k(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(GNe);
class YNe extends pe {
  constructor(t) {
    super(t), je(this, "registeredEvents", []), je(this, "state", {
      drawingManager: null
    }), je(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), pi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Lw(Lw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: S$,
      eventMap: P$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: S$,
      eventMap: P$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Nn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
je(YNe, "contextType", Ht);
function M$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ad(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? M$(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : M$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var D$ = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, _$ = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Ew = {};
function JNe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: R,
    onClickableChanged: N,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: H,
    onFlatChanged: X,
    onIconChanged: G,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, W = ge(Ht), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null), [re, Se] = E(null), [We, Ze] = E(null), [Me, rt] = E(null), [Ve, be] = E(null), [qe, ct] = E(null), [ye, xe] = E(null), [Ee, Ue] = E(null), [De, st] = E(null), [ve, wt] = E(null), [at, lt] = E(null), [pt, Ot] = E(null), [dt, Ct] = E(null), [Xe, ht] = E(null), [ot, xt] = E(null), [ft, Pt] = E(null), [Lt, St] = E(null), [Et, Mt] = E(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (re !== null && google.maps.event.removeListener(re), Se(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), Ze(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Me !== null && google.maps.event.removeListener(Me), rt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && R && (Ve !== null && google.maps.event.removeListener(Ve), be(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && L && (qe !== null && google.maps.event.removeListener(qe), ct(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (ye !== null && google.maps.event.removeListener(ye), xe(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && N && (Ee !== null && google.maps.event.removeListener(Ee), Ue(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && V && (De !== null && google.maps.event.removeListener(De), st(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), wt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && X && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(O, "flat_changed", X)));
  }, [X]), h(() => {
    O && G && (dt !== null && google.maps.event.removeListener(dt), Ct(google.maps.event.addListener(O, "icon_changed", G)));
  }, [G]), h(() => {
    O && Y && (Xe !== null && google.maps.event.removeListener(Xe), ht(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (ot !== null && google.maps.event.removeListener(ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (ft !== null && google.maps.event.removeListener(ft), Pt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Lt !== null && google.maps.event.removeListener(Lt), St(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (Et !== null && google.maps.event.removeListener(Et), Mt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var gt = ad(ad(ad({}, n || Ew), r ? Ew : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(gt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof y < "u" && te.setOpacity(y), f && te.setShape(f), typeof v == "string" && te.setTitle(v), typeof b == "number" && te.setZIndex(b), w && j(google.maps.event.addListener(te, "dblclick", w)), x && A(google.maps.event.addListener(te, "dragend", x)), m && B(google.maps.event.addListener(te, "dragstart", m)), k && he(google.maps.event.addListener(te, "mousedown", k)), C && Se(google.maps.event.addListener(te, "mouseout", C)), S && Ze(google.maps.event.addListener(te, "mouseover", S)), U && rt(google.maps.event.addListener(te, "mouseup", U)), R && be(google.maps.event.addListener(te, "rightclick", R)), L && ct(google.maps.event.addListener(te, "click", L)), D && xe(google.maps.event.addListener(te, "drag", D)), N && Ue(google.maps.event.addListener(te, "clickable_changed", N)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), $ && wt(google.maps.event.addListener(te, "animation_changed", $)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), X && Ot(google.maps.event.addListener(te, "flat_changed", X)), G && Ct(google.maps.event.addListener(te, "icon_changed", G)), Y && ht(google.maps.event.addListener(te, "position_changed", Y)), Q && xt(google.maps.event.addListener(te, "shape_changed", Q)), J && Pt(google.maps.event.addListener(te, "title_changed", J)), P && St(google.maps.event.addListener(te, "visible_changed", P)), _ && Mt(google.maps.event.addListener(te, "zindex_changed", _)), I(te), z && z(te), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), re !== null && google.maps.event.removeListener(re), We !== null && google.maps.event.removeListener(We), Me !== null && google.maps.event.removeListener(Me), Ve !== null && google.maps.event.removeListener(Ve), qe !== null && google.maps.event.removeListener(qe), Ee !== null && google.maps.event.removeListener(Ee), De !== null && google.maps.event.removeListener(De), ve !== null && google.maps.event.removeListener(ve), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), Xe !== null && google.maps.event.removeListener(Xe), ft !== null && google.maps.event.removeListener(ft), Lt !== null && google.maps.event.removeListener(Lt), Et !== null && google.maps.event.removeListener(Et), M && M(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var _t = zt(() => i ? ut.map(i, (gt) => {
    if (!wi(gt))
      return gt;
    var te = gt;
    return Oi(te, {
      anchor: O
    });
  }) : null, [i, O]);
  return ws.jsx(ws.Fragment, {
    children: _t
  }) || null;
}
me(JNe);
class QNe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Wse(function* () {
      var n = ad(ad(ad({}, t.props.options || Ew), t.props.clusterer ? Ew : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = kn({
        updaterMap: _$,
        eventMap: D$,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: _$,
      eventMap: D$,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Nn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Oi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
je(QNe, "contextType", Ht);
var eRe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), tRe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new eRe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function nRe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var rRe = 2e3, oRe = 500, iRe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", sRe = "png", aRe = [53, 56, 66, 78, 90], lRe = "cluster", qse = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || iRe, this.imageExtension = r.imageExtension || sRe, this.imageSizes = r.imageSizes || aRe, this.calculator = r.calculator || nRe, this.batchSize = r.batchSize || rRe, this.batchSizeIE = r.batchSizeIE || oRe, this.clusterClass = r.clusterClass || lRe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new tRe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function T$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uRe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? T$(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : T$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ga = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, $n = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, cRe = {};
function pRe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, R] = E(null), N = ge(Ht), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, ga.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, ga.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, ga.onClick, w)));
  }, [w]), h(() => {
    k && D && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(k, ga.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (G !== null && google.maps.event.removeListener(G), X(google.maps.event.addListener(k, ga.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && $n.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && $n.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && $n.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && $n.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && $n.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && $n.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && $n.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && $n.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && $n.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && $n.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && $n.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && $n.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && $n.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && $n.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && $n.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (N) {
      var z = uRe({}, n || cRe), M = new qse(N, [], z);
      return r && $n.averageCenter(M, r), o && $n.batchSizeIE(M, o), i && $n.calculator(M, i), a && $n.clusterClass(M, a), s && $n.enableRetinaIcons(M, s), l && $n.gridSize(M, l), u && $n.ignoreHidden(M, u), c && $n.imageExtension(M, c), p && $n.imagePath(M, p), d && $n.imageSizes(M, d), y && $n.maxZoom(M, y), f && $n.minimumClusterSize(M, f), v && $n.styles(M, v), b && $n.title(M, b), L && $n.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, ga.onMouseOut, C)), m && _(google.maps.event.addListener(M, ga.onMouseOver, m)), w && $(google.maps.event.addListener(M, ga.onClick, w)), D && X(google.maps.event.addListener(M, ga.onClusteringBegin, D)), x && Y(google.maps.event.addListener(M, ga.onClusteringEnd, x)), R(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(pRe);
class dRe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      markerClusterer: null
    }), je(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new qse(this.context, [], this.props.options);
      this.registeredEvents = kn({
        updaterMap: $n,
        eventMap: ga,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: $n,
      eventMap: ga,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Nn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
je(dRe, "contextType", Ht);
function j$(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Xse = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || j$(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, j$));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), fRe = ["position"], hRe = ["position"];
function A$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? A$(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : A$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var I$ = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, B$ = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, gRe = {};
function mRe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Ht), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var N = r || gRe, {
        position: V
      } = N, $ = gI(N, fRe), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var X = new Xse(kw(kw({}, $), H ? {
        position: H
      } : {}));
      R.current = document.createElement("div"), v(X), a && L(google.maps.event.addListener(X, "closeclick", a)), s && D(google.maps.event.addListener(X, "domready", s)), l && m(google.maps.event.addListener(X, "content_changed", l)), u && S(google.maps.event.addListener(X, "position_changed", u)), c && k(google.maps.event.addListener(X, "zindex_changed", c)), X.setContent(R.current), n ? X.open(y, n) : X.getPosition() ? X.open(y) : pi(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(X);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(mRe);
class vRe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "containerElement", null), je(this, "state", {
      infoBox: null
    }), je(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : pi(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), je(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = gI(t, hRe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Xse(kw(kw({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = kn({
      updaterMap: B$,
      eventMap: I$,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: B$,
      eventMap: I$,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Nn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
je(vRe, "contextType", Ht);
var N$, R$;
function yRe() {
  return R$ || (R$ = 1, N$ = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), N$;
}
var bRe = yRe(), F$ = /* @__PURE__ */ Use(bRe), z$ = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], tk = 1, Ef = 8;
class mI {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== tk)
      throw new Error("Got v".concat(o, " data when expected v").concat(tk, "."));
    var i = z$[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new mI(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = z$.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Ef, t), this.coords = new this.ArrayType(this.data, Ef + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Ef + a + s + l), this.ids = new this.IndexArrayType(this.data, Ef, t), this.coords = new this.ArrayType(this.data, Ef + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (tk << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return VD(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          U$(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      U$(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function VD(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Kse(e, t, a, r, o, i), VD(e, t, n, r, a - 1, 1 - i), VD(e, t, n, a + 1, o, 1 - i);
  }
}
function Kse(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Kse(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (kf(e, t, r, n), t[2 * o + i] > y && kf(e, t, r, o); f < v; ) {
      for (kf(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? kf(e, t, r, v) : (v++, kf(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function kf(e, t, n, r) {
  nk(e, n, r), nk(t, 2 * n, 2 * r), nk(t, 2 * n + 1, 2 * r + 1);
}
function nk(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function U$(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var wRe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, W$ = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Ac = 2, Au = 3, rk = 4, Eu = 5, Gse = 6;
class ORe {
  constructor(t) {
    this.options = Object.assign(Object.create(wRe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = W$(Sy(u)), d = W$(My(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Sy(r), My(a), Sy(i), My(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Eu] > 1 ? H$(p, f, this.clusterProps) : this.points[p[f + Au]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + rk] === t && p.push(a[y + Eu] > 1 ? H$(a, y, this.clusterProps) : this.points[a[y + Au]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new mI(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Eu] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Yse(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Au]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = Sy(f), d = My(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + Au] : L = this.points[n[l + Au]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Ac] <= n)) {
        l[p + Ac] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Eu], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + Ac] > n && (b += l[w + Eu]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + Ac] <= n)) {
              l[k + Ac] = n;
              var R = l[k + Eu];
              D += l[k] * R, x += l[k + 1] * R, l[k + rk] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + rk] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + Ac] <= n)) {
                l[$ + Ac] = n;
                for (var H = 0; H < c; H++) u.push(l[$ + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Eu] > 1) {
      var o = this.clusterProps[t[n + Gse]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Au]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function H$(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Au],
    properties: Yse(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [CRe(e[t]), xRe(e[t + 1])]
    }
  };
}
function Yse(e, t, n) {
  var r = e[t + Eu], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Gse], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Au],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Sy(e) {
  return e / 360 + 0.5;
}
function My(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function CRe(e) {
  return (e - 0.5) * 360;
}
function xRe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function LRe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Us {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class $D {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Us.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Us.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Us.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class ERe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return kRe(n);
  }
}
var kRe = (e) => {
  var t = e.map((n) => new $D({
    position: Us.getPosition(n),
    markers: [n]
  }));
  return t;
};
class PRe extends ERe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = LRe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new ORe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!F$(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Us.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !F$(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new $D({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new $D({
      markers: [i],
      position: Us.getPosition(i)
    });
  }
}
class SRe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class MRe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Us.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function DRe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class vI {
  constructor() {
    DRe(vI, google.maps.OverlayView);
  }
}
var Ih;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Ih || (Ih = {}));
var _Re = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class TRe extends vI {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new PRe(o),
      renderer: a = new MRe(),
      onClusterClick: s = _Re
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Us.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Ih.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Us.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Us.setMap(l, null)));
      }
      google.maps.event.trigger(this, Ih.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Us.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new SRe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Us.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Ih.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Us.setMap(r.marker, n);
    });
  }
}
function V$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? V$(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : V$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function jRe(e) {
  var t = _Ne(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new TRe($$($$({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function ARe(e) {
  var {
    children: t,
    options: n
  } = e, r = jRe(n);
  return r !== null ? t(r) : null;
}
me(ARe);
var Z$ = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, q$ = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function IRe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Ht), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return v(N), R.current = document.createElement("div"), a && L(google.maps.event.addListener(N, "closeclick", a)), s && D(google.maps.event.addListener(N, "domready", s)), l && m(google.maps.event.addListener(N, "content_changed", l)), u && S(google.maps.event.addListener(N, "position_changed", u)), c && k(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(R.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(y, n) : N.getPosition() ? N.open(y) : pi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(N), N.close();
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(IRe);
class BRe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "containerElement", null), je(this, "state", {
      infoWindow: null
    }), je(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : pi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), je(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = kn({
      updaterMap: q$,
      eventMap: Z$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: q$,
      eventMap: Z$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Nn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
je(BRe, "contextType", Ht);
function X$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? X$(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : X$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var K$ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, G$ = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, NRe = {};
function RRe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(Ht), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var j = new google.maps.Polyline(Pw(Pw({}, t || NRe), {}, {
      map: D
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && S(google.maps.event.addListener(j, "dblclick", a)), s && k(google.maps.event.addListener(j, "dragend", s)), l && N(google.maps.event.addListener(j, "dragstart", l)), u && $(google.maps.event.addListener(j, "mousedown", u)), c && X(google.maps.event.addListener(j, "mousemove", c)), p && Y(google.maps.event.addListener(j, "mouseout", p)), d && J(google.maps.event.addListener(j, "mouseover", d)), y && _(google.maps.event.addListener(j, "mouseup", y)), f && M(google.maps.event.addListener(j, "rightclick", f)), v && O(google.maps.event.addListener(j, "click", v)), b && F(google.maps.event.addListener(j, "drag", b)), m(j), L && L(j), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
me(RRe);
class FRe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      polyline: null
    }), je(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Pw(Pw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: G$,
      eventMap: K$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: G$,
      eventMap: K$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Nn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
je(FRe, "contextType", Ht);
function Y$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function J$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Y$(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Y$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Q$ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, e3 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function zRe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Ht), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var A = new google.maps.Polygon(J$(J$({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && k(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && $(google.maps.event.addListener(A, "dragstart", u)), c && X(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), b && F(google.maps.event.addListener(A, "click", b)), L && q(google.maps.event.addListener(A, "drag", L)), S(A), w && w(A), () => {
      U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), D && D(A), A.setMap(null);
    };
  }, []), null;
}
me(zRe);
class URe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = kn({
      updaterMap: e3,
      eventMap: Q$,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: e3,
      eventMap: Q$,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Nn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
je(URe, "contextType", Ht);
function t3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? t3(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : t3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var n3 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, r3 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function WRe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Ht), [m, C] = E(null), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var K = new google.maps.Rectangle(Sw(Sw({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && K.setVisible(i), typeof o < "u" && K.setEditable(o), typeof r < "u" && K.setDraggable(r), typeof n < "u" && K.setBounds(n), a && U(google.maps.event.addListener(K, "dblclick", a)), s && R(google.maps.event.addListener(K, "dragend", s)), l && V(google.maps.event.addListener(K, "dragstart", l)), u && H(google.maps.event.addListener(K, "mousedown", u)), c && G(google.maps.event.addListener(K, "mousemove", c)), p && Q(google.maps.event.addListener(K, "mouseout", p)), d && P(google.maps.event.addListener(K, "mouseover", d)), y && z(google.maps.event.addListener(K, "mouseup", y)), f && W(google.maps.event.addListener(K, "rightclick", f)), v && I(google.maps.event.addListener(K, "click", v)), b && j(google.maps.event.addListener(K, "drag", b)), L && A(google.maps.event.addListener(K, "bounds_changed", L)), C(K), w && w(K), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(K), K.setMap(null);
    };
  }, []), null;
}
me(WRe);
class HRe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      rectangle: null
    }), je(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Sw(Sw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: r3,
      eventMap: n3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: r3,
      eventMap: n3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Nn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
je(HRe, "contextType", Ht);
function o3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? o3(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : o3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var i3 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, s3 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, VRe = {};
function $Re(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Ht), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var re = new google.maps.Circle(Mw(Mw({}, t || VRe), {}, {
      map: C
    }));
    return typeof r == "number" && re.setRadius(r), typeof n < "u" && re.setCenter(n), typeof r == "number" && re.setRadius(r), typeof a < "u" && re.setVisible(a), typeof i < "u" && re.setEditable(i), typeof o < "u" && re.setDraggable(o), s && R(google.maps.event.addListener(re, "dblclick", s)), l && V(google.maps.event.addListener(re, "dragend", l)), u && H(google.maps.event.addListener(re, "dragstart", u)), c && G(google.maps.event.addListener(re, "mousedown", c)), p && Q(google.maps.event.addListener(re, "mousemove", p)), d && P(google.maps.event.addListener(re, "mouseout", d)), y && z(google.maps.event.addListener(re, "mouseover", y)), f && W(google.maps.event.addListener(re, "mouseup", f)), v && I(google.maps.event.addListener(re, "rightclick", v)), b && j(google.maps.event.addListener(re, "click", b)), L && A(google.maps.event.addListener(re, "drag", L)), w && B(google.maps.event.addListener(re, "center_changed", w)), D && he(google.maps.event.addListener(re, "radius_changed", D)), U(re), x && x(re), () => {
      k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), m && m(re), re.setMap(null);
    };
  }, []), null;
}
me($Re);
class ZRe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      circle: null
    }), je(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Mw(Mw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: s3,
      eventMap: i3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: s3,
      eventMap: i3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Nn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
je(ZRe, "contextType", Ht);
function a3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a3(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var l3 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, u3 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function qRe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(Ht), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var A = new google.maps.Data(Dw(Dw({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && k(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && $(google.maps.event.addListener(A, "mouseover", s)), l && X(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && q(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), j !== null && google.maps.event.removeListener(j), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(qRe);
class XRe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      data: null
    }), je(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Dw(Dw({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = kn({
        updaterMap: u3,
        eventMap: l3,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: u3,
      eventMap: l3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Nn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
je(XRe, "contextType", Ht);
function c3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function p3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? c3(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var d3 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, f3 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class KRe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      kmlLayer: null
    }), je(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(p3(p3({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: f3,
      eventMap: d3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: f3,
      eventMap: d3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Nn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
je(KRe, "contextType", Ht);
function Jse(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function GRe(e, t) {
  return new t(e.lat, e.lng);
}
function YRe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function JRe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function QRe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function eFe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function tFe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Qse(e, t, n, r) {
  return n !== void 0 ? eFe(e, t, QRe(n, google.maps.LatLngBounds, YRe)) : tFe(e, t, JRe(r, google.maps.LatLng, GRe));
}
function nFe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function h3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rFe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? h3(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : h3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function oFe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = rFe({}, this.container ? Jse(this.container, o) : {
        x: 0,
        y: 0
      }), u = Qse(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function g3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iFe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? g3(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : g3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function m3(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function v3(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function sFe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Ht), c = zt(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = zt(() => oFe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
me(sFe);
class zd extends pe {
  constructor(t) {
    super(t), je(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), je(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      pi(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), je(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), je(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = iFe({
        x: 0,
        y: 0
      }, this.containerRef.current ? Jse(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Qse(r, o, this.props.bounds, this.props.position);
      if (!nFe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), je(this, "draw", () => {
      this.onPositionElement();
    }), je(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = jn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = m3(t.position), r = m3(this.props.position), o = v3(t.bounds), i = v3(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(ws.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
je(zd, "FLOAT_PANE", "floatPane");
je(zd, "MAP_PANE", "mapPane");
je(zd, "MARKER_LAYER", "markerLayer");
je(zd, "OVERLAY_LAYER", "overlayLayer");
je(zd, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
je(zd, "contextType", Ht);
function aFe() {
}
function y3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function b3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? y3(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : y3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var w3 = {
  onDblClick: "dblclick",
  onClick: "click"
}, O3 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function lFe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Ht), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = zt(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(lFe);
class eae extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      groundOverlay: null
    }), je(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    pi(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, b3(b3({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: O3,
      eventMap: w3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: O3,
      eventMap: w3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
je(eae, "defaultProps", {
  onLoad: aFe
});
je(eae, "contextType", Ht);
function C3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _w(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? C3(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : C3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var x3 = {}, L3 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function uFe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Ht), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || pi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    pi(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(_w(_w({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(uFe);
class cFe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      heatmapLayer: null
    }), je(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    pi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), pi(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(_w(_w({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: L3,
      eventMap: x3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: L3,
      eventMap: x3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Nn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
je(cFe, "contextType", Ht);
var E3 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, k3 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class pFe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      streetViewPanorama: null
    }), je(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = kn({
      updaterMap: k3,
      eventMap: E3,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: k3,
      eventMap: E3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Nn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
je(pFe, "contextType", Ht);
class dFe extends pe {
  constructor() {
    super(...arguments), je(this, "state", {
      streetViewService: null
    }), je(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
je(dFe, "contextType", Ht);
var P3 = {
  onDirectionsChanged: "directions_changed"
}, S3 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class fFe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      directionsRenderer: null
    }), je(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = kn({
      updaterMap: S3,
      eventMap: P3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: S3,
      eventMap: P3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Nn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
je(fFe, "contextType", Ht);
var M3 = {
  onPlacesChanged: "places_changed"
}, D3 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class hFe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "containerElement", jn()), je(this, "state", {
      searchBox: null
    }), je(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (pi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = kn({
          updaterMap: D3,
          eventMap: M3,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: D3,
      eventMap: M3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Nn(this.registeredEvents));
  }
  render() {
    return ws.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
je(hFe, "contextType", Ht);
var _3 = {
  onPlaceChanged: "place_changed"
}, T3 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class tae extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "containerElement", jn()), je(this, "state", {
      autocomplete: null
    }), je(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    pi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = kn({
        updaterMap: T3,
        eventMap: _3,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Nn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: T3,
      eventMap: _3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Nn(this.registeredEvents);
  }
  render() {
    return ws.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
je(tae, "defaultProps", {
  className: ""
});
je(tae, "contextType", Ht);
let gFe = { data: "" }, mFe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || gFe, vFe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, yFe = /\/\*[^]*?\*\/|  +/g, j3 = /\n+/g, $u = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? $u(a, i) : i + "{" + $u(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += $u(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += $u.p ? $u.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Cl = {}, nae = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + nae(e[n]);
    return t;
  }
  return e;
}, bFe = (e, t, n, r, o) => {
  let i = nae(e), a = Cl[i] || (Cl[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Cl[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = vFe.exec(u.replace(yFe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(j3, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(j3, " ").trim();
      return d[0];
    })(e);
    Cl[a] = $u(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Cl.g ? Cl.g : null;
  return n && (Cl.g = Cl[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Cl[a], t, r, s), a;
}, wFe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : $u(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Ox(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return bFe(n.unshift ? n.raw ? wFe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, mFe(t.target), t.g, t.o, t.k);
}
let rae, ZD, qD;
Ox.bind({ g: 1 });
let Ul = Ox.bind({ k: 1 });
function OFe(e, t, n, r) {
  $u.p = t, rae = e, ZD = n, qD = r;
}
function Cc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: ZD && ZD() }, s), n.o = / *go\d+/.test(l), s.className = Ox.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), qD && u[0] && qD(s), rae(u, s);
    }
    return o;
  };
}
var CFe = (e) => typeof e == "function", xFe = (e, t) => CFe(e) ? e(t) : e, LFe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), EFe = Ul`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, kFe = Ul`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, PFe = Ul`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, SFe = Cc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${EFe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${kFe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${PFe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, MFe = Ul`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, DFe = Cc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${MFe} 1s linear infinite;
`, _Fe = Ul`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, TFe = Ul`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, jFe = Cc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${_Fe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${TFe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, AFe = Cc("div")`
  position: absolute;
`, IFe = Cc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, BFe = Ul`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, NFe = Cc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${BFe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, RFe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? _e.createElement(NFe, null, t) : t : n === "blank" ? null : _e.createElement(IFe, null, _e.createElement(DFe, { ...r }), n !== "loading" && _e.createElement(AFe, null, n === "error" ? _e.createElement(SFe, { ...r }) : _e.createElement(jFe, { ...r })));
}, FFe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, zFe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, UFe = "0%{opacity:0;} 100%{opacity:1;}", WFe = "0%{opacity:1;} 100%{opacity:0;}", HFe = Cc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, VFe = Cc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, $Fe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = LFe() ? [UFe, WFe] : [FFe(n), zFe(n)];
  return { animation: t ? `${Ul(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ul(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
_e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? $Fe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = _e.createElement(RFe, { toast: e }), a = _e.createElement(VFe, { ...e.ariaProps }, xFe(e.message, e));
  return _e.createElement(HFe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : _e.createElement(_e.Fragment, null, i, a));
});
OFe(_e.createElement);
Ox`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
He({});
function ZFe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const qFe = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
ZFe(qFe.CNPJ).length;
ka((e, t) => /* @__PURE__ */ bs.jsx("input", { ref: t, ...e }));
He({});
var Jl = {};
Object.defineProperty(Jl, "__esModule", {
  value: !0
});
var XFe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), ok = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, oae = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: XFe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, yI = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Dy = 1; Dy < 20; Dy++)
  yI["f" + Dy] = 111 + Dy;
function Cx(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return iae(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return sae(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function KFe(e, t) {
  return Cx(e, t);
}
function GFe(e, t) {
  return Cx(e, { byKey: !0 }, t);
}
function iae(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in ok)
    r[ok[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = bI(d), v = ok[f];
      if (d.length > 1 && !v && !oae[d] && !yI[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = aae(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function sae(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function aae(e) {
  e = bI(e);
  var t = yI[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function bI(e) {
  return e = e.toLowerCase(), e = oae[e] || e, e;
}
Jl.default = Cx;
var ik = Jl.isHotkey = Cx;
Jl.isCodeHotkey = KFe;
Jl.isKeyHotkey = GFe;
Jl.parseHotkey = iae;
Jl.compareHotkey = sae;
Jl.toKeyCode = aae;
Jl.toKeyName = bI;
var YFe = typeof jr == "object" && jr && jr.Object === Object && jr, JFe = YFe, QFe = JFe, eze = typeof self == "object" && self && self.Object === Object && self, tze = QFe || eze || Function("return this")(), nze = tze, rze = nze, oze = rze.Symbol, lae = oze, A3 = lae;
A3 && A3.toStringTag;
var I3 = lae;
I3 && I3.toStringTag;
var B3;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(B3 || (B3 = {}));
var wI = function(e) {
  return Object.freeze(e);
}, ize = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, wI(this);
  }
  return e;
}(), sze = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, wI(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), N3 = typeof window < "u" ? window : {};
/msie|trident/i.test(N3.navigator && N3.navigator.userAgent);
var sk = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new ize((n ? t : e) || 0, (n ? e : t) || 0);
};
wI({
  devicePixelContentBoxSize: sk(),
  borderBoxSize: sk(),
  contentBoxSize: sk(),
  contentRect: new sze(0, 0, 0, 0)
});
function Rg(e) {
  "@babel/helpers - typeof";
  return Rg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Rg(e);
}
function aze(e, t) {
  if (Rg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Rg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function lze(e) {
  var t = aze(e, "string");
  return Rg(t) === "symbol" ? t : String(t);
}
function Bh(e, t, n) {
  return t = lze(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var uze = /* @__PURE__ */ He(null), ak, lk;
parseInt(Oe.version.split(".")[0], 10);
var R3 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), uk = typeof navigator < "u" && /Android/.test(navigator.userAgent), _y = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), cze = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (ak = navigator.userAgent.match(/Version\/(\d+)/)) !== null && ak !== void 0 && ak[1] && parseInt((lk = navigator.userAgent.match(/Version\/(\d+)/)) === null || lk === void 0 ? void 0 : lk[1], 10) < 17;
var pze = /* @__PURE__ */ new WeakMap(), dze = /* @__PURE__ */ new WeakMap(), fze = /* @__PURE__ */ new WeakMap(), hze = /* @__PURE__ */ new WeakMap(), gze = /* @__PURE__ */ new WeakMap(), F3 = /* @__PURE__ */ new WeakMap(), mze = /* @__PURE__ */ new WeakMap(), z3 = /* @__PURE__ */ new WeakMap(), Ty = /* @__PURE__ */ new WeakMap(), vze = /* @__PURE__ */ new WeakMap(), yze = /* @__PURE__ */ new WeakMap(), bze = /* @__PURE__ */ new WeakMap(), uae = globalThis.Node, wze = globalThis.Text, cae = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, Oze = (e) => Tw(e) && e.nodeType === 8, Ka = (e) => Tw(e) && e.nodeType === 1, Tw = (e) => {
  var t = cae(e);
  return !!t && e instanceof t.Node;
}, U3 = (e) => {
  var t = e && e.anchorNode && cae(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Cze = (e) => {
  var [t, n] = e;
  if (Ka(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = pae(t, o, r ? "backward" : "forward"), r = o < n; Ka(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = Lze(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, xze = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, pae = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (Oze(o) || Ka(o) && o.childNodes.length === 0 || Ka(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, Lze = (e, t, n) => {
  var [r] = pae(e, t, n);
  return r;
}, W3 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), dae = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ka(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = bn.getWindow(e);
  if (o.contains(r))
    return bn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : dae(e, i, n);
}, H3 = (e, t) => !!(e.compareDocumentPosition(t) & uae.DOCUMENT_POSITION_PRECEDING), Eze = (e, t) => !!(e.compareDocumentPosition(t) & uae.DOCUMENT_POSITION_FOLLOWING), kze = 0;
class Pze {
  constructor() {
    Bh(this, "id", void 0), this.id = "".concat(kze++);
  }
}
var bn = {
  androidPendingDiffs: (e) => bze.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = yze.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = bn.toDOMNode(e, e), n = bn.findDocumentOrShadowRoot(e);
    Ty.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = bn.findDocumentOrShadowRoot(e), r = W3(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && J0.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = bn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = bn.toSlateNode(e, t.target), a = bn.findPath(e, i);
    if (Il.isElement(i) && Lr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Lr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Lr.before(e, u) : Lr.after(e, u);
      if (c) {
        var p = Lr.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = bn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = bn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = F3.get(t);
    return n || (n = new Pze(), F3.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = dze.get(r);
      if (o == null) {
        if (Lr.isEditor(r))
          return n;
        break;
      }
      var i = pze.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Ns.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Ty.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          bn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = bn.toDOMNode(e, e), r = bn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = W3(r), i = bn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || J0.select(e, Lr.start(e, [])), Ty.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = fze.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = bn.toDOMNode(e, e), i;
    try {
      i = Ka(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Tw(t) && bn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Lr.hasPath(e, n.path) && Lr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => bn.hasEditableTarget(e, t) || bn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Tw(t) && bn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!vze.get(e),
  isFocused: (e) => !!Ty.get(e),
  isReadOnly: (e) => !!z3.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (z3.get(e)) return !1;
    var n = bn.hasTarget(e, t) && bn.toSlateNode(e, t);
    return Il.isElement(n) && Lr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = mze.get(e), r = Lr.isEditor(t) ? hze.get(e) : n == null ? void 0 : n.get(bn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Ns.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Lr.node(e, t.path), r = bn.toDOMNode(e, n), o;
    Lr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof wze ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Ns.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = nn.isBackward(t), i = bn.toDOMPoint(e, n), a = nn.isCollapsed(t) ? i : bn.toDOMPoint(e, r), s = bn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = Ka(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = Ka(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ka(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? gze.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : Cze(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = bn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = bn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (uk && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var R = U[k];
          if (bn.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var N = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, H = [...N(V), ...N(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = H.find((M) => Eze(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var X, G = [...N(V == null ? void 0 : V.previousElementSibling), ...N(V)];
          w = (X = G.findLast((M) => H3(L, M))) !== null && X !== void 0 ? X : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      uk && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      _y && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (uk && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && bn.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = bn.toSlateNode(e, Y), {
          path: J,
          offset: P
        } = Lr.start(e, bn.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = bn.toSlateNode(e, u), z = bn.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = U3(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (U3(t)) {
        if (_y && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        cze && xze(s) || _y ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    _y && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = bn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = H3(s, u) || s === u && c < l, x = p ? w : bn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return nn.isExpanded(m) && nn.isForward(m) && Ka(u) && Lr.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = Lr.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, Sze = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, Mze = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, Dze = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, ho = (e) => {
  var t = Sze[e], n = Mze[e], r = Dze[e], o = t && ik(t), i = n && ik(n), a = r && ik(r);
  return (s) => !!(o && o(s) || R3 && i && i(s) || !R3 && a && a(s));
};
ho("bold"), ho("compose"), ho("moveBackward"), ho("moveForward"), ho("deleteBackward"), ho("deleteForward"), ho("deleteLineBackward"), ho("deleteLineForward"), ho("deleteWordBackward"), ho("deleteWordForward"), ho("extendBackward"), ho("extendForward"), ho("extendLineBackward"), ho("extendLineForward"), ho("italic"), ho("moveLineBackward"), ho("moveLineForward"), ho("moveWordBackward"), ho("moveWordForward"), ho("redo"), ho("insertSoftBreak"), ho("splitBlock"), ho("transposeCharacter"), ho("undo");
var _ze = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => dae(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, Tze = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class jze extends Kl {
  constructor() {
    super(...arguments), Bh(this, "context", null), Bh(this, "manager", null), Bh(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, Tze);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = _ze(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Bh(jze, "contextType", uze);
He({});
He({});
He({});
var ri = {}, OI = {}, gm = {}, mm = {}, fae = "Expected a function", V3 = NaN, Aze = "[object Symbol]", Ize = /^\s+|\s+$/g, Bze = /^[-+]0x[0-9a-f]+$/i, Nze = /^0b[01]+$/i, Rze = /^0o[0-7]+$/i, Fze = parseInt, zze = typeof jr == "object" && jr && jr.Object === Object && jr, Uze = typeof self == "object" && self && self.Object === Object && self, Wze = zze || Uze || Function("return this")(), Hze = Object.prototype, Vze = Hze.toString, $ze = Math.max, Zze = Math.min, ck = function() {
  return Wze.Date.now();
};
function qze(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(fae);
  t = $3(t) || 0, jw(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? $ze($3(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? Zze(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = ck();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(ck());
  }
  function m() {
    var C = ck(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function Xze(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(fae);
  return jw(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), qze(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function jw(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Kze(e) {
  return !!e && typeof e == "object";
}
function Gze(e) {
  return typeof e == "symbol" || Kze(e) && Vze.call(e) == Aze;
}
function $3(e) {
  if (typeof e == "number")
    return e;
  if (Gze(e))
    return V3;
  if (jw(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = jw(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Ize, "");
  var n = Nze.test(e);
  return n || Rze.test(e) ? Fze(e.slice(2), n ? 2 : 8) : Bze.test(e) ? V3 : +e;
}
var Yze = Xze, vm = {};
Object.defineProperty(vm, "__esModule", {
  value: !0
});
vm.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), r0.has(t) || r0.set(t, /* @__PURE__ */ new Set());
  var o = r0.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
vm.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), r0.get(t).delete(n.name || t);
};
var r0 = /* @__PURE__ */ new Map();
Object.defineProperty(mm, "__esModule", {
  value: !0
});
var Jze = Yze, Qze = t2e(Jze), e2e = vm;
function t2e(e) {
  return e && e.__esModule ? e : { default: e };
}
var n2e = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Qze.default)(e, t);
}, _o = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = n2e(function(r) {
        _o.scrollHandler(e);
      }, t);
      _o.scrollSpyContainers.push(e), (0, e2e.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return _o.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = _o.scrollSpyContainers[_o.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(_o.currentPositionX(e), _o.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    _o.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = _o.scrollSpyContainers[_o.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(_o.currentPositionX(t), _o.currentPositionY(t));
  },
  updateStates: function() {
    _o.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    _o.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), _o.spySetState && _o.spySetState.length && _o.spySetState.indexOf(e) > -1 && _o.spySetState.splice(_o.spySetState.indexOf(e), 1), document.removeEventListener("scroll", _o.scrollHandler);
  },
  update: function() {
    return _o.scrollSpyContainers.forEach(function(e) {
      return _o.scrollHandler(e);
    });
  }
};
mm.default = _o;
var Ud = {}, ym = {};
Object.defineProperty(ym, "__esModule", {
  value: !0
});
var r2e = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, o2e = function() {
  return window.location.hash.replace(/^#/, "");
}, i2e = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, s2e = function(e) {
  return getComputedStyle(e).position !== "static";
}, pk = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, a2e = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (s2e(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = pk(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return pk(t, s).offsetTop - pk(e, s).offsetTop;
};
ym.default = {
  updateHash: r2e,
  getHash: o2e,
  filterElementInContainer: i2e,
  scrollOffset: a2e
};
var xx = {}, CI = {};
Object.defineProperty(CI, "__esModule", {
  value: !0
});
CI.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var xI = {};
Object.defineProperty(xI, "__esModule", {
  value: !0
});
var l2e = vm, u2e = ["mousedown", "mousewheel", "touchmove", "keydown"];
xI.default = {
  subscribe: function(e) {
    return typeof document < "u" && u2e.forEach(function(t) {
      return (0, l2e.addPassiveEventListener)(document, t, e);
    });
  }
};
var bm = {};
Object.defineProperty(bm, "__esModule", {
  value: !0
});
var XD = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      XD.registered[e] = t;
    },
    remove: function(e) {
      XD.registered[e] = null;
    }
  }
};
bm.default = XD;
Object.defineProperty(xx, "__esModule", {
  value: !0
});
var c2e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, p2e = ym;
Lx(p2e);
var d2e = CI, Z3 = Lx(d2e), f2e = xI, h2e = Lx(f2e), g2e = bm, za = Lx(g2e);
function Lx(e) {
  return e && e.__esModule ? e : { default: e };
}
var hae = function(e) {
  return Z3.default[e.smooth] || Z3.default.defaultEasing;
}, m2e = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, v2e = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, KD = function() {
  return v2e() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), gae = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, mae = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, vae = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, y2e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, b2e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, w2e = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    za.default.registered.end && za.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    KD.call(window, i);
    return;
  }
  za.default.registered.end && za.default.registered.end(o.to, o.target, o.currentPosition);
}, LI = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, wm = function(e, t, n, r) {
  t.data = t.data || gae(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (h2e.default.subscribe(o), LI(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? mae(t) : vae(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    za.default.registered.end && za.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = m2e(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = hae(t), a = w2e.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      za.default.registered.begin && za.default.registered.begin(t.data.to, t.data.target), KD.call(window, a);
    }, t.delay);
    return;
  }
  za.default.registered.begin && za.default.registered.begin(t.data.to, t.data.target), KD.call(window, a);
}, Ex = function(e) {
  return e = c2e({}, e), e.data = e.data || gae(), e.absolute = !0, e;
}, O2e = function(e) {
  wm(0, Ex(e));
}, C2e = function(e, t) {
  wm(e, Ex(t));
}, x2e = function(e) {
  e = Ex(e), LI(e), wm(e.horizontal ? y2e(e) : b2e(e), e);
}, L2e = function(e, t) {
  t = Ex(t), LI(t);
  var n = t.horizontal ? mae(t) : vae(t);
  wm(e + n, t);
};
xx.default = {
  animateTopScroll: wm,
  getAnimationType: hae,
  scrollToTop: O2e,
  scrollToBottom: x2e,
  scrollTo: C2e,
  scrollMore: L2e
};
Object.defineProperty(Ud, "__esModule", {
  value: !0
});
var E2e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, k2e = ym, P2e = EI(k2e), S2e = xx, M2e = EI(S2e), D2e = bm, jy = EI(D2e);
function EI(e) {
  return e && e.__esModule ? e : { default: e };
}
var Ay = {}, q3 = void 0;
Ud.default = {
  unmount: function() {
    Ay = {};
  },
  register: function(e, t) {
    Ay[e] = t;
  },
  unregister: function(e) {
    delete Ay[e];
  },
  get: function(e) {
    return Ay[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return q3 = e;
  },
  getActiveLink: function() {
    return q3;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = E2e({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = P2e.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      jy.default.registered.begin && jy.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, jy.default.registered.end && jy.default.registered.end(e, n);
      return;
    }
    M2e.default.animateTopScroll(s, t, e, n);
  }
};
var GD = { exports: {} }, dk = { exports: {} }, tr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var X3;
function _2e() {
  if (X3) return tr;
  X3 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return tr.AsyncMode = l, tr.ConcurrentMode = u, tr.ContextConsumer = s, tr.ContextProvider = a, tr.Element = t, tr.ForwardRef = c, tr.Fragment = r, tr.Lazy = f, tr.Memo = y, tr.Portal = n, tr.Profiler = i, tr.StrictMode = o, tr.Suspense = p, tr.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, tr.isConcurrentMode = x, tr.isContextConsumer = function(m) {
    return D(m) === s;
  }, tr.isContextProvider = function(m) {
    return D(m) === a;
  }, tr.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, tr.isForwardRef = function(m) {
    return D(m) === c;
  }, tr.isFragment = function(m) {
    return D(m) === r;
  }, tr.isLazy = function(m) {
    return D(m) === f;
  }, tr.isMemo = function(m) {
    return D(m) === y;
  }, tr.isPortal = function(m) {
    return D(m) === n;
  }, tr.isProfiler = function(m) {
    return D(m) === i;
  }, tr.isStrictMode = function(m) {
    return D(m) === o;
  }, tr.isSuspense = function(m) {
    return D(m) === p;
  }, tr.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, tr.typeOf = D, tr;
}
var dr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var K3;
function T2e() {
  return K3 || (K3 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === y || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === L || B.$$typeof === w || B.$$typeof === v);
    }
    function x(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var re = he && he.$$typeof;
                switch (re) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return re;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, R = c, N = r, V = f, $ = y, H = n, X = i, G = o, Y = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || x(B) === l;
    }
    function P(B) {
      return x(B) === u;
    }
    function _(B) {
      return x(B) === s;
    }
    function z(B) {
      return x(B) === a;
    }
    function M(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return x(B) === c;
    }
    function O(B) {
      return x(B) === r;
    }
    function I(B) {
      return x(B) === f;
    }
    function F(B) {
      return x(B) === y;
    }
    function j(B) {
      return x(B) === n;
    }
    function q(B) {
      return x(B) === i;
    }
    function A(B) {
      return x(B) === o;
    }
    function K(B) {
      return x(B) === p;
    }
    dr.AsyncMode = m, dr.ConcurrentMode = C, dr.ContextConsumer = S, dr.ContextProvider = U, dr.Element = k, dr.ForwardRef = R, dr.Fragment = N, dr.Lazy = V, dr.Memo = $, dr.Portal = H, dr.Profiler = X, dr.StrictMode = G, dr.Suspense = Y, dr.isAsyncMode = J, dr.isConcurrentMode = P, dr.isContextConsumer = _, dr.isContextProvider = z, dr.isElement = M, dr.isForwardRef = W, dr.isFragment = O, dr.isLazy = I, dr.isMemo = F, dr.isPortal = j, dr.isProfiler = q, dr.isStrictMode = A, dr.isSuspense = K, dr.isValidElementType = D, dr.typeOf = x;
  }()), dr;
}
var G3;
function yae() {
  return G3 || (G3 = 1, process.env.NODE_ENV === "production" ? dk.exports = _2e() : dk.exports = T2e()), dk.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var fk, Y3;
function j2e() {
  if (Y3) return fk;
  Y3 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return fk = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, fk;
}
var hk, J3;
function kI() {
  if (J3) return hk;
  J3 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return hk = e, hk;
}
var Q3, e6;
function bae() {
  return e6 || (e6 = 1, Q3 = Function.call.bind(Object.prototype.hasOwnProperty)), Q3;
}
var gk, t6;
function A2e() {
  if (t6) return gk;
  t6 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = kI(), n = {}, r = bae();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, gk = o, gk;
}
var mk, n6;
function I2e() {
  if (n6) return mk;
  n6 = 1;
  var e = yae(), t = j2e(), n = kI(), r = bae(), o = A2e(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return mk = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, I, F, j, q, A, K) {
        if (j = j || d, A = A || F, K !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = j + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return I[F] == null ? O ? I[F] === null ? new v("The " + q + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new v("The " + q + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : P(I, F, j, q, A);
      }
      var W = M.bind(null, !1);
      return W.isRequired = M.bind(null, !0), W;
    }
    function L(P) {
      function _(z, M, W, O, I, F) {
        var j = z[M], q = G(j);
        if (q !== P) {
          var A = Y(j);
          return new v(
            "Invalid " + O + " `" + I + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var j = G(F);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var A = P(F, q, W, O, I + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!s(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!e.isValidElementType(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, W, O, I) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, j = J(z[M]);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, W, O, I) {
        for (var F = z[M], j = 0; j < P.length; j++)
          if (f(F, P[j]))
            return null;
        var q = JSON.stringify(P, function(A, K) {
          var B = Y(K);
          return B === "symbol" ? String(K) : K;
        });
        return new v("Invalid " + O + " `" + I + "` of value `" + String(F) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var A = P(F, q, W, O, I + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(W, O, I, F, j) {
        for (var q = [], A = 0; A < P.length; A++) {
          var K = P[A], B = K(W, O, I, F, j, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + j + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(M);
    }
    function R() {
      function P(_, z, M, W, O) {
        return H(_[z]) ? null : new v("Invalid " + W + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function N(P, _, z, M, W) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return N(W, O, I, q, Y(A));
          var K = A(F, q, W, O, I + "." + q, n);
          if (K)
            return K;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var A in q) {
          var K = P[A];
          if (r(P, A) && typeof K != "function")
            return N(W, O, I, A, Y(K));
          if (!K)
            return new v(
              "Invalid " + O + " `" + I + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = K(F, A, W, O, I + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!H(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var W = M.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function X(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function G(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : X(_, P) ? "symbol" : _;
    }
    function Y(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = G(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = Y(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, mk;
}
var vk, r6;
function B2e() {
  if (r6) return vk;
  r6 = 1;
  var e = kI();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, vk = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, vk;
}
if (process.env.NODE_ENV !== "production") {
  var N2e = yae(), R2e = !0;
  GD.exports = I2e()(N2e.isElement, R2e);
} else
  GD.exports = B2e()();
var kx = GD.exports, Px = {};
Object.defineProperty(Px, "__esModule", {
  value: !0
});
var F2e = ym, yk = z2e(F2e);
function z2e(e) {
  return e && e.__esModule ? e : { default: e };
}
var U2e = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return yk.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && yk.default.getHash() !== e && yk.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Px.default = U2e;
Object.defineProperty(gm, "__esModule", {
  value: !0
});
var Iy = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, W2e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), H2e = Oe, o6 = Om(H2e), V2e = mm, By = Om(V2e), $2e = Ud, Z2e = Om($2e), q2e = kx, go = Om(q2e), X2e = Px, uu = Om(X2e);
function Om(e) {
  return e && e.__esModule ? e : { default: e };
}
function K2e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function G2e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Y2e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var i6 = {
  to: go.default.string.isRequired,
  containerId: go.default.string,
  container: go.default.object,
  activeClass: go.default.string,
  activeStyle: go.default.object,
  spy: go.default.bool,
  horizontal: go.default.bool,
  smooth: go.default.oneOfType([go.default.bool, go.default.string]),
  offset: go.default.number,
  delay: go.default.number,
  isDynamic: go.default.bool,
  onClick: go.default.func,
  duration: go.default.oneOfType([go.default.number, go.default.func]),
  absolute: go.default.bool,
  onSetActive: go.default.func,
  onSetInactive: go.default.func,
  ignoreCancelEvents: go.default.bool,
  hashSpy: go.default.bool,
  saveHashHistory: go.default.bool,
  spyThrottle: go.default.number
};
gm.default = function(e, t) {
  var n = t || Z2e.default, r = function(i) {
    Y2e(a, i);
    function a(s) {
      K2e(this, a);
      var l = G2e(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return W2e(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          By.default.isMounted(s) || By.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (uu.default.isMounted() || uu.default.mount(n), uu.default.mapContainer(this.props.to, s)), By.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        By.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Iy({}, this.props.style, this.props.activeStyle) : l = Iy({}, this.props.style);
        var u = Iy({}, this.props);
        for (var c in i6)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, o6.default.createElement(e, u);
      }
    }]), a;
  }(o6.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Iy({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(uu.default.isMounted() && !uu.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var R = n.getActiveLink();
        if (y) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && uu.default.getHash() === c) {
            var N = i.props.saveHashHistory, V = N === void 0 ? !1 : N;
            uu.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, H = $ === void 0 ? !1 : $;
          i.props.hashSpy && uu.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = i6, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(OI, "__esModule", {
  value: !0
});
var J2e = Oe, s6 = wae(J2e), Q2e = gm, eUe = wae(Q2e);
function wae(e) {
  return e && e.__esModule ? e : { default: e };
}
function tUe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function a6(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function nUe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var rUe = function(e) {
  nUe(t, e);
  function t() {
    var n, r, o, i;
    tUe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = a6(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return s6.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), a6(o, i);
  }
  return t;
}(s6.default.Component);
OI.default = (0, eUe.default)(rUe);
var PI = {};
Object.defineProperty(PI, "__esModule", {
  value: !0
});
var oUe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), iUe = Oe, l6 = Oae(iUe), sUe = gm, aUe = Oae(sUe);
function Oae(e) {
  return e && e.__esModule ? e : { default: e };
}
function lUe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function uUe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function cUe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var pUe = function(e) {
  cUe(t, e);
  function t() {
    return lUe(this, t), uUe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return oUe(t, [{
    key: "render",
    value: function() {
      return l6.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(l6.default.Component);
PI.default = (0, aUe.default)(pUe);
var SI = {}, Sx = {};
Object.defineProperty(Sx, "__esModule", {
  value: !0
});
var dUe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, fUe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), hUe = Oe, u6 = Mx(hUe), gUe = nl;
Mx(gUe);
var mUe = Ud, c6 = Mx(mUe), vUe = kx, p6 = Mx(vUe);
function Mx(e) {
  return e && e.__esModule ? e : { default: e };
}
function yUe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function bUe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function wUe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Sx.default = function(e) {
  var t = function(n) {
    wUe(r, n);
    function r(o) {
      yUe(this, r);
      var i = bUe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return fUe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        c6.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        c6.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return u6.default.createElement(e, dUe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(u6.default.Component);
  return t.propTypes = {
    name: p6.default.string,
    id: p6.default.string
  }, t;
};
Object.defineProperty(SI, "__esModule", {
  value: !0
});
var d6 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, OUe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), CUe = Oe, f6 = MI(CUe), xUe = Sx, LUe = MI(xUe), EUe = kx, h6 = MI(EUe);
function MI(e) {
  return e && e.__esModule ? e : { default: e };
}
function kUe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function PUe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function SUe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Cae = function(e) {
  SUe(t, e);
  function t() {
    return kUe(this, t), PUe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return OUe(t, [{
    key: "render",
    value: function() {
      var n = this, r = d6({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, f6.default.createElement(
        "div",
        d6({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(f6.default.Component);
Cae.propTypes = {
  name: h6.default.string,
  id: h6.default.string
};
SI.default = (0, LUe.default)(Cae);
var bk = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, g6 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function m6(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function v6(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function y6(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Ny = Oe, Ic = mm, wk = Ud, zo = kx, cu = Px, b6 = {
  to: zo.string.isRequired,
  containerId: zo.string,
  container: zo.object,
  activeClass: zo.string,
  spy: zo.bool,
  smooth: zo.oneOfType([zo.bool, zo.string]),
  offset: zo.number,
  delay: zo.number,
  isDynamic: zo.bool,
  onClick: zo.func,
  duration: zo.oneOfType([zo.number, zo.func]),
  absolute: zo.bool,
  onSetActive: zo.func,
  onSetInactive: zo.func,
  ignoreCancelEvents: zo.bool,
  hashSpy: zo.bool,
  spyThrottle: zo.number
}, MUe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || wk, r = function(i) {
      y6(a, i);
      function a(s) {
        m6(this, a);
        var l = v6(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return g6(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Ic.isMounted(s) || Ic.mount(s, this.props.spyThrottle), this.props.hashSpy && (cu.isMounted() || cu.mount(n), cu.mapContainer(this.props.to, s)), this.props.spy && Ic.addStateHandler(this.stateHandler), Ic.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Ic.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = bk({}, this.props);
          for (var u in b6)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Ny.createElement(e, l);
        }
      }]), a;
    }(Ny.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, bk({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(cu.isMounted() && !cu.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && cu.getHash() === l && cu.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Ic.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && cu.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Ic.updateStates();
        }
      };
    };
    return r.propTypes = b6, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      y6(r, n);
      function r(o) {
        m6(this, r);
        var i = v6(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return g6(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          wk.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          wk.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Ny.createElement(e, bk({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Ny.Component);
    return t.propTypes = {
      name: zo.string,
      id: zo.string
    }, t;
  }
}, DUe = MUe;
Object.defineProperty(ri, "__esModule", {
  value: !0
});
ri.Helpers = ri.ScrollElement = ri.ScrollLink = ri.animateScroll = ri.scrollSpy = ri.Events = ri.scroller = ri.Element = ri.Button = ri.Link = void 0;
var _Ue = OI, xae = il(_Ue), TUe = PI, Lae = il(TUe), jUe = SI, Eae = il(jUe), AUe = Ud, kae = il(AUe), IUe = bm, Pae = il(IUe), BUe = mm, Sae = il(BUe), NUe = xx, Mae = il(NUe), RUe = gm, Dae = il(RUe), FUe = Sx, _ae = il(FUe), zUe = DUe, Tae = il(zUe);
function il(e) {
  return e && e.__esModule ? e : { default: e };
}
ri.Link = xae.default;
ri.Button = Lae.default;
ri.Element = Eae.default;
ri.scroller = kae.default;
ri.Events = Pae.default;
ri.scrollSpy = Sae.default;
ri.animateScroll = Mae.default;
ri.ScrollLink = Dae.default;
ri.ScrollElement = _ae.default;
ri.Helpers = Tae.default;
ri.default = { Link: xae.default, Button: Lae.default, Element: Eae.default, scroller: kae.default, Events: Pae.default, scrollSpy: Sae.default, animateScroll: Mae.default, ScrollLink: Dae.default, ScrollElement: _ae.default, Helpers: Tae.default };
He({});
He({});
He({});
function Fg(e) {
  "@babel/helpers - typeof";
  return Fg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Fg(e);
}
function UUe(e, t) {
  if (Fg(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Fg(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function WUe(e) {
  var t = UUe(e, "string");
  return Fg(t) == "symbol" ? t : t + "";
}
function Ae(e, t, n) {
  return (t = WUe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function jae(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ok, w6;
function HUe() {
  if (w6) return Ok;
  w6 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Ok = t, Ok;
}
var VUe = HUe(), di = /* @__PURE__ */ jae(VUe), Vt = He(null);
function $Ue() {
  di(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Vt);
  return di(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function ZUe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function qUe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function XUe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return qUe(e, i), o;
}
function KUe(e, t, n) {
  var r = ZUe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function GUe(e) {
  google.maps.event.removeListener(e);
}
function Rn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(GUe);
}
function Pn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = KUe(o, i, n);
  return XUe(t, r, o, i), a;
}
function YUe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = vt(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null), [A, K] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), K(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var B = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(B), B !== null && D && D(B), () => {
      B !== null && x && x(B);
    };
  }, []), bs.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: bs.jsx(Vt.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(YUe);
function O6(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Aae(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        O6(i, r, o, a, s, "next", l);
      }
      function s(l) {
        O6(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Iae(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return di(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var vp = typeof document < "u";
function Bae(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return vp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function C6(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Nae() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return C6(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return C6(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Pf = !1;
function Rae() {
  return bs.jsx("div", {
    children: "Loading..."
  });
}
var YD = {
  id: "script-loader",
  version: "weekly"
};
class JUe extends pe {
  constructor() {
    super(...arguments), Ae(this, "check", jn()), Ae(this, "state", {
      loaded: !1
    }), Ae(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Ae(this, "isCleaningUp", /* @__PURE__ */ Aae(function* () {
      function t(n) {
        if (!Pf)
          n();
        else if (vp)
          var r = window.setInterval(function() {
            Pf || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Ae(this, "cleanup", () => {
      Pf = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Ae(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Nae(), di(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Iae(this.props)
      };
      Bae(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (vp) {
      if (window.google && window.google.maps && !Pf) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), vp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (vp) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Pf = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return bs.jsxs(bs.Fragment, {
      children: [bs.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || bs.jsx(Rae, {})]
    });
  }
}
Ae(JUe, "defaultProps", YD);
function QUe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function DI(e, t) {
  if (e == null) return {};
  var n, r, o = QUe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var x6;
function eWe(e) {
  var {
    id: t = YD.id,
    version: n = YD.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = vt(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    vp && u && Nae();
  }, [u]), h(function() {
    f && di(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Iae({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!vp)
      return;
    function x() {
      y.current && (v(!0), x6 = w);
    }
    if (window.google && window.google.maps && x6 === w) {
      x();
      return;
    }
    Bae({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = vt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var tWe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], nWe = bs.jsx(Rae, {});
function rWe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = DI(e, tWe), {
    isLoaded: s,
    loadError: l
  } = eWe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || nWe;
}
me(rWe);
var L6;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(L6 || (L6 = {}));
function E6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Aw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? E6(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : E6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var k6 = {}, P6 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function oWe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Vt), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Aw(Aw({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(oWe);
class iWe extends pe {
  constructor() {
    super(...arguments), Ae(this, "state", {
      trafficLayer: null
    }), Ae(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Ae(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Aw(Aw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: P6,
      eventMap: k6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: P6,
      eventMap: k6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Rn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(iWe, "contextType", Vt);
function sWe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Vt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(sWe);
class aWe extends pe {
  constructor() {
    super(...arguments), Ae(this, "state", {
      bicyclingLayer: null
    }), Ae(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(aWe, "contextType", Vt);
function lWe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Vt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(lWe);
class uWe extends pe {
  constructor() {
    super(...arguments), Ae(this, "state", {
      transitLayer: null
    }), Ae(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(uWe, "contextType", Vt);
function S6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Iw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? S6(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : S6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var M6 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, D6 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function cWe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Vt), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    di(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(Iw(Iw({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && L(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && k(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(cWe);
class pWe extends pe {
  constructor(t) {
    super(t), Ae(this, "registeredEvents", []), Ae(this, "state", {
      drawingManager: null
    }), Ae(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), di(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Iw(Iw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: D6,
      eventMap: M6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: D6,
      eventMap: M6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Rn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(pWe, "contextType", Vt);
function _6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ld(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _6(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var T6 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, j6 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Bw = {};
function dWe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: R,
    onClickableChanged: N,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: H,
    onFlatChanged: X,
    onIconChanged: G,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, W = ge(Vt), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null), [re, Se] = E(null), [We, Ze] = E(null), [Me, rt] = E(null), [Ve, be] = E(null), [qe, ct] = E(null), [ye, xe] = E(null), [Ee, Ue] = E(null), [De, st] = E(null), [ve, wt] = E(null), [at, lt] = E(null), [pt, Ot] = E(null), [dt, Ct] = E(null), [Xe, ht] = E(null), [ot, xt] = E(null), [ft, Pt] = E(null), [Lt, St] = E(null), [Et, Mt] = E(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (re !== null && google.maps.event.removeListener(re), Se(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), Ze(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Me !== null && google.maps.event.removeListener(Me), rt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && R && (Ve !== null && google.maps.event.removeListener(Ve), be(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && L && (qe !== null && google.maps.event.removeListener(qe), ct(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (ye !== null && google.maps.event.removeListener(ye), xe(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && N && (Ee !== null && google.maps.event.removeListener(Ee), Ue(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && V && (De !== null && google.maps.event.removeListener(De), st(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), wt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && X && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(O, "flat_changed", X)));
  }, [X]), h(() => {
    O && G && (dt !== null && google.maps.event.removeListener(dt), Ct(google.maps.event.addListener(O, "icon_changed", G)));
  }, [G]), h(() => {
    O && Y && (Xe !== null && google.maps.event.removeListener(Xe), ht(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (ot !== null && google.maps.event.removeListener(ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (ft !== null && google.maps.event.removeListener(ft), Pt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Lt !== null && google.maps.event.removeListener(Lt), St(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (Et !== null && google.maps.event.removeListener(Et), Mt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var gt = ld(ld(ld({}, n || Bw), r ? Bw : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(gt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof y < "u" && te.setOpacity(y), f && te.setShape(f), typeof v == "string" && te.setTitle(v), typeof b == "number" && te.setZIndex(b), w && j(google.maps.event.addListener(te, "dblclick", w)), x && A(google.maps.event.addListener(te, "dragend", x)), m && B(google.maps.event.addListener(te, "dragstart", m)), k && he(google.maps.event.addListener(te, "mousedown", k)), C && Se(google.maps.event.addListener(te, "mouseout", C)), S && Ze(google.maps.event.addListener(te, "mouseover", S)), U && rt(google.maps.event.addListener(te, "mouseup", U)), R && be(google.maps.event.addListener(te, "rightclick", R)), L && ct(google.maps.event.addListener(te, "click", L)), D && xe(google.maps.event.addListener(te, "drag", D)), N && Ue(google.maps.event.addListener(te, "clickable_changed", N)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), $ && wt(google.maps.event.addListener(te, "animation_changed", $)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), X && Ot(google.maps.event.addListener(te, "flat_changed", X)), G && Ct(google.maps.event.addListener(te, "icon_changed", G)), Y && ht(google.maps.event.addListener(te, "position_changed", Y)), Q && xt(google.maps.event.addListener(te, "shape_changed", Q)), J && Pt(google.maps.event.addListener(te, "title_changed", J)), P && St(google.maps.event.addListener(te, "visible_changed", P)), _ && Mt(google.maps.event.addListener(te, "zindex_changed", _)), I(te), z && z(te), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), re !== null && google.maps.event.removeListener(re), We !== null && google.maps.event.removeListener(We), Me !== null && google.maps.event.removeListener(Me), Ve !== null && google.maps.event.removeListener(Ve), qe !== null && google.maps.event.removeListener(qe), Ee !== null && google.maps.event.removeListener(Ee), De !== null && google.maps.event.removeListener(De), ve !== null && google.maps.event.removeListener(ve), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), Xe !== null && google.maps.event.removeListener(Xe), ft !== null && google.maps.event.removeListener(ft), Lt !== null && google.maps.event.removeListener(Lt), Et !== null && google.maps.event.removeListener(Et), M && M(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var _t = zt(() => i ? ut.map(i, (gt) => {
    if (!wi(gt))
      return gt;
    var te = gt;
    return Oi(te, {
      anchor: O
    });
  }) : null, [i, O]);
  return bs.jsx(bs.Fragment, {
    children: _t
  }) || null;
}
me(dWe);
class fWe extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Aae(function* () {
      var n = ld(ld(ld({}, t.props.options || Bw), t.props.clusterer ? Bw : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Pn({
        updaterMap: j6,
        eventMap: T6,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: j6,
      eventMap: T6,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Rn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Oi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Ae(fWe, "contextType", Vt);
var hWe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), gWe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new hWe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function mWe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var vWe = 2e3, yWe = 500, bWe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", wWe = "png", OWe = [53, 56, 66, 78, 90], CWe = "cluster", Fae = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || bWe, this.imageExtension = r.imageExtension || wWe, this.imageSizes = r.imageSizes || OWe, this.calculator = r.calculator || mWe, this.batchSize = r.batchSize || vWe, this.batchSizeIE = r.batchSizeIE || yWe, this.clusterClass = r.clusterClass || CWe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new gWe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function A6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xWe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? A6(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : A6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ma = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Zn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, LWe = {};
function EWe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, R] = E(null), N = ge(Vt), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, ma.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, ma.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, ma.onClick, w)));
  }, [w]), h(() => {
    k && D && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(k, ma.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (G !== null && google.maps.event.removeListener(G), X(google.maps.event.addListener(k, ma.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && Zn.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && Zn.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && Zn.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && Zn.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && Zn.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && Zn.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && Zn.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && Zn.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && Zn.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && Zn.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && Zn.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && Zn.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && Zn.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && Zn.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && Zn.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (N) {
      var z = xWe({}, n || LWe), M = new Fae(N, [], z);
      return r && Zn.averageCenter(M, r), o && Zn.batchSizeIE(M, o), i && Zn.calculator(M, i), a && Zn.clusterClass(M, a), s && Zn.enableRetinaIcons(M, s), l && Zn.gridSize(M, l), u && Zn.ignoreHidden(M, u), c && Zn.imageExtension(M, c), p && Zn.imagePath(M, p), d && Zn.imageSizes(M, d), y && Zn.maxZoom(M, y), f && Zn.minimumClusterSize(M, f), v && Zn.styles(M, v), b && Zn.title(M, b), L && Zn.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, ma.onMouseOut, C)), m && _(google.maps.event.addListener(M, ma.onMouseOver, m)), w && $(google.maps.event.addListener(M, ma.onClick, w)), D && X(google.maps.event.addListener(M, ma.onClusteringBegin, D)), x && Y(google.maps.event.addListener(M, ma.onClusteringEnd, x)), R(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(EWe);
class kWe extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      markerClusterer: null
    }), Ae(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Fae(this.context, [], this.props.options);
      this.registeredEvents = Pn({
        updaterMap: Zn,
        eventMap: ma,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: Zn,
      eventMap: ma,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Rn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Ae(kWe, "contextType", Vt);
function I6(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var zae = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || I6(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, I6));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), PWe = ["position"], SWe = ["position"];
function B6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? B6(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : B6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var N6 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, R6 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, MWe = {};
function DWe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Vt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var N = r || MWe, {
        position: V
      } = N, $ = DI(N, PWe), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var X = new zae(Nw(Nw({}, $), H ? {
        position: H
      } : {}));
      R.current = document.createElement("div"), v(X), a && L(google.maps.event.addListener(X, "closeclick", a)), s && D(google.maps.event.addListener(X, "domready", s)), l && m(google.maps.event.addListener(X, "content_changed", l)), u && S(google.maps.event.addListener(X, "position_changed", u)), c && k(google.maps.event.addListener(X, "zindex_changed", c)), X.setContent(R.current), n ? X.open(y, n) : X.getPosition() ? X.open(y) : di(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(X);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(DWe);
class _We extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "containerElement", null), Ae(this, "state", {
      infoBox: null
    }), Ae(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : di(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Ae(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = DI(t, SWe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new zae(Nw(Nw({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Pn({
      updaterMap: R6,
      eventMap: N6,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: R6,
      eventMap: N6,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Rn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
Ae(_We, "contextType", Vt);
var F6, z6;
function TWe() {
  return z6 || (z6 = 1, F6 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), F6;
}
var jWe = TWe(), U6 = /* @__PURE__ */ jae(jWe), W6 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Ck = 1, Sf = 8;
class _I {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Ck)
      throw new Error("Got v".concat(o, " data when expected v").concat(Ck, "."));
    var i = W6[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new _I(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = W6.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Sf, t), this.coords = new this.ArrayType(this.data, Sf + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Sf + a + s + l), this.ids = new this.IndexArrayType(this.data, Sf, t), this.coords = new this.ArrayType(this.data, Sf + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Ck << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return JD(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          H6(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      H6(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function JD(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Uae(e, t, a, r, o, i), JD(e, t, n, r, a - 1, 1 - i), JD(e, t, n, a + 1, o, 1 - i);
  }
}
function Uae(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Uae(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (Mf(e, t, r, n), t[2 * o + i] > y && Mf(e, t, r, o); f < v; ) {
      for (Mf(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? Mf(e, t, r, v) : (v++, Mf(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function Mf(e, t, n, r) {
  xk(e, n, r), xk(t, 2 * n, 2 * r), xk(t, 2 * n + 1, 2 * r + 1);
}
function xk(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function H6(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var AWe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, V6 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Bc = 2, Iu = 3, Lk = 4, ku = 5, Wae = 6;
class IWe {
  constructor(t) {
    this.options = Object.assign(Object.create(AWe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = V6(Ry(u)), d = V6(Fy(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Ry(r), Fy(a), Ry(i), Fy(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + ku] > 1 ? $6(p, f, this.clusterProps) : this.points[p[f + Iu]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + Lk] === t && p.push(a[y + ku] > 1 ? $6(a, y, this.clusterProps) : this.points[a[y + Iu]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new _I(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + ku] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Hae(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Iu]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = Ry(f), d = Fy(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + Iu] : L = this.points[n[l + Iu]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Bc] <= n)) {
        l[p + Bc] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + ku], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + Bc] > n && (b += l[w + ku]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + Bc] <= n)) {
              l[k + Bc] = n;
              var R = l[k + ku];
              D += l[k] * R, x += l[k + 1] * R, l[k + Lk] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + Lk] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + Bc] <= n)) {
                l[$ + Bc] = n;
                for (var H = 0; H < c; H++) u.push(l[$ + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ku] > 1) {
      var o = this.clusterProps[t[n + Wae]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Iu]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function $6(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Iu],
    properties: Hae(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [BWe(e[t]), NWe(e[t + 1])]
    }
  };
}
function Hae(e, t, n) {
  var r = e[t + ku], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Wae], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Iu],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Ry(e) {
  return e / 360 + 0.5;
}
function Fy(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function BWe(e) {
  return (e - 0.5) * 360;
}
function NWe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function RWe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ws {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class QD {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ws.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ws.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ws.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class FWe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return zWe(n);
  }
}
var zWe = (e) => {
  var t = e.map((n) => new QD({
    position: Ws.getPosition(n),
    markers: [n]
  }));
  return t;
};
class UWe extends FWe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = RWe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new IWe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!U6(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Ws.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !U6(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new QD({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new QD({
      markers: [i],
      position: Ws.getPosition(i)
    });
  }
}
class WWe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class HWe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ws.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function VWe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class TI {
  constructor() {
    VWe(TI, google.maps.OverlayView);
  }
}
var Nh;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Nh || (Nh = {}));
var $We = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class ZWe extends TI {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new UWe(o),
      renderer: a = new HWe(),
      onClusterClick: s = $We
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ws.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Nh.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Ws.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Ws.setMap(l, null)));
      }
      google.maps.event.trigger(this, Nh.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ws.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new WWe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ws.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Nh.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ws.setMap(r.marker, n);
    });
  }
}
function Z6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function q6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Z6(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Z6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function qWe(e) {
  var t = $Ue(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new ZWe(q6(q6({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function XWe(e) {
  var {
    children: t,
    options: n
  } = e, r = qWe(n);
  return r !== null ? t(r) : null;
}
me(XWe);
var X6 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, K6 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function KWe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Vt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return v(N), R.current = document.createElement("div"), a && L(google.maps.event.addListener(N, "closeclick", a)), s && D(google.maps.event.addListener(N, "domready", s)), l && m(google.maps.event.addListener(N, "content_changed", l)), u && S(google.maps.event.addListener(N, "position_changed", u)), c && k(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(R.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(y, n) : N.getPosition() ? N.open(y) : di(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(N), N.close();
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(KWe);
class GWe extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "containerElement", null), Ae(this, "state", {
      infoWindow: null
    }), Ae(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : di(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Ae(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Pn({
      updaterMap: K6,
      eventMap: X6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: K6,
      eventMap: X6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Rn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
Ae(GWe, "contextType", Vt);
function G6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G6(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Y6 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, J6 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, YWe = {};
function JWe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(Vt), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var j = new google.maps.Polyline(Rw(Rw({}, t || YWe), {}, {
      map: D
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && S(google.maps.event.addListener(j, "dblclick", a)), s && k(google.maps.event.addListener(j, "dragend", s)), l && N(google.maps.event.addListener(j, "dragstart", l)), u && $(google.maps.event.addListener(j, "mousedown", u)), c && X(google.maps.event.addListener(j, "mousemove", c)), p && Y(google.maps.event.addListener(j, "mouseout", p)), d && J(google.maps.event.addListener(j, "mouseover", d)), y && _(google.maps.event.addListener(j, "mouseup", y)), f && M(google.maps.event.addListener(j, "rightclick", f)), v && O(google.maps.event.addListener(j, "click", v)), b && F(google.maps.event.addListener(j, "drag", b)), m(j), L && L(j), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
me(JWe);
class QWe extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      polyline: null
    }), Ae(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Rw(Rw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: J6,
      eventMap: Y6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: J6,
      eventMap: Y6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Rn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(QWe, "contextType", Vt);
function Q6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function e9(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Q6(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Q6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var t9 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, n9 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function eHe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Vt), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var A = new google.maps.Polygon(e9(e9({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && k(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && $(google.maps.event.addListener(A, "dragstart", u)), c && X(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), b && F(google.maps.event.addListener(A, "click", b)), L && q(google.maps.event.addListener(A, "drag", L)), S(A), w && w(A), () => {
      U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), D && D(A), A.setMap(null);
    };
  }, []), null;
}
me(eHe);
class tHe extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Pn({
      updaterMap: n9,
      eventMap: t9,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: n9,
      eventMap: t9,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Rn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(tHe, "contextType", Vt);
function r9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? r9(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var o9 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, i9 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function nHe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Vt), [m, C] = E(null), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var K = new google.maps.Rectangle(Fw(Fw({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && K.setVisible(i), typeof o < "u" && K.setEditable(o), typeof r < "u" && K.setDraggable(r), typeof n < "u" && K.setBounds(n), a && U(google.maps.event.addListener(K, "dblclick", a)), s && R(google.maps.event.addListener(K, "dragend", s)), l && V(google.maps.event.addListener(K, "dragstart", l)), u && H(google.maps.event.addListener(K, "mousedown", u)), c && G(google.maps.event.addListener(K, "mousemove", c)), p && Q(google.maps.event.addListener(K, "mouseout", p)), d && P(google.maps.event.addListener(K, "mouseover", d)), y && z(google.maps.event.addListener(K, "mouseup", y)), f && W(google.maps.event.addListener(K, "rightclick", f)), v && I(google.maps.event.addListener(K, "click", v)), b && j(google.maps.event.addListener(K, "drag", b)), L && A(google.maps.event.addListener(K, "bounds_changed", L)), C(K), w && w(K), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(K), K.setMap(null);
    };
  }, []), null;
}
me(nHe);
class rHe extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      rectangle: null
    }), Ae(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Fw(Fw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: i9,
      eventMap: o9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: i9,
      eventMap: o9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Rn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(rHe, "contextType", Vt);
function s9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? s9(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : s9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var a9 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, l9 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, oHe = {};
function iHe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Vt), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var re = new google.maps.Circle(zw(zw({}, t || oHe), {}, {
      map: C
    }));
    return typeof r == "number" && re.setRadius(r), typeof n < "u" && re.setCenter(n), typeof r == "number" && re.setRadius(r), typeof a < "u" && re.setVisible(a), typeof i < "u" && re.setEditable(i), typeof o < "u" && re.setDraggable(o), s && R(google.maps.event.addListener(re, "dblclick", s)), l && V(google.maps.event.addListener(re, "dragend", l)), u && H(google.maps.event.addListener(re, "dragstart", u)), c && G(google.maps.event.addListener(re, "mousedown", c)), p && Q(google.maps.event.addListener(re, "mousemove", p)), d && P(google.maps.event.addListener(re, "mouseout", d)), y && z(google.maps.event.addListener(re, "mouseover", y)), f && W(google.maps.event.addListener(re, "mouseup", f)), v && I(google.maps.event.addListener(re, "rightclick", v)), b && j(google.maps.event.addListener(re, "click", b)), L && A(google.maps.event.addListener(re, "drag", L)), w && B(google.maps.event.addListener(re, "center_changed", w)), D && he(google.maps.event.addListener(re, "radius_changed", D)), U(re), x && x(re), () => {
      k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), m && m(re), re.setMap(null);
    };
  }, []), null;
}
me(iHe);
class sHe extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      circle: null
    }), Ae(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(zw(zw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: l9,
      eventMap: a9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: l9,
      eventMap: a9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Rn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Ae(sHe, "contextType", Vt);
function u9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? u9(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : u9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var c9 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, p9 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function aHe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(Vt), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var A = new google.maps.Data(Uw(Uw({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && k(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && $(google.maps.event.addListener(A, "mouseover", s)), l && X(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && q(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), j !== null && google.maps.event.removeListener(j), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(aHe);
class lHe extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      data: null
    }), Ae(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Uw(Uw({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Pn({
        updaterMap: p9,
        eventMap: c9,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: p9,
      eventMap: c9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Rn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(lHe, "contextType", Vt);
function d9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function f9(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? d9(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : d9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var h9 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, g9 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class uHe extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      kmlLayer: null
    }), Ae(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(f9(f9({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: g9,
      eventMap: h9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: g9,
      eventMap: h9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Rn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(uHe, "contextType", Vt);
function Vae(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function cHe(e, t) {
  return new t(e.lat, e.lng);
}
function pHe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function dHe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function fHe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function hHe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function gHe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function $ae(e, t, n, r) {
  return n !== void 0 ? hHe(e, t, fHe(n, google.maps.LatLngBounds, pHe)) : gHe(e, t, dHe(r, google.maps.LatLng, cHe));
}
function mHe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function m9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vHe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? m9(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : m9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function yHe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = vHe({}, this.container ? Vae(this.container, o) : {
        x: 0,
        y: 0
      }), u = $ae(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function v9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bHe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? v9(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : v9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function y9(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function b9(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function wHe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Vt), c = zt(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = zt(() => yHe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
me(wHe);
class Wd extends pe {
  constructor(t) {
    super(t), Ae(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Ae(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      di(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Ae(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Ae(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = bHe({
        x: 0,
        y: 0
      }, this.containerRef.current ? Vae(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = $ae(r, o, this.props.bounds, this.props.position);
      if (!mHe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Ae(this, "draw", () => {
      this.onPositionElement();
    }), Ae(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = jn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = y9(t.position), r = y9(this.props.position), o = b9(t.bounds), i = b9(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(bs.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
Ae(Wd, "FLOAT_PANE", "floatPane");
Ae(Wd, "MAP_PANE", "mapPane");
Ae(Wd, "MARKER_LAYER", "markerLayer");
Ae(Wd, "OVERLAY_LAYER", "overlayLayer");
Ae(Wd, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Ae(Wd, "contextType", Vt);
function OHe() {
}
function w9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function O9(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? w9(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : w9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var C9 = {
  onDblClick: "dblclick",
  onClick: "click"
}, x9 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function CHe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Vt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = zt(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(CHe);
class Zae extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      groundOverlay: null
    }), Ae(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    di(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, O9(O9({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: x9,
      eventMap: C9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: x9,
      eventMap: C9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(Zae, "defaultProps", {
  onLoad: OHe
});
Ae(Zae, "contextType", Vt);
function L9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ww(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? L9(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : L9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var E9 = {}, k9 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function xHe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Vt), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || di(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    di(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(Ww(Ww({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(xHe);
class LHe extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      heatmapLayer: null
    }), Ae(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    di(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), di(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Ww(Ww({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: k9,
      eventMap: E9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: k9,
      eventMap: E9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Rn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(LHe, "contextType", Vt);
var P9 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, S9 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class EHe extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      streetViewPanorama: null
    }), Ae(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Pn({
      updaterMap: S9,
      eventMap: P9,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: S9,
      eventMap: P9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Rn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Ae(EHe, "contextType", Vt);
class kHe extends pe {
  constructor() {
    super(...arguments), Ae(this, "state", {
      streetViewService: null
    }), Ae(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Ae(kHe, "contextType", Vt);
var M9 = {
  onDirectionsChanged: "directions_changed"
}, D9 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class PHe extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      directionsRenderer: null
    }), Ae(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Pn({
      updaterMap: D9,
      eventMap: M9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: D9,
      eventMap: M9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Rn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(PHe, "contextType", Vt);
var _9 = {
  onPlacesChanged: "places_changed"
}, T9 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class SHe extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "containerElement", jn()), Ae(this, "state", {
      searchBox: null
    }), Ae(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (di(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Pn({
          updaterMap: T9,
          eventMap: _9,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: T9,
      eventMap: _9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Rn(this.registeredEvents));
  }
  render() {
    return bs.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
Ae(SHe, "contextType", Vt);
var j9 = {
  onPlaceChanged: "place_changed"
}, A9 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class qae extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "containerElement", jn()), Ae(this, "state", {
      autocomplete: null
    }), Ae(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    di(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Pn({
        updaterMap: A9,
        eventMap: j9,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Rn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: A9,
      eventMap: j9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Rn(this.registeredEvents);
  }
  render() {
    return bs.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
Ae(qae, "defaultProps", {
  className: ""
});
Ae(qae, "contextType", Vt);
let MHe = { data: "" }, DHe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || MHe, _He = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, THe = /\/\*[^]*?\*\/|  +/g, I9 = /\n+/g, Zu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Zu(a, i) : i + "{" + Zu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Zu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Zu.p ? Zu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, xl = {}, Xae = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Xae(e[n]);
    return t;
  }
  return e;
}, jHe = (e, t, n, r, o) => {
  let i = Xae(e), a = xl[i] || (xl[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!xl[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = _He.exec(u.replace(THe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(I9, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(I9, " ").trim();
      return d[0];
    })(e);
    xl[a] = Zu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && xl.g ? xl.g : null;
  return n && (xl.g = xl[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(xl[a], t, r, s), a;
}, AHe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Zu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Dx(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return jHe(n.unshift ? n.raw ? AHe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, DHe(t.target), t.g, t.o, t.k);
}
let Kae, e_, t_;
Dx.bind({ g: 1 });
let Wl = Dx.bind({ k: 1 });
function IHe(e, t, n, r) {
  Zu.p = t, Kae = e, e_ = n, t_ = r;
}
function xc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: e_ && e_() }, s), n.o = / *go\d+/.test(l), s.className = Dx.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), t_ && u[0] && t_(s), Kae(u, s);
    }
    return o;
  };
}
var BHe = (e) => typeof e == "function", NHe = (e, t) => BHe(e) ? e(t) : e, RHe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), FHe = Wl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, zHe = Wl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, UHe = Wl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, WHe = xc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${FHe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${zHe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${UHe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, HHe = Wl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, VHe = xc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${HHe} 1s linear infinite;
`, $He = Wl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, ZHe = Wl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, qHe = xc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${$He} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${ZHe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, XHe = xc("div")`
  position: absolute;
`, KHe = xc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, GHe = Wl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, YHe = xc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${GHe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, JHe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? _e.createElement(YHe, null, t) : t : n === "blank" ? null : _e.createElement(KHe, null, _e.createElement(VHe, { ...r }), n !== "loading" && _e.createElement(XHe, null, n === "error" ? _e.createElement(WHe, { ...r }) : _e.createElement(qHe, { ...r })));
}, QHe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, eVe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, tVe = "0%{opacity:0;} 100%{opacity:1;}", nVe = "0%{opacity:1;} 100%{opacity:0;}", rVe = xc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, oVe = xc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, iVe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = RHe() ? [tVe, nVe] : [QHe(n), eVe(n)];
  return { animation: t ? `${Wl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Wl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
_e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? iVe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = _e.createElement(JHe, { toast: e }), a = _e.createElement(oVe, { ...e.ariaProps }, NHe(e.message, e));
  return _e.createElement(rVe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : _e.createElement(_e.Fragment, null, i, a));
});
IHe(_e.createElement);
Dx`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
He({});
function sVe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const aVe = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
sVe(aVe.CNPJ).length;
ka((e, t) => /* @__PURE__ */ ys.jsx("input", { ref: t, ...e }));
He({});
var Ql = {};
Object.defineProperty(Ql, "__esModule", {
  value: !0
});
var lVe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Ek = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Gae = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: lVe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, jI = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var zy = 1; zy < 20; zy++)
  jI["f" + zy] = 111 + zy;
function _x(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Yae(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Jae(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function uVe(e, t) {
  return _x(e, t);
}
function cVe(e, t) {
  return _x(e, { byKey: !0 }, t);
}
function Yae(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in Ek)
    r[Ek[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = AI(d), v = Ek[f];
      if (d.length > 1 && !v && !Gae[d] && !jI[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = Qae(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Jae(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Qae(e) {
  e = AI(e);
  var t = jI[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function AI(e) {
  return e = e.toLowerCase(), e = Gae[e] || e, e;
}
Ql.default = _x;
var kk = Ql.isHotkey = _x;
Ql.isCodeHotkey = uVe;
Ql.isKeyHotkey = cVe;
Ql.parseHotkey = Yae;
Ql.compareHotkey = Jae;
Ql.toKeyCode = Qae;
Ql.toKeyName = AI;
var pVe = typeof Tr == "object" && Tr && Tr.Object === Object && Tr, dVe = pVe, fVe = dVe, hVe = typeof self == "object" && self && self.Object === Object && self, gVe = fVe || hVe || Function("return this")(), mVe = gVe, vVe = mVe, yVe = vVe.Symbol, ele = yVe, B9 = ele;
B9 && B9.toStringTag;
var N9 = ele;
N9 && N9.toStringTag;
var R9;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(R9 || (R9 = {}));
var II = function(e) {
  return Object.freeze(e);
}, bVe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, II(this);
  }
  return e;
}(), wVe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, II(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), F9 = typeof window < "u" ? window : {};
/msie|trident/i.test(F9.navigator && F9.navigator.userAgent);
var Pk = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new bVe((n ? t : e) || 0, (n ? e : t) || 0);
};
II({
  devicePixelContentBoxSize: Pk(),
  borderBoxSize: Pk(),
  contentBoxSize: Pk(),
  contentRect: new wVe(0, 0, 0, 0)
});
function zg(e) {
  "@babel/helpers - typeof";
  return zg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zg(e);
}
function OVe(e, t) {
  if (zg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (zg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function CVe(e) {
  var t = OVe(e, "string");
  return zg(t) === "symbol" ? t : String(t);
}
function Rh(e, t, n) {
  return t = CVe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var xVe = /* @__PURE__ */ He(null), Sk, Mk;
parseInt(Oe.version.split(".")[0], 10);
var z9 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Dk = typeof navigator < "u" && /Android/.test(navigator.userAgent), Uy = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), LVe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Sk = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Sk !== void 0 && Sk[1] && parseInt((Mk = navigator.userAgent.match(/Version\/(\d+)/)) === null || Mk === void 0 ? void 0 : Mk[1], 10) < 17;
var EVe = /* @__PURE__ */ new WeakMap(), kVe = /* @__PURE__ */ new WeakMap(), PVe = /* @__PURE__ */ new WeakMap(), SVe = /* @__PURE__ */ new WeakMap(), MVe = /* @__PURE__ */ new WeakMap(), U9 = /* @__PURE__ */ new WeakMap(), DVe = /* @__PURE__ */ new WeakMap(), W9 = /* @__PURE__ */ new WeakMap(), Wy = /* @__PURE__ */ new WeakMap(), _Ve = /* @__PURE__ */ new WeakMap(), TVe = /* @__PURE__ */ new WeakMap(), jVe = /* @__PURE__ */ new WeakMap(), tle = globalThis.Node, AVe = globalThis.Text, nle = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, IVe = (e) => Hw(e) && e.nodeType === 8, Ga = (e) => Hw(e) && e.nodeType === 1, Hw = (e) => {
  var t = nle(e);
  return !!t && e instanceof t.Node;
}, H9 = (e) => {
  var t = e && e.anchorNode && nle(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, BVe = (e) => {
  var [t, n] = e;
  if (Ga(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = rle(t, o, r ? "backward" : "forward"), r = o < n; Ga(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = RVe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, NVe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, rle = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (IVe(o) || Ga(o) && o.childNodes.length === 0 || Ga(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, RVe = (e, t, n) => {
  var [r] = rle(e, t, n);
  return r;
}, V9 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), ole = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ga(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = wn.getWindow(e);
  if (o.contains(r))
    return wn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : ole(e, i, n);
}, $9 = (e, t) => !!(e.compareDocumentPosition(t) & tle.DOCUMENT_POSITION_PRECEDING), FVe = (e, t) => !!(e.compareDocumentPosition(t) & tle.DOCUMENT_POSITION_FOLLOWING), zVe = 0;
class UVe {
  constructor() {
    Rh(this, "id", void 0), this.id = "".concat(zVe++);
  }
}
var wn = {
  androidPendingDiffs: (e) => jVe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = TVe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = wn.toDOMNode(e, e), n = wn.findDocumentOrShadowRoot(e);
    Wy.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = wn.findDocumentOrShadowRoot(e), r = V9(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && q0.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = wn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = wn.toSlateNode(e, t.target), a = wn.findPath(e, i);
    if (Al.isElement(i) && xr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = xr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? xr.before(e, u) : xr.after(e, u);
      if (c) {
        var p = xr.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = wn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = wn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = U9.get(t);
    return n || (n = new UVe(), U9.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = kVe.get(r);
      if (o == null) {
        if (xr.isEditor(r))
          return n;
        break;
      }
      var i = EVe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Bs.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Wy.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          wn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = wn.toDOMNode(e, e), r = wn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = V9(r), i = wn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || q0.select(e, xr.start(e, [])), Wy.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = PVe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = wn.toDOMNode(e, e), i;
    try {
      i = Ga(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Hw(t) && wn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return xr.hasPath(e, n.path) && xr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => wn.hasEditableTarget(e, t) || wn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Hw(t) && wn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!_Ve.get(e),
  isFocused: (e) => !!Wy.get(e),
  isReadOnly: (e) => !!W9.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (W9.get(e)) return !1;
    var n = wn.hasTarget(e, t) && wn.toSlateNode(e, t);
    return Al.isElement(n) && xr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = DVe.get(e), r = xr.isEditor(t) ? SVe.get(e) : n == null ? void 0 : n.get(wn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Bs.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = xr.node(e, t.path), r = wn.toDOMNode(e, n), o;
    xr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof AVe ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Bs.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = tn.isBackward(t), i = wn.toDOMPoint(e, n), a = tn.isCollapsed(t) ? i : wn.toDOMPoint(e, r), s = wn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = Ga(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = Ga(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ga(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? MVe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : BVe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = wn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = wn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (Dk && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var R = U[k];
          if (wn.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var N = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, H = [...N(V), ...N(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = H.find((M) => FVe(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var X, G = [...N(V == null ? void 0 : V.previousElementSibling), ...N(V)];
          w = (X = G.findLast((M) => $9(L, M))) !== null && X !== void 0 ? X : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Dk && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Uy && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Dk && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && wn.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = wn.toSlateNode(e, Y), {
          path: J,
          offset: P
        } = xr.start(e, wn.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = wn.toSlateNode(e, u), z = wn.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = H9(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (H9(t)) {
        if (Uy && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        LVe && NVe(s) || Uy ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Uy && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = wn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = $9(s, u) || s === u && c < l, x = p ? w : wn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return tn.isExpanded(m) && tn.isForward(m) && Ga(u) && xr.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = xr.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, WVe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, HVe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, VVe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, mo = (e) => {
  var t = WVe[e], n = HVe[e], r = VVe[e], o = t && kk(t), i = n && kk(n), a = r && kk(r);
  return (s) => !!(o && o(s) || z9 && i && i(s) || !z9 && a && a(s));
};
mo("bold"), mo("compose"), mo("moveBackward"), mo("moveForward"), mo("deleteBackward"), mo("deleteForward"), mo("deleteLineBackward"), mo("deleteLineForward"), mo("deleteWordBackward"), mo("deleteWordForward"), mo("extendBackward"), mo("extendForward"), mo("extendLineBackward"), mo("extendLineForward"), mo("italic"), mo("moveLineBackward"), mo("moveLineForward"), mo("moveWordBackward"), mo("moveWordForward"), mo("redo"), mo("insertSoftBreak"), mo("splitBlock"), mo("transposeCharacter"), mo("undo");
var $Ve = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => ole(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, ZVe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class qVe extends Kl {
  constructor() {
    super(...arguments), Rh(this, "context", null), Rh(this, "manager", null), Rh(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, ZVe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = $Ve(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Rh(qVe, "contextType", xVe);
He({});
He({});
He({});
var oi = {}, BI = {}, Cm = {}, xm = {}, ile = "Expected a function", Z9 = NaN, XVe = "[object Symbol]", KVe = /^\s+|\s+$/g, GVe = /^[-+]0x[0-9a-f]+$/i, YVe = /^0b[01]+$/i, JVe = /^0o[0-7]+$/i, QVe = parseInt, e$e = typeof Tr == "object" && Tr && Tr.Object === Object && Tr, t$e = typeof self == "object" && self && self.Object === Object && self, n$e = e$e || t$e || Function("return this")(), r$e = Object.prototype, o$e = r$e.toString, i$e = Math.max, s$e = Math.min, _k = function() {
  return n$e.Date.now();
};
function a$e(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(ile);
  t = q9(t) || 0, Vw(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? i$e(q9(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? s$e(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = _k();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(_k());
  }
  function m() {
    var C = _k(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function l$e(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(ile);
  return Vw(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), a$e(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Vw(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function u$e(e) {
  return !!e && typeof e == "object";
}
function c$e(e) {
  return typeof e == "symbol" || u$e(e) && o$e.call(e) == XVe;
}
function q9(e) {
  if (typeof e == "number")
    return e;
  if (c$e(e))
    return Z9;
  if (Vw(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Vw(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(KVe, "");
  var n = YVe.test(e);
  return n || JVe.test(e) ? QVe(e.slice(2), n ? 2 : 8) : GVe.test(e) ? Z9 : +e;
}
var p$e = l$e, Lm = {};
Object.defineProperty(Lm, "__esModule", {
  value: !0
});
Lm.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), o0.has(t) || o0.set(t, /* @__PURE__ */ new Set());
  var o = o0.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Lm.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), o0.get(t).delete(n.name || t);
};
var o0 = /* @__PURE__ */ new Map();
Object.defineProperty(xm, "__esModule", {
  value: !0
});
var d$e = p$e, f$e = g$e(d$e), h$e = Lm;
function g$e(e) {
  return e && e.__esModule ? e : { default: e };
}
var m$e = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, f$e.default)(e, t);
}, To = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = m$e(function(r) {
        To.scrollHandler(e);
      }, t);
      To.scrollSpyContainers.push(e), (0, h$e.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return To.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = To.scrollSpyContainers[To.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(To.currentPositionX(e), To.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    To.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = To.scrollSpyContainers[To.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(To.currentPositionX(t), To.currentPositionY(t));
  },
  updateStates: function() {
    To.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    To.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), To.spySetState && To.spySetState.length && To.spySetState.indexOf(e) > -1 && To.spySetState.splice(To.spySetState.indexOf(e), 1), document.removeEventListener("scroll", To.scrollHandler);
  },
  update: function() {
    return To.scrollSpyContainers.forEach(function(e) {
      return To.scrollHandler(e);
    });
  }
};
xm.default = To;
var Hd = {}, Em = {};
Object.defineProperty(Em, "__esModule", {
  value: !0
});
var v$e = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, y$e = function() {
  return window.location.hash.replace(/^#/, "");
}, b$e = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, w$e = function(e) {
  return getComputedStyle(e).position !== "static";
}, Tk = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, O$e = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (w$e(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Tk(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return Tk(t, s).offsetTop - Tk(e, s).offsetTop;
};
Em.default = {
  updateHash: v$e,
  getHash: y$e,
  filterElementInContainer: b$e,
  scrollOffset: O$e
};
var Tx = {}, NI = {};
Object.defineProperty(NI, "__esModule", {
  value: !0
});
NI.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var RI = {};
Object.defineProperty(RI, "__esModule", {
  value: !0
});
var C$e = Lm, x$e = ["mousedown", "mousewheel", "touchmove", "keydown"];
RI.default = {
  subscribe: function(e) {
    return typeof document < "u" && x$e.forEach(function(t) {
      return (0, C$e.addPassiveEventListener)(document, t, e);
    });
  }
};
var km = {};
Object.defineProperty(km, "__esModule", {
  value: !0
});
var n_ = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      n_.registered[e] = t;
    },
    remove: function(e) {
      n_.registered[e] = null;
    }
  }
};
km.default = n_;
Object.defineProperty(Tx, "__esModule", {
  value: !0
});
var L$e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, E$e = Em;
jx(E$e);
var k$e = NI, X9 = jx(k$e), P$e = RI, S$e = jx(P$e), M$e = km, Ua = jx(M$e);
function jx(e) {
  return e && e.__esModule ? e : { default: e };
}
var sle = function(e) {
  return X9.default[e.smooth] || X9.default.defaultEasing;
}, D$e = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, _$e = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, r_ = function() {
  return _$e() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), ale = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, lle = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, ule = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, T$e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, j$e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, A$e = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Ua.default.registered.end && Ua.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    r_.call(window, i);
    return;
  }
  Ua.default.registered.end && Ua.default.registered.end(o.to, o.target, o.currentPosition);
}, FI = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Pm = function(e, t, n, r) {
  t.data = t.data || ale(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (S$e.default.subscribe(o), FI(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? lle(t) : ule(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Ua.default.registered.end && Ua.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = D$e(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = sle(t), a = A$e.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Ua.default.registered.begin && Ua.default.registered.begin(t.data.to, t.data.target), r_.call(window, a);
    }, t.delay);
    return;
  }
  Ua.default.registered.begin && Ua.default.registered.begin(t.data.to, t.data.target), r_.call(window, a);
}, Ax = function(e) {
  return e = L$e({}, e), e.data = e.data || ale(), e.absolute = !0, e;
}, I$e = function(e) {
  Pm(0, Ax(e));
}, B$e = function(e, t) {
  Pm(e, Ax(t));
}, N$e = function(e) {
  e = Ax(e), FI(e), Pm(e.horizontal ? T$e(e) : j$e(e), e);
}, R$e = function(e, t) {
  t = Ax(t), FI(t);
  var n = t.horizontal ? lle(t) : ule(t);
  Pm(e + n, t);
};
Tx.default = {
  animateTopScroll: Pm,
  getAnimationType: sle,
  scrollToTop: I$e,
  scrollToBottom: N$e,
  scrollTo: B$e,
  scrollMore: R$e
};
Object.defineProperty(Hd, "__esModule", {
  value: !0
});
var F$e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, z$e = Em, U$e = zI(z$e), W$e = Tx, H$e = zI(W$e), V$e = km, Hy = zI(V$e);
function zI(e) {
  return e && e.__esModule ? e : { default: e };
}
var Vy = {}, K9 = void 0;
Hd.default = {
  unmount: function() {
    Vy = {};
  },
  register: function(e, t) {
    Vy[e] = t;
  },
  unregister: function(e) {
    delete Vy[e];
  },
  get: function(e) {
    return Vy[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return K9 = e;
  },
  getActiveLink: function() {
    return K9;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = F$e({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = U$e.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Hy.default.registered.begin && Hy.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Hy.default.registered.end && Hy.default.registered.end(e, n);
      return;
    }
    H$e.default.animateTopScroll(s, t, e, n);
  }
};
var o_ = { exports: {} }, jk = { exports: {} }, nr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var G9;
function $$e() {
  if (G9) return nr;
  G9 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return nr.AsyncMode = l, nr.ConcurrentMode = u, nr.ContextConsumer = s, nr.ContextProvider = a, nr.Element = t, nr.ForwardRef = c, nr.Fragment = r, nr.Lazy = f, nr.Memo = y, nr.Portal = n, nr.Profiler = i, nr.StrictMode = o, nr.Suspense = p, nr.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, nr.isConcurrentMode = x, nr.isContextConsumer = function(m) {
    return D(m) === s;
  }, nr.isContextProvider = function(m) {
    return D(m) === a;
  }, nr.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, nr.isForwardRef = function(m) {
    return D(m) === c;
  }, nr.isFragment = function(m) {
    return D(m) === r;
  }, nr.isLazy = function(m) {
    return D(m) === f;
  }, nr.isMemo = function(m) {
    return D(m) === y;
  }, nr.isPortal = function(m) {
    return D(m) === n;
  }, nr.isProfiler = function(m) {
    return D(m) === i;
  }, nr.isStrictMode = function(m) {
    return D(m) === o;
  }, nr.isSuspense = function(m) {
    return D(m) === p;
  }, nr.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, nr.typeOf = D, nr;
}
var fr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Y9;
function Z$e() {
  return Y9 || (Y9 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === y || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === L || B.$$typeof === w || B.$$typeof === v);
    }
    function x(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var re = he && he.$$typeof;
                switch (re) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return re;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, R = c, N = r, V = f, $ = y, H = n, X = i, G = o, Y = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || x(B) === l;
    }
    function P(B) {
      return x(B) === u;
    }
    function _(B) {
      return x(B) === s;
    }
    function z(B) {
      return x(B) === a;
    }
    function M(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return x(B) === c;
    }
    function O(B) {
      return x(B) === r;
    }
    function I(B) {
      return x(B) === f;
    }
    function F(B) {
      return x(B) === y;
    }
    function j(B) {
      return x(B) === n;
    }
    function q(B) {
      return x(B) === i;
    }
    function A(B) {
      return x(B) === o;
    }
    function K(B) {
      return x(B) === p;
    }
    fr.AsyncMode = m, fr.ConcurrentMode = C, fr.ContextConsumer = S, fr.ContextProvider = U, fr.Element = k, fr.ForwardRef = R, fr.Fragment = N, fr.Lazy = V, fr.Memo = $, fr.Portal = H, fr.Profiler = X, fr.StrictMode = G, fr.Suspense = Y, fr.isAsyncMode = J, fr.isConcurrentMode = P, fr.isContextConsumer = _, fr.isContextProvider = z, fr.isElement = M, fr.isForwardRef = W, fr.isFragment = O, fr.isLazy = I, fr.isMemo = F, fr.isPortal = j, fr.isProfiler = q, fr.isStrictMode = A, fr.isSuspense = K, fr.isValidElementType = D, fr.typeOf = x;
  }()), fr;
}
var J9;
function cle() {
  return J9 || (J9 = 1, process.env.NODE_ENV === "production" ? jk.exports = $$e() : jk.exports = Z$e()), jk.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Ak, Q9;
function q$e() {
  if (Q9) return Ak;
  Q9 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Ak = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, Ak;
}
var Ik, e8;
function UI() {
  if (e8) return Ik;
  e8 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Ik = e, Ik;
}
var t8, n8;
function ple() {
  return n8 || (n8 = 1, t8 = Function.call.bind(Object.prototype.hasOwnProperty)), t8;
}
var Bk, r8;
function X$e() {
  if (r8) return Bk;
  r8 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = UI(), n = {}, r = ple();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Bk = o, Bk;
}
var Nk, o8;
function K$e() {
  if (o8) return Nk;
  o8 = 1;
  var e = cle(), t = q$e(), n = UI(), r = ple(), o = X$e(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Nk = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, I, F, j, q, A, K) {
        if (j = j || d, A = A || F, K !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = j + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return I[F] == null ? O ? I[F] === null ? new v("The " + q + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new v("The " + q + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : P(I, F, j, q, A);
      }
      var W = M.bind(null, !1);
      return W.isRequired = M.bind(null, !0), W;
    }
    function L(P) {
      function _(z, M, W, O, I, F) {
        var j = z[M], q = G(j);
        if (q !== P) {
          var A = Y(j);
          return new v(
            "Invalid " + O + " `" + I + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var j = G(F);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var A = P(F, q, W, O, I + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!s(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!e.isValidElementType(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, W, O, I) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, j = J(z[M]);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, W, O, I) {
        for (var F = z[M], j = 0; j < P.length; j++)
          if (f(F, P[j]))
            return null;
        var q = JSON.stringify(P, function(A, K) {
          var B = Y(K);
          return B === "symbol" ? String(K) : K;
        });
        return new v("Invalid " + O + " `" + I + "` of value `" + String(F) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var A = P(F, q, W, O, I + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(W, O, I, F, j) {
        for (var q = [], A = 0; A < P.length; A++) {
          var K = P[A], B = K(W, O, I, F, j, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + j + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(M);
    }
    function R() {
      function P(_, z, M, W, O) {
        return H(_[z]) ? null : new v("Invalid " + W + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function N(P, _, z, M, W) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return N(W, O, I, q, Y(A));
          var K = A(F, q, W, O, I + "." + q, n);
          if (K)
            return K;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var A in q) {
          var K = P[A];
          if (r(P, A) && typeof K != "function")
            return N(W, O, I, A, Y(K));
          if (!K)
            return new v(
              "Invalid " + O + " `" + I + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = K(F, A, W, O, I + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!H(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var W = M.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function X(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function G(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : X(_, P) ? "symbol" : _;
    }
    function Y(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = G(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = Y(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, Nk;
}
var Rk, i8;
function G$e() {
  if (i8) return Rk;
  i8 = 1;
  var e = UI();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Rk = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Rk;
}
if (process.env.NODE_ENV !== "production") {
  var Y$e = cle(), J$e = !0;
  o_.exports = K$e()(Y$e.isElement, J$e);
} else
  o_.exports = G$e()();
var Ix = o_.exports, Bx = {};
Object.defineProperty(Bx, "__esModule", {
  value: !0
});
var Q$e = Em, Fk = e3e(Q$e);
function e3e(e) {
  return e && e.__esModule ? e : { default: e };
}
var t3e = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Fk.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Fk.default.getHash() !== e && Fk.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Bx.default = t3e;
Object.defineProperty(Cm, "__esModule", {
  value: !0
});
var $y = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, n3e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), r3e = Oe, s8 = Sm(r3e), o3e = xm, Zy = Sm(o3e), i3e = Hd, s3e = Sm(i3e), a3e = Ix, vo = Sm(a3e), l3e = Bx, pu = Sm(l3e);
function Sm(e) {
  return e && e.__esModule ? e : { default: e };
}
function u3e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function c3e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function p3e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var a8 = {
  to: vo.default.string.isRequired,
  containerId: vo.default.string,
  container: vo.default.object,
  activeClass: vo.default.string,
  activeStyle: vo.default.object,
  spy: vo.default.bool,
  horizontal: vo.default.bool,
  smooth: vo.default.oneOfType([vo.default.bool, vo.default.string]),
  offset: vo.default.number,
  delay: vo.default.number,
  isDynamic: vo.default.bool,
  onClick: vo.default.func,
  duration: vo.default.oneOfType([vo.default.number, vo.default.func]),
  absolute: vo.default.bool,
  onSetActive: vo.default.func,
  onSetInactive: vo.default.func,
  ignoreCancelEvents: vo.default.bool,
  hashSpy: vo.default.bool,
  saveHashHistory: vo.default.bool,
  spyThrottle: vo.default.number
};
Cm.default = function(e, t) {
  var n = t || s3e.default, r = function(i) {
    p3e(a, i);
    function a(s) {
      u3e(this, a);
      var l = c3e(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return n3e(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          Zy.default.isMounted(s) || Zy.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (pu.default.isMounted() || pu.default.mount(n), pu.default.mapContainer(this.props.to, s)), Zy.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Zy.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = $y({}, this.props.style, this.props.activeStyle) : l = $y({}, this.props.style);
        var u = $y({}, this.props);
        for (var c in a8)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, s8.default.createElement(e, u);
      }
    }]), a;
  }(s8.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, $y({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(pu.default.isMounted() && !pu.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var R = n.getActiveLink();
        if (y) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && pu.default.getHash() === c) {
            var N = i.props.saveHashHistory, V = N === void 0 ? !1 : N;
            pu.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, H = $ === void 0 ? !1 : $;
          i.props.hashSpy && pu.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = a8, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(BI, "__esModule", {
  value: !0
});
var d3e = Oe, l8 = dle(d3e), f3e = Cm, h3e = dle(f3e);
function dle(e) {
  return e && e.__esModule ? e : { default: e };
}
function g3e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function u8(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function m3e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var v3e = function(e) {
  m3e(t, e);
  function t() {
    var n, r, o, i;
    g3e(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = u8(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return l8.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), u8(o, i);
  }
  return t;
}(l8.default.Component);
BI.default = (0, h3e.default)(v3e);
var WI = {};
Object.defineProperty(WI, "__esModule", {
  value: !0
});
var y3e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), b3e = Oe, c8 = fle(b3e), w3e = Cm, O3e = fle(w3e);
function fle(e) {
  return e && e.__esModule ? e : { default: e };
}
function C3e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function x3e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function L3e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var E3e = function(e) {
  L3e(t, e);
  function t() {
    return C3e(this, t), x3e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return y3e(t, [{
    key: "render",
    value: function() {
      return c8.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(c8.default.Component);
WI.default = (0, O3e.default)(E3e);
var HI = {}, Nx = {};
Object.defineProperty(Nx, "__esModule", {
  value: !0
});
var k3e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, P3e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), S3e = Oe, p8 = Rx(S3e), M3e = nl;
Rx(M3e);
var D3e = Hd, d8 = Rx(D3e), _3e = Ix, f8 = Rx(_3e);
function Rx(e) {
  return e && e.__esModule ? e : { default: e };
}
function T3e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function j3e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function A3e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Nx.default = function(e) {
  var t = function(n) {
    A3e(r, n);
    function r(o) {
      T3e(this, r);
      var i = j3e(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return P3e(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        d8.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        d8.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return p8.default.createElement(e, k3e({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(p8.default.Component);
  return t.propTypes = {
    name: f8.default.string,
    id: f8.default.string
  }, t;
};
Object.defineProperty(HI, "__esModule", {
  value: !0
});
var h8 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, I3e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), B3e = Oe, g8 = VI(B3e), N3e = Nx, R3e = VI(N3e), F3e = Ix, m8 = VI(F3e);
function VI(e) {
  return e && e.__esModule ? e : { default: e };
}
function z3e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function U3e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function W3e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var hle = function(e) {
  W3e(t, e);
  function t() {
    return z3e(this, t), U3e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return I3e(t, [{
    key: "render",
    value: function() {
      var n = this, r = h8({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, g8.default.createElement(
        "div",
        h8({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(g8.default.Component);
hle.propTypes = {
  name: m8.default.string,
  id: m8.default.string
};
HI.default = (0, R3e.default)(hle);
var zk = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, v8 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function y8(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function b8(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function w8(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var qy = Oe, Nc = xm, Uk = Hd, Uo = Ix, du = Bx, O8 = {
  to: Uo.string.isRequired,
  containerId: Uo.string,
  container: Uo.object,
  activeClass: Uo.string,
  spy: Uo.bool,
  smooth: Uo.oneOfType([Uo.bool, Uo.string]),
  offset: Uo.number,
  delay: Uo.number,
  isDynamic: Uo.bool,
  onClick: Uo.func,
  duration: Uo.oneOfType([Uo.number, Uo.func]),
  absolute: Uo.bool,
  onSetActive: Uo.func,
  onSetInactive: Uo.func,
  ignoreCancelEvents: Uo.bool,
  hashSpy: Uo.bool,
  spyThrottle: Uo.number
}, H3e = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Uk, r = function(i) {
      w8(a, i);
      function a(s) {
        y8(this, a);
        var l = b8(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return v8(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Nc.isMounted(s) || Nc.mount(s, this.props.spyThrottle), this.props.hashSpy && (du.isMounted() || du.mount(n), du.mapContainer(this.props.to, s)), this.props.spy && Nc.addStateHandler(this.stateHandler), Nc.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Nc.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = zk({}, this.props);
          for (var u in O8)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, qy.createElement(e, l);
        }
      }]), a;
    }(qy.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, zk({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(du.isMounted() && !du.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && du.getHash() === l && du.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Nc.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && du.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Nc.updateStates();
        }
      };
    };
    return r.propTypes = O8, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      w8(r, n);
      function r(o) {
        y8(this, r);
        var i = b8(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return v8(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Uk.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Uk.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return qy.createElement(e, zk({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(qy.Component);
    return t.propTypes = {
      name: Uo.string,
      id: Uo.string
    }, t;
  }
}, V3e = H3e;
Object.defineProperty(oi, "__esModule", {
  value: !0
});
oi.Helpers = oi.ScrollElement = oi.ScrollLink = oi.animateScroll = oi.scrollSpy = oi.Events = oi.scroller = oi.Element = oi.Button = oi.Link = void 0;
var $3e = BI, gle = sl($3e), Z3e = WI, mle = sl(Z3e), q3e = HI, vle = sl(q3e), X3e = Hd, yle = sl(X3e), K3e = km, ble = sl(K3e), G3e = xm, wle = sl(G3e), Y3e = Tx, Ole = sl(Y3e), J3e = Cm, Cle = sl(J3e), Q3e = Nx, xle = sl(Q3e), e6e = V3e, Lle = sl(e6e);
function sl(e) {
  return e && e.__esModule ? e : { default: e };
}
oi.Link = gle.default;
oi.Button = mle.default;
oi.Element = vle.default;
oi.scroller = yle.default;
oi.Events = ble.default;
oi.scrollSpy = wle.default;
oi.animateScroll = Ole.default;
oi.ScrollLink = Cle.default;
oi.ScrollElement = xle.default;
oi.Helpers = Lle.default;
oi.default = { Link: gle.default, Button: mle.default, Element: vle.default, scroller: yle.default, Events: ble.default, scrollSpy: wle.default, animateScroll: Ole.default, ScrollLink: Cle.default, ScrollElement: xle.default, Helpers: Lle.default };
He({});
He({});
He({});
function Ug(e) {
  "@babel/helpers - typeof";
  return Ug = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ug(e);
}
function t6e(e, t) {
  if (Ug(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ug(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function n6e(e) {
  var t = t6e(e, "string");
  return Ug(t) == "symbol" ? t : t + "";
}
function Ie(e, t, n) {
  return (t = n6e(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Ele(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Wk, C8;
function r6e() {
  if (C8) return Wk;
  C8 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Wk = t, Wk;
}
var o6e = r6e(), fi = /* @__PURE__ */ Ele(o6e), $t = He(null);
function i6e() {
  fi(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge($t);
  return fi(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function s6e(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function a6e(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function l6e(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return a6e(e, i), o;
}
function u6e(e, t, n) {
  var r = s6e(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function c6e(e) {
  google.maps.event.removeListener(e);
}
function Fn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(c6e);
}
function Sn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = u6e(o, i, n);
  return l6e(t, r, o, i), a;
}
function p6e(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = vt(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null), [A, K] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), K(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var B = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(B), B !== null && D && D(B), () => {
      B !== null && x && x(B);
    };
  }, []), ys.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: ys.jsx($t.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(p6e);
function x8(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function kle(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        x8(i, r, o, a, s, "next", l);
      }
      function s(l) {
        x8(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Ple(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return fi(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var yp = typeof document < "u";
function Sle(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return yp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function L8(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Mle() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return L8(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return L8(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Df = !1;
function Dle() {
  return ys.jsx("div", {
    children: "Loading..."
  });
}
var i_ = {
  id: "script-loader",
  version: "weekly"
};
class d6e extends pe {
  constructor() {
    super(...arguments), Ie(this, "check", jn()), Ie(this, "state", {
      loaded: !1
    }), Ie(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Ie(this, "isCleaningUp", /* @__PURE__ */ kle(function* () {
      function t(n) {
        if (!Df)
          n();
        else if (yp)
          var r = window.setInterval(function() {
            Df || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Ie(this, "cleanup", () => {
      Df = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Ie(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Mle(), fi(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Ple(this.props)
      };
      Sle(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (yp) {
      if (window.google && window.google.maps && !Df) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), yp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (yp) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Df = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return ys.jsxs(ys.Fragment, {
      children: [ys.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || ys.jsx(Dle, {})]
    });
  }
}
Ie(d6e, "defaultProps", i_);
function f6e(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function $I(e, t) {
  if (e == null) return {};
  var n, r, o = f6e(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var E8;
function h6e(e) {
  var {
    id: t = i_.id,
    version: n = i_.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = vt(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    yp && u && Mle();
  }, [u]), h(function() {
    f && fi(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Ple({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!yp)
      return;
    function x() {
      y.current && (v(!0), E8 = w);
    }
    if (window.google && window.google.maps && E8 === w) {
      x();
      return;
    }
    Sle({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = vt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var g6e = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], m6e = ys.jsx(Dle, {});
function v6e(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = $I(e, g6e), {
    isLoaded: s,
    loadError: l
  } = h6e(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || m6e;
}
me(v6e);
var k8;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(k8 || (k8 = {}));
function P8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $w(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? P8(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : P8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var S8 = {}, M8 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function y6e(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge($t), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer($w($w({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(y6e);
class b6e extends pe {
  constructor() {
    super(...arguments), Ie(this, "state", {
      trafficLayer: null
    }), Ie(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Ie(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer($w($w({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: M8,
      eventMap: S8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: M8,
      eventMap: S8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Fn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(b6e, "contextType", $t);
function w6e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge($t), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(w6e);
class O6e extends pe {
  constructor() {
    super(...arguments), Ie(this, "state", {
      bicyclingLayer: null
    }), Ie(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(O6e, "contextType", $t);
function C6e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge($t), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(C6e);
class x6e extends pe {
  constructor() {
    super(...arguments), Ie(this, "state", {
      transitLayer: null
    }), Ie(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(x6e, "contextType", $t);
function D8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? D8(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : D8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _8 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, T8 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function L6e(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge($t), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    fi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(Zw(Zw({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && L(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && k(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(L6e);
class E6e extends pe {
  constructor(t) {
    super(t), Ie(this, "registeredEvents", []), Ie(this, "state", {
      drawingManager: null
    }), Ie(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), fi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Zw(Zw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: T8,
      eventMap: _8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: T8,
      eventMap: _8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Fn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(E6e, "contextType", $t);
function j8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ud(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? j8(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : j8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var A8 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, I8 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, qw = {};
function k6e(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: R,
    onClickableChanged: N,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: H,
    onFlatChanged: X,
    onIconChanged: G,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, W = ge($t), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null), [re, Se] = E(null), [We, Ze] = E(null), [Me, rt] = E(null), [Ve, be] = E(null), [qe, ct] = E(null), [ye, xe] = E(null), [Ee, Ue] = E(null), [De, st] = E(null), [ve, wt] = E(null), [at, lt] = E(null), [pt, Ot] = E(null), [dt, Ct] = E(null), [Xe, ht] = E(null), [ot, xt] = E(null), [ft, Pt] = E(null), [Lt, St] = E(null), [Et, Mt] = E(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (re !== null && google.maps.event.removeListener(re), Se(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), Ze(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Me !== null && google.maps.event.removeListener(Me), rt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && R && (Ve !== null && google.maps.event.removeListener(Ve), be(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && L && (qe !== null && google.maps.event.removeListener(qe), ct(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (ye !== null && google.maps.event.removeListener(ye), xe(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && N && (Ee !== null && google.maps.event.removeListener(Ee), Ue(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && V && (De !== null && google.maps.event.removeListener(De), st(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), wt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && X && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(O, "flat_changed", X)));
  }, [X]), h(() => {
    O && G && (dt !== null && google.maps.event.removeListener(dt), Ct(google.maps.event.addListener(O, "icon_changed", G)));
  }, [G]), h(() => {
    O && Y && (Xe !== null && google.maps.event.removeListener(Xe), ht(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (ot !== null && google.maps.event.removeListener(ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (ft !== null && google.maps.event.removeListener(ft), Pt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Lt !== null && google.maps.event.removeListener(Lt), St(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (Et !== null && google.maps.event.removeListener(Et), Mt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var gt = ud(ud(ud({}, n || qw), r ? qw : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(gt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof y < "u" && te.setOpacity(y), f && te.setShape(f), typeof v == "string" && te.setTitle(v), typeof b == "number" && te.setZIndex(b), w && j(google.maps.event.addListener(te, "dblclick", w)), x && A(google.maps.event.addListener(te, "dragend", x)), m && B(google.maps.event.addListener(te, "dragstart", m)), k && he(google.maps.event.addListener(te, "mousedown", k)), C && Se(google.maps.event.addListener(te, "mouseout", C)), S && Ze(google.maps.event.addListener(te, "mouseover", S)), U && rt(google.maps.event.addListener(te, "mouseup", U)), R && be(google.maps.event.addListener(te, "rightclick", R)), L && ct(google.maps.event.addListener(te, "click", L)), D && xe(google.maps.event.addListener(te, "drag", D)), N && Ue(google.maps.event.addListener(te, "clickable_changed", N)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), $ && wt(google.maps.event.addListener(te, "animation_changed", $)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), X && Ot(google.maps.event.addListener(te, "flat_changed", X)), G && Ct(google.maps.event.addListener(te, "icon_changed", G)), Y && ht(google.maps.event.addListener(te, "position_changed", Y)), Q && xt(google.maps.event.addListener(te, "shape_changed", Q)), J && Pt(google.maps.event.addListener(te, "title_changed", J)), P && St(google.maps.event.addListener(te, "visible_changed", P)), _ && Mt(google.maps.event.addListener(te, "zindex_changed", _)), I(te), z && z(te), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), re !== null && google.maps.event.removeListener(re), We !== null && google.maps.event.removeListener(We), Me !== null && google.maps.event.removeListener(Me), Ve !== null && google.maps.event.removeListener(Ve), qe !== null && google.maps.event.removeListener(qe), Ee !== null && google.maps.event.removeListener(Ee), De !== null && google.maps.event.removeListener(De), ve !== null && google.maps.event.removeListener(ve), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), Xe !== null && google.maps.event.removeListener(Xe), ft !== null && google.maps.event.removeListener(ft), Lt !== null && google.maps.event.removeListener(Lt), Et !== null && google.maps.event.removeListener(Et), M && M(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var _t = zt(() => i ? ut.map(i, (gt) => {
    if (!wi(gt))
      return gt;
    var te = gt;
    return Oi(te, {
      anchor: O
    });
  }) : null, [i, O]);
  return ys.jsx(ys.Fragment, {
    children: _t
  }) || null;
}
me(k6e);
class P6e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return kle(function* () {
      var n = ud(ud(ud({}, t.props.options || qw), t.props.clusterer ? qw : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Sn({
        updaterMap: I8,
        eventMap: A8,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: I8,
      eventMap: A8,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Fn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Oi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Ie(P6e, "contextType", $t);
var S6e = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), M6e = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new S6e(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function D6e(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var _6e = 2e3, T6e = 500, j6e = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", A6e = "png", I6e = [53, 56, 66, 78, 90], B6e = "cluster", _le = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || j6e, this.imageExtension = r.imageExtension || A6e, this.imageSizes = r.imageSizes || I6e, this.calculator = r.calculator || D6e, this.batchSize = r.batchSize || _6e, this.batchSizeIE = r.batchSizeIE || T6e, this.clusterClass = r.clusterClass || B6e, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new M6e(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function B8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function N6e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? B8(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : B8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var va = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, qn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, R6e = {};
function F6e(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, R] = E(null), N = ge($t), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, va.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, va.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, va.onClick, w)));
  }, [w]), h(() => {
    k && D && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(k, va.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (G !== null && google.maps.event.removeListener(G), X(google.maps.event.addListener(k, va.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && qn.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && qn.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && qn.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && qn.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && qn.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && qn.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && qn.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && qn.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && qn.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && qn.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && qn.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && qn.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && qn.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && qn.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && qn.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (N) {
      var z = N6e({}, n || R6e), M = new _le(N, [], z);
      return r && qn.averageCenter(M, r), o && qn.batchSizeIE(M, o), i && qn.calculator(M, i), a && qn.clusterClass(M, a), s && qn.enableRetinaIcons(M, s), l && qn.gridSize(M, l), u && qn.ignoreHidden(M, u), c && qn.imageExtension(M, c), p && qn.imagePath(M, p), d && qn.imageSizes(M, d), y && qn.maxZoom(M, y), f && qn.minimumClusterSize(M, f), v && qn.styles(M, v), b && qn.title(M, b), L && qn.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, va.onMouseOut, C)), m && _(google.maps.event.addListener(M, va.onMouseOver, m)), w && $(google.maps.event.addListener(M, va.onClick, w)), D && X(google.maps.event.addListener(M, va.onClusteringBegin, D)), x && Y(google.maps.event.addListener(M, va.onClusteringEnd, x)), R(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(F6e);
class z6e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      markerClusterer: null
    }), Ie(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new _le(this.context, [], this.props.options);
      this.registeredEvents = Sn({
        updaterMap: qn,
        eventMap: va,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: qn,
      eventMap: va,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Fn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Ie(z6e, "contextType", $t);
function N8(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Tle = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || N8(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, N8));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), U6e = ["position"], W6e = ["position"];
function R8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? R8(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : R8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var F8 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, z8 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, H6e = {};
function V6e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge($t), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var N = r || H6e, {
        position: V
      } = N, $ = $I(N, U6e), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var X = new Tle(Xw(Xw({}, $), H ? {
        position: H
      } : {}));
      R.current = document.createElement("div"), v(X), a && L(google.maps.event.addListener(X, "closeclick", a)), s && D(google.maps.event.addListener(X, "domready", s)), l && m(google.maps.event.addListener(X, "content_changed", l)), u && S(google.maps.event.addListener(X, "position_changed", u)), c && k(google.maps.event.addListener(X, "zindex_changed", c)), X.setContent(R.current), n ? X.open(y, n) : X.getPosition() ? X.open(y) : fi(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(X);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(V6e);
class $6e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "containerElement", null), Ie(this, "state", {
      infoBox: null
    }), Ie(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : fi(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Ie(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = $I(t, W6e), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Tle(Xw(Xw({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Sn({
      updaterMap: z8,
      eventMap: F8,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: z8,
      eventMap: F8,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Fn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
Ie($6e, "contextType", $t);
var U8, W8;
function Z6e() {
  return W8 || (W8 = 1, U8 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), U8;
}
var q6e = Z6e(), H8 = /* @__PURE__ */ Ele(q6e), V8 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Hk = 1, _f = 8;
let X6e = class jle {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Hk)
      throw new Error("Got v".concat(o, " data when expected v").concat(Hk, "."));
    var i = V8[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new jle(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = V8.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, _f, t), this.coords = new this.ArrayType(this.data, _f + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(_f + a + s + l), this.ids = new this.IndexArrayType(this.data, _f, t), this.coords = new this.ArrayType(this.data, _f + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Hk << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return s_(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          $8(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      $8(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
};
function s_(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Ale(e, t, a, r, o, i), s_(e, t, n, r, a - 1, 1 - i), s_(e, t, n, a + 1, o, 1 - i);
  }
}
function Ale(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Ale(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (Tf(e, t, r, n), t[2 * o + i] > y && Tf(e, t, r, o); f < v; ) {
      for (Tf(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? Tf(e, t, r, v) : (v++, Tf(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function Tf(e, t, n, r) {
  Vk(e, n, r), Vk(t, 2 * n, 2 * r), Vk(t, 2 * n + 1, 2 * r + 1);
}
function Vk(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function $8(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var K6e = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, Z8 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Rc = 2, Bu = 3, $k = 4, Pu = 5, Ile = 6;
class G6e {
  constructor(t) {
    this.options = Object.assign(Object.create(K6e), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = Z8(Xy(u)), d = Z8(Ky(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Xy(r), Ky(a), Xy(i), Ky(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Pu] > 1 ? q8(p, f, this.clusterProps) : this.points[p[f + Bu]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + $k] === t && p.push(a[y + Pu] > 1 ? q8(a, y, this.clusterProps) : this.points[a[y + Bu]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new X6e(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Pu] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Ble(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Bu]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = Xy(f), d = Ky(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + Bu] : L = this.points[n[l + Bu]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Rc] <= n)) {
        l[p + Rc] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Pu], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + Rc] > n && (b += l[w + Pu]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + Rc] <= n)) {
              l[k + Rc] = n;
              var R = l[k + Pu];
              D += l[k] * R, x += l[k + 1] * R, l[k + $k] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + $k] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + Rc] <= n)) {
                l[$ + Rc] = n;
                for (var H = 0; H < c; H++) u.push(l[$ + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Pu] > 1) {
      var o = this.clusterProps[t[n + Ile]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Bu]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function q8(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Bu],
    properties: Ble(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [Y6e(e[t]), J6e(e[t + 1])]
    }
  };
}
function Ble(e, t, n) {
  var r = e[t + Pu], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Ile], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Bu],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Xy(e) {
  return e / 360 + 0.5;
}
function Ky(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function Y6e(e) {
  return (e - 0.5) * 360;
}
function J6e(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Q6e(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Hs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class a_ {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Hs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Hs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Hs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class e9e {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return t9e(n);
  }
}
var t9e = (e) => {
  var t = e.map((n) => new a_({
    position: Hs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class n9e extends e9e {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = Q6e(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new G6e(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!H8(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Hs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !H8(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new a_({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new a_({
      markers: [i],
      position: Hs.getPosition(i)
    });
  }
}
class r9e {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class o9e {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Hs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function i9e(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class ZI {
  constructor() {
    i9e(ZI, google.maps.OverlayView);
  }
}
var Fh;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Fh || (Fh = {}));
var s9e = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class a9e extends ZI {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new n9e(o),
      renderer: a = new o9e(),
      onClusterClick: s = s9e
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Hs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Fh.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Hs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Hs.setMap(l, null)));
      }
      google.maps.event.trigger(this, Fh.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Hs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new r9e(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Hs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Fh.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Hs.setMap(r.marker, n);
    });
  }
}
function X8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function K8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? X8(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : X8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function l9e(e) {
  var t = i6e(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new a9e(K8(K8({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function u9e(e) {
  var {
    children: t,
    options: n
  } = e, r = l9e(n);
  return r !== null ? t(r) : null;
}
me(u9e);
var G8 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Y8 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function c9e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge($t), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return v(N), R.current = document.createElement("div"), a && L(google.maps.event.addListener(N, "closeclick", a)), s && D(google.maps.event.addListener(N, "domready", s)), l && m(google.maps.event.addListener(N, "content_changed", l)), u && S(google.maps.event.addListener(N, "position_changed", u)), c && k(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(R.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(y, n) : N.getPosition() ? N.open(y) : fi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(N), N.close();
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(c9e);
class p9e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "containerElement", null), Ie(this, "state", {
      infoWindow: null
    }), Ie(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : fi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Ie(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Sn({
      updaterMap: Y8,
      eventMap: G8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: Y8,
      eventMap: G8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Fn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
Ie(p9e, "contextType", $t);
function J8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? J8(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : J8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Q8 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, e5 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, d9e = {};
function f9e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge($t), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var j = new google.maps.Polyline(Kw(Kw({}, t || d9e), {}, {
      map: D
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && S(google.maps.event.addListener(j, "dblclick", a)), s && k(google.maps.event.addListener(j, "dragend", s)), l && N(google.maps.event.addListener(j, "dragstart", l)), u && $(google.maps.event.addListener(j, "mousedown", u)), c && X(google.maps.event.addListener(j, "mousemove", c)), p && Y(google.maps.event.addListener(j, "mouseout", p)), d && J(google.maps.event.addListener(j, "mouseover", d)), y && _(google.maps.event.addListener(j, "mouseup", y)), f && M(google.maps.event.addListener(j, "rightclick", f)), v && O(google.maps.event.addListener(j, "click", v)), b && F(google.maps.event.addListener(j, "drag", b)), m(j), L && L(j), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
me(f9e);
class h9e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      polyline: null
    }), Ie(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Kw(Kw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: e5,
      eventMap: Q8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: e5,
      eventMap: Q8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Fn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(h9e, "contextType", $t);
function t5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function n5(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? t5(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : t5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var r5 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, o5 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function g9e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge($t), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var A = new google.maps.Polygon(n5(n5({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && k(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && $(google.maps.event.addListener(A, "dragstart", u)), c && X(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), b && F(google.maps.event.addListener(A, "click", b)), L && q(google.maps.event.addListener(A, "drag", L)), S(A), w && w(A), () => {
      U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), D && D(A), A.setMap(null);
    };
  }, []), null;
}
me(g9e);
class m9e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Sn({
      updaterMap: o5,
      eventMap: r5,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: o5,
      eventMap: r5,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Fn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(m9e, "contextType", $t);
function i5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? i5(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : i5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var s5 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, a5 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function v9e(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge($t), [m, C] = E(null), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var K = new google.maps.Rectangle(Gw(Gw({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && K.setVisible(i), typeof o < "u" && K.setEditable(o), typeof r < "u" && K.setDraggable(r), typeof n < "u" && K.setBounds(n), a && U(google.maps.event.addListener(K, "dblclick", a)), s && R(google.maps.event.addListener(K, "dragend", s)), l && V(google.maps.event.addListener(K, "dragstart", l)), u && H(google.maps.event.addListener(K, "mousedown", u)), c && G(google.maps.event.addListener(K, "mousemove", c)), p && Q(google.maps.event.addListener(K, "mouseout", p)), d && P(google.maps.event.addListener(K, "mouseover", d)), y && z(google.maps.event.addListener(K, "mouseup", y)), f && W(google.maps.event.addListener(K, "rightclick", f)), v && I(google.maps.event.addListener(K, "click", v)), b && j(google.maps.event.addListener(K, "drag", b)), L && A(google.maps.event.addListener(K, "bounds_changed", L)), C(K), w && w(K), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(K), K.setMap(null);
    };
  }, []), null;
}
me(v9e);
class y9e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      rectangle: null
    }), Ie(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Gw(Gw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: a5,
      eventMap: s5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: a5,
      eventMap: s5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Fn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(y9e, "contextType", $t);
function l5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? l5(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : l5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var u5 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, c5 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, b9e = {};
function w9e(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge($t), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var re = new google.maps.Circle(Yw(Yw({}, t || b9e), {}, {
      map: C
    }));
    return typeof r == "number" && re.setRadius(r), typeof n < "u" && re.setCenter(n), typeof r == "number" && re.setRadius(r), typeof a < "u" && re.setVisible(a), typeof i < "u" && re.setEditable(i), typeof o < "u" && re.setDraggable(o), s && R(google.maps.event.addListener(re, "dblclick", s)), l && V(google.maps.event.addListener(re, "dragend", l)), u && H(google.maps.event.addListener(re, "dragstart", u)), c && G(google.maps.event.addListener(re, "mousedown", c)), p && Q(google.maps.event.addListener(re, "mousemove", p)), d && P(google.maps.event.addListener(re, "mouseout", d)), y && z(google.maps.event.addListener(re, "mouseover", y)), f && W(google.maps.event.addListener(re, "mouseup", f)), v && I(google.maps.event.addListener(re, "rightclick", v)), b && j(google.maps.event.addListener(re, "click", b)), L && A(google.maps.event.addListener(re, "drag", L)), w && B(google.maps.event.addListener(re, "center_changed", w)), D && he(google.maps.event.addListener(re, "radius_changed", D)), U(re), x && x(re), () => {
      k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), m && m(re), re.setMap(null);
    };
  }, []), null;
}
me(w9e);
class O9e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      circle: null
    }), Ie(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Yw(Yw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: c5,
      eventMap: u5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: c5,
      eventMap: u5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Fn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Ie(O9e, "contextType", $t);
function p5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? p5(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : p5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var d5 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, f5 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function C9e(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge($t), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var A = new google.maps.Data(Jw(Jw({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && k(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && $(google.maps.event.addListener(A, "mouseover", s)), l && X(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && q(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), j !== null && google.maps.event.removeListener(j), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(C9e);
class x9e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      data: null
    }), Ie(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Jw(Jw({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Sn({
        updaterMap: f5,
        eventMap: d5,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: f5,
      eventMap: d5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Fn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(x9e, "contextType", $t);
function h5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function g5(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? h5(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : h5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var m5 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, v5 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class L9e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      kmlLayer: null
    }), Ie(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(g5(g5({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: v5,
      eventMap: m5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: v5,
      eventMap: m5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Fn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(L9e, "contextType", $t);
function Nle(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function E9e(e, t) {
  return new t(e.lat, e.lng);
}
function k9e(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function P9e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function S9e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function M9e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function D9e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Rle(e, t, n, r) {
  return n !== void 0 ? M9e(e, t, S9e(n, google.maps.LatLngBounds, k9e)) : D9e(e, t, P9e(r, google.maps.LatLng, E9e));
}
function _9e(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function y5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function T9e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? y5(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : y5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function j9e(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = T9e({}, this.container ? Nle(this.container, o) : {
        x: 0,
        y: 0
      }), u = Rle(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function b5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function A9e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? b5(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : b5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function w5(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function O5(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function I9e(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge($t), c = zt(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = zt(() => j9e(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
me(I9e);
class Vd extends pe {
  constructor(t) {
    super(t), Ie(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Ie(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      fi(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Ie(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Ie(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = A9e({
        x: 0,
        y: 0
      }, this.containerRef.current ? Nle(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Rle(r, o, this.props.bounds, this.props.position);
      if (!_9e(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Ie(this, "draw", () => {
      this.onPositionElement();
    }), Ie(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = jn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = w5(t.position), r = w5(this.props.position), o = O5(t.bounds), i = O5(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(ys.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
Ie(Vd, "FLOAT_PANE", "floatPane");
Ie(Vd, "MAP_PANE", "mapPane");
Ie(Vd, "MARKER_LAYER", "markerLayer");
Ie(Vd, "OVERLAY_LAYER", "overlayLayer");
Ie(Vd, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Ie(Vd, "contextType", $t);
function B9e() {
}
function C5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function x5(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? C5(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : C5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var L5 = {
  onDblClick: "dblclick",
  onClick: "click"
}, E5 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function N9e(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge($t), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = zt(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(N9e);
class Fle extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      groundOverlay: null
    }), Ie(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    fi(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, x5(x5({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: E5,
      eventMap: L5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: E5,
      eventMap: L5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(Fle, "defaultProps", {
  onLoad: B9e
});
Ie(Fle, "contextType", $t);
function k5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? k5(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : k5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var P5 = {}, S5 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function R9e(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge($t), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || fi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    fi(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(Qw(Qw({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(R9e);
class F9e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      heatmapLayer: null
    }), Ie(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    fi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), fi(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Qw(Qw({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: S5,
      eventMap: P5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: S5,
      eventMap: P5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Fn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(F9e, "contextType", $t);
var M5 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, D5 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class z9e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      streetViewPanorama: null
    }), Ie(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Sn({
      updaterMap: D5,
      eventMap: M5,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: D5,
      eventMap: M5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Fn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Ie(z9e, "contextType", $t);
class U9e extends pe {
  constructor() {
    super(...arguments), Ie(this, "state", {
      streetViewService: null
    }), Ie(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Ie(U9e, "contextType", $t);
var _5 = {
  onDirectionsChanged: "directions_changed"
}, T5 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class W9e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      directionsRenderer: null
    }), Ie(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Sn({
      updaterMap: T5,
      eventMap: _5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: T5,
      eventMap: _5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Fn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(W9e, "contextType", $t);
var j5 = {
  onPlacesChanged: "places_changed"
}, A5 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class H9e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "containerElement", jn()), Ie(this, "state", {
      searchBox: null
    }), Ie(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (fi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Sn({
          updaterMap: A5,
          eventMap: j5,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: A5,
      eventMap: j5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Fn(this.registeredEvents));
  }
  render() {
    return ys.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
Ie(H9e, "contextType", $t);
var I5 = {
  onPlaceChanged: "place_changed"
}, B5 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class zle extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "containerElement", jn()), Ie(this, "state", {
      autocomplete: null
    }), Ie(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    fi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Sn({
        updaterMap: B5,
        eventMap: I5,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Fn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: B5,
      eventMap: I5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Fn(this.registeredEvents);
  }
  render() {
    return ys.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
Ie(zle, "defaultProps", {
  className: ""
});
Ie(zle, "contextType", $t);
let V9e = { data: "" }, $9e = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || V9e, Z9e = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, q9e = /\/\*[^]*?\*\/|  +/g, N5 = /\n+/g, qu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? qu(a, i) : i + "{" + qu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += qu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += qu.p ? qu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ll = {}, Ule = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Ule(e[n]);
    return t;
  }
  return e;
}, X9e = (e, t, n, r, o) => {
  let i = Ule(e), a = Ll[i] || (Ll[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ll[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Z9e.exec(u.replace(q9e, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(N5, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(N5, " ").trim();
      return d[0];
    })(e);
    Ll[a] = qu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ll.g ? Ll.g : null;
  return n && (Ll.g = Ll[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ll[a], t, r, s), a;
}, K9e = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : qu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Fx(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return X9e(n.unshift ? n.raw ? K9e(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, $9e(t.target), t.g, t.o, t.k);
}
let Wle, l_, u_;
Fx.bind({ g: 1 });
let Hl = Fx.bind({ k: 1 });
function G9e(e, t, n, r) {
  qu.p = t, Wle = e, l_ = n, u_ = r;
}
function Lc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: l_ && l_() }, s), n.o = / *go\d+/.test(l), s.className = Fx.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), u_ && u[0] && u_(s), Wle(u, s);
    }
    return o;
  };
}
var Y9e = (e) => typeof e == "function", J9e = (e, t) => Y9e(e) ? e(t) : e, Q9e = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), e8e = Hl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, t8e = Hl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, n8e = Hl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, r8e = Lc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${e8e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${t8e} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${n8e} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, o8e = Hl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, i8e = Lc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${o8e} 1s linear infinite;
`, s8e = Hl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, a8e = Hl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, l8e = Lc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${s8e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${a8e} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, u8e = Lc("div")`
  position: absolute;
`, c8e = Lc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, p8e = Hl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, d8e = Lc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${p8e} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, f8e = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? _e.createElement(d8e, null, t) : t : n === "blank" ? null : _e.createElement(c8e, null, _e.createElement(i8e, { ...r }), n !== "loading" && _e.createElement(u8e, null, n === "error" ? _e.createElement(r8e, { ...r }) : _e.createElement(l8e, { ...r })));
}, h8e = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, g8e = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, m8e = "0%{opacity:0;} 100%{opacity:1;}", v8e = "0%{opacity:1;} 100%{opacity:0;}", y8e = Lc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, b8e = Lc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, w8e = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Q9e() ? [m8e, v8e] : [h8e(n), g8e(n)];
  return { animation: t ? `${Hl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Hl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
_e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? w8e(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = _e.createElement(f8e, { toast: e }), a = _e.createElement(b8e, { ...e.ariaProps }, J9e(e.message, e));
  return _e.createElement(y8e, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : _e.createElement(_e.Fragment, null, i, a));
});
G9e(_e.createElement);
Fx`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
He({});
function O8e(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const C8e = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
O8e(C8e.CNPJ).length;
ka((e, t) => /* @__PURE__ */ vs.jsx("input", { ref: t, ...e }));
He({});
var eu = {};
Object.defineProperty(eu, "__esModule", {
  value: !0
});
var x8e = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Zk = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Hle = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: x8e ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, qI = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Gy = 1; Gy < 20; Gy++)
  qI["f" + Gy] = 111 + Gy;
function zx(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Vle(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return $le(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function L8e(e, t) {
  return zx(e, t);
}
function E8e(e, t) {
  return zx(e, { byKey: !0 }, t);
}
function Vle(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in Zk)
    r[Zk[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = XI(d), v = Zk[f];
      if (d.length > 1 && !v && !Hle[d] && !qI[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = Zle(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function $le(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Zle(e) {
  e = XI(e);
  var t = qI[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function XI(e) {
  return e = e.toLowerCase(), e = Hle[e] || e, e;
}
eu.default = zx;
var qk = eu.isHotkey = zx;
eu.isCodeHotkey = L8e;
eu.isKeyHotkey = E8e;
eu.parseHotkey = Vle;
eu.compareHotkey = $le;
eu.toKeyCode = Zle;
eu.toKeyName = XI;
var k8e = typeof _r == "object" && _r && _r.Object === Object && _r, P8e = k8e, S8e = P8e, M8e = typeof self == "object" && self && self.Object === Object && self, D8e = S8e || M8e || Function("return this")(), _8e = D8e, T8e = _8e, j8e = T8e.Symbol, qle = j8e, R5 = qle;
R5 && R5.toStringTag;
var F5 = qle;
F5 && F5.toStringTag;
var z5;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(z5 || (z5 = {}));
var KI = function(e) {
  return Object.freeze(e);
}, A8e = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, KI(this);
  }
  return e;
}(), I8e = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, KI(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), U5 = typeof window < "u" ? window : {};
/msie|trident/i.test(U5.navigator && U5.navigator.userAgent);
var Xk = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new A8e((n ? t : e) || 0, (n ? e : t) || 0);
};
KI({
  devicePixelContentBoxSize: Xk(),
  borderBoxSize: Xk(),
  contentBoxSize: Xk(),
  contentRect: new I8e(0, 0, 0, 0)
});
function Wg(e) {
  "@babel/helpers - typeof";
  return Wg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Wg(e);
}
function B8e(e, t) {
  if (Wg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Wg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function N8e(e) {
  var t = B8e(e, "string");
  return Wg(t) === "symbol" ? t : String(t);
}
function zh(e, t, n) {
  return t = N8e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var R8e = /* @__PURE__ */ He(null), Kk, Gk;
parseInt(Oe.version.split(".")[0], 10);
var W5 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Yk = typeof navigator < "u" && /Android/.test(navigator.userAgent), Yy = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), F8e = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Kk = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Kk !== void 0 && Kk[1] && parseInt((Gk = navigator.userAgent.match(/Version\/(\d+)/)) === null || Gk === void 0 ? void 0 : Gk[1], 10) < 17;
var z8e = /* @__PURE__ */ new WeakMap(), U8e = /* @__PURE__ */ new WeakMap(), W8e = /* @__PURE__ */ new WeakMap(), H8e = /* @__PURE__ */ new WeakMap(), V8e = /* @__PURE__ */ new WeakMap(), H5 = /* @__PURE__ */ new WeakMap(), $8e = /* @__PURE__ */ new WeakMap(), V5 = /* @__PURE__ */ new WeakMap(), Jy = /* @__PURE__ */ new WeakMap(), Z8e = /* @__PURE__ */ new WeakMap(), q8e = /* @__PURE__ */ new WeakMap(), X8e = /* @__PURE__ */ new WeakMap(), Xle = globalThis.Node, K8e = globalThis.Text, Kle = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, G8e = (e) => e1(e) && e.nodeType === 8, Ya = (e) => e1(e) && e.nodeType === 1, e1 = (e) => {
  var t = Kle(e);
  return !!t && e instanceof t.Node;
}, $5 = (e) => {
  var t = e && e.anchorNode && Kle(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Y8e = (e) => {
  var [t, n] = e;
  if (Ya(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Gle(t, o, r ? "backward" : "forward"), r = o < n; Ya(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = Q8e(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, J8e = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Gle = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (G8e(o) || Ya(o) && o.childNodes.length === 0 || Ya(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, Q8e = (e, t, n) => {
  var [r] = Gle(e, t, n);
  return r;
}, Z5 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Yle = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ya(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = On.getWindow(e);
  if (o.contains(r))
    return On.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Yle(e, i, n);
}, q5 = (e, t) => !!(e.compareDocumentPosition(t) & Xle.DOCUMENT_POSITION_PRECEDING), e5e = (e, t) => !!(e.compareDocumentPosition(t) & Xle.DOCUMENT_POSITION_FOLLOWING), t5e = 0;
class n5e {
  constructor() {
    zh(this, "id", void 0), this.id = "".concat(t5e++);
  }
}
var On = {
  androidPendingDiffs: (e) => X8e.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = q8e.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = On.toDOMNode(e, e), n = On.findDocumentOrShadowRoot(e);
    Jy.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = On.findDocumentOrShadowRoot(e), r = Z5(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && W0.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = On.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = On.toSlateNode(e, t.target), a = On.findPath(e, i);
    if (jl.isElement(i) && Cr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Cr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Cr.before(e, u) : Cr.after(e, u);
      if (c) {
        var p = Cr.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = On.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = On.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = H5.get(t);
    return n || (n = new n5e(), H5.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = U8e.get(r);
      if (o == null) {
        if (Cr.isEditor(r))
          return n;
        break;
      }
      var i = z8e.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Is.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Jy.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          On.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = On.toDOMNode(e, e), r = On.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = Z5(r), i = On.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || W0.select(e, Cr.start(e, [])), Jy.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = W8e.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = On.toDOMNode(e, e), i;
    try {
      i = Ya(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => e1(t) && On.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Cr.hasPath(e, n.path) && Cr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => On.hasEditableTarget(e, t) || On.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => e1(t) && On.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Z8e.get(e),
  isFocused: (e) => !!Jy.get(e),
  isReadOnly: (e) => !!V5.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (V5.get(e)) return !1;
    var n = On.hasTarget(e, t) && On.toSlateNode(e, t);
    return jl.isElement(n) && Cr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = $8e.get(e), r = Cr.isEditor(t) ? H8e.get(e) : n == null ? void 0 : n.get(On.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Is.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Cr.node(e, t.path), r = On.toDOMNode(e, n), o;
    Cr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof K8e ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Is.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = en.isBackward(t), i = On.toDOMPoint(e, n), a = en.isCollapsed(t) ? i : On.toDOMPoint(e, r), s = On.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = Ya(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = Ya(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ya(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? V8e.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : Y8e(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = On.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = On.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (Yk && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var R = U[k];
          if (On.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var N = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, H = [...N(V), ...N(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = H.find((M) => e5e(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var X, G = [...N(V == null ? void 0 : V.previousElementSibling), ...N(V)];
          w = (X = G.findLast((M) => q5(L, M))) !== null && X !== void 0 ? X : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Yk && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Yy && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Yk && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && On.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = On.toSlateNode(e, Y), {
          path: J,
          offset: P
        } = Cr.start(e, On.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = On.toSlateNode(e, u), z = On.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = $5(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if ($5(t)) {
        if (Yy && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        F8e && J8e(s) || Yy ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Yy && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = On.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = q5(s, u) || s === u && c < l, x = p ? w : On.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return en.isExpanded(m) && en.isForward(m) && Ya(u) && Cr.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = Cr.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, r5e = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, o5e = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, i5e = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, yo = (e) => {
  var t = r5e[e], n = o5e[e], r = i5e[e], o = t && qk(t), i = n && qk(n), a = r && qk(r);
  return (s) => !!(o && o(s) || W5 && i && i(s) || !W5 && a && a(s));
};
yo("bold"), yo("compose"), yo("moveBackward"), yo("moveForward"), yo("deleteBackward"), yo("deleteForward"), yo("deleteLineBackward"), yo("deleteLineForward"), yo("deleteWordBackward"), yo("deleteWordForward"), yo("extendBackward"), yo("extendForward"), yo("extendLineBackward"), yo("extendLineForward"), yo("italic"), yo("moveLineBackward"), yo("moveLineForward"), yo("moveWordBackward"), yo("moveWordForward"), yo("redo"), yo("insertSoftBreak"), yo("splitBlock"), yo("transposeCharacter"), yo("undo");
var s5e = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Yle(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, a5e = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class l5e extends Kl {
  constructor() {
    super(...arguments), zh(this, "context", null), zh(this, "manager", null), zh(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, a5e);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = s5e(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
zh(l5e, "contextType", R8e);
He({});
He({});
He({});
var ii = {}, GI = {}, Mm = {}, Dm = {}, Jle = "Expected a function", X5 = NaN, u5e = "[object Symbol]", c5e = /^\s+|\s+$/g, p5e = /^[-+]0x[0-9a-f]+$/i, d5e = /^0b[01]+$/i, f5e = /^0o[0-7]+$/i, h5e = parseInt, g5e = typeof _r == "object" && _r && _r.Object === Object && _r, m5e = typeof self == "object" && self && self.Object === Object && self, v5e = g5e || m5e || Function("return this")(), y5e = Object.prototype, b5e = y5e.toString, w5e = Math.max, O5e = Math.min, Jk = function() {
  return v5e.Date.now();
};
function C5e(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Jle);
  t = K5(t) || 0, t1(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? w5e(K5(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? O5e(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = Jk();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(Jk());
  }
  function m() {
    var C = Jk(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function x5e(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Jle);
  return t1(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), C5e(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function t1(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function L5e(e) {
  return !!e && typeof e == "object";
}
function E5e(e) {
  return typeof e == "symbol" || L5e(e) && b5e.call(e) == u5e;
}
function K5(e) {
  if (typeof e == "number")
    return e;
  if (E5e(e))
    return X5;
  if (t1(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = t1(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(c5e, "");
  var n = d5e.test(e);
  return n || f5e.test(e) ? h5e(e.slice(2), n ? 2 : 8) : p5e.test(e) ? X5 : +e;
}
var k5e = x5e, _m = {};
Object.defineProperty(_m, "__esModule", {
  value: !0
});
_m.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), i0.has(t) || i0.set(t, /* @__PURE__ */ new Set());
  var o = i0.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
_m.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), i0.get(t).delete(n.name || t);
};
var i0 = /* @__PURE__ */ new Map();
Object.defineProperty(Dm, "__esModule", {
  value: !0
});
var P5e = k5e, S5e = D5e(P5e), M5e = _m;
function D5e(e) {
  return e && e.__esModule ? e : { default: e };
}
var _5e = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, S5e.default)(e, t);
}, jo = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = _5e(function(r) {
        jo.scrollHandler(e);
      }, t);
      jo.scrollSpyContainers.push(e), (0, M5e.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return jo.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = jo.scrollSpyContainers[jo.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(jo.currentPositionX(e), jo.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    jo.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = jo.scrollSpyContainers[jo.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(jo.currentPositionX(t), jo.currentPositionY(t));
  },
  updateStates: function() {
    jo.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    jo.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), jo.spySetState && jo.spySetState.length && jo.spySetState.indexOf(e) > -1 && jo.spySetState.splice(jo.spySetState.indexOf(e), 1), document.removeEventListener("scroll", jo.scrollHandler);
  },
  update: function() {
    return jo.scrollSpyContainers.forEach(function(e) {
      return jo.scrollHandler(e);
    });
  }
};
Dm.default = jo;
var $d = {}, Tm = {};
Object.defineProperty(Tm, "__esModule", {
  value: !0
});
var T5e = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, j5e = function() {
  return window.location.hash.replace(/^#/, "");
}, A5e = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, I5e = function(e) {
  return getComputedStyle(e).position !== "static";
}, Qk = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, B5e = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (I5e(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Qk(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return Qk(t, s).offsetTop - Qk(e, s).offsetTop;
};
Tm.default = {
  updateHash: T5e,
  getHash: j5e,
  filterElementInContainer: A5e,
  scrollOffset: B5e
};
var Ux = {}, YI = {};
Object.defineProperty(YI, "__esModule", {
  value: !0
});
YI.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var JI = {};
Object.defineProperty(JI, "__esModule", {
  value: !0
});
var N5e = _m, R5e = ["mousedown", "mousewheel", "touchmove", "keydown"];
JI.default = {
  subscribe: function(e) {
    return typeof document < "u" && R5e.forEach(function(t) {
      return (0, N5e.addPassiveEventListener)(document, t, e);
    });
  }
};
var jm = {};
Object.defineProperty(jm, "__esModule", {
  value: !0
});
var c_ = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      c_.registered[e] = t;
    },
    remove: function(e) {
      c_.registered[e] = null;
    }
  }
};
jm.default = c_;
Object.defineProperty(Ux, "__esModule", {
  value: !0
});
var F5e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, z5e = Tm;
Wx(z5e);
var U5e = YI, G5 = Wx(U5e), W5e = JI, H5e = Wx(W5e), V5e = jm, Wa = Wx(V5e);
function Wx(e) {
  return e && e.__esModule ? e : { default: e };
}
var Qle = function(e) {
  return G5.default[e.smooth] || G5.default.defaultEasing;
}, $5e = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Z5e = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, p_ = function() {
  return Z5e() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), eue = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, tue = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, nue = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, q5e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, X5e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, K5e = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Wa.default.registered.end && Wa.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    p_.call(window, i);
    return;
  }
  Wa.default.registered.end && Wa.default.registered.end(o.to, o.target, o.currentPosition);
}, QI = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Am = function(e, t, n, r) {
  t.data = t.data || eue(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (H5e.default.subscribe(o), QI(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? tue(t) : nue(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Wa.default.registered.end && Wa.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = $5e(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Qle(t), a = K5e.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Wa.default.registered.begin && Wa.default.registered.begin(t.data.to, t.data.target), p_.call(window, a);
    }, t.delay);
    return;
  }
  Wa.default.registered.begin && Wa.default.registered.begin(t.data.to, t.data.target), p_.call(window, a);
}, Hx = function(e) {
  return e = F5e({}, e), e.data = e.data || eue(), e.absolute = !0, e;
}, G5e = function(e) {
  Am(0, Hx(e));
}, Y5e = function(e, t) {
  Am(e, Hx(t));
}, J5e = function(e) {
  e = Hx(e), QI(e), Am(e.horizontal ? q5e(e) : X5e(e), e);
}, Q5e = function(e, t) {
  t = Hx(t), QI(t);
  var n = t.horizontal ? tue(t) : nue(t);
  Am(e + n, t);
};
Ux.default = {
  animateTopScroll: Am,
  getAnimationType: Qle,
  scrollToTop: G5e,
  scrollToBottom: J5e,
  scrollTo: Y5e,
  scrollMore: Q5e
};
Object.defineProperty($d, "__esModule", {
  value: !0
});
var e4e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, t4e = Tm, n4e = eB(t4e), r4e = Ux, o4e = eB(r4e), i4e = jm, Qy = eB(i4e);
function eB(e) {
  return e && e.__esModule ? e : { default: e };
}
var eb = {}, Y5 = void 0;
$d.default = {
  unmount: function() {
    eb = {};
  },
  register: function(e, t) {
    eb[e] = t;
  },
  unregister: function(e) {
    delete eb[e];
  },
  get: function(e) {
    return eb[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return Y5 = e;
  },
  getActiveLink: function() {
    return Y5;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = e4e({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = n4e.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Qy.default.registered.begin && Qy.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Qy.default.registered.end && Qy.default.registered.end(e, n);
      return;
    }
    o4e.default.animateTopScroll(s, t, e, n);
  }
};
var d_ = { exports: {} }, eP = { exports: {} }, rr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var J5;
function s4e() {
  if (J5) return rr;
  J5 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return rr.AsyncMode = l, rr.ConcurrentMode = u, rr.ContextConsumer = s, rr.ContextProvider = a, rr.Element = t, rr.ForwardRef = c, rr.Fragment = r, rr.Lazy = f, rr.Memo = y, rr.Portal = n, rr.Profiler = i, rr.StrictMode = o, rr.Suspense = p, rr.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, rr.isConcurrentMode = x, rr.isContextConsumer = function(m) {
    return D(m) === s;
  }, rr.isContextProvider = function(m) {
    return D(m) === a;
  }, rr.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, rr.isForwardRef = function(m) {
    return D(m) === c;
  }, rr.isFragment = function(m) {
    return D(m) === r;
  }, rr.isLazy = function(m) {
    return D(m) === f;
  }, rr.isMemo = function(m) {
    return D(m) === y;
  }, rr.isPortal = function(m) {
    return D(m) === n;
  }, rr.isProfiler = function(m) {
    return D(m) === i;
  }, rr.isStrictMode = function(m) {
    return D(m) === o;
  }, rr.isSuspense = function(m) {
    return D(m) === p;
  }, rr.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, rr.typeOf = D, rr;
}
var hr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Q5;
function a4e() {
  return Q5 || (Q5 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === y || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === L || B.$$typeof === w || B.$$typeof === v);
    }
    function x(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var re = he && he.$$typeof;
                switch (re) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return re;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, R = c, N = r, V = f, $ = y, H = n, X = i, G = o, Y = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || x(B) === l;
    }
    function P(B) {
      return x(B) === u;
    }
    function _(B) {
      return x(B) === s;
    }
    function z(B) {
      return x(B) === a;
    }
    function M(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return x(B) === c;
    }
    function O(B) {
      return x(B) === r;
    }
    function I(B) {
      return x(B) === f;
    }
    function F(B) {
      return x(B) === y;
    }
    function j(B) {
      return x(B) === n;
    }
    function q(B) {
      return x(B) === i;
    }
    function A(B) {
      return x(B) === o;
    }
    function K(B) {
      return x(B) === p;
    }
    hr.AsyncMode = m, hr.ConcurrentMode = C, hr.ContextConsumer = S, hr.ContextProvider = U, hr.Element = k, hr.ForwardRef = R, hr.Fragment = N, hr.Lazy = V, hr.Memo = $, hr.Portal = H, hr.Profiler = X, hr.StrictMode = G, hr.Suspense = Y, hr.isAsyncMode = J, hr.isConcurrentMode = P, hr.isContextConsumer = _, hr.isContextProvider = z, hr.isElement = M, hr.isForwardRef = W, hr.isFragment = O, hr.isLazy = I, hr.isMemo = F, hr.isPortal = j, hr.isProfiler = q, hr.isStrictMode = A, hr.isSuspense = K, hr.isValidElementType = D, hr.typeOf = x;
  }()), hr;
}
var e4;
function rue() {
  return e4 || (e4 = 1, process.env.NODE_ENV === "production" ? eP.exports = s4e() : eP.exports = a4e()), eP.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var tP, t4;
function l4e() {
  if (t4) return tP;
  t4 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return tP = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, tP;
}
var nP, n4;
function tB() {
  if (n4) return nP;
  n4 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return nP = e, nP;
}
var r4, o4;
function oue() {
  return o4 || (o4 = 1, r4 = Function.call.bind(Object.prototype.hasOwnProperty)), r4;
}
var rP, i4;
function u4e() {
  if (i4) return rP;
  i4 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = tB(), n = {}, r = oue();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, rP = o, rP;
}
var oP, s4;
function c4e() {
  if (s4) return oP;
  s4 = 1;
  var e = rue(), t = l4e(), n = tB(), r = oue(), o = u4e(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return oP = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, I, F, j, q, A, K) {
        if (j = j || d, A = A || F, K !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = j + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return I[F] == null ? O ? I[F] === null ? new v("The " + q + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new v("The " + q + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : P(I, F, j, q, A);
      }
      var W = M.bind(null, !1);
      return W.isRequired = M.bind(null, !0), W;
    }
    function L(P) {
      function _(z, M, W, O, I, F) {
        var j = z[M], q = G(j);
        if (q !== P) {
          var A = Y(j);
          return new v(
            "Invalid " + O + " `" + I + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var j = G(F);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var A = P(F, q, W, O, I + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!s(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!e.isValidElementType(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, W, O, I) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, j = J(z[M]);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, W, O, I) {
        for (var F = z[M], j = 0; j < P.length; j++)
          if (f(F, P[j]))
            return null;
        var q = JSON.stringify(P, function(A, K) {
          var B = Y(K);
          return B === "symbol" ? String(K) : K;
        });
        return new v("Invalid " + O + " `" + I + "` of value `" + String(F) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var A = P(F, q, W, O, I + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(W, O, I, F, j) {
        for (var q = [], A = 0; A < P.length; A++) {
          var K = P[A], B = K(W, O, I, F, j, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + j + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(M);
    }
    function R() {
      function P(_, z, M, W, O) {
        return H(_[z]) ? null : new v("Invalid " + W + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function N(P, _, z, M, W) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return N(W, O, I, q, Y(A));
          var K = A(F, q, W, O, I + "." + q, n);
          if (K)
            return K;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var A in q) {
          var K = P[A];
          if (r(P, A) && typeof K != "function")
            return N(W, O, I, A, Y(K));
          if (!K)
            return new v(
              "Invalid " + O + " `" + I + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = K(F, A, W, O, I + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!H(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var W = M.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function X(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function G(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : X(_, P) ? "symbol" : _;
    }
    function Y(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = G(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = Y(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, oP;
}
var iP, a4;
function p4e() {
  if (a4) return iP;
  a4 = 1;
  var e = tB();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, iP = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, iP;
}
if (process.env.NODE_ENV !== "production") {
  var d4e = rue(), f4e = !0;
  d_.exports = c4e()(d4e.isElement, f4e);
} else
  d_.exports = p4e()();
var Vx = d_.exports, $x = {};
Object.defineProperty($x, "__esModule", {
  value: !0
});
var h4e = Tm, sP = g4e(h4e);
function g4e(e) {
  return e && e.__esModule ? e : { default: e };
}
var m4e = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return sP.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && sP.default.getHash() !== e && sP.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
$x.default = m4e;
Object.defineProperty(Mm, "__esModule", {
  value: !0
});
var tb = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, v4e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), y4e = Oe, l4 = Im(y4e), b4e = Dm, nb = Im(b4e), w4e = $d, O4e = Im(w4e), C4e = Vx, bo = Im(C4e), x4e = $x, fu = Im(x4e);
function Im(e) {
  return e && e.__esModule ? e : { default: e };
}
function L4e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function E4e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function k4e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var u4 = {
  to: bo.default.string.isRequired,
  containerId: bo.default.string,
  container: bo.default.object,
  activeClass: bo.default.string,
  activeStyle: bo.default.object,
  spy: bo.default.bool,
  horizontal: bo.default.bool,
  smooth: bo.default.oneOfType([bo.default.bool, bo.default.string]),
  offset: bo.default.number,
  delay: bo.default.number,
  isDynamic: bo.default.bool,
  onClick: bo.default.func,
  duration: bo.default.oneOfType([bo.default.number, bo.default.func]),
  absolute: bo.default.bool,
  onSetActive: bo.default.func,
  onSetInactive: bo.default.func,
  ignoreCancelEvents: bo.default.bool,
  hashSpy: bo.default.bool,
  saveHashHistory: bo.default.bool,
  spyThrottle: bo.default.number
};
Mm.default = function(e, t) {
  var n = t || O4e.default, r = function(i) {
    k4e(a, i);
    function a(s) {
      L4e(this, a);
      var l = E4e(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return v4e(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          nb.default.isMounted(s) || nb.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (fu.default.isMounted() || fu.default.mount(n), fu.default.mapContainer(this.props.to, s)), nb.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        nb.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = tb({}, this.props.style, this.props.activeStyle) : l = tb({}, this.props.style);
        var u = tb({}, this.props);
        for (var c in u4)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, l4.default.createElement(e, u);
      }
    }]), a;
  }(l4.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, tb({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(fu.default.isMounted() && !fu.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var R = n.getActiveLink();
        if (y) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && fu.default.getHash() === c) {
            var N = i.props.saveHashHistory, V = N === void 0 ? !1 : N;
            fu.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, H = $ === void 0 ? !1 : $;
          i.props.hashSpy && fu.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = u4, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(GI, "__esModule", {
  value: !0
});
var P4e = Oe, c4 = iue(P4e), S4e = Mm, M4e = iue(S4e);
function iue(e) {
  return e && e.__esModule ? e : { default: e };
}
function D4e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function p4(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function _4e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var T4e = function(e) {
  _4e(t, e);
  function t() {
    var n, r, o, i;
    D4e(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = p4(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return c4.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), p4(o, i);
  }
  return t;
}(c4.default.Component);
GI.default = (0, M4e.default)(T4e);
var nB = {};
Object.defineProperty(nB, "__esModule", {
  value: !0
});
var j4e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), A4e = Oe, d4 = sue(A4e), I4e = Mm, B4e = sue(I4e);
function sue(e) {
  return e && e.__esModule ? e : { default: e };
}
function N4e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function R4e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function F4e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var z4e = function(e) {
  F4e(t, e);
  function t() {
    return N4e(this, t), R4e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return j4e(t, [{
    key: "render",
    value: function() {
      return d4.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(d4.default.Component);
nB.default = (0, B4e.default)(z4e);
var rB = {}, Zx = {};
Object.defineProperty(Zx, "__esModule", {
  value: !0
});
var U4e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, W4e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), H4e = Oe, f4 = qx(H4e), V4e = nl;
qx(V4e);
var $4e = $d, h4 = qx($4e), Z4e = Vx, g4 = qx(Z4e);
function qx(e) {
  return e && e.__esModule ? e : { default: e };
}
function q4e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function X4e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function K4e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Zx.default = function(e) {
  var t = function(n) {
    K4e(r, n);
    function r(o) {
      q4e(this, r);
      var i = X4e(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return W4e(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        h4.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        h4.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return f4.default.createElement(e, U4e({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(f4.default.Component);
  return t.propTypes = {
    name: g4.default.string,
    id: g4.default.string
  }, t;
};
Object.defineProperty(rB, "__esModule", {
  value: !0
});
var m4 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, G4e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Y4e = Oe, v4 = oB(Y4e), J4e = Zx, Q4e = oB(J4e), eZe = Vx, y4 = oB(eZe);
function oB(e) {
  return e && e.__esModule ? e : { default: e };
}
function tZe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function nZe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function rZe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var aue = function(e) {
  rZe(t, e);
  function t() {
    return tZe(this, t), nZe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return G4e(t, [{
    key: "render",
    value: function() {
      var n = this, r = m4({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, v4.default.createElement(
        "div",
        m4({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(v4.default.Component);
aue.propTypes = {
  name: y4.default.string,
  id: y4.default.string
};
rB.default = (0, Q4e.default)(aue);
var aP = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, b4 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function w4(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function O4(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function C4(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var rb = Oe, Fc = Dm, lP = $d, Wo = Vx, hu = $x, x4 = {
  to: Wo.string.isRequired,
  containerId: Wo.string,
  container: Wo.object,
  activeClass: Wo.string,
  spy: Wo.bool,
  smooth: Wo.oneOfType([Wo.bool, Wo.string]),
  offset: Wo.number,
  delay: Wo.number,
  isDynamic: Wo.bool,
  onClick: Wo.func,
  duration: Wo.oneOfType([Wo.number, Wo.func]),
  absolute: Wo.bool,
  onSetActive: Wo.func,
  onSetInactive: Wo.func,
  ignoreCancelEvents: Wo.bool,
  hashSpy: Wo.bool,
  spyThrottle: Wo.number
}, oZe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || lP, r = function(i) {
      C4(a, i);
      function a(s) {
        w4(this, a);
        var l = O4(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return b4(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Fc.isMounted(s) || Fc.mount(s, this.props.spyThrottle), this.props.hashSpy && (hu.isMounted() || hu.mount(n), hu.mapContainer(this.props.to, s)), this.props.spy && Fc.addStateHandler(this.stateHandler), Fc.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Fc.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = aP({}, this.props);
          for (var u in x4)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, rb.createElement(e, l);
        }
      }]), a;
    }(rb.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, aP({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(hu.isMounted() && !hu.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && hu.getHash() === l && hu.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Fc.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && hu.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Fc.updateStates();
        }
      };
    };
    return r.propTypes = x4, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      C4(r, n);
      function r(o) {
        w4(this, r);
        var i = O4(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return b4(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          lP.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          lP.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return rb.createElement(e, aP({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(rb.Component);
    return t.propTypes = {
      name: Wo.string,
      id: Wo.string
    }, t;
  }
}, iZe = oZe;
Object.defineProperty(ii, "__esModule", {
  value: !0
});
ii.Helpers = ii.ScrollElement = ii.ScrollLink = ii.animateScroll = ii.scrollSpy = ii.Events = ii.scroller = ii.Element = ii.Button = ii.Link = void 0;
var sZe = GI, lue = al(sZe), aZe = nB, uue = al(aZe), lZe = rB, cue = al(lZe), uZe = $d, pue = al(uZe), cZe = jm, due = al(cZe), pZe = Dm, fue = al(pZe), dZe = Ux, hue = al(dZe), fZe = Mm, gue = al(fZe), hZe = Zx, mue = al(hZe), gZe = iZe, vue = al(gZe);
function al(e) {
  return e && e.__esModule ? e : { default: e };
}
ii.Link = lue.default;
ii.Button = uue.default;
ii.Element = cue.default;
ii.scroller = pue.default;
ii.Events = due.default;
ii.scrollSpy = fue.default;
ii.animateScroll = hue.default;
ii.ScrollLink = gue.default;
ii.ScrollElement = mue.default;
ii.Helpers = vue.default;
ii.default = { Link: lue.default, Button: uue.default, Element: cue.default, scroller: pue.default, Events: due.default, scrollSpy: fue.default, animateScroll: hue.default, ScrollLink: gue.default, ScrollElement: mue.default, Helpers: vue.default };
He({});
He({});
He({});
function Hg(e) {
  "@babel/helpers - typeof";
  return Hg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Hg(e);
}
function mZe(e, t) {
  if (Hg(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Hg(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function vZe(e) {
  var t = mZe(e, "string");
  return Hg(t) == "symbol" ? t : t + "";
}
function Be(e, t, n) {
  return (t = vZe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function yue(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var uP, L4;
function yZe() {
  if (L4) return uP;
  L4 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return uP = t, uP;
}
var bZe = yZe(), hi = /* @__PURE__ */ yue(bZe), Zt = He(null);
function wZe() {
  hi(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Zt);
  return hi(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function OZe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function CZe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function xZe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return CZe(e, i), o;
}
function LZe(e, t, n) {
  var r = OZe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function EZe(e) {
  google.maps.event.removeListener(e);
}
function zn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(EZe);
}
function Mn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = LZe(o, i, n);
  return xZe(t, r, o, i), a;
}
function kZe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = vt(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null), [A, K] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), K(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var B = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(B), B !== null && D && D(B), () => {
      B !== null && x && x(B);
    };
  }, []), vs.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: vs.jsx(Zt.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(kZe);
function E4(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function bue(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        E4(i, r, o, a, s, "next", l);
      }
      function s(l) {
        E4(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function wue(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return hi(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var bp = typeof document < "u";
function Oue(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return bp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function k4(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Cue() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return k4(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return k4(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var jf = !1;
function xue() {
  return vs.jsx("div", {
    children: "Loading..."
  });
}
var f_ = {
  id: "script-loader",
  version: "weekly"
};
class PZe extends pe {
  constructor() {
    super(...arguments), Be(this, "check", jn()), Be(this, "state", {
      loaded: !1
    }), Be(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Be(this, "isCleaningUp", /* @__PURE__ */ bue(function* () {
      function t(n) {
        if (!jf)
          n();
        else if (bp)
          var r = window.setInterval(function() {
            jf || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Be(this, "cleanup", () => {
      jf = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Be(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Cue(), hi(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: wue(this.props)
      };
      Oue(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (bp) {
      if (window.google && window.google.maps && !jf) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), bp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (bp) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, jf = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return vs.jsxs(vs.Fragment, {
      children: [vs.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || vs.jsx(xue, {})]
    });
  }
}
Be(PZe, "defaultProps", f_);
function SZe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function iB(e, t) {
  if (e == null) return {};
  var n, r, o = SZe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var P4;
function MZe(e) {
  var {
    id: t = f_.id,
    version: n = f_.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = vt(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    bp && u && Cue();
  }, [u]), h(function() {
    f && hi(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = wue({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!bp)
      return;
    function x() {
      y.current && (v(!0), P4 = w);
    }
    if (window.google && window.google.maps && P4 === w) {
      x();
      return;
    }
    Oue({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = vt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var DZe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], _Ze = vs.jsx(xue, {});
function TZe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = iB(e, DZe), {
    isLoaded: s,
    loadError: l
  } = MZe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || _Ze;
}
me(TZe);
var S4;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(S4 || (S4 = {}));
function M4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function n1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? M4(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : M4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var D4 = {}, _4 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function jZe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Zt), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(n1(n1({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(jZe);
class AZe extends pe {
  constructor() {
    super(...arguments), Be(this, "state", {
      trafficLayer: null
    }), Be(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Be(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(n1(n1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: _4,
      eventMap: D4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: _4,
      eventMap: D4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), zn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Be(AZe, "contextType", Zt);
function IZe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Zt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(IZe);
class BZe extends pe {
  constructor() {
    super(...arguments), Be(this, "state", {
      bicyclingLayer: null
    }), Be(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Be(BZe, "contextType", Zt);
function NZe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Zt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(NZe);
class RZe extends pe {
  constructor() {
    super(...arguments), Be(this, "state", {
      transitLayer: null
    }), Be(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Be(RZe, "contextType", Zt);
function T4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function r1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? T4(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : T4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var j4 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, A4 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function FZe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Zt), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    hi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(r1(r1({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && L(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && k(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(FZe);
class zZe extends pe {
  constructor(t) {
    super(t), Be(this, "registeredEvents", []), Be(this, "state", {
      drawingManager: null
    }), Be(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), hi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(r1(r1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: A4,
      eventMap: j4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: A4,
      eventMap: j4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), zn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Be(zZe, "contextType", Zt);
function I4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? I4(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : I4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var B4 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, N4 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, o1 = {};
function UZe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: R,
    onClickableChanged: N,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: H,
    onFlatChanged: X,
    onIconChanged: G,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, W = ge(Zt), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null), [re, Se] = E(null), [We, Ze] = E(null), [Me, rt] = E(null), [Ve, be] = E(null), [qe, ct] = E(null), [ye, xe] = E(null), [Ee, Ue] = E(null), [De, st] = E(null), [ve, wt] = E(null), [at, lt] = E(null), [pt, Ot] = E(null), [dt, Ct] = E(null), [Xe, ht] = E(null), [ot, xt] = E(null), [ft, Pt] = E(null), [Lt, St] = E(null), [Et, Mt] = E(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (re !== null && google.maps.event.removeListener(re), Se(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), Ze(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Me !== null && google.maps.event.removeListener(Me), rt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && R && (Ve !== null && google.maps.event.removeListener(Ve), be(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && L && (qe !== null && google.maps.event.removeListener(qe), ct(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (ye !== null && google.maps.event.removeListener(ye), xe(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && N && (Ee !== null && google.maps.event.removeListener(Ee), Ue(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && V && (De !== null && google.maps.event.removeListener(De), st(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), wt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && X && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(O, "flat_changed", X)));
  }, [X]), h(() => {
    O && G && (dt !== null && google.maps.event.removeListener(dt), Ct(google.maps.event.addListener(O, "icon_changed", G)));
  }, [G]), h(() => {
    O && Y && (Xe !== null && google.maps.event.removeListener(Xe), ht(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (ot !== null && google.maps.event.removeListener(ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (ft !== null && google.maps.event.removeListener(ft), Pt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Lt !== null && google.maps.event.removeListener(Lt), St(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (Et !== null && google.maps.event.removeListener(Et), Mt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var gt = cd(cd(cd({}, n || o1), r ? o1 : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(gt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof y < "u" && te.setOpacity(y), f && te.setShape(f), typeof v == "string" && te.setTitle(v), typeof b == "number" && te.setZIndex(b), w && j(google.maps.event.addListener(te, "dblclick", w)), x && A(google.maps.event.addListener(te, "dragend", x)), m && B(google.maps.event.addListener(te, "dragstart", m)), k && he(google.maps.event.addListener(te, "mousedown", k)), C && Se(google.maps.event.addListener(te, "mouseout", C)), S && Ze(google.maps.event.addListener(te, "mouseover", S)), U && rt(google.maps.event.addListener(te, "mouseup", U)), R && be(google.maps.event.addListener(te, "rightclick", R)), L && ct(google.maps.event.addListener(te, "click", L)), D && xe(google.maps.event.addListener(te, "drag", D)), N && Ue(google.maps.event.addListener(te, "clickable_changed", N)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), $ && wt(google.maps.event.addListener(te, "animation_changed", $)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), X && Ot(google.maps.event.addListener(te, "flat_changed", X)), G && Ct(google.maps.event.addListener(te, "icon_changed", G)), Y && ht(google.maps.event.addListener(te, "position_changed", Y)), Q && xt(google.maps.event.addListener(te, "shape_changed", Q)), J && Pt(google.maps.event.addListener(te, "title_changed", J)), P && St(google.maps.event.addListener(te, "visible_changed", P)), _ && Mt(google.maps.event.addListener(te, "zindex_changed", _)), I(te), z && z(te), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), re !== null && google.maps.event.removeListener(re), We !== null && google.maps.event.removeListener(We), Me !== null && google.maps.event.removeListener(Me), Ve !== null && google.maps.event.removeListener(Ve), qe !== null && google.maps.event.removeListener(qe), Ee !== null && google.maps.event.removeListener(Ee), De !== null && google.maps.event.removeListener(De), ve !== null && google.maps.event.removeListener(ve), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), Xe !== null && google.maps.event.removeListener(Xe), ft !== null && google.maps.event.removeListener(ft), Lt !== null && google.maps.event.removeListener(Lt), Et !== null && google.maps.event.removeListener(Et), M && M(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var _t = zt(() => i ? ut.map(i, (gt) => {
    if (!wi(gt))
      return gt;
    var te = gt;
    return Oi(te, {
      anchor: O
    });
  }) : null, [i, O]);
  return vs.jsx(vs.Fragment, {
    children: _t
  }) || null;
}
me(UZe);
class WZe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return bue(function* () {
      var n = cd(cd(cd({}, t.props.options || o1), t.props.clusterer ? o1 : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Mn({
        updaterMap: N4,
        eventMap: B4,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: N4,
      eventMap: B4,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), zn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Oi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Be(WZe, "contextType", Zt);
var HZe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), VZe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new HZe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function $Ze(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var ZZe = 2e3, qZe = 500, XZe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", KZe = "png", GZe = [53, 56, 66, 78, 90], YZe = "cluster", Lue = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || XZe, this.imageExtension = r.imageExtension || KZe, this.imageSizes = r.imageSizes || GZe, this.calculator = r.calculator || $Ze, this.batchSize = r.batchSize || ZZe, this.batchSizeIE = r.batchSizeIE || qZe, this.clusterClass = r.clusterClass || YZe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new VZe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function R4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function JZe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? R4(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : R4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ya = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Xn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, QZe = {};
function eqe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, R] = E(null), N = ge(Zt), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, ya.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, ya.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, ya.onClick, w)));
  }, [w]), h(() => {
    k && D && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(k, ya.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (G !== null && google.maps.event.removeListener(G), X(google.maps.event.addListener(k, ya.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && Xn.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && Xn.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && Xn.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && Xn.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && Xn.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && Xn.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && Xn.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && Xn.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && Xn.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && Xn.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && Xn.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && Xn.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && Xn.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && Xn.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && Xn.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (N) {
      var z = JZe({}, n || QZe), M = new Lue(N, [], z);
      return r && Xn.averageCenter(M, r), o && Xn.batchSizeIE(M, o), i && Xn.calculator(M, i), a && Xn.clusterClass(M, a), s && Xn.enableRetinaIcons(M, s), l && Xn.gridSize(M, l), u && Xn.ignoreHidden(M, u), c && Xn.imageExtension(M, c), p && Xn.imagePath(M, p), d && Xn.imageSizes(M, d), y && Xn.maxZoom(M, y), f && Xn.minimumClusterSize(M, f), v && Xn.styles(M, v), b && Xn.title(M, b), L && Xn.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, ya.onMouseOut, C)), m && _(google.maps.event.addListener(M, ya.onMouseOver, m)), w && $(google.maps.event.addListener(M, ya.onClick, w)), D && X(google.maps.event.addListener(M, ya.onClusteringBegin, D)), x && Y(google.maps.event.addListener(M, ya.onClusteringEnd, x)), R(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(eqe);
class tqe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      markerClusterer: null
    }), Be(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Lue(this.context, [], this.props.options);
      this.registeredEvents = Mn({
        updaterMap: Xn,
        eventMap: ya,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: Xn,
      eventMap: ya,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), zn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Be(tqe, "contextType", Zt);
function F4(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Eue = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || F4(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, F4));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), nqe = ["position"], rqe = ["position"];
function z4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function i1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? z4(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : z4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var U4 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, W4 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, oqe = {};
function iqe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Zt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var N = r || oqe, {
        position: V
      } = N, $ = iB(N, nqe), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var X = new Eue(i1(i1({}, $), H ? {
        position: H
      } : {}));
      R.current = document.createElement("div"), v(X), a && L(google.maps.event.addListener(X, "closeclick", a)), s && D(google.maps.event.addListener(X, "domready", s)), l && m(google.maps.event.addListener(X, "content_changed", l)), u && S(google.maps.event.addListener(X, "position_changed", u)), c && k(google.maps.event.addListener(X, "zindex_changed", c)), X.setContent(R.current), n ? X.open(y, n) : X.getPosition() ? X.open(y) : hi(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(X);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(iqe);
class sqe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "containerElement", null), Be(this, "state", {
      infoBox: null
    }), Be(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : hi(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Be(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = iB(t, rqe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Eue(i1(i1({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Mn({
      updaterMap: W4,
      eventMap: U4,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: W4,
      eventMap: U4,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), zn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
Be(sqe, "contextType", Zt);
var H4, V4;
function aqe() {
  return V4 || (V4 = 1, H4 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), H4;
}
var lqe = aqe(), $4 = /* @__PURE__ */ yue(lqe), Z4 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], cP = 1, Af = 8;
class sB {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== cP)
      throw new Error("Got v".concat(o, " data when expected v").concat(cP, "."));
    var i = Z4[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new sB(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = Z4.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Af, t), this.coords = new this.ArrayType(this.data, Af + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Af + a + s + l), this.ids = new this.IndexArrayType(this.data, Af, t), this.coords = new this.ArrayType(this.data, Af + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (cP << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return h_(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          q4(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      q4(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function h_(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    kue(e, t, a, r, o, i), h_(e, t, n, r, a - 1, 1 - i), h_(e, t, n, a + 1, o, 1 - i);
  }
}
function kue(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      kue(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (If(e, t, r, n), t[2 * o + i] > y && If(e, t, r, o); f < v; ) {
      for (If(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? If(e, t, r, v) : (v++, If(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function If(e, t, n, r) {
  pP(e, n, r), pP(t, 2 * n, 2 * r), pP(t, 2 * n + 1, 2 * r + 1);
}
function pP(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function q4(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var uqe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, X4 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), zc = 2, Nu = 3, dP = 4, Su = 5, Pue = 6;
class cqe {
  constructor(t) {
    this.options = Object.assign(Object.create(uqe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = X4(ob(u)), d = X4(ib(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(ob(r), ib(a), ob(i), ib(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Su] > 1 ? K4(p, f, this.clusterProps) : this.points[p[f + Nu]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + dP] === t && p.push(a[y + Su] > 1 ? K4(a, y, this.clusterProps) : this.points[a[y + Nu]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new sB(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Su] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Sue(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Nu]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = ob(f), d = ib(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + Nu] : L = this.points[n[l + Nu]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + zc] <= n)) {
        l[p + zc] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Su], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + zc] > n && (b += l[w + Su]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + zc] <= n)) {
              l[k + zc] = n;
              var R = l[k + Su];
              D += l[k] * R, x += l[k + 1] * R, l[k + dP] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + dP] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + zc] <= n)) {
                l[$ + zc] = n;
                for (var H = 0; H < c; H++) u.push(l[$ + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Su] > 1) {
      var o = this.clusterProps[t[n + Pue]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Nu]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function K4(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Nu],
    properties: Sue(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [pqe(e[t]), dqe(e[t + 1])]
    }
  };
}
function Sue(e, t, n) {
  var r = e[t + Su], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Pue], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Nu],
    point_count: r,
    point_count_abbreviated: o
  });
}
function ob(e) {
  return e / 360 + 0.5;
}
function ib(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function pqe(e) {
  return (e - 0.5) * 360;
}
function dqe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function fqe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Vs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class g_ {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Vs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Vs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Vs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class hqe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return gqe(n);
  }
}
var gqe = (e) => {
  var t = e.map((n) => new g_({
    position: Vs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class mqe extends hqe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = fqe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new cqe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!$4(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Vs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !$4(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new g_({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new g_({
      markers: [i],
      position: Vs.getPosition(i)
    });
  }
}
class vqe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class yqe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Vs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function bqe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class aB {
  constructor() {
    bqe(aB, google.maps.OverlayView);
  }
}
var Uh;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Uh || (Uh = {}));
var wqe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Oqe extends aB {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new mqe(o),
      renderer: a = new yqe(),
      onClusterClick: s = wqe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Vs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Uh.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Vs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Vs.setMap(l, null)));
      }
      google.maps.event.trigger(this, Uh.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Vs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new vqe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Vs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Uh.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Vs.setMap(r.marker, n);
    });
  }
}
function G4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Y4(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G4(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Cqe(e) {
  var t = wZe(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new Oqe(Y4(Y4({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function xqe(e) {
  var {
    children: t,
    options: n
  } = e, r = Cqe(n);
  return r !== null ? t(r) : null;
}
me(xqe);
var J4 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Q4 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Lqe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Zt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return v(N), R.current = document.createElement("div"), a && L(google.maps.event.addListener(N, "closeclick", a)), s && D(google.maps.event.addListener(N, "domready", s)), l && m(google.maps.event.addListener(N, "content_changed", l)), u && S(google.maps.event.addListener(N, "position_changed", u)), c && k(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(R.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(y, n) : N.getPosition() ? N.open(y) : hi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(N), N.close();
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(Lqe);
class Eqe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "containerElement", null), Be(this, "state", {
      infoWindow: null
    }), Be(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : hi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Be(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Mn({
      updaterMap: Q4,
      eventMap: J4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: Q4,
      eventMap: J4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (zn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
Be(Eqe, "contextType", Zt);
function eZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function s1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eZ(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tZ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, nZ = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, kqe = {};
function Pqe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(Zt), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var j = new google.maps.Polyline(s1(s1({}, t || kqe), {}, {
      map: D
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && S(google.maps.event.addListener(j, "dblclick", a)), s && k(google.maps.event.addListener(j, "dragend", s)), l && N(google.maps.event.addListener(j, "dragstart", l)), u && $(google.maps.event.addListener(j, "mousedown", u)), c && X(google.maps.event.addListener(j, "mousemove", c)), p && Y(google.maps.event.addListener(j, "mouseout", p)), d && J(google.maps.event.addListener(j, "mouseover", d)), y && _(google.maps.event.addListener(j, "mouseup", y)), f && M(google.maps.event.addListener(j, "rightclick", f)), v && O(google.maps.event.addListener(j, "click", v)), b && F(google.maps.event.addListener(j, "drag", b)), m(j), L && L(j), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
me(Pqe);
class Sqe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      polyline: null
    }), Be(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(s1(s1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: nZ,
      eventMap: tZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: nZ,
      eventMap: tZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), zn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Be(Sqe, "contextType", Zt);
function rZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oZ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rZ(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var iZ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, sZ = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Mqe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Zt), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var A = new google.maps.Polygon(oZ(oZ({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && k(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && $(google.maps.event.addListener(A, "dragstart", u)), c && X(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), b && F(google.maps.event.addListener(A, "click", b)), L && q(google.maps.event.addListener(A, "drag", L)), S(A), w && w(A), () => {
      U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), D && D(A), A.setMap(null);
    };
  }, []), null;
}
me(Mqe);
class Dqe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Mn({
      updaterMap: sZ,
      eventMap: iZ,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: sZ,
      eventMap: iZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), zn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Be(Dqe, "contextType", Zt);
function aZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function a1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aZ(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lZ = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, uZ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function _qe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Zt), [m, C] = E(null), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var K = new google.maps.Rectangle(a1(a1({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && K.setVisible(i), typeof o < "u" && K.setEditable(o), typeof r < "u" && K.setDraggable(r), typeof n < "u" && K.setBounds(n), a && U(google.maps.event.addListener(K, "dblclick", a)), s && R(google.maps.event.addListener(K, "dragend", s)), l && V(google.maps.event.addListener(K, "dragstart", l)), u && H(google.maps.event.addListener(K, "mousedown", u)), c && G(google.maps.event.addListener(K, "mousemove", c)), p && Q(google.maps.event.addListener(K, "mouseout", p)), d && P(google.maps.event.addListener(K, "mouseover", d)), y && z(google.maps.event.addListener(K, "mouseup", y)), f && W(google.maps.event.addListener(K, "rightclick", f)), v && I(google.maps.event.addListener(K, "click", v)), b && j(google.maps.event.addListener(K, "drag", b)), L && A(google.maps.event.addListener(K, "bounds_changed", L)), C(K), w && w(K), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(K), K.setMap(null);
    };
  }, []), null;
}
me(_qe);
class Tqe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      rectangle: null
    }), Be(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(a1(a1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: uZ,
      eventMap: lZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: uZ,
      eventMap: lZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), zn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Be(Tqe, "contextType", Zt);
function cZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function l1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cZ(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pZ = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, dZ = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, jqe = {};
function Aqe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Zt), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var re = new google.maps.Circle(l1(l1({}, t || jqe), {}, {
      map: C
    }));
    return typeof r == "number" && re.setRadius(r), typeof n < "u" && re.setCenter(n), typeof r == "number" && re.setRadius(r), typeof a < "u" && re.setVisible(a), typeof i < "u" && re.setEditable(i), typeof o < "u" && re.setDraggable(o), s && R(google.maps.event.addListener(re, "dblclick", s)), l && V(google.maps.event.addListener(re, "dragend", l)), u && H(google.maps.event.addListener(re, "dragstart", u)), c && G(google.maps.event.addListener(re, "mousedown", c)), p && Q(google.maps.event.addListener(re, "mousemove", p)), d && P(google.maps.event.addListener(re, "mouseout", d)), y && z(google.maps.event.addListener(re, "mouseover", y)), f && W(google.maps.event.addListener(re, "mouseup", f)), v && I(google.maps.event.addListener(re, "rightclick", v)), b && j(google.maps.event.addListener(re, "click", b)), L && A(google.maps.event.addListener(re, "drag", L)), w && B(google.maps.event.addListener(re, "center_changed", w)), D && he(google.maps.event.addListener(re, "radius_changed", D)), U(re), x && x(re), () => {
      k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), m && m(re), re.setMap(null);
    };
  }, []), null;
}
me(Aqe);
class Iqe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      circle: null
    }), Be(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(l1(l1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: dZ,
      eventMap: pZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: dZ,
      eventMap: pZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), zn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Be(Iqe, "contextType", Zt);
function fZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function u1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fZ(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hZ = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, gZ = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Bqe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(Zt), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var A = new google.maps.Data(u1(u1({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && k(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && $(google.maps.event.addListener(A, "mouseover", s)), l && X(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && q(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), j !== null && google.maps.event.removeListener(j), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(Bqe);
class Nqe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      data: null
    }), Be(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(u1(u1({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Mn({
        updaterMap: gZ,
        eventMap: hZ,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: gZ,
      eventMap: hZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), zn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Be(Nqe, "contextType", Zt);
function mZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vZ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mZ(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yZ = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, bZ = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class Rqe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      kmlLayer: null
    }), Be(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(vZ(vZ({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: bZ,
      eventMap: yZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: bZ,
      eventMap: yZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), zn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Be(Rqe, "contextType", Zt);
function Mue(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Fqe(e, t) {
  return new t(e.lat, e.lng);
}
function zqe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Uqe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Wqe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Hqe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Vqe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Due(e, t, n, r) {
  return n !== void 0 ? Hqe(e, t, Wqe(n, google.maps.LatLngBounds, zqe)) : Vqe(e, t, Uqe(r, google.maps.LatLng, Fqe));
}
function $qe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function wZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zqe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wZ(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function qqe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = Zqe({}, this.container ? Mue(this.container, o) : {
        x: 0,
        y: 0
      }), u = Due(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function OZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xqe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OZ(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function CZ(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function xZ(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Kqe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Zt), c = zt(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = zt(() => qqe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
me(Kqe);
class Zd extends pe {
  constructor(t) {
    super(t), Be(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Be(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      hi(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Be(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Be(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Xqe({
        x: 0,
        y: 0
      }, this.containerRef.current ? Mue(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Due(r, o, this.props.bounds, this.props.position);
      if (!$qe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Be(this, "draw", () => {
      this.onPositionElement();
    }), Be(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = jn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = CZ(t.position), r = CZ(this.props.position), o = xZ(t.bounds), i = xZ(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(vs.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
Be(Zd, "FLOAT_PANE", "floatPane");
Be(Zd, "MAP_PANE", "mapPane");
Be(Zd, "MARKER_LAYER", "markerLayer");
Be(Zd, "OVERLAY_LAYER", "overlayLayer");
Be(Zd, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Be(Zd, "contextType", Zt);
function Gqe() {
}
function LZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function EZ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LZ(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kZ = {
  onDblClick: "dblclick",
  onClick: "click"
}, PZ = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Yqe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Zt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = zt(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(Yqe);
class _ue extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      groundOverlay: null
    }), Be(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    hi(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, EZ(EZ({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: PZ,
      eventMap: kZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: PZ,
      eventMap: kZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Be(_ue, "defaultProps", {
  onLoad: Gqe
});
Be(_ue, "contextType", Zt);
function SZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function c1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SZ(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var MZ = {}, DZ = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Jqe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Zt), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || hi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    hi(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(c1(c1({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(Jqe);
class Qqe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      heatmapLayer: null
    }), Be(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    hi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), hi(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(c1(c1({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: DZ,
      eventMap: MZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: DZ,
      eventMap: MZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), zn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Be(Qqe, "contextType", Zt);
var _Z = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, TZ = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class e7e extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      streetViewPanorama: null
    }), Be(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Mn({
      updaterMap: TZ,
      eventMap: _Z,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: TZ,
      eventMap: _Z,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), zn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Be(e7e, "contextType", Zt);
class t7e extends pe {
  constructor() {
    super(...arguments), Be(this, "state", {
      streetViewService: null
    }), Be(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Be(t7e, "contextType", Zt);
var jZ = {
  onDirectionsChanged: "directions_changed"
}, AZ = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class n7e extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      directionsRenderer: null
    }), Be(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Mn({
      updaterMap: AZ,
      eventMap: jZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: AZ,
      eventMap: jZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), zn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Be(n7e, "contextType", Zt);
var IZ = {
  onPlacesChanged: "places_changed"
}, BZ = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class r7e extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "containerElement", jn()), Be(this, "state", {
      searchBox: null
    }), Be(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (hi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Mn({
          updaterMap: BZ,
          eventMap: IZ,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: BZ,
      eventMap: IZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), zn(this.registeredEvents));
  }
  render() {
    return vs.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
Be(r7e, "contextType", Zt);
var NZ = {
  onPlaceChanged: "place_changed"
}, RZ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class Tue extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "containerElement", jn()), Be(this, "state", {
      autocomplete: null
    }), Be(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    hi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Mn({
        updaterMap: RZ,
        eventMap: NZ,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    zn(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: RZ,
      eventMap: NZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && zn(this.registeredEvents);
  }
  render() {
    return vs.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
Be(Tue, "defaultProps", {
  className: ""
});
Be(Tue, "contextType", Zt);
let o7e = { data: "" }, i7e = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || o7e, s7e = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, a7e = /\/\*[^]*?\*\/|  +/g, FZ = /\n+/g, Xu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Xu(a, i) : i + "{" + Xu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Xu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Xu.p ? Xu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, El = {}, jue = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + jue(e[n]);
    return t;
  }
  return e;
}, l7e = (e, t, n, r, o) => {
  let i = jue(e), a = El[i] || (El[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!El[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = s7e.exec(u.replace(a7e, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(FZ, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(FZ, " ").trim();
      return d[0];
    })(e);
    El[a] = Xu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && El.g ? El.g : null;
  return n && (El.g = El[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(El[a], t, r, s), a;
}, u7e = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Xu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Xx(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return l7e(n.unshift ? n.raw ? u7e(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, i7e(t.target), t.g, t.o, t.k);
}
let Aue, m_, v_;
Xx.bind({ g: 1 });
let Vl = Xx.bind({ k: 1 });
function c7e(e, t, n, r) {
  Xu.p = t, Aue = e, m_ = n, v_ = r;
}
function Ec(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: m_ && m_() }, s), n.o = / *go\d+/.test(l), s.className = Xx.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), v_ && u[0] && v_(s), Aue(u, s);
    }
    return o;
  };
}
var p7e = (e) => typeof e == "function", d7e = (e, t) => p7e(e) ? e(t) : e, f7e = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), h7e = Vl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, g7e = Vl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, m7e = Vl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, v7e = Ec("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${h7e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${g7e} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${m7e} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, y7e = Vl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, b7e = Ec("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${y7e} 1s linear infinite;
`, w7e = Vl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, O7e = Vl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, C7e = Ec("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${w7e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${O7e} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, x7e = Ec("div")`
  position: absolute;
`, L7e = Ec("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, E7e = Vl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, k7e = Ec("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${E7e} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, P7e = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? _e.createElement(k7e, null, t) : t : n === "blank" ? null : _e.createElement(L7e, null, _e.createElement(b7e, { ...r }), n !== "loading" && _e.createElement(x7e, null, n === "error" ? _e.createElement(v7e, { ...r }) : _e.createElement(C7e, { ...r })));
}, S7e = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, M7e = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, D7e = "0%{opacity:0;} 100%{opacity:1;}", _7e = "0%{opacity:1;} 100%{opacity:0;}", T7e = Ec("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, j7e = Ec("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, A7e = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = f7e() ? [D7e, _7e] : [S7e(n), M7e(n)];
  return { animation: t ? `${Vl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Vl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
_e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? A7e(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = _e.createElement(P7e, { toast: e }), a = _e.createElement(j7e, { ...e.ariaProps }, d7e(e.message, e));
  return _e.createElement(T7e, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : _e.createElement(_e.Fragment, null, i, a));
});
c7e(_e.createElement);
Xx`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
He({});
function I7e(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const B7e = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
I7e(B7e.CNPJ).length;
ka((e, t) => /* @__PURE__ */ ms.jsx("input", { ref: t, ...e }));
He({});
var tu = {};
Object.defineProperty(tu, "__esModule", {
  value: !0
});
var N7e = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), fP = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Iue = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: N7e ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, lB = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var sb = 1; sb < 20; sb++)
  lB["f" + sb] = 111 + sb;
function Kx(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Bue(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Nue(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function R7e(e, t) {
  return Kx(e, t);
}
function F7e(e, t) {
  return Kx(e, { byKey: !0 }, t);
}
function Bue(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in fP)
    r[fP[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = uB(d), v = fP[f];
      if (d.length > 1 && !v && !Iue[d] && !lB[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = Rue(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Nue(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Rue(e) {
  e = uB(e);
  var t = lB[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function uB(e) {
  return e = e.toLowerCase(), e = Iue[e] || e, e;
}
tu.default = Kx;
var hP = tu.isHotkey = Kx;
tu.isCodeHotkey = R7e;
tu.isKeyHotkey = F7e;
tu.parseHotkey = Bue;
tu.compareHotkey = Nue;
tu.toKeyCode = Rue;
tu.toKeyName = uB;
var z7e = typeof Dr == "object" && Dr && Dr.Object === Object && Dr, U7e = z7e, W7e = U7e, H7e = typeof self == "object" && self && self.Object === Object && self, V7e = W7e || H7e || Function("return this")(), $7e = V7e, Z7e = $7e, q7e = Z7e.Symbol, Fue = q7e, zZ = Fue;
zZ && zZ.toStringTag;
var UZ = Fue;
UZ && UZ.toStringTag;
var WZ;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(WZ || (WZ = {}));
var cB = function(e) {
  return Object.freeze(e);
}, X7e = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, cB(this);
  }
  return e;
}(), K7e = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, cB(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), HZ = typeof window < "u" ? window : {};
/msie|trident/i.test(HZ.navigator && HZ.navigator.userAgent);
var gP = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new X7e((n ? t : e) || 0, (n ? e : t) || 0);
};
cB({
  devicePixelContentBoxSize: gP(),
  borderBoxSize: gP(),
  contentBoxSize: gP(),
  contentRect: new K7e(0, 0, 0, 0)
});
function Vg(e) {
  "@babel/helpers - typeof";
  return Vg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Vg(e);
}
function G7e(e, t) {
  if (Vg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Vg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Y7e(e) {
  var t = G7e(e, "string");
  return Vg(t) === "symbol" ? t : String(t);
}
function Wh(e, t, n) {
  return t = Y7e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var J7e = /* @__PURE__ */ He(null), mP, vP;
parseInt(Oe.version.split(".")[0], 10);
var VZ = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), yP = typeof navigator < "u" && /Android/.test(navigator.userAgent), ab = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Q7e = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (mP = navigator.userAgent.match(/Version\/(\d+)/)) !== null && mP !== void 0 && mP[1] && parseInt((vP = navigator.userAgent.match(/Version\/(\d+)/)) === null || vP === void 0 ? void 0 : vP[1], 10) < 17;
var eXe = /* @__PURE__ */ new WeakMap(), tXe = /* @__PURE__ */ new WeakMap(), nXe = /* @__PURE__ */ new WeakMap(), rXe = /* @__PURE__ */ new WeakMap(), oXe = /* @__PURE__ */ new WeakMap(), $Z = /* @__PURE__ */ new WeakMap(), iXe = /* @__PURE__ */ new WeakMap(), ZZ = /* @__PURE__ */ new WeakMap(), lb = /* @__PURE__ */ new WeakMap(), sXe = /* @__PURE__ */ new WeakMap(), aXe = /* @__PURE__ */ new WeakMap(), lXe = /* @__PURE__ */ new WeakMap(), zue = globalThis.Node, uXe = globalThis.Text, Uue = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, cXe = (e) => p1(e) && e.nodeType === 8, Ja = (e) => p1(e) && e.nodeType === 1, p1 = (e) => {
  var t = Uue(e);
  return !!t && e instanceof t.Node;
}, qZ = (e) => {
  var t = e && e.anchorNode && Uue(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, pXe = (e) => {
  var [t, n] = e;
  if (Ja(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Wue(t, o, r ? "backward" : "forward"), r = o < n; Ja(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = fXe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, dXe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Wue = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (cXe(o) || Ja(o) && o.childNodes.length === 0 || Ja(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, fXe = (e, t, n) => {
  var [r] = Wue(e, t, n);
  return r;
}, XZ = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Hue = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ja(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Cn.getWindow(e);
  if (o.contains(r))
    return Cn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Hue(e, i, n);
}, KZ = (e, t) => !!(e.compareDocumentPosition(t) & zue.DOCUMENT_POSITION_PRECEDING), hXe = (e, t) => !!(e.compareDocumentPosition(t) & zue.DOCUMENT_POSITION_FOLLOWING), gXe = 0;
class mXe {
  constructor() {
    Wh(this, "id", void 0), this.id = "".concat(gXe++);
  }
}
var Cn = {
  androidPendingDiffs: (e) => lXe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = aXe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Cn.toDOMNode(e, e), n = Cn.findDocumentOrShadowRoot(e);
    lb.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Cn.findDocumentOrShadowRoot(e), r = XZ(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && N0.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Cn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Cn.toSlateNode(e, t.target), a = Cn.findPath(e, i);
    if (Tl.isElement(i) && Or.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Or.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Or.before(e, u) : Or.after(e, u);
      if (c) {
        var p = Or.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = Cn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = Cn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = $Z.get(t);
    return n || (n = new mXe(), $Z.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = tXe.get(r);
      if (o == null) {
        if (Or.isEditor(r))
          return n;
        break;
      }
      var i = eXe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(As.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!lb.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Cn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Cn.toDOMNode(e, e), r = Cn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = XZ(r), i = Cn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || N0.select(e, Or.start(e, [])), lb.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = nXe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Cn.toDOMNode(e, e), i;
    try {
      i = Ja(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => p1(t) && Cn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Or.hasPath(e, n.path) && Or.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Cn.hasEditableTarget(e, t) || Cn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => p1(t) && Cn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!sXe.get(e),
  isFocused: (e) => !!lb.get(e),
  isReadOnly: (e) => !!ZZ.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (ZZ.get(e)) return !1;
    var n = Cn.hasTarget(e, t) && Cn.toSlateNode(e, t);
    return Tl.isElement(n) && Or.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = iXe.get(e), r = Or.isEditor(t) ? rXe.get(e) : n == null ? void 0 : n.get(Cn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(As.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Or.node(e, t.path), r = Cn.toDOMNode(e, n), o;
    Or.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof uXe ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(As.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Qt.isBackward(t), i = Cn.toDOMPoint(e, n), a = Qt.isCollapsed(t) ? i : Cn.toDOMPoint(e, r), s = Cn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = Ja(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = Ja(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ja(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? oXe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : pXe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = Cn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = Cn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (yP && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var R = U[k];
          if (Cn.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var N = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, H = [...N(V), ...N(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = H.find((M) => hXe(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var X, G = [...N(V == null ? void 0 : V.previousElementSibling), ...N(V)];
          w = (X = G.findLast((M) => KZ(L, M))) !== null && X !== void 0 ? X : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      yP && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      ab && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (yP && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && Cn.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = Cn.toSlateNode(e, Y), {
          path: J,
          offset: P
        } = Or.start(e, Cn.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = Cn.toSlateNode(e, u), z = Cn.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = qZ(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (qZ(t)) {
        if (ab && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Q7e && dXe(s) || ab ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    ab && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Cn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = KZ(s, u) || s === u && c < l, x = p ? w : Cn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Qt.isExpanded(m) && Qt.isForward(m) && Ja(u) && Or.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = Or.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, vXe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, yXe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, bXe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, wo = (e) => {
  var t = vXe[e], n = yXe[e], r = bXe[e], o = t && hP(t), i = n && hP(n), a = r && hP(r);
  return (s) => !!(o && o(s) || VZ && i && i(s) || !VZ && a && a(s));
};
wo("bold"), wo("compose"), wo("moveBackward"), wo("moveForward"), wo("deleteBackward"), wo("deleteForward"), wo("deleteLineBackward"), wo("deleteLineForward"), wo("deleteWordBackward"), wo("deleteWordForward"), wo("extendBackward"), wo("extendForward"), wo("extendLineBackward"), wo("extendLineForward"), wo("italic"), wo("moveLineBackward"), wo("moveLineForward"), wo("moveWordBackward"), wo("moveWordForward"), wo("redo"), wo("insertSoftBreak"), wo("splitBlock"), wo("transposeCharacter"), wo("undo");
var wXe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Hue(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, OXe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class CXe extends Kl {
  constructor() {
    super(...arguments), Wh(this, "context", null), Wh(this, "manager", null), Wh(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, OXe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = wXe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Wh(CXe, "contextType", J7e);
He({});
He({});
He({});
var si = {}, pB = {}, Bm = {}, Nm = {}, Vue = "Expected a function", GZ = NaN, xXe = "[object Symbol]", LXe = /^\s+|\s+$/g, EXe = /^[-+]0x[0-9a-f]+$/i, kXe = /^0b[01]+$/i, PXe = /^0o[0-7]+$/i, SXe = parseInt, MXe = typeof Dr == "object" && Dr && Dr.Object === Object && Dr, DXe = typeof self == "object" && self && self.Object === Object && self, _Xe = MXe || DXe || Function("return this")(), TXe = Object.prototype, jXe = TXe.toString, AXe = Math.max, IXe = Math.min, bP = function() {
  return _Xe.Date.now();
};
function BXe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Vue);
  t = YZ(t) || 0, d1(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? AXe(YZ(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? IXe(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = bP();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(bP());
  }
  function m() {
    var C = bP(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function NXe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Vue);
  return d1(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), BXe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function d1(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function RXe(e) {
  return !!e && typeof e == "object";
}
function FXe(e) {
  return typeof e == "symbol" || RXe(e) && jXe.call(e) == xXe;
}
function YZ(e) {
  if (typeof e == "number")
    return e;
  if (FXe(e))
    return GZ;
  if (d1(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = d1(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(LXe, "");
  var n = kXe.test(e);
  return n || PXe.test(e) ? SXe(e.slice(2), n ? 2 : 8) : EXe.test(e) ? GZ : +e;
}
var zXe = NXe, Rm = {};
Object.defineProperty(Rm, "__esModule", {
  value: !0
});
Rm.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), s0.has(t) || s0.set(t, /* @__PURE__ */ new Set());
  var o = s0.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Rm.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), s0.get(t).delete(n.name || t);
};
var s0 = /* @__PURE__ */ new Map();
Object.defineProperty(Nm, "__esModule", {
  value: !0
});
var UXe = zXe, WXe = VXe(UXe), HXe = Rm;
function VXe(e) {
  return e && e.__esModule ? e : { default: e };
}
var $Xe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, WXe.default)(e, t);
}, Ao = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = $Xe(function(r) {
        Ao.scrollHandler(e);
      }, t);
      Ao.scrollSpyContainers.push(e), (0, HXe.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return Ao.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Ao.scrollSpyContainers[Ao.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Ao.currentPositionX(e), Ao.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Ao.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Ao.scrollSpyContainers[Ao.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(Ao.currentPositionX(t), Ao.currentPositionY(t));
  },
  updateStates: function() {
    Ao.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Ao.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Ao.spySetState && Ao.spySetState.length && Ao.spySetState.indexOf(e) > -1 && Ao.spySetState.splice(Ao.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Ao.scrollHandler);
  },
  update: function() {
    return Ao.scrollSpyContainers.forEach(function(e) {
      return Ao.scrollHandler(e);
    });
  }
};
Nm.default = Ao;
var qd = {}, Fm = {};
Object.defineProperty(Fm, "__esModule", {
  value: !0
});
var ZXe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, qXe = function() {
  return window.location.hash.replace(/^#/, "");
}, XXe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, KXe = function(e) {
  return getComputedStyle(e).position !== "static";
}, wP = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, GXe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (KXe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = wP(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return wP(t, s).offsetTop - wP(e, s).offsetTop;
};
Fm.default = {
  updateHash: ZXe,
  getHash: qXe,
  filterElementInContainer: XXe,
  scrollOffset: GXe
};
var Gx = {}, dB = {};
Object.defineProperty(dB, "__esModule", {
  value: !0
});
dB.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var fB = {};
Object.defineProperty(fB, "__esModule", {
  value: !0
});
var YXe = Rm, JXe = ["mousedown", "mousewheel", "touchmove", "keydown"];
fB.default = {
  subscribe: function(e) {
    return typeof document < "u" && JXe.forEach(function(t) {
      return (0, YXe.addPassiveEventListener)(document, t, e);
    });
  }
};
var zm = {};
Object.defineProperty(zm, "__esModule", {
  value: !0
});
var y_ = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      y_.registered[e] = t;
    },
    remove: function(e) {
      y_.registered[e] = null;
    }
  }
};
zm.default = y_;
Object.defineProperty(Gx, "__esModule", {
  value: !0
});
var QXe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, eKe = Fm;
Yx(eKe);
var tKe = dB, JZ = Yx(tKe), nKe = fB, rKe = Yx(nKe), oKe = zm, Ha = Yx(oKe);
function Yx(e) {
  return e && e.__esModule ? e : { default: e };
}
var $ue = function(e) {
  return JZ.default[e.smooth] || JZ.default.defaultEasing;
}, iKe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, sKe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, b_ = function() {
  return sKe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Zue = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, que = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Xue = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, aKe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, lKe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, uKe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Ha.default.registered.end && Ha.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    b_.call(window, i);
    return;
  }
  Ha.default.registered.end && Ha.default.registered.end(o.to, o.target, o.currentPosition);
}, hB = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Um = function(e, t, n, r) {
  t.data = t.data || Zue(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (rKe.default.subscribe(o), hB(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? que(t) : Xue(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Ha.default.registered.end && Ha.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = iKe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = $ue(t), a = uKe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Ha.default.registered.begin && Ha.default.registered.begin(t.data.to, t.data.target), b_.call(window, a);
    }, t.delay);
    return;
  }
  Ha.default.registered.begin && Ha.default.registered.begin(t.data.to, t.data.target), b_.call(window, a);
}, Jx = function(e) {
  return e = QXe({}, e), e.data = e.data || Zue(), e.absolute = !0, e;
}, cKe = function(e) {
  Um(0, Jx(e));
}, pKe = function(e, t) {
  Um(e, Jx(t));
}, dKe = function(e) {
  e = Jx(e), hB(e), Um(e.horizontal ? aKe(e) : lKe(e), e);
}, fKe = function(e, t) {
  t = Jx(t), hB(t);
  var n = t.horizontal ? que(t) : Xue(t);
  Um(e + n, t);
};
Gx.default = {
  animateTopScroll: Um,
  getAnimationType: $ue,
  scrollToTop: cKe,
  scrollToBottom: dKe,
  scrollTo: pKe,
  scrollMore: fKe
};
Object.defineProperty(qd, "__esModule", {
  value: !0
});
var hKe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, gKe = Fm, mKe = gB(gKe), vKe = Gx, yKe = gB(vKe), bKe = zm, ub = gB(bKe);
function gB(e) {
  return e && e.__esModule ? e : { default: e };
}
var cb = {}, QZ = void 0;
qd.default = {
  unmount: function() {
    cb = {};
  },
  register: function(e, t) {
    cb[e] = t;
  },
  unregister: function(e) {
    delete cb[e];
  },
  get: function(e) {
    return cb[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return QZ = e;
  },
  getActiveLink: function() {
    return QZ;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = hKe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = mKe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      ub.default.registered.begin && ub.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, ub.default.registered.end && ub.default.registered.end(e, n);
      return;
    }
    yKe.default.animateTopScroll(s, t, e, n);
  }
};
var w_ = { exports: {} }, OP = { exports: {} }, or = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var eq;
function wKe() {
  if (eq) return or;
  eq = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return or.AsyncMode = l, or.ConcurrentMode = u, or.ContextConsumer = s, or.ContextProvider = a, or.Element = t, or.ForwardRef = c, or.Fragment = r, or.Lazy = f, or.Memo = y, or.Portal = n, or.Profiler = i, or.StrictMode = o, or.Suspense = p, or.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, or.isConcurrentMode = x, or.isContextConsumer = function(m) {
    return D(m) === s;
  }, or.isContextProvider = function(m) {
    return D(m) === a;
  }, or.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, or.isForwardRef = function(m) {
    return D(m) === c;
  }, or.isFragment = function(m) {
    return D(m) === r;
  }, or.isLazy = function(m) {
    return D(m) === f;
  }, or.isMemo = function(m) {
    return D(m) === y;
  }, or.isPortal = function(m) {
    return D(m) === n;
  }, or.isProfiler = function(m) {
    return D(m) === i;
  }, or.isStrictMode = function(m) {
    return D(m) === o;
  }, or.isSuspense = function(m) {
    return D(m) === p;
  }, or.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, or.typeOf = D, or;
}
var gr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tq;
function OKe() {
  return tq || (tq = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === y || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === L || B.$$typeof === w || B.$$typeof === v);
    }
    function x(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var re = he && he.$$typeof;
                switch (re) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return re;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, R = c, N = r, V = f, $ = y, H = n, X = i, G = o, Y = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || x(B) === l;
    }
    function P(B) {
      return x(B) === u;
    }
    function _(B) {
      return x(B) === s;
    }
    function z(B) {
      return x(B) === a;
    }
    function M(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return x(B) === c;
    }
    function O(B) {
      return x(B) === r;
    }
    function I(B) {
      return x(B) === f;
    }
    function F(B) {
      return x(B) === y;
    }
    function j(B) {
      return x(B) === n;
    }
    function q(B) {
      return x(B) === i;
    }
    function A(B) {
      return x(B) === o;
    }
    function K(B) {
      return x(B) === p;
    }
    gr.AsyncMode = m, gr.ConcurrentMode = C, gr.ContextConsumer = S, gr.ContextProvider = U, gr.Element = k, gr.ForwardRef = R, gr.Fragment = N, gr.Lazy = V, gr.Memo = $, gr.Portal = H, gr.Profiler = X, gr.StrictMode = G, gr.Suspense = Y, gr.isAsyncMode = J, gr.isConcurrentMode = P, gr.isContextConsumer = _, gr.isContextProvider = z, gr.isElement = M, gr.isForwardRef = W, gr.isFragment = O, gr.isLazy = I, gr.isMemo = F, gr.isPortal = j, gr.isProfiler = q, gr.isStrictMode = A, gr.isSuspense = K, gr.isValidElementType = D, gr.typeOf = x;
  }()), gr;
}
var nq;
function Kue() {
  return nq || (nq = 1, process.env.NODE_ENV === "production" ? OP.exports = wKe() : OP.exports = OKe()), OP.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var CP, rq;
function CKe() {
  if (rq) return CP;
  rq = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return CP = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, CP;
}
var xP, oq;
function mB() {
  if (oq) return xP;
  oq = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return xP = e, xP;
}
var iq, sq;
function Gue() {
  return sq || (sq = 1, iq = Function.call.bind(Object.prototype.hasOwnProperty)), iq;
}
var LP, aq;
function xKe() {
  if (aq) return LP;
  aq = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = mB(), n = {}, r = Gue();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, LP = o, LP;
}
var EP, lq;
function LKe() {
  if (lq) return EP;
  lq = 1;
  var e = Kue(), t = CKe(), n = mB(), r = Gue(), o = xKe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return EP = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, I, F, j, q, A, K) {
        if (j = j || d, A = A || F, K !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = j + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return I[F] == null ? O ? I[F] === null ? new v("The " + q + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new v("The " + q + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : P(I, F, j, q, A);
      }
      var W = M.bind(null, !1);
      return W.isRequired = M.bind(null, !0), W;
    }
    function L(P) {
      function _(z, M, W, O, I, F) {
        var j = z[M], q = G(j);
        if (q !== P) {
          var A = Y(j);
          return new v(
            "Invalid " + O + " `" + I + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var j = G(F);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var A = P(F, q, W, O, I + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!s(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!e.isValidElementType(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, W, O, I) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, j = J(z[M]);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, W, O, I) {
        for (var F = z[M], j = 0; j < P.length; j++)
          if (f(F, P[j]))
            return null;
        var q = JSON.stringify(P, function(A, K) {
          var B = Y(K);
          return B === "symbol" ? String(K) : K;
        });
        return new v("Invalid " + O + " `" + I + "` of value `" + String(F) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var A = P(F, q, W, O, I + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(W, O, I, F, j) {
        for (var q = [], A = 0; A < P.length; A++) {
          var K = P[A], B = K(W, O, I, F, j, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + j + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(M);
    }
    function R() {
      function P(_, z, M, W, O) {
        return H(_[z]) ? null : new v("Invalid " + W + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function N(P, _, z, M, W) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return N(W, O, I, q, Y(A));
          var K = A(F, q, W, O, I + "." + q, n);
          if (K)
            return K;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var A in q) {
          var K = P[A];
          if (r(P, A) && typeof K != "function")
            return N(W, O, I, A, Y(K));
          if (!K)
            return new v(
              "Invalid " + O + " `" + I + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = K(F, A, W, O, I + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!H(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var W = M.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function X(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function G(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : X(_, P) ? "symbol" : _;
    }
    function Y(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = G(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = Y(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, EP;
}
var kP, uq;
function EKe() {
  if (uq) return kP;
  uq = 1;
  var e = mB();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, kP = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, kP;
}
if (process.env.NODE_ENV !== "production") {
  var kKe = Kue(), PKe = !0;
  w_.exports = LKe()(kKe.isElement, PKe);
} else
  w_.exports = EKe()();
var Qx = w_.exports, eL = {};
Object.defineProperty(eL, "__esModule", {
  value: !0
});
var SKe = Fm, PP = MKe(SKe);
function MKe(e) {
  return e && e.__esModule ? e : { default: e };
}
var DKe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return PP.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && PP.default.getHash() !== e && PP.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
eL.default = DKe;
Object.defineProperty(Bm, "__esModule", {
  value: !0
});
var pb = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, _Ke = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), TKe = Oe, cq = Wm(TKe), jKe = Nm, db = Wm(jKe), AKe = qd, IKe = Wm(AKe), BKe = Qx, Oo = Wm(BKe), NKe = eL, gu = Wm(NKe);
function Wm(e) {
  return e && e.__esModule ? e : { default: e };
}
function RKe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function FKe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function zKe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var pq = {
  to: Oo.default.string.isRequired,
  containerId: Oo.default.string,
  container: Oo.default.object,
  activeClass: Oo.default.string,
  activeStyle: Oo.default.object,
  spy: Oo.default.bool,
  horizontal: Oo.default.bool,
  smooth: Oo.default.oneOfType([Oo.default.bool, Oo.default.string]),
  offset: Oo.default.number,
  delay: Oo.default.number,
  isDynamic: Oo.default.bool,
  onClick: Oo.default.func,
  duration: Oo.default.oneOfType([Oo.default.number, Oo.default.func]),
  absolute: Oo.default.bool,
  onSetActive: Oo.default.func,
  onSetInactive: Oo.default.func,
  ignoreCancelEvents: Oo.default.bool,
  hashSpy: Oo.default.bool,
  saveHashHistory: Oo.default.bool,
  spyThrottle: Oo.default.number
};
Bm.default = function(e, t) {
  var n = t || IKe.default, r = function(i) {
    zKe(a, i);
    function a(s) {
      RKe(this, a);
      var l = FKe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return _Ke(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          db.default.isMounted(s) || db.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (gu.default.isMounted() || gu.default.mount(n), gu.default.mapContainer(this.props.to, s)), db.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        db.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = pb({}, this.props.style, this.props.activeStyle) : l = pb({}, this.props.style);
        var u = pb({}, this.props);
        for (var c in pq)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, cq.default.createElement(e, u);
      }
    }]), a;
  }(cq.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, pb({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(gu.default.isMounted() && !gu.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var R = n.getActiveLink();
        if (y) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && gu.default.getHash() === c) {
            var N = i.props.saveHashHistory, V = N === void 0 ? !1 : N;
            gu.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, H = $ === void 0 ? !1 : $;
          i.props.hashSpy && gu.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = pq, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(pB, "__esModule", {
  value: !0
});
var UKe = Oe, dq = Yue(UKe), WKe = Bm, HKe = Yue(WKe);
function Yue(e) {
  return e && e.__esModule ? e : { default: e };
}
function VKe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function fq(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function $Ke(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ZKe = function(e) {
  $Ke(t, e);
  function t() {
    var n, r, o, i;
    VKe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = fq(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return dq.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), fq(o, i);
  }
  return t;
}(dq.default.Component);
pB.default = (0, HKe.default)(ZKe);
var vB = {};
Object.defineProperty(vB, "__esModule", {
  value: !0
});
var qKe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), XKe = Oe, hq = Jue(XKe), KKe = Bm, GKe = Jue(KKe);
function Jue(e) {
  return e && e.__esModule ? e : { default: e };
}
function YKe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function JKe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function QKe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var eGe = function(e) {
  QKe(t, e);
  function t() {
    return YKe(this, t), JKe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return qKe(t, [{
    key: "render",
    value: function() {
      return hq.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(hq.default.Component);
vB.default = (0, GKe.default)(eGe);
var yB = {}, tL = {};
Object.defineProperty(tL, "__esModule", {
  value: !0
});
var tGe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, nGe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), rGe = Oe, gq = nL(rGe), oGe = nl;
nL(oGe);
var iGe = qd, mq = nL(iGe), sGe = Qx, vq = nL(sGe);
function nL(e) {
  return e && e.__esModule ? e : { default: e };
}
function aGe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lGe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function uGe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
tL.default = function(e) {
  var t = function(n) {
    uGe(r, n);
    function r(o) {
      aGe(this, r);
      var i = lGe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return nGe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        mq.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        mq.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return gq.default.createElement(e, tGe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(gq.default.Component);
  return t.propTypes = {
    name: vq.default.string,
    id: vq.default.string
  }, t;
};
Object.defineProperty(yB, "__esModule", {
  value: !0
});
var yq = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, cGe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), pGe = Oe, bq = bB(pGe), dGe = tL, fGe = bB(dGe), hGe = Qx, wq = bB(hGe);
function bB(e) {
  return e && e.__esModule ? e : { default: e };
}
function gGe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function mGe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function vGe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Que = function(e) {
  vGe(t, e);
  function t() {
    return gGe(this, t), mGe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return cGe(t, [{
    key: "render",
    value: function() {
      var n = this, r = yq({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, bq.default.createElement(
        "div",
        yq({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(bq.default.Component);
Que.propTypes = {
  name: wq.default.string,
  id: wq.default.string
};
yB.default = (0, fGe.default)(Que);
var SP = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Oq = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function Cq(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function xq(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Lq(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var fb = Oe, Uc = Nm, MP = qd, Ho = Qx, mu = eL, Eq = {
  to: Ho.string.isRequired,
  containerId: Ho.string,
  container: Ho.object,
  activeClass: Ho.string,
  spy: Ho.bool,
  smooth: Ho.oneOfType([Ho.bool, Ho.string]),
  offset: Ho.number,
  delay: Ho.number,
  isDynamic: Ho.bool,
  onClick: Ho.func,
  duration: Ho.oneOfType([Ho.number, Ho.func]),
  absolute: Ho.bool,
  onSetActive: Ho.func,
  onSetInactive: Ho.func,
  ignoreCancelEvents: Ho.bool,
  hashSpy: Ho.bool,
  spyThrottle: Ho.number
}, yGe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || MP, r = function(i) {
      Lq(a, i);
      function a(s) {
        Cq(this, a);
        var l = xq(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return Oq(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Uc.isMounted(s) || Uc.mount(s, this.props.spyThrottle), this.props.hashSpy && (mu.isMounted() || mu.mount(n), mu.mapContainer(this.props.to, s)), this.props.spy && Uc.addStateHandler(this.stateHandler), Uc.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Uc.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = SP({}, this.props);
          for (var u in Eq)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, fb.createElement(e, l);
        }
      }]), a;
    }(fb.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, SP({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(mu.isMounted() && !mu.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && mu.getHash() === l && mu.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Uc.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && mu.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Uc.updateStates();
        }
      };
    };
    return r.propTypes = Eq, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      Lq(r, n);
      function r(o) {
        Cq(this, r);
        var i = xq(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return Oq(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          MP.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          MP.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return fb.createElement(e, SP({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(fb.Component);
    return t.propTypes = {
      name: Ho.string,
      id: Ho.string
    }, t;
  }
}, bGe = yGe;
Object.defineProperty(si, "__esModule", {
  value: !0
});
si.Helpers = si.ScrollElement = si.ScrollLink = si.animateScroll = si.scrollSpy = si.Events = si.scroller = si.Element = si.Button = si.Link = void 0;
var wGe = pB, ece = ll(wGe), OGe = vB, tce = ll(OGe), CGe = yB, nce = ll(CGe), xGe = qd, rce = ll(xGe), LGe = zm, oce = ll(LGe), EGe = Nm, ice = ll(EGe), kGe = Gx, sce = ll(kGe), PGe = Bm, ace = ll(PGe), SGe = tL, lce = ll(SGe), MGe = bGe, uce = ll(MGe);
function ll(e) {
  return e && e.__esModule ? e : { default: e };
}
si.Link = ece.default;
si.Button = tce.default;
si.Element = nce.default;
si.scroller = rce.default;
si.Events = oce.default;
si.scrollSpy = ice.default;
si.animateScroll = sce.default;
si.ScrollLink = ace.default;
si.ScrollElement = lce.default;
si.Helpers = uce.default;
si.default = { Link: ece.default, Button: tce.default, Element: nce.default, scroller: rce.default, Events: oce.default, scrollSpy: ice.default, animateScroll: sce.default, ScrollLink: ace.default, ScrollElement: lce.default, Helpers: uce.default };
He({});
He({});
He({});
function $g(e) {
  "@babel/helpers - typeof";
  return $g = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, $g(e);
}
function DGe(e, t) {
  if ($g(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if ($g(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function _Ge(e) {
  var t = DGe(e, "string");
  return $g(t) == "symbol" ? t : t + "";
}
function Ne(e, t, n) {
  return (t = _Ge(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function cce(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var DP, kq;
function TGe() {
  if (kq) return DP;
  kq = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return DP = t, DP;
}
var jGe = TGe(), gi = /* @__PURE__ */ cce(jGe), qt = He(null);
function AGe() {
  gi(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(qt);
  return gi(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function IGe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function BGe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function NGe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return BGe(e, i), o;
}
function RGe(e, t, n) {
  var r = IGe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function FGe(e) {
  google.maps.event.removeListener(e);
}
function Un() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(FGe);
}
function Dn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = RGe(o, i, n);
  return NGe(t, r, o, i), a;
}
function zGe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = vt(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null), [A, K] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), K(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var B = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(B), B !== null && D && D(B), () => {
      B !== null && x && x(B);
    };
  }, []), ms.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: ms.jsx(qt.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(zGe);
function Pq(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function pce(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        Pq(i, r, o, a, s, "next", l);
      }
      function s(l) {
        Pq(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function dce(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return gi(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var wp = typeof document < "u";
function fce(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return wp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function Sq(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function hce() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return Sq(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return Sq(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Bf = !1;
function gce() {
  return ms.jsx("div", {
    children: "Loading..."
  });
}
var O_ = {
  id: "script-loader",
  version: "weekly"
};
class UGe extends pe {
  constructor() {
    super(...arguments), Ne(this, "check", jn()), Ne(this, "state", {
      loaded: !1
    }), Ne(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Ne(this, "isCleaningUp", /* @__PURE__ */ pce(function* () {
      function t(n) {
        if (!Bf)
          n();
        else if (wp)
          var r = window.setInterval(function() {
            Bf || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Ne(this, "cleanup", () => {
      Bf = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Ne(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && hce(), gi(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: dce(this.props)
      };
      fce(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (wp) {
      if (window.google && window.google.maps && !Bf) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), wp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (wp) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Bf = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return ms.jsxs(ms.Fragment, {
      children: [ms.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || ms.jsx(gce, {})]
    });
  }
}
Ne(UGe, "defaultProps", O_);
function WGe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function wB(e, t) {
  if (e == null) return {};
  var n, r, o = WGe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var Mq;
function HGe(e) {
  var {
    id: t = O_.id,
    version: n = O_.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = vt(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    wp && u && hce();
  }, [u]), h(function() {
    f && gi(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = dce({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!wp)
      return;
    function x() {
      y.current && (v(!0), Mq = w);
    }
    if (window.google && window.google.maps && Mq === w) {
      x();
      return;
    }
    fce({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = vt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var VGe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], $Ge = ms.jsx(gce, {});
function ZGe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = wB(e, VGe), {
    isLoaded: s,
    loadError: l
  } = HGe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || $Ge;
}
me(ZGe);
var Dq;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Dq || (Dq = {}));
function _q(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function f1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _q(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _q(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Tq = {}, jq = {
  options(e, t) {
    e.setOptions(t);
  }
};
function qGe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(qt), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(f1(f1({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(qGe);
class XGe extends pe {
  constructor() {
    super(...arguments), Ne(this, "state", {
      trafficLayer: null
    }), Ne(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Ne(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(f1(f1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: jq,
      eventMap: Tq,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: jq,
      eventMap: Tq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Un(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(XGe, "contextType", qt);
function KGe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(qt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(KGe);
class GGe extends pe {
  constructor() {
    super(...arguments), Ne(this, "state", {
      bicyclingLayer: null
    }), Ne(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(GGe, "contextType", qt);
function YGe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(qt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(YGe);
class JGe extends pe {
  constructor() {
    super(...arguments), Ne(this, "state", {
      transitLayer: null
    }), Ne(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(JGe, "contextType", qt);
function Aq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function h1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Aq(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Aq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Iq = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, Bq = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function QGe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(qt), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    gi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(h1(h1({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && L(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && k(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(QGe);
class eYe extends pe {
  constructor(t) {
    super(t), Ne(this, "registeredEvents", []), Ne(this, "state", {
      drawingManager: null
    }), Ne(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), gi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(h1(h1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: Bq,
      eventMap: Iq,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: Bq,
      eventMap: Iq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Un(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(eYe, "contextType", qt);
function Nq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Nq(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Nq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Rq = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, Fq = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, g1 = {};
function tYe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: R,
    onClickableChanged: N,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: H,
    onFlatChanged: X,
    onIconChanged: G,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, W = ge(qt), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null), [re, Se] = E(null), [We, Ze] = E(null), [Me, rt] = E(null), [Ve, be] = E(null), [qe, ct] = E(null), [ye, xe] = E(null), [Ee, Ue] = E(null), [De, st] = E(null), [ve, wt] = E(null), [at, lt] = E(null), [pt, Ot] = E(null), [dt, Ct] = E(null), [Xe, ht] = E(null), [ot, xt] = E(null), [ft, Pt] = E(null), [Lt, St] = E(null), [Et, Mt] = E(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (re !== null && google.maps.event.removeListener(re), Se(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), Ze(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Me !== null && google.maps.event.removeListener(Me), rt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && R && (Ve !== null && google.maps.event.removeListener(Ve), be(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && L && (qe !== null && google.maps.event.removeListener(qe), ct(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (ye !== null && google.maps.event.removeListener(ye), xe(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && N && (Ee !== null && google.maps.event.removeListener(Ee), Ue(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && V && (De !== null && google.maps.event.removeListener(De), st(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), wt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && X && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(O, "flat_changed", X)));
  }, [X]), h(() => {
    O && G && (dt !== null && google.maps.event.removeListener(dt), Ct(google.maps.event.addListener(O, "icon_changed", G)));
  }, [G]), h(() => {
    O && Y && (Xe !== null && google.maps.event.removeListener(Xe), ht(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (ot !== null && google.maps.event.removeListener(ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (ft !== null && google.maps.event.removeListener(ft), Pt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Lt !== null && google.maps.event.removeListener(Lt), St(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (Et !== null && google.maps.event.removeListener(Et), Mt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var gt = pd(pd(pd({}, n || g1), r ? g1 : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(gt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof y < "u" && te.setOpacity(y), f && te.setShape(f), typeof v == "string" && te.setTitle(v), typeof b == "number" && te.setZIndex(b), w && j(google.maps.event.addListener(te, "dblclick", w)), x && A(google.maps.event.addListener(te, "dragend", x)), m && B(google.maps.event.addListener(te, "dragstart", m)), k && he(google.maps.event.addListener(te, "mousedown", k)), C && Se(google.maps.event.addListener(te, "mouseout", C)), S && Ze(google.maps.event.addListener(te, "mouseover", S)), U && rt(google.maps.event.addListener(te, "mouseup", U)), R && be(google.maps.event.addListener(te, "rightclick", R)), L && ct(google.maps.event.addListener(te, "click", L)), D && xe(google.maps.event.addListener(te, "drag", D)), N && Ue(google.maps.event.addListener(te, "clickable_changed", N)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), $ && wt(google.maps.event.addListener(te, "animation_changed", $)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), X && Ot(google.maps.event.addListener(te, "flat_changed", X)), G && Ct(google.maps.event.addListener(te, "icon_changed", G)), Y && ht(google.maps.event.addListener(te, "position_changed", Y)), Q && xt(google.maps.event.addListener(te, "shape_changed", Q)), J && Pt(google.maps.event.addListener(te, "title_changed", J)), P && St(google.maps.event.addListener(te, "visible_changed", P)), _ && Mt(google.maps.event.addListener(te, "zindex_changed", _)), I(te), z && z(te), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), re !== null && google.maps.event.removeListener(re), We !== null && google.maps.event.removeListener(We), Me !== null && google.maps.event.removeListener(Me), Ve !== null && google.maps.event.removeListener(Ve), qe !== null && google.maps.event.removeListener(qe), Ee !== null && google.maps.event.removeListener(Ee), De !== null && google.maps.event.removeListener(De), ve !== null && google.maps.event.removeListener(ve), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), Xe !== null && google.maps.event.removeListener(Xe), ft !== null && google.maps.event.removeListener(ft), Lt !== null && google.maps.event.removeListener(Lt), Et !== null && google.maps.event.removeListener(Et), M && M(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var _t = zt(() => i ? ut.map(i, (gt) => {
    if (!wi(gt))
      return gt;
    var te = gt;
    return Oi(te, {
      anchor: O
    });
  }) : null, [i, O]);
  return ms.jsx(ms.Fragment, {
    children: _t
  }) || null;
}
me(tYe);
class nYe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return pce(function* () {
      var n = pd(pd(pd({}, t.props.options || g1), t.props.clusterer ? g1 : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Dn({
        updaterMap: Fq,
        eventMap: Rq,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: Fq,
      eventMap: Rq,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Un(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Oi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Ne(nYe, "contextType", qt);
var rYe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), oYe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new rYe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function iYe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var sYe = 2e3, aYe = 500, lYe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", uYe = "png", cYe = [53, 56, 66, 78, 90], pYe = "cluster", mce = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || lYe, this.imageExtension = r.imageExtension || uYe, this.imageSizes = r.imageSizes || cYe, this.calculator = r.calculator || iYe, this.batchSize = r.batchSize || sYe, this.batchSizeIE = r.batchSizeIE || aYe, this.clusterClass = r.clusterClass || pYe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new oYe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function zq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dYe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zq(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ba = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Kn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, fYe = {};
function hYe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, R] = E(null), N = ge(qt), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, ba.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, ba.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, ba.onClick, w)));
  }, [w]), h(() => {
    k && D && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(k, ba.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (G !== null && google.maps.event.removeListener(G), X(google.maps.event.addListener(k, ba.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && Kn.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && Kn.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && Kn.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && Kn.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && Kn.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && Kn.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && Kn.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && Kn.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && Kn.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && Kn.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && Kn.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && Kn.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && Kn.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && Kn.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && Kn.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (N) {
      var z = dYe({}, n || fYe), M = new mce(N, [], z);
      return r && Kn.averageCenter(M, r), o && Kn.batchSizeIE(M, o), i && Kn.calculator(M, i), a && Kn.clusterClass(M, a), s && Kn.enableRetinaIcons(M, s), l && Kn.gridSize(M, l), u && Kn.ignoreHidden(M, u), c && Kn.imageExtension(M, c), p && Kn.imagePath(M, p), d && Kn.imageSizes(M, d), y && Kn.maxZoom(M, y), f && Kn.minimumClusterSize(M, f), v && Kn.styles(M, v), b && Kn.title(M, b), L && Kn.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, ba.onMouseOut, C)), m && _(google.maps.event.addListener(M, ba.onMouseOver, m)), w && $(google.maps.event.addListener(M, ba.onClick, w)), D && X(google.maps.event.addListener(M, ba.onClusteringBegin, D)), x && Y(google.maps.event.addListener(M, ba.onClusteringEnd, x)), R(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(hYe);
class gYe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      markerClusterer: null
    }), Ne(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new mce(this.context, [], this.props.options);
      this.registeredEvents = Dn({
        updaterMap: Kn,
        eventMap: ba,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: Kn,
      eventMap: ba,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Un(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Ne(gYe, "contextType", qt);
function Uq(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var vce = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || Uq(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, Uq));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), mYe = ["position"], vYe = ["position"];
function Wq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function m1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Wq(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Wq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Hq = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Vq = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, yYe = {};
function bYe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(qt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var N = r || yYe, {
        position: V
      } = N, $ = wB(N, mYe), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var X = new vce(m1(m1({}, $), H ? {
        position: H
      } : {}));
      R.current = document.createElement("div"), v(X), a && L(google.maps.event.addListener(X, "closeclick", a)), s && D(google.maps.event.addListener(X, "domready", s)), l && m(google.maps.event.addListener(X, "content_changed", l)), u && S(google.maps.event.addListener(X, "position_changed", u)), c && k(google.maps.event.addListener(X, "zindex_changed", c)), X.setContent(R.current), n ? X.open(y, n) : X.getPosition() ? X.open(y) : gi(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(X);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(bYe);
class wYe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "containerElement", null), Ne(this, "state", {
      infoBox: null
    }), Ne(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : gi(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Ne(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = wB(t, vYe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new vce(m1(m1({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Dn({
      updaterMap: Vq,
      eventMap: Hq,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: Vq,
      eventMap: Hq,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Un(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
Ne(wYe, "contextType", qt);
var $q, Zq;
function OYe() {
  return Zq || (Zq = 1, $q = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), $q;
}
var CYe = OYe(), qq = /* @__PURE__ */ cce(CYe), Xq = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], _P = 1, Nf = 8;
class OB {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== _P)
      throw new Error("Got v".concat(o, " data when expected v").concat(_P, "."));
    var i = Xq[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new OB(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = Xq.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Nf, t), this.coords = new this.ArrayType(this.data, Nf + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Nf + a + s + l), this.ids = new this.IndexArrayType(this.data, Nf, t), this.coords = new this.ArrayType(this.data, Nf + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (_P << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return C_(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          Kq(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      Kq(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function C_(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    yce(e, t, a, r, o, i), C_(e, t, n, r, a - 1, 1 - i), C_(e, t, n, a + 1, o, 1 - i);
  }
}
function yce(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      yce(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (Rf(e, t, r, n), t[2 * o + i] > y && Rf(e, t, r, o); f < v; ) {
      for (Rf(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? Rf(e, t, r, v) : (v++, Rf(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function Rf(e, t, n, r) {
  TP(e, n, r), TP(t, 2 * n, 2 * r), TP(t, 2 * n + 1, 2 * r + 1);
}
function TP(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function Kq(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var xYe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, Gq = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Wc = 2, Ru = 3, jP = 4, Mu = 5, bce = 6;
class LYe {
  constructor(t) {
    this.options = Object.assign(Object.create(xYe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = Gq(hb(u)), d = Gq(gb(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(hb(r), gb(a), hb(i), gb(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Mu] > 1 ? Yq(p, f, this.clusterProps) : this.points[p[f + Ru]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + jP] === t && p.push(a[y + Mu] > 1 ? Yq(a, y, this.clusterProps) : this.points[a[y + Ru]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new OB(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Mu] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = wce(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Ru]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = hb(f), d = gb(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + Ru] : L = this.points[n[l + Ru]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Wc] <= n)) {
        l[p + Wc] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Mu], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + Wc] > n && (b += l[w + Mu]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + Wc] <= n)) {
              l[k + Wc] = n;
              var R = l[k + Mu];
              D += l[k] * R, x += l[k + 1] * R, l[k + jP] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + jP] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + Wc] <= n)) {
                l[$ + Wc] = n;
                for (var H = 0; H < c; H++) u.push(l[$ + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Mu] > 1) {
      var o = this.clusterProps[t[n + bce]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Ru]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function Yq(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Ru],
    properties: wce(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [EYe(e[t]), kYe(e[t + 1])]
    }
  };
}
function wce(e, t, n) {
  var r = e[t + Mu], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + bce], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Ru],
    point_count: r,
    point_count_abbreviated: o
  });
}
function hb(e) {
  return e / 360 + 0.5;
}
function gb(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function EYe(e) {
  return (e - 0.5) * 360;
}
function kYe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function PYe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class $s {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class x_ {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend($s.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => $s.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && ($s.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class SYe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return MYe(n);
  }
}
var MYe = (e) => {
  var t = e.map((n) => new x_({
    position: $s.getPosition(n),
    markers: [n]
  }));
  return t;
};
class DYe extends SYe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = PYe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new LYe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!qq(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = $s.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !qq(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new x_({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new x_({
      markers: [i],
      position: $s.getPosition(i)
    });
  }
}
class _Ye {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class TYe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if ($s.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function jYe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class CB {
  constructor() {
    jYe(CB, google.maps.OverlayView);
  }
}
var Hh;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Hh || (Hh = {}));
var AYe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class IYe extends CB {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new DYe(o),
      renderer: a = new TYe(),
      onClusterClick: s = AYe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : ($s.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Hh.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || $s.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => $s.setMap(l, null)));
      }
      google.maps.event.trigger(this, Hh.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => $s.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new _Ye(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => $s.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Hh.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), $s.setMap(r.marker, n);
    });
  }
}
function Jq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qq(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Jq(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Jq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function BYe(e) {
  var t = AGe(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new IYe(Qq(Qq({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function NYe(e) {
  var {
    children: t,
    options: n
  } = e, r = BYe(n);
  return r !== null ? t(r) : null;
}
me(NYe);
var e7 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, t7 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function RYe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(qt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return v(N), R.current = document.createElement("div"), a && L(google.maps.event.addListener(N, "closeclick", a)), s && D(google.maps.event.addListener(N, "domready", s)), l && m(google.maps.event.addListener(N, "content_changed", l)), u && S(google.maps.event.addListener(N, "position_changed", u)), c && k(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(R.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(y, n) : N.getPosition() ? N.open(y) : gi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(N), N.close();
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(RYe);
class FYe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "containerElement", null), Ne(this, "state", {
      infoWindow: null
    }), Ne(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : gi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Ne(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Dn({
      updaterMap: t7,
      eventMap: e7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: t7,
      eventMap: e7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Un(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
Ne(FYe, "contextType", qt);
function n7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function v1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? n7(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : n7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var r7 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, o7 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, zYe = {};
function UYe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(qt), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var j = new google.maps.Polyline(v1(v1({}, t || zYe), {}, {
      map: D
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && S(google.maps.event.addListener(j, "dblclick", a)), s && k(google.maps.event.addListener(j, "dragend", s)), l && N(google.maps.event.addListener(j, "dragstart", l)), u && $(google.maps.event.addListener(j, "mousedown", u)), c && X(google.maps.event.addListener(j, "mousemove", c)), p && Y(google.maps.event.addListener(j, "mouseout", p)), d && J(google.maps.event.addListener(j, "mouseover", d)), y && _(google.maps.event.addListener(j, "mouseup", y)), f && M(google.maps.event.addListener(j, "rightclick", f)), v && O(google.maps.event.addListener(j, "click", v)), b && F(google.maps.event.addListener(j, "drag", b)), m(j), L && L(j), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
me(UYe);
class WYe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      polyline: null
    }), Ne(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(v1(v1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: o7,
      eventMap: r7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: o7,
      eventMap: r7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Un(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(WYe, "contextType", qt);
function i7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function s7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? i7(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : i7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var a7 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, l7 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function HYe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(qt), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var A = new google.maps.Polygon(s7(s7({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && k(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && $(google.maps.event.addListener(A, "dragstart", u)), c && X(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), b && F(google.maps.event.addListener(A, "click", b)), L && q(google.maps.event.addListener(A, "drag", L)), S(A), w && w(A), () => {
      U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), D && D(A), A.setMap(null);
    };
  }, []), null;
}
me(HYe);
class VYe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Dn({
      updaterMap: l7,
      eventMap: a7,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: l7,
      eventMap: a7,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Un(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(VYe, "contextType", qt);
function u7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function y1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? u7(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : u7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var c7 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, p7 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function $Ye(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(qt), [m, C] = E(null), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var K = new google.maps.Rectangle(y1(y1({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && K.setVisible(i), typeof o < "u" && K.setEditable(o), typeof r < "u" && K.setDraggable(r), typeof n < "u" && K.setBounds(n), a && U(google.maps.event.addListener(K, "dblclick", a)), s && R(google.maps.event.addListener(K, "dragend", s)), l && V(google.maps.event.addListener(K, "dragstart", l)), u && H(google.maps.event.addListener(K, "mousedown", u)), c && G(google.maps.event.addListener(K, "mousemove", c)), p && Q(google.maps.event.addListener(K, "mouseout", p)), d && P(google.maps.event.addListener(K, "mouseover", d)), y && z(google.maps.event.addListener(K, "mouseup", y)), f && W(google.maps.event.addListener(K, "rightclick", f)), v && I(google.maps.event.addListener(K, "click", v)), b && j(google.maps.event.addListener(K, "drag", b)), L && A(google.maps.event.addListener(K, "bounds_changed", L)), C(K), w && w(K), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(K), K.setMap(null);
    };
  }, []), null;
}
me($Ye);
class ZYe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      rectangle: null
    }), Ne(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(y1(y1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: p7,
      eventMap: c7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: p7,
      eventMap: c7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Un(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(ZYe, "contextType", qt);
function d7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function b1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? d7(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : d7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var f7 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, h7 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, qYe = {};
function XYe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(qt), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var re = new google.maps.Circle(b1(b1({}, t || qYe), {}, {
      map: C
    }));
    return typeof r == "number" && re.setRadius(r), typeof n < "u" && re.setCenter(n), typeof r == "number" && re.setRadius(r), typeof a < "u" && re.setVisible(a), typeof i < "u" && re.setEditable(i), typeof o < "u" && re.setDraggable(o), s && R(google.maps.event.addListener(re, "dblclick", s)), l && V(google.maps.event.addListener(re, "dragend", l)), u && H(google.maps.event.addListener(re, "dragstart", u)), c && G(google.maps.event.addListener(re, "mousedown", c)), p && Q(google.maps.event.addListener(re, "mousemove", p)), d && P(google.maps.event.addListener(re, "mouseout", d)), y && z(google.maps.event.addListener(re, "mouseover", y)), f && W(google.maps.event.addListener(re, "mouseup", f)), v && I(google.maps.event.addListener(re, "rightclick", v)), b && j(google.maps.event.addListener(re, "click", b)), L && A(google.maps.event.addListener(re, "drag", L)), w && B(google.maps.event.addListener(re, "center_changed", w)), D && he(google.maps.event.addListener(re, "radius_changed", D)), U(re), x && x(re), () => {
      k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), m && m(re), re.setMap(null);
    };
  }, []), null;
}
me(XYe);
class KYe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      circle: null
    }), Ne(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(b1(b1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: h7,
      eventMap: f7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: h7,
      eventMap: f7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Un(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Ne(KYe, "contextType", qt);
function g7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function w1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? g7(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : g7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var m7 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, v7 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function GYe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(qt), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var A = new google.maps.Data(w1(w1({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && k(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && $(google.maps.event.addListener(A, "mouseover", s)), l && X(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && q(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), j !== null && google.maps.event.removeListener(j), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(GYe);
class YYe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      data: null
    }), Ne(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(w1(w1({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Dn({
        updaterMap: v7,
        eventMap: m7,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: v7,
      eventMap: m7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Un(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(YYe, "contextType", qt);
function y7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function b7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? y7(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : y7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var w7 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, O7 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class JYe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      kmlLayer: null
    }), Ne(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(b7(b7({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: O7,
      eventMap: w7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: O7,
      eventMap: w7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Un(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(JYe, "contextType", qt);
function Oce(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function QYe(e, t) {
  return new t(e.lat, e.lng);
}
function eJe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function tJe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function nJe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function rJe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function oJe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Cce(e, t, n, r) {
  return n !== void 0 ? rJe(e, t, nJe(n, google.maps.LatLngBounds, eJe)) : oJe(e, t, tJe(r, google.maps.LatLng, QYe));
}
function iJe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function C7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sJe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? C7(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : C7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function aJe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = sJe({}, this.container ? Oce(this.container, o) : {
        x: 0,
        y: 0
      }), u = Cce(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function x7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lJe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? x7(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : x7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function L7(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function E7(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function uJe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(qt), c = zt(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = zt(() => aJe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
me(uJe);
class Xd extends pe {
  constructor(t) {
    super(t), Ne(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Ne(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      gi(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Ne(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Ne(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = lJe({
        x: 0,
        y: 0
      }, this.containerRef.current ? Oce(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Cce(r, o, this.props.bounds, this.props.position);
      if (!iJe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Ne(this, "draw", () => {
      this.onPositionElement();
    }), Ne(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = jn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = L7(t.position), r = L7(this.props.position), o = E7(t.bounds), i = E7(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(ms.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
Ne(Xd, "FLOAT_PANE", "floatPane");
Ne(Xd, "MAP_PANE", "mapPane");
Ne(Xd, "MARKER_LAYER", "markerLayer");
Ne(Xd, "OVERLAY_LAYER", "overlayLayer");
Ne(Xd, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Ne(Xd, "contextType", qt);
function cJe() {
}
function k7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function P7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? k7(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : k7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var S7 = {
  onDblClick: "dblclick",
  onClick: "click"
}, M7 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function pJe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(qt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = zt(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(pJe);
class xce extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      groundOverlay: null
    }), Ne(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    gi(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, P7(P7({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: M7,
      eventMap: S7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: M7,
      eventMap: S7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(xce, "defaultProps", {
  onLoad: cJe
});
Ne(xce, "contextType", qt);
function D7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function O1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? D7(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : D7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _7 = {}, T7 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function dJe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(qt), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || gi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    gi(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(O1(O1({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(dJe);
class fJe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      heatmapLayer: null
    }), Ne(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    gi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), gi(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(O1(O1({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: T7,
      eventMap: _7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: T7,
      eventMap: _7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Un(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(fJe, "contextType", qt);
var j7 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, A7 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class hJe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      streetViewPanorama: null
    }), Ne(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Dn({
      updaterMap: A7,
      eventMap: j7,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: A7,
      eventMap: j7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Un(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Ne(hJe, "contextType", qt);
class gJe extends pe {
  constructor() {
    super(...arguments), Ne(this, "state", {
      streetViewService: null
    }), Ne(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Ne(gJe, "contextType", qt);
var I7 = {
  onDirectionsChanged: "directions_changed"
}, B7 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class mJe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      directionsRenderer: null
    }), Ne(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Dn({
      updaterMap: B7,
      eventMap: I7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: B7,
      eventMap: I7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Un(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(mJe, "contextType", qt);
var N7 = {
  onPlacesChanged: "places_changed"
}, R7 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class vJe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "containerElement", jn()), Ne(this, "state", {
      searchBox: null
    }), Ne(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (gi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Dn({
          updaterMap: R7,
          eventMap: N7,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: R7,
      eventMap: N7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Un(this.registeredEvents));
  }
  render() {
    return ms.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
Ne(vJe, "contextType", qt);
var F7 = {
  onPlaceChanged: "place_changed"
}, z7 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class Lce extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "containerElement", jn()), Ne(this, "state", {
      autocomplete: null
    }), Ne(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    gi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Dn({
        updaterMap: z7,
        eventMap: F7,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Un(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: z7,
      eventMap: F7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Un(this.registeredEvents);
  }
  render() {
    return ms.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
Ne(Lce, "defaultProps", {
  className: ""
});
Ne(Lce, "contextType", qt);
let yJe = { data: "" }, bJe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || yJe, wJe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, OJe = /\/\*[^]*?\*\/|  +/g, U7 = /\n+/g, Ku = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Ku(a, i) : i + "{" + Ku(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Ku(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Ku.p ? Ku.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, kl = {}, Ece = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Ece(e[n]);
    return t;
  }
  return e;
}, CJe = (e, t, n, r, o) => {
  let i = Ece(e), a = kl[i] || (kl[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!kl[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = wJe.exec(u.replace(OJe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(U7, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(U7, " ").trim();
      return d[0];
    })(e);
    kl[a] = Ku(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && kl.g ? kl.g : null;
  return n && (kl.g = kl[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(kl[a], t, r, s), a;
}, xJe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Ku(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function rL(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return CJe(n.unshift ? n.raw ? xJe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, bJe(t.target), t.g, t.o, t.k);
}
let kce, L_, E_;
rL.bind({ g: 1 });
let $l = rL.bind({ k: 1 });
function LJe(e, t, n, r) {
  Ku.p = t, kce = e, L_ = n, E_ = r;
}
function kc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: L_ && L_() }, s), n.o = / *go\d+/.test(l), s.className = rL.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), E_ && u[0] && E_(s), kce(u, s);
    }
    return o;
  };
}
var EJe = (e) => typeof e == "function", kJe = (e, t) => EJe(e) ? e(t) : e, PJe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), SJe = $l`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, MJe = $l`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, DJe = $l`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, _Je = kc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${SJe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${MJe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${DJe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, TJe = $l`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, jJe = kc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${TJe} 1s linear infinite;
`, AJe = $l`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, IJe = $l`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, BJe = kc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${AJe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${IJe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, NJe = kc("div")`
  position: absolute;
`, RJe = kc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, FJe = $l`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, zJe = kc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${FJe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, UJe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? _e.createElement(zJe, null, t) : t : n === "blank" ? null : _e.createElement(RJe, null, _e.createElement(jJe, { ...r }), n !== "loading" && _e.createElement(NJe, null, n === "error" ? _e.createElement(_Je, { ...r }) : _e.createElement(BJe, { ...r })));
}, WJe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, HJe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, VJe = "0%{opacity:0;} 100%{opacity:1;}", $Je = "0%{opacity:1;} 100%{opacity:0;}", ZJe = kc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, qJe = kc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, XJe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = PJe() ? [VJe, $Je] : [WJe(n), HJe(n)];
  return { animation: t ? `${$l(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${$l(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
_e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? XJe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = _e.createElement(UJe, { toast: e }), a = _e.createElement(qJe, { ...e.ariaProps }, kJe(e.message, e));
  return _e.createElement(ZJe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : _e.createElement(_e.Fragment, null, i, a));
});
LJe(_e.createElement);
rL`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
He({});
function KJe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const GJe = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
KJe(GJe.CNPJ).length;
ka((e, t) => /* @__PURE__ */ gs.jsx("input", { ref: t, ...e }));
He({});
var nu = {};
Object.defineProperty(nu, "__esModule", {
  value: !0
});
var YJe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), AP = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Pce = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: YJe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, xB = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var mb = 1; mb < 20; mb++)
  xB["f" + mb] = 111 + mb;
function oL(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Sce(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Mce(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function JJe(e, t) {
  return oL(e, t);
}
function QJe(e, t) {
  return oL(e, { byKey: !0 }, t);
}
function Sce(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in AP)
    r[AP[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = LB(d), v = AP[f];
      if (d.length > 1 && !v && !Pce[d] && !xB[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = Dce(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Mce(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Dce(e) {
  e = LB(e);
  var t = xB[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function LB(e) {
  return e = e.toLowerCase(), e = Pce[e] || e, e;
}
nu.default = oL;
var IP = nu.isHotkey = oL;
nu.isCodeHotkey = JJe;
nu.isKeyHotkey = QJe;
nu.parseHotkey = Sce;
nu.compareHotkey = Mce;
nu.toKeyCode = Dce;
nu.toKeyName = LB;
var eQe = typeof Mr == "object" && Mr && Mr.Object === Object && Mr, tQe = eQe, nQe = tQe, rQe = typeof self == "object" && self && self.Object === Object && self, oQe = nQe || rQe || Function("return this")(), iQe = oQe, sQe = iQe, aQe = sQe.Symbol, _ce = aQe, W7 = _ce;
W7 && W7.toStringTag;
var H7 = _ce;
H7 && H7.toStringTag;
var V7;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(V7 || (V7 = {}));
var EB = function(e) {
  return Object.freeze(e);
}, lQe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, EB(this);
  }
  return e;
}(), uQe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, EB(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), $7 = typeof window < "u" ? window : {};
/msie|trident/i.test($7.navigator && $7.navigator.userAgent);
var BP = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new lQe((n ? t : e) || 0, (n ? e : t) || 0);
};
EB({
  devicePixelContentBoxSize: BP(),
  borderBoxSize: BP(),
  contentBoxSize: BP(),
  contentRect: new uQe(0, 0, 0, 0)
});
function Zg(e) {
  "@babel/helpers - typeof";
  return Zg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Zg(e);
}
function cQe(e, t) {
  if (Zg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Zg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function pQe(e) {
  var t = cQe(e, "string");
  return Zg(t) === "symbol" ? t : String(t);
}
function Vh(e, t, n) {
  return t = pQe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var dQe = /* @__PURE__ */ He(null), NP, RP;
parseInt(Oe.version.split(".")[0], 10);
var Z7 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), FP = typeof navigator < "u" && /Android/.test(navigator.userAgent), vb = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), fQe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (NP = navigator.userAgent.match(/Version\/(\d+)/)) !== null && NP !== void 0 && NP[1] && parseInt((RP = navigator.userAgent.match(/Version\/(\d+)/)) === null || RP === void 0 ? void 0 : RP[1], 10) < 17;
var hQe = /* @__PURE__ */ new WeakMap(), gQe = /* @__PURE__ */ new WeakMap(), mQe = /* @__PURE__ */ new WeakMap(), vQe = /* @__PURE__ */ new WeakMap(), yQe = /* @__PURE__ */ new WeakMap(), q7 = /* @__PURE__ */ new WeakMap(), bQe = /* @__PURE__ */ new WeakMap(), X7 = /* @__PURE__ */ new WeakMap(), yb = /* @__PURE__ */ new WeakMap(), wQe = /* @__PURE__ */ new WeakMap(), OQe = /* @__PURE__ */ new WeakMap(), CQe = /* @__PURE__ */ new WeakMap(), Tce = globalThis.Node, xQe = globalThis.Text, jce = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, LQe = (e) => C1(e) && e.nodeType === 8, Qa = (e) => C1(e) && e.nodeType === 1, C1 = (e) => {
  var t = jce(e);
  return !!t && e instanceof t.Node;
}, K7 = (e) => {
  var t = e && e.anchorNode && jce(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, EQe = (e) => {
  var [t, n] = e;
  if (Qa(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Ace(t, o, r ? "backward" : "forward"), r = o < n; Qa(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = PQe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, kQe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Ace = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (LQe(o) || Qa(o) && o.childNodes.length === 0 || Qa(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, PQe = (e, t, n) => {
  var [r] = Ace(e, t, n);
  return r;
}, G7 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Ice = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Qa(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = xn.getWindow(e);
  if (o.contains(r))
    return xn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Ice(e, i, n);
}, Y7 = (e, t) => !!(e.compareDocumentPosition(t) & Tce.DOCUMENT_POSITION_PRECEDING), SQe = (e, t) => !!(e.compareDocumentPosition(t) & Tce.DOCUMENT_POSITION_FOLLOWING), MQe = 0;
class DQe {
  constructor() {
    Vh(this, "id", void 0), this.id = "".concat(MQe++);
  }
}
var xn = {
  androidPendingDiffs: (e) => CQe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = OQe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = xn.toDOMNode(e, e), n = xn.findDocumentOrShadowRoot(e);
    yb.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = xn.findDocumentOrShadowRoot(e), r = G7(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && T0.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = xn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = xn.toSlateNode(e, t.target), a = xn.findPath(e, i);
    if (_l.isElement(i) && wr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = wr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? wr.before(e, u) : wr.after(e, u);
      if (c) {
        var p = wr.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = xn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = xn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = q7.get(t);
    return n || (n = new DQe(), q7.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = gQe.get(r);
      if (o == null) {
        if (wr.isEditor(r))
          return n;
        break;
      }
      var i = hQe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(js.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!yb.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          xn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = xn.toDOMNode(e, e), r = xn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = G7(r), i = xn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || T0.select(e, wr.start(e, [])), yb.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = mQe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = xn.toDOMNode(e, e), i;
    try {
      i = Qa(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => C1(t) && xn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return wr.hasPath(e, n.path) && wr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => xn.hasEditableTarget(e, t) || xn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => C1(t) && xn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!wQe.get(e),
  isFocused: (e) => !!yb.get(e),
  isReadOnly: (e) => !!X7.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (X7.get(e)) return !1;
    var n = xn.hasTarget(e, t) && xn.toSlateNode(e, t);
    return _l.isElement(n) && wr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = bQe.get(e), r = wr.isEditor(t) ? vQe.get(e) : n == null ? void 0 : n.get(xn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(js.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = wr.node(e, t.path), r = xn.toDOMNode(e, n), o;
    wr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof xQe ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(js.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Jt.isBackward(t), i = xn.toDOMPoint(e, n), a = Jt.isCollapsed(t) ? i : xn.toDOMPoint(e, r), s = xn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = Qa(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = Qa(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Qa(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? yQe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : EQe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = xn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = xn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (FP && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var R = U[k];
          if (xn.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var N = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, H = [...N(V), ...N(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = H.find((M) => SQe(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var X, G = [...N(V == null ? void 0 : V.previousElementSibling), ...N(V)];
          w = (X = G.findLast((M) => Y7(L, M))) !== null && X !== void 0 ? X : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      FP && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      vb && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (FP && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && xn.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = xn.toSlateNode(e, Y), {
          path: J,
          offset: P
        } = wr.start(e, xn.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = xn.toSlateNode(e, u), z = xn.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = K7(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (K7(t)) {
        if (vb && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        fQe && kQe(s) || vb ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    vb && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = xn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = Y7(s, u) || s === u && c < l, x = p ? w : xn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Jt.isExpanded(m) && Jt.isForward(m) && Qa(u) && wr.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = wr.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, _Qe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, TQe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, jQe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Co = (e) => {
  var t = _Qe[e], n = TQe[e], r = jQe[e], o = t && IP(t), i = n && IP(n), a = r && IP(r);
  return (s) => !!(o && o(s) || Z7 && i && i(s) || !Z7 && a && a(s));
};
Co("bold"), Co("compose"), Co("moveBackward"), Co("moveForward"), Co("deleteBackward"), Co("deleteForward"), Co("deleteLineBackward"), Co("deleteLineForward"), Co("deleteWordBackward"), Co("deleteWordForward"), Co("extendBackward"), Co("extendForward"), Co("extendLineBackward"), Co("extendLineForward"), Co("italic"), Co("moveLineBackward"), Co("moveLineForward"), Co("moveWordBackward"), Co("moveWordForward"), Co("redo"), Co("insertSoftBreak"), Co("splitBlock"), Co("transposeCharacter"), Co("undo");
var AQe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Ice(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, IQe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class BQe extends Kl {
  constructor() {
    super(...arguments), Vh(this, "context", null), Vh(this, "manager", null), Vh(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, IQe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = AQe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Vh(BQe, "contextType", dQe);
He({});
He({});
He({});
var ai = {}, kB = {}, Hm = {}, Vm = {}, Bce = "Expected a function", J7 = NaN, NQe = "[object Symbol]", RQe = /^\s+|\s+$/g, FQe = /^[-+]0x[0-9a-f]+$/i, zQe = /^0b[01]+$/i, UQe = /^0o[0-7]+$/i, WQe = parseInt, HQe = typeof Mr == "object" && Mr && Mr.Object === Object && Mr, VQe = typeof self == "object" && self && self.Object === Object && self, $Qe = HQe || VQe || Function("return this")(), ZQe = Object.prototype, qQe = ZQe.toString, XQe = Math.max, KQe = Math.min, zP = function() {
  return $Qe.Date.now();
};
function GQe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Bce);
  t = Q7(t) || 0, x1(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? XQe(Q7(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? KQe(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = zP();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(zP());
  }
  function m() {
    var C = zP(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function YQe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Bce);
  return x1(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), GQe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function x1(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function JQe(e) {
  return !!e && typeof e == "object";
}
function QQe(e) {
  return typeof e == "symbol" || JQe(e) && qQe.call(e) == NQe;
}
function Q7(e) {
  if (typeof e == "number")
    return e;
  if (QQe(e))
    return J7;
  if (x1(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = x1(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(RQe, "");
  var n = zQe.test(e);
  return n || UQe.test(e) ? WQe(e.slice(2), n ? 2 : 8) : FQe.test(e) ? J7 : +e;
}
var eet = YQe, $m = {};
Object.defineProperty($m, "__esModule", {
  value: !0
});
$m.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), a0.has(t) || a0.set(t, /* @__PURE__ */ new Set());
  var o = a0.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
$m.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), a0.get(t).delete(n.name || t);
};
var a0 = /* @__PURE__ */ new Map();
Object.defineProperty(Vm, "__esModule", {
  value: !0
});
var tet = eet, net = oet(tet), ret = $m;
function oet(e) {
  return e && e.__esModule ? e : { default: e };
}
var iet = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, net.default)(e, t);
}, Io = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = iet(function(r) {
        Io.scrollHandler(e);
      }, t);
      Io.scrollSpyContainers.push(e), (0, ret.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return Io.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Io.scrollSpyContainers[Io.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Io.currentPositionX(e), Io.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Io.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Io.scrollSpyContainers[Io.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(Io.currentPositionX(t), Io.currentPositionY(t));
  },
  updateStates: function() {
    Io.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Io.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Io.spySetState && Io.spySetState.length && Io.spySetState.indexOf(e) > -1 && Io.spySetState.splice(Io.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Io.scrollHandler);
  },
  update: function() {
    return Io.scrollSpyContainers.forEach(function(e) {
      return Io.scrollHandler(e);
    });
  }
};
Vm.default = Io;
var Kd = {}, Zm = {};
Object.defineProperty(Zm, "__esModule", {
  value: !0
});
var set = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, aet = function() {
  return window.location.hash.replace(/^#/, "");
}, uet = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, cet = function(e) {
  return getComputedStyle(e).position !== "static";
}, UP = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, pet = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (cet(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = UP(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return UP(t, s).offsetTop - UP(e, s).offsetTop;
};
Zm.default = {
  updateHash: set,
  getHash: aet,
  filterElementInContainer: uet,
  scrollOffset: pet
};
var iL = {}, PB = {};
Object.defineProperty(PB, "__esModule", {
  value: !0
});
PB.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var SB = {};
Object.defineProperty(SB, "__esModule", {
  value: !0
});
var det = $m, fet = ["mousedown", "mousewheel", "touchmove", "keydown"];
SB.default = {
  subscribe: function(e) {
    return typeof document < "u" && fet.forEach(function(t) {
      return (0, det.addPassiveEventListener)(document, t, e);
    });
  }
};
var qm = {};
Object.defineProperty(qm, "__esModule", {
  value: !0
});
var k_ = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      k_.registered[e] = t;
    },
    remove: function(e) {
      k_.registered[e] = null;
    }
  }
};
qm.default = k_;
Object.defineProperty(iL, "__esModule", {
  value: !0
});
var het = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, get = Zm;
sL(get);
var met = PB, eX = sL(met), vet = SB, yet = sL(vet), bet = qm, Va = sL(bet);
function sL(e) {
  return e && e.__esModule ? e : { default: e };
}
var Nce = function(e) {
  return eX.default[e.smooth] || eX.default.defaultEasing;
}, wet = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Oet = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, P_ = function() {
  return Oet() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Rce = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Fce = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, zce = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, Cet = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, xet = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, Let = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Va.default.registered.end && Va.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    P_.call(window, i);
    return;
  }
  Va.default.registered.end && Va.default.registered.end(o.to, o.target, o.currentPosition);
}, MB = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Xm = function(e, t, n, r) {
  t.data = t.data || Rce(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (yet.default.subscribe(o), MB(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Fce(t) : zce(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Va.default.registered.end && Va.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = wet(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Nce(t), a = Let.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Va.default.registered.begin && Va.default.registered.begin(t.data.to, t.data.target), P_.call(window, a);
    }, t.delay);
    return;
  }
  Va.default.registered.begin && Va.default.registered.begin(t.data.to, t.data.target), P_.call(window, a);
}, aL = function(e) {
  return e = het({}, e), e.data = e.data || Rce(), e.absolute = !0, e;
}, Eet = function(e) {
  Xm(0, aL(e));
}, ket = function(e, t) {
  Xm(e, aL(t));
}, Pet = function(e) {
  e = aL(e), MB(e), Xm(e.horizontal ? Cet(e) : xet(e), e);
}, Met = function(e, t) {
  t = aL(t), MB(t);
  var n = t.horizontal ? Fce(t) : zce(t);
  Xm(e + n, t);
};
iL.default = {
  animateTopScroll: Xm,
  getAnimationType: Nce,
  scrollToTop: Eet,
  scrollToBottom: Pet,
  scrollTo: ket,
  scrollMore: Met
};
Object.defineProperty(Kd, "__esModule", {
  value: !0
});
var Det = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, _et = Zm, Tet = DB(_et), jet = iL, Aet = DB(jet), Iet = qm, bb = DB(Iet);
function DB(e) {
  return e && e.__esModule ? e : { default: e };
}
var wb = {}, tX = void 0;
Kd.default = {
  unmount: function() {
    wb = {};
  },
  register: function(e, t) {
    wb[e] = t;
  },
  unregister: function(e) {
    delete wb[e];
  },
  get: function(e) {
    return wb[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return tX = e;
  },
  getActiveLink: function() {
    return tX;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Det({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = Tet.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      bb.default.registered.begin && bb.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, bb.default.registered.end && bb.default.registered.end(e, n);
      return;
    }
    Aet.default.animateTopScroll(s, t, e, n);
  }
};
var S_ = { exports: {} }, WP = { exports: {} }, ir = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nX;
function Bet() {
  if (nX) return ir;
  nX = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return ir.AsyncMode = l, ir.ConcurrentMode = u, ir.ContextConsumer = s, ir.ContextProvider = a, ir.Element = t, ir.ForwardRef = c, ir.Fragment = r, ir.Lazy = f, ir.Memo = y, ir.Portal = n, ir.Profiler = i, ir.StrictMode = o, ir.Suspense = p, ir.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, ir.isConcurrentMode = x, ir.isContextConsumer = function(m) {
    return D(m) === s;
  }, ir.isContextProvider = function(m) {
    return D(m) === a;
  }, ir.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, ir.isForwardRef = function(m) {
    return D(m) === c;
  }, ir.isFragment = function(m) {
    return D(m) === r;
  }, ir.isLazy = function(m) {
    return D(m) === f;
  }, ir.isMemo = function(m) {
    return D(m) === y;
  }, ir.isPortal = function(m) {
    return D(m) === n;
  }, ir.isProfiler = function(m) {
    return D(m) === i;
  }, ir.isStrictMode = function(m) {
    return D(m) === o;
  }, ir.isSuspense = function(m) {
    return D(m) === p;
  }, ir.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, ir.typeOf = D, ir;
}
var mr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rX;
function Net() {
  return rX || (rX = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === y || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === L || B.$$typeof === w || B.$$typeof === v);
    }
    function x(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var re = he && he.$$typeof;
                switch (re) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return re;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, R = c, N = r, V = f, $ = y, H = n, X = i, G = o, Y = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || x(B) === l;
    }
    function P(B) {
      return x(B) === u;
    }
    function _(B) {
      return x(B) === s;
    }
    function z(B) {
      return x(B) === a;
    }
    function M(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return x(B) === c;
    }
    function O(B) {
      return x(B) === r;
    }
    function I(B) {
      return x(B) === f;
    }
    function F(B) {
      return x(B) === y;
    }
    function j(B) {
      return x(B) === n;
    }
    function q(B) {
      return x(B) === i;
    }
    function A(B) {
      return x(B) === o;
    }
    function K(B) {
      return x(B) === p;
    }
    mr.AsyncMode = m, mr.ConcurrentMode = C, mr.ContextConsumer = S, mr.ContextProvider = U, mr.Element = k, mr.ForwardRef = R, mr.Fragment = N, mr.Lazy = V, mr.Memo = $, mr.Portal = H, mr.Profiler = X, mr.StrictMode = G, mr.Suspense = Y, mr.isAsyncMode = J, mr.isConcurrentMode = P, mr.isContextConsumer = _, mr.isContextProvider = z, mr.isElement = M, mr.isForwardRef = W, mr.isFragment = O, mr.isLazy = I, mr.isMemo = F, mr.isPortal = j, mr.isProfiler = q, mr.isStrictMode = A, mr.isSuspense = K, mr.isValidElementType = D, mr.typeOf = x;
  }()), mr;
}
var oX;
function Uce() {
  return oX || (oX = 1, process.env.NODE_ENV === "production" ? WP.exports = Bet() : WP.exports = Net()), WP.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var HP, iX;
function Ret() {
  if (iX) return HP;
  iX = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return HP = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, HP;
}
var VP, sX;
function _B() {
  if (sX) return VP;
  sX = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return VP = e, VP;
}
var aX, lX;
function Wce() {
  return lX || (lX = 1, aX = Function.call.bind(Object.prototype.hasOwnProperty)), aX;
}
var $P, uX;
function Fet() {
  if (uX) return $P;
  uX = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = _B(), n = {}, r = Wce();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, $P = o, $P;
}
var ZP, cX;
function zet() {
  if (cX) return ZP;
  cX = 1;
  var e = Uce(), t = Ret(), n = _B(), r = Wce(), o = Fet(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return ZP = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, I, F, j, q, A, K) {
        if (j = j || d, A = A || F, K !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = j + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return I[F] == null ? O ? I[F] === null ? new v("The " + q + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new v("The " + q + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : P(I, F, j, q, A);
      }
      var W = M.bind(null, !1);
      return W.isRequired = M.bind(null, !0), W;
    }
    function L(P) {
      function _(z, M, W, O, I, F) {
        var j = z[M], q = G(j);
        if (q !== P) {
          var A = Y(j);
          return new v(
            "Invalid " + O + " `" + I + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var j = G(F);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var A = P(F, q, W, O, I + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!s(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!e.isValidElementType(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, W, O, I) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, j = J(z[M]);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, W, O, I) {
        for (var F = z[M], j = 0; j < P.length; j++)
          if (f(F, P[j]))
            return null;
        var q = JSON.stringify(P, function(A, K) {
          var B = Y(K);
          return B === "symbol" ? String(K) : K;
        });
        return new v("Invalid " + O + " `" + I + "` of value `" + String(F) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var A = P(F, q, W, O, I + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(W, O, I, F, j) {
        for (var q = [], A = 0; A < P.length; A++) {
          var K = P[A], B = K(W, O, I, F, j, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + j + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(M);
    }
    function R() {
      function P(_, z, M, W, O) {
        return H(_[z]) ? null : new v("Invalid " + W + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function N(P, _, z, M, W) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return N(W, O, I, q, Y(A));
          var K = A(F, q, W, O, I + "." + q, n);
          if (K)
            return K;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var A in q) {
          var K = P[A];
          if (r(P, A) && typeof K != "function")
            return N(W, O, I, A, Y(K));
          if (!K)
            return new v(
              "Invalid " + O + " `" + I + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = K(F, A, W, O, I + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!H(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var W = M.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function X(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function G(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : X(_, P) ? "symbol" : _;
    }
    function Y(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = G(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = Y(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, ZP;
}
var qP, pX;
function Uet() {
  if (pX) return qP;
  pX = 1;
  var e = _B();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, qP = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, qP;
}
if (process.env.NODE_ENV !== "production") {
  var Wet = Uce(), Het = !0;
  S_.exports = zet()(Wet.isElement, Het);
} else
  S_.exports = Uet()();
var lL = S_.exports, uL = {};
Object.defineProperty(uL, "__esModule", {
  value: !0
});
var Vet = Zm, XP = $et(Vet);
function $et(e) {
  return e && e.__esModule ? e : { default: e };
}
var Zet = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return XP.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && XP.default.getHash() !== e && XP.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
uL.default = Zet;
Object.defineProperty(Hm, "__esModule", {
  value: !0
});
var Ob = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, qet = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Xet = Oe, dX = Km(Xet), Ket = Vm, Cb = Km(Ket), Get = Kd, Yet = Km(Get), Jet = lL, xo = Km(Jet), Qet = uL, vu = Km(Qet);
function Km(e) {
  return e && e.__esModule ? e : { default: e };
}
function ett(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ttt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ntt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var fX = {
  to: xo.default.string.isRequired,
  containerId: xo.default.string,
  container: xo.default.object,
  activeClass: xo.default.string,
  activeStyle: xo.default.object,
  spy: xo.default.bool,
  horizontal: xo.default.bool,
  smooth: xo.default.oneOfType([xo.default.bool, xo.default.string]),
  offset: xo.default.number,
  delay: xo.default.number,
  isDynamic: xo.default.bool,
  onClick: xo.default.func,
  duration: xo.default.oneOfType([xo.default.number, xo.default.func]),
  absolute: xo.default.bool,
  onSetActive: xo.default.func,
  onSetInactive: xo.default.func,
  ignoreCancelEvents: xo.default.bool,
  hashSpy: xo.default.bool,
  saveHashHistory: xo.default.bool,
  spyThrottle: xo.default.number
};
Hm.default = function(e, t) {
  var n = t || Yet.default, r = function(i) {
    ntt(a, i);
    function a(s) {
      ett(this, a);
      var l = ttt(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return qet(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          Cb.default.isMounted(s) || Cb.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (vu.default.isMounted() || vu.default.mount(n), vu.default.mapContainer(this.props.to, s)), Cb.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Cb.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Ob({}, this.props.style, this.props.activeStyle) : l = Ob({}, this.props.style);
        var u = Ob({}, this.props);
        for (var c in fX)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, dX.default.createElement(e, u);
      }
    }]), a;
  }(dX.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Ob({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(vu.default.isMounted() && !vu.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var R = n.getActiveLink();
        if (y) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && vu.default.getHash() === c) {
            var N = i.props.saveHashHistory, V = N === void 0 ? !1 : N;
            vu.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, H = $ === void 0 ? !1 : $;
          i.props.hashSpy && vu.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = fX, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(kB, "__esModule", {
  value: !0
});
var rtt = Oe, hX = Hce(rtt), ott = Hm, itt = Hce(ott);
function Hce(e) {
  return e && e.__esModule ? e : { default: e };
}
function stt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function gX(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function att(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ltt = function(e) {
  att(t, e);
  function t() {
    var n, r, o, i;
    stt(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = gX(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return hX.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), gX(o, i);
  }
  return t;
}(hX.default.Component);
kB.default = (0, itt.default)(ltt);
var TB = {};
Object.defineProperty(TB, "__esModule", {
  value: !0
});
var utt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ctt = Oe, mX = Vce(ctt), ptt = Hm, dtt = Vce(ptt);
function Vce(e) {
  return e && e.__esModule ? e : { default: e };
}
function ftt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function htt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function gtt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var mtt = function(e) {
  gtt(t, e);
  function t() {
    return ftt(this, t), htt(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return utt(t, [{
    key: "render",
    value: function() {
      return mX.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(mX.default.Component);
TB.default = (0, dtt.default)(mtt);
var jB = {}, cL = {};
Object.defineProperty(cL, "__esModule", {
  value: !0
});
var vtt = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, ytt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), btt = Oe, vX = pL(btt), wtt = nl;
pL(wtt);
var Ott = Kd, yX = pL(Ott), Ctt = lL, bX = pL(Ctt);
function pL(e) {
  return e && e.__esModule ? e : { default: e };
}
function xtt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ltt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Ett(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
cL.default = function(e) {
  var t = function(n) {
    Ett(r, n);
    function r(o) {
      xtt(this, r);
      var i = Ltt(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return ytt(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        yX.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        yX.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return vX.default.createElement(e, vtt({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(vX.default.Component);
  return t.propTypes = {
    name: bX.default.string,
    id: bX.default.string
  }, t;
};
Object.defineProperty(jB, "__esModule", {
  value: !0
});
var wX = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, ktt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Ptt = Oe, OX = AB(Ptt), Stt = cL, Mtt = AB(Stt), Dtt = lL, CX = AB(Dtt);
function AB(e) {
  return e && e.__esModule ? e : { default: e };
}
function _tt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ttt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function jtt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var $ce = function(e) {
  jtt(t, e);
  function t() {
    return _tt(this, t), Ttt(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return ktt(t, [{
    key: "render",
    value: function() {
      var n = this, r = wX({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, OX.default.createElement(
        "div",
        wX({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(OX.default.Component);
$ce.propTypes = {
  name: CX.default.string,
  id: CX.default.string
};
jB.default = (0, Mtt.default)($ce);
var KP = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, xX = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function LX(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function EX(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function kX(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var xb = Oe, Hc = Vm, GP = Kd, Vo = lL, yu = uL, PX = {
  to: Vo.string.isRequired,
  containerId: Vo.string,
  container: Vo.object,
  activeClass: Vo.string,
  spy: Vo.bool,
  smooth: Vo.oneOfType([Vo.bool, Vo.string]),
  offset: Vo.number,
  delay: Vo.number,
  isDynamic: Vo.bool,
  onClick: Vo.func,
  duration: Vo.oneOfType([Vo.number, Vo.func]),
  absolute: Vo.bool,
  onSetActive: Vo.func,
  onSetInactive: Vo.func,
  ignoreCancelEvents: Vo.bool,
  hashSpy: Vo.bool,
  spyThrottle: Vo.number
}, Att = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || GP, r = function(i) {
      kX(a, i);
      function a(s) {
        LX(this, a);
        var l = EX(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return xX(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Hc.isMounted(s) || Hc.mount(s, this.props.spyThrottle), this.props.hashSpy && (yu.isMounted() || yu.mount(n), yu.mapContainer(this.props.to, s)), this.props.spy && Hc.addStateHandler(this.stateHandler), Hc.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Hc.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = KP({}, this.props);
          for (var u in PX)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, xb.createElement(e, l);
        }
      }]), a;
    }(xb.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, KP({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(yu.isMounted() && !yu.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && yu.getHash() === l && yu.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Hc.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && yu.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Hc.updateStates();
        }
      };
    };
    return r.propTypes = PX, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      kX(r, n);
      function r(o) {
        LX(this, r);
        var i = EX(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return xX(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          GP.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          GP.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return xb.createElement(e, KP({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(xb.Component);
    return t.propTypes = {
      name: Vo.string,
      id: Vo.string
    }, t;
  }
}, Itt = Att;
Object.defineProperty(ai, "__esModule", {
  value: !0
});
ai.Helpers = ai.ScrollElement = ai.ScrollLink = ai.animateScroll = ai.scrollSpy = ai.Events = ai.scroller = ai.Element = ai.Button = ai.Link = void 0;
var Btt = kB, Zce = ul(Btt), Ntt = TB, qce = ul(Ntt), Rtt = jB, Xce = ul(Rtt), Ftt = Kd, Kce = ul(Ftt), ztt = qm, Gce = ul(ztt), Utt = Vm, Yce = ul(Utt), Wtt = iL, Jce = ul(Wtt), Htt = Hm, Qce = ul(Htt), Vtt = cL, epe = ul(Vtt), $tt = Itt, tpe = ul($tt);
function ul(e) {
  return e && e.__esModule ? e : { default: e };
}
ai.Link = Zce.default;
ai.Button = qce.default;
ai.Element = Xce.default;
ai.scroller = Kce.default;
ai.Events = Gce.default;
ai.scrollSpy = Yce.default;
ai.animateScroll = Jce.default;
ai.ScrollLink = Qce.default;
ai.ScrollElement = epe.default;
ai.Helpers = tpe.default;
ai.default = { Link: Zce.default, Button: qce.default, Element: Xce.default, scroller: Kce.default, Events: Gce.default, scrollSpy: Yce.default, animateScroll: Jce.default, ScrollLink: Qce.default, ScrollElement: epe.default, Helpers: tpe.default };
He({});
He({});
He({});
function qg(e) {
  "@babel/helpers - typeof";
  return qg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, qg(e);
}
function Ztt(e, t) {
  if (qg(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (qg(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function qtt(e) {
  var t = Ztt(e, "string");
  return qg(t) == "symbol" ? t : t + "";
}
function Re(e, t, n) {
  return (t = qtt(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function npe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var YP, SX;
function Xtt() {
  if (SX) return YP;
  SX = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return YP = t, YP;
}
var Ktt = Xtt(), mi = /* @__PURE__ */ npe(Ktt), Xt = He(null);
function Gtt() {
  mi(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Xt);
  return mi(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Ytt(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function Jtt(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Qtt(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Jtt(e, i), o;
}
function ent(e, t, n) {
  var r = Ytt(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function tnt(e) {
  google.maps.event.removeListener(e);
}
function Wn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(tnt);
}
function _n(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = ent(o, i, n);
  return Qtt(t, r, o, i), a;
}
function nnt(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = vt(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null), [A, K] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), K(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var B = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(B), B !== null && D && D(B), () => {
      B !== null && x && x(B);
    };
  }, []), gs.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: gs.jsx(Xt.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(nnt);
function MX(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function rpe(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        MX(i, r, o, a, s, "next", l);
      }
      function s(l) {
        MX(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function ope(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return mi(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var Op = typeof document < "u";
function ipe(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return Op ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function DX(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function spe() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return DX(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return DX(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Ff = !1;
function ape() {
  return gs.jsx("div", {
    children: "Loading..."
  });
}
var M_ = {
  id: "script-loader",
  version: "weekly"
};
class rnt extends pe {
  constructor() {
    super(...arguments), Re(this, "check", jn()), Re(this, "state", {
      loaded: !1
    }), Re(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Re(this, "isCleaningUp", /* @__PURE__ */ rpe(function* () {
      function t(n) {
        if (!Ff)
          n();
        else if (Op)
          var r = window.setInterval(function() {
            Ff || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Re(this, "cleanup", () => {
      Ff = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Re(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && spe(), mi(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: ope(this.props)
      };
      ipe(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (Op) {
      if (window.google && window.google.maps && !Ff) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), Op && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (Op) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Ff = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return gs.jsxs(gs.Fragment, {
      children: [gs.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || gs.jsx(ape, {})]
    });
  }
}
Re(rnt, "defaultProps", M_);
function ont(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function IB(e, t) {
  if (e == null) return {};
  var n, r, o = ont(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var _X;
function int(e) {
  var {
    id: t = M_.id,
    version: n = M_.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = vt(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    Op && u && spe();
  }, [u]), h(function() {
    f && mi(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = ope({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!Op)
      return;
    function x() {
      y.current && (v(!0), _X = w);
    }
    if (window.google && window.google.maps && _X === w) {
      x();
      return;
    }
    ipe({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = vt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var snt = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], ant = gs.jsx(ape, {});
function lnt(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = IB(e, snt), {
    isLoaded: s,
    loadError: l
  } = int(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || ant;
}
me(lnt);
var TX;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(TX || (TX = {}));
function jX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function L1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jX(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var AX = {}, IX = {
  options(e, t) {
    e.setOptions(t);
  }
};
function unt(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Xt), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(L1(L1({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(unt);
class cnt extends pe {
  constructor() {
    super(...arguments), Re(this, "state", {
      trafficLayer: null
    }), Re(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Re(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(L1(L1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: IX,
      eventMap: AX,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: IX,
      eventMap: AX,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Wn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Re(cnt, "contextType", Xt);
function pnt(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Xt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(pnt);
class dnt extends pe {
  constructor() {
    super(...arguments), Re(this, "state", {
      bicyclingLayer: null
    }), Re(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Re(dnt, "contextType", Xt);
function fnt(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Xt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(fnt);
class hnt extends pe {
  constructor() {
    super(...arguments), Re(this, "state", {
      transitLayer: null
    }), Re(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Re(hnt, "contextType", Xt);
function BX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function E1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BX(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var NX = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, RX = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function gnt(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Xt), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    mi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(E1(E1({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && L(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && k(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(gnt);
class mnt extends pe {
  constructor(t) {
    super(t), Re(this, "registeredEvents", []), Re(this, "state", {
      drawingManager: null
    }), Re(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), mi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(E1(E1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: RX,
      eventMap: NX,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: RX,
      eventMap: NX,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Wn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Re(mnt, "contextType", Xt);
function FX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FX(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zX = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, UX = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, k1 = {};
function vnt(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: R,
    onClickableChanged: N,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: H,
    onFlatChanged: X,
    onIconChanged: G,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, W = ge(Xt), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null), [re, Se] = E(null), [We, Ze] = E(null), [Me, rt] = E(null), [Ve, be] = E(null), [qe, ct] = E(null), [ye, xe] = E(null), [Ee, Ue] = E(null), [De, st] = E(null), [ve, wt] = E(null), [at, lt] = E(null), [pt, Ot] = E(null), [dt, Ct] = E(null), [Xe, ht] = E(null), [ot, xt] = E(null), [ft, Pt] = E(null), [Lt, St] = E(null), [Et, Mt] = E(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (re !== null && google.maps.event.removeListener(re), Se(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), Ze(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Me !== null && google.maps.event.removeListener(Me), rt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && R && (Ve !== null && google.maps.event.removeListener(Ve), be(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && L && (qe !== null && google.maps.event.removeListener(qe), ct(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (ye !== null && google.maps.event.removeListener(ye), xe(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && N && (Ee !== null && google.maps.event.removeListener(Ee), Ue(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && V && (De !== null && google.maps.event.removeListener(De), st(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), wt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && X && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(O, "flat_changed", X)));
  }, [X]), h(() => {
    O && G && (dt !== null && google.maps.event.removeListener(dt), Ct(google.maps.event.addListener(O, "icon_changed", G)));
  }, [G]), h(() => {
    O && Y && (Xe !== null && google.maps.event.removeListener(Xe), ht(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (ot !== null && google.maps.event.removeListener(ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (ft !== null && google.maps.event.removeListener(ft), Pt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Lt !== null && google.maps.event.removeListener(Lt), St(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (Et !== null && google.maps.event.removeListener(Et), Mt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var gt = dd(dd(dd({}, n || k1), r ? k1 : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(gt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof y < "u" && te.setOpacity(y), f && te.setShape(f), typeof v == "string" && te.setTitle(v), typeof b == "number" && te.setZIndex(b), w && j(google.maps.event.addListener(te, "dblclick", w)), x && A(google.maps.event.addListener(te, "dragend", x)), m && B(google.maps.event.addListener(te, "dragstart", m)), k && he(google.maps.event.addListener(te, "mousedown", k)), C && Se(google.maps.event.addListener(te, "mouseout", C)), S && Ze(google.maps.event.addListener(te, "mouseover", S)), U && rt(google.maps.event.addListener(te, "mouseup", U)), R && be(google.maps.event.addListener(te, "rightclick", R)), L && ct(google.maps.event.addListener(te, "click", L)), D && xe(google.maps.event.addListener(te, "drag", D)), N && Ue(google.maps.event.addListener(te, "clickable_changed", N)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), $ && wt(google.maps.event.addListener(te, "animation_changed", $)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), X && Ot(google.maps.event.addListener(te, "flat_changed", X)), G && Ct(google.maps.event.addListener(te, "icon_changed", G)), Y && ht(google.maps.event.addListener(te, "position_changed", Y)), Q && xt(google.maps.event.addListener(te, "shape_changed", Q)), J && Pt(google.maps.event.addListener(te, "title_changed", J)), P && St(google.maps.event.addListener(te, "visible_changed", P)), _ && Mt(google.maps.event.addListener(te, "zindex_changed", _)), I(te), z && z(te), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), re !== null && google.maps.event.removeListener(re), We !== null && google.maps.event.removeListener(We), Me !== null && google.maps.event.removeListener(Me), Ve !== null && google.maps.event.removeListener(Ve), qe !== null && google.maps.event.removeListener(qe), Ee !== null && google.maps.event.removeListener(Ee), De !== null && google.maps.event.removeListener(De), ve !== null && google.maps.event.removeListener(ve), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), Xe !== null && google.maps.event.removeListener(Xe), ft !== null && google.maps.event.removeListener(ft), Lt !== null && google.maps.event.removeListener(Lt), Et !== null && google.maps.event.removeListener(Et), M && M(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var _t = zt(() => i ? ut.map(i, (gt) => {
    if (!wi(gt))
      return gt;
    var te = gt;
    return Oi(te, {
      anchor: O
    });
  }) : null, [i, O]);
  return gs.jsx(gs.Fragment, {
    children: _t
  }) || null;
}
me(vnt);
class ynt extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return rpe(function* () {
      var n = dd(dd(dd({}, t.props.options || k1), t.props.clusterer ? k1 : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = _n({
        updaterMap: UX,
        eventMap: zX,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: UX,
      eventMap: zX,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Wn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Oi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Re(ynt, "contextType", Xt);
var bnt = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), wnt = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new bnt(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function Ont(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Cnt = 2e3, xnt = 500, Lnt = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Ent = "png", knt = [53, 56, 66, 78, 90], Pnt = "cluster", lpe = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Lnt, this.imageExtension = r.imageExtension || Ent, this.imageSizes = r.imageSizes || knt, this.calculator = r.calculator || Ont, this.batchSize = r.batchSize || Cnt, this.batchSizeIE = r.batchSizeIE || xnt, this.clusterClass = r.clusterClass || Pnt, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new wnt(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function WX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Snt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WX(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wa = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Gn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Mnt = {};
function Dnt(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, R] = E(null), N = ge(Xt), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, wa.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, wa.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, wa.onClick, w)));
  }, [w]), h(() => {
    k && D && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(k, wa.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (G !== null && google.maps.event.removeListener(G), X(google.maps.event.addListener(k, wa.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && Gn.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && Gn.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && Gn.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && Gn.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && Gn.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && Gn.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && Gn.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && Gn.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && Gn.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && Gn.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && Gn.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && Gn.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && Gn.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && Gn.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && Gn.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (N) {
      var z = Snt({}, n || Mnt), M = new lpe(N, [], z);
      return r && Gn.averageCenter(M, r), o && Gn.batchSizeIE(M, o), i && Gn.calculator(M, i), a && Gn.clusterClass(M, a), s && Gn.enableRetinaIcons(M, s), l && Gn.gridSize(M, l), u && Gn.ignoreHidden(M, u), c && Gn.imageExtension(M, c), p && Gn.imagePath(M, p), d && Gn.imageSizes(M, d), y && Gn.maxZoom(M, y), f && Gn.minimumClusterSize(M, f), v && Gn.styles(M, v), b && Gn.title(M, b), L && Gn.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, wa.onMouseOut, C)), m && _(google.maps.event.addListener(M, wa.onMouseOver, m)), w && $(google.maps.event.addListener(M, wa.onClick, w)), D && X(google.maps.event.addListener(M, wa.onClusteringBegin, D)), x && Y(google.maps.event.addListener(M, wa.onClusteringEnd, x)), R(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(Dnt);
class _nt extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      markerClusterer: null
    }), Re(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new lpe(this.context, [], this.props.options);
      this.registeredEvents = _n({
        updaterMap: Gn,
        eventMap: wa,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: Gn,
      eventMap: wa,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Wn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Re(_nt, "contextType", Xt);
function HX(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var upe = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || HX(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, HX));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Tnt = ["position"], jnt = ["position"];
function VX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function P1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VX(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $X = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, ZX = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Ant = {};
function Int(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Xt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var N = r || Ant, {
        position: V
      } = N, $ = IB(N, Tnt), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var X = new upe(P1(P1({}, $), H ? {
        position: H
      } : {}));
      R.current = document.createElement("div"), v(X), a && L(google.maps.event.addListener(X, "closeclick", a)), s && D(google.maps.event.addListener(X, "domready", s)), l && m(google.maps.event.addListener(X, "content_changed", l)), u && S(google.maps.event.addListener(X, "position_changed", u)), c && k(google.maps.event.addListener(X, "zindex_changed", c)), X.setContent(R.current), n ? X.open(y, n) : X.getPosition() ? X.open(y) : mi(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(X);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(Int);
class Bnt extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "containerElement", null), Re(this, "state", {
      infoBox: null
    }), Re(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : mi(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Re(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = IB(t, jnt), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new upe(P1(P1({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = _n({
      updaterMap: ZX,
      eventMap: $X,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: ZX,
      eventMap: $X,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Wn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
Re(Bnt, "contextType", Xt);
var qX, XX;
function Nnt() {
  return XX || (XX = 1, qX = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), qX;
}
var Rnt = Nnt(), KX = /* @__PURE__ */ npe(Rnt), GX = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], JP = 1, zf = 8;
class BB {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== JP)
      throw new Error("Got v".concat(o, " data when expected v").concat(JP, "."));
    var i = GX[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new BB(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = GX.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, zf, t), this.coords = new this.ArrayType(this.data, zf + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(zf + a + s + l), this.ids = new this.IndexArrayType(this.data, zf, t), this.coords = new this.ArrayType(this.data, zf + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (JP << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return D_(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          YX(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      YX(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function D_(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    cpe(e, t, a, r, o, i), D_(e, t, n, r, a - 1, 1 - i), D_(e, t, n, a + 1, o, 1 - i);
  }
}
function cpe(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      cpe(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (Uf(e, t, r, n), t[2 * o + i] > y && Uf(e, t, r, o); f < v; ) {
      for (Uf(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? Uf(e, t, r, v) : (v++, Uf(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function Uf(e, t, n, r) {
  QP(e, n, r), QP(t, 2 * n, 2 * r), QP(t, 2 * n + 1, 2 * r + 1);
}
function QP(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function YX(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Fnt = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, JX = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Vc = 2, Fu = 3, eS = 4, Du = 5, ppe = 6;
class znt {
  constructor(t) {
    this.options = Object.assign(Object.create(Fnt), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = JX(Lb(u)), d = JX(Eb(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Lb(r), Eb(a), Lb(i), Eb(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Du] > 1 ? QX(p, f, this.clusterProps) : this.points[p[f + Fu]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + eS] === t && p.push(a[y + Du] > 1 ? QX(a, y, this.clusterProps) : this.points[a[y + Fu]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new BB(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Du] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = dpe(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Fu]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = Lb(f), d = Eb(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + Fu] : L = this.points[n[l + Fu]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Vc] <= n)) {
        l[p + Vc] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Du], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + Vc] > n && (b += l[w + Du]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + Vc] <= n)) {
              l[k + Vc] = n;
              var R = l[k + Du];
              D += l[k] * R, x += l[k + 1] * R, l[k + eS] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + eS] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + Vc] <= n)) {
                l[$ + Vc] = n;
                for (var H = 0; H < c; H++) u.push(l[$ + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Du] > 1) {
      var o = this.clusterProps[t[n + ppe]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Fu]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function QX(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Fu],
    properties: dpe(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [Unt(e[t]), Wnt(e[t + 1])]
    }
  };
}
function dpe(e, t, n) {
  var r = e[t + Du], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + ppe], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Fu],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Lb(e) {
  return e / 360 + 0.5;
}
function Eb(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function Unt(e) {
  return (e - 0.5) * 360;
}
function Wnt(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Hnt(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Zs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class __ {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Zs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Zs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Zs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Vnt {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return $nt(n);
  }
}
var $nt = (e) => {
  var t = e.map((n) => new __({
    position: Zs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class Znt extends Vnt {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = Hnt(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new znt(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!KX(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Zs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !KX(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new __({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new __({
      markers: [i],
      position: Zs.getPosition(i)
    });
  }
}
class qnt {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Xnt {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Zs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function Knt(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class NB {
  constructor() {
    Knt(NB, google.maps.OverlayView);
  }
}
var $h;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})($h || ($h = {}));
var Gnt = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Ynt extends NB {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new Znt(o),
      renderer: a = new Xnt(),
      onClusterClick: s = Gnt
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Zs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, $h.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Zs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Zs.setMap(l, null)));
      }
      google.maps.event.trigger(this, $h.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Zs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new qnt(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Zs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, $h.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Zs.setMap(r.marker, n);
    });
  }
}
function eK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tK(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Jnt(e) {
  var t = Gtt(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new Ynt(tK(tK({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Qnt(e) {
  var {
    children: t,
    options: n
  } = e, r = Jnt(n);
  return r !== null ? t(r) : null;
}
me(Qnt);
var nK = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, rK = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function ert(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Xt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return v(N), R.current = document.createElement("div"), a && L(google.maps.event.addListener(N, "closeclick", a)), s && D(google.maps.event.addListener(N, "domready", s)), l && m(google.maps.event.addListener(N, "content_changed", l)), u && S(google.maps.event.addListener(N, "position_changed", u)), c && k(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(R.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(y, n) : N.getPosition() ? N.open(y) : mi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(N), N.close();
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(ert);
class trt extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "containerElement", null), Re(this, "state", {
      infoWindow: null
    }), Re(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : mi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Re(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = _n({
      updaterMap: rK,
      eventMap: nK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: rK,
      eventMap: nK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Wn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
Re(trt, "contextType", Xt);
function oK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function S1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var iK = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, sK = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, nrt = {};
function rrt(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(Xt), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var j = new google.maps.Polyline(S1(S1({}, t || nrt), {}, {
      map: D
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && S(google.maps.event.addListener(j, "dblclick", a)), s && k(google.maps.event.addListener(j, "dragend", s)), l && N(google.maps.event.addListener(j, "dragstart", l)), u && $(google.maps.event.addListener(j, "mousedown", u)), c && X(google.maps.event.addListener(j, "mousemove", c)), p && Y(google.maps.event.addListener(j, "mouseout", p)), d && J(google.maps.event.addListener(j, "mouseover", d)), y && _(google.maps.event.addListener(j, "mouseup", y)), f && M(google.maps.event.addListener(j, "rightclick", f)), v && O(google.maps.event.addListener(j, "click", v)), b && F(google.maps.event.addListener(j, "drag", b)), m(j), L && L(j), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
me(rrt);
class ort extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      polyline: null
    }), Re(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(S1(S1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: sK,
      eventMap: iK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: sK,
      eventMap: iK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Wn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Re(ort, "contextType", Xt);
function aK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lK(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var uK = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, cK = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function irt(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Xt), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var A = new google.maps.Polygon(lK(lK({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && k(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && $(google.maps.event.addListener(A, "dragstart", u)), c && X(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), b && F(google.maps.event.addListener(A, "click", b)), L && q(google.maps.event.addListener(A, "drag", L)), S(A), w && w(A), () => {
      U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), D && D(A), A.setMap(null);
    };
  }, []), null;
}
me(irt);
class srt extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = _n({
      updaterMap: cK,
      eventMap: uK,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: cK,
      eventMap: uK,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Wn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Re(srt, "contextType", Xt);
function pK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function M1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dK = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, fK = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function art(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Xt), [m, C] = E(null), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var K = new google.maps.Rectangle(M1(M1({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && K.setVisible(i), typeof o < "u" && K.setEditable(o), typeof r < "u" && K.setDraggable(r), typeof n < "u" && K.setBounds(n), a && U(google.maps.event.addListener(K, "dblclick", a)), s && R(google.maps.event.addListener(K, "dragend", s)), l && V(google.maps.event.addListener(K, "dragstart", l)), u && H(google.maps.event.addListener(K, "mousedown", u)), c && G(google.maps.event.addListener(K, "mousemove", c)), p && Q(google.maps.event.addListener(K, "mouseout", p)), d && P(google.maps.event.addListener(K, "mouseover", d)), y && z(google.maps.event.addListener(K, "mouseup", y)), f && W(google.maps.event.addListener(K, "rightclick", f)), v && I(google.maps.event.addListener(K, "click", v)), b && j(google.maps.event.addListener(K, "drag", b)), L && A(google.maps.event.addListener(K, "bounds_changed", L)), C(K), w && w(K), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(K), K.setMap(null);
    };
  }, []), null;
}
me(art);
class lrt extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      rectangle: null
    }), Re(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(M1(M1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: fK,
      eventMap: dK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: fK,
      eventMap: dK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Wn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Re(lrt, "contextType", Xt);
function hK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function D1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gK = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, mK = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, urt = {};
function crt(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Xt), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var re = new google.maps.Circle(D1(D1({}, t || urt), {}, {
      map: C
    }));
    return typeof r == "number" && re.setRadius(r), typeof n < "u" && re.setCenter(n), typeof r == "number" && re.setRadius(r), typeof a < "u" && re.setVisible(a), typeof i < "u" && re.setEditable(i), typeof o < "u" && re.setDraggable(o), s && R(google.maps.event.addListener(re, "dblclick", s)), l && V(google.maps.event.addListener(re, "dragend", l)), u && H(google.maps.event.addListener(re, "dragstart", u)), c && G(google.maps.event.addListener(re, "mousedown", c)), p && Q(google.maps.event.addListener(re, "mousemove", p)), d && P(google.maps.event.addListener(re, "mouseout", d)), y && z(google.maps.event.addListener(re, "mouseover", y)), f && W(google.maps.event.addListener(re, "mouseup", f)), v && I(google.maps.event.addListener(re, "rightclick", v)), b && j(google.maps.event.addListener(re, "click", b)), L && A(google.maps.event.addListener(re, "drag", L)), w && B(google.maps.event.addListener(re, "center_changed", w)), D && he(google.maps.event.addListener(re, "radius_changed", D)), U(re), x && x(re), () => {
      k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), m && m(re), re.setMap(null);
    };
  }, []), null;
}
me(crt);
class prt extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      circle: null
    }), Re(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(D1(D1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: mK,
      eventMap: gK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: mK,
      eventMap: gK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Wn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Re(prt, "contextType", Xt);
function vK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yK = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, bK = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function drt(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(Xt), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var A = new google.maps.Data(_1(_1({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && k(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && $(google.maps.event.addListener(A, "mouseover", s)), l && X(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && q(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), j !== null && google.maps.event.removeListener(j), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(drt);
class frt extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      data: null
    }), Re(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(_1(_1({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = _n({
        updaterMap: bK,
        eventMap: yK,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: bK,
      eventMap: yK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Wn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Re(frt, "contextType", Xt);
function wK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function OK(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var CK = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, xK = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class hrt extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      kmlLayer: null
    }), Re(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(OK(OK({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: xK,
      eventMap: CK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: xK,
      eventMap: CK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Wn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Re(hrt, "contextType", Xt);
function fpe(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function grt(e, t) {
  return new t(e.lat, e.lng);
}
function mrt(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function vrt(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function yrt(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function brt(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function wrt(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function hpe(e, t, n, r) {
  return n !== void 0 ? brt(e, t, yrt(n, google.maps.LatLngBounds, mrt)) : wrt(e, t, vrt(r, google.maps.LatLng, grt));
}
function Ort(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function LK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Crt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function xrt(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = Crt({}, this.container ? fpe(this.container, o) : {
        x: 0,
        y: 0
      }), u = hpe(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function EK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lrt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function kK(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function PK(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Ert(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Xt), c = zt(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = zt(() => xrt(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
me(Ert);
class Gd extends pe {
  constructor(t) {
    super(t), Re(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Re(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      mi(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Re(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Re(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Lrt({
        x: 0,
        y: 0
      }, this.containerRef.current ? fpe(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = hpe(r, o, this.props.bounds, this.props.position);
      if (!Ort(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Re(this, "draw", () => {
      this.onPositionElement();
    }), Re(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = jn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = kK(t.position), r = kK(this.props.position), o = PK(t.bounds), i = PK(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(gs.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
Re(Gd, "FLOAT_PANE", "floatPane");
Re(Gd, "MAP_PANE", "mapPane");
Re(Gd, "MARKER_LAYER", "markerLayer");
Re(Gd, "OVERLAY_LAYER", "overlayLayer");
Re(Gd, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Re(Gd, "contextType", Xt);
function krt() {
}
function SK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function MK(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var DK = {
  onDblClick: "dblclick",
  onClick: "click"
}, _K = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Prt(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Xt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = zt(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(Prt);
class gpe extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      groundOverlay: null
    }), Re(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    mi(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, MK(MK({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: _K,
      eventMap: DK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: _K,
      eventMap: DK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Re(gpe, "defaultProps", {
  onLoad: krt
});
Re(gpe, "contextType", Xt);
function TK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function T1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jK = {}, AK = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Srt(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Xt), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || mi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    mi(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(T1(T1({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(Srt);
class Mrt extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      heatmapLayer: null
    }), Re(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    mi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), mi(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(T1(T1({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: AK,
      eventMap: jK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: AK,
      eventMap: jK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Wn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Re(Mrt, "contextType", Xt);
var IK = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, BK = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Drt extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      streetViewPanorama: null
    }), Re(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = _n({
      updaterMap: BK,
      eventMap: IK,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: BK,
      eventMap: IK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Wn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Re(Drt, "contextType", Xt);
class _rt extends pe {
  constructor() {
    super(...arguments), Re(this, "state", {
      streetViewService: null
    }), Re(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Re(_rt, "contextType", Xt);
var NK = {
  onDirectionsChanged: "directions_changed"
}, RK = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Trt extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      directionsRenderer: null
    }), Re(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = _n({
      updaterMap: RK,
      eventMap: NK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: RK,
      eventMap: NK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Wn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Re(Trt, "contextType", Xt);
var FK = {
  onPlacesChanged: "places_changed"
}, zK = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class jrt extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "containerElement", jn()), Re(this, "state", {
      searchBox: null
    }), Re(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (mi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = _n({
          updaterMap: zK,
          eventMap: FK,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: zK,
      eventMap: FK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Wn(this.registeredEvents));
  }
  render() {
    return gs.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
Re(jrt, "contextType", Xt);
var UK = {
  onPlaceChanged: "place_changed"
}, WK = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class mpe extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "containerElement", jn()), Re(this, "state", {
      autocomplete: null
    }), Re(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    mi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = _n({
        updaterMap: WK,
        eventMap: UK,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Wn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: WK,
      eventMap: UK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Wn(this.registeredEvents);
  }
  render() {
    return gs.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
Re(mpe, "defaultProps", {
  className: ""
});
Re(mpe, "contextType", Xt);
let Art = { data: "" }, Irt = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Art, Brt = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Nrt = /\/\*[^]*?\*\/|  +/g, HK = /\n+/g, Gu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Gu(a, i) : i + "{" + Gu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Gu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Gu.p ? Gu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Pl = {}, vpe = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + vpe(e[n]);
    return t;
  }
  return e;
}, Rrt = (e, t, n, r, o) => {
  let i = vpe(e), a = Pl[i] || (Pl[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Pl[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Brt.exec(u.replace(Nrt, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(HK, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(HK, " ").trim();
      return d[0];
    })(e);
    Pl[a] = Gu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Pl.g ? Pl.g : null;
  return n && (Pl.g = Pl[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Pl[a], t, r, s), a;
}, Frt = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Gu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function dL(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Rrt(n.unshift ? n.raw ? Frt(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Irt(t.target), t.g, t.o, t.k);
}
let ype, T_, j_;
dL.bind({ g: 1 });
let Zl = dL.bind({ k: 1 });
function zrt(e, t, n, r) {
  Gu.p = t, ype = e, T_ = n, j_ = r;
}
function Pc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: T_ && T_() }, s), n.o = / *go\d+/.test(l), s.className = dL.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), j_ && u[0] && j_(s), ype(u, s);
    }
    return o;
  };
}
var Urt = (e) => typeof e == "function", Wrt = (e, t) => Urt(e) ? e(t) : e, Hrt = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Vrt = Zl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, $rt = Zl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Zrt = Zl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, qrt = Pc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Vrt} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${$rt} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Zrt} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Xrt = Zl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Krt = Pc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Xrt} 1s linear infinite;
`, Grt = Zl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Yrt = Zl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, Jrt = Pc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Grt} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Yrt} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Qrt = Pc("div")`
  position: absolute;
`, eot = Pc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, tot = Zl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, not = Pc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${tot} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, rot = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? _e.createElement(not, null, t) : t : n === "blank" ? null : _e.createElement(eot, null, _e.createElement(Krt, { ...r }), n !== "loading" && _e.createElement(Qrt, null, n === "error" ? _e.createElement(qrt, { ...r }) : _e.createElement(Jrt, { ...r })));
}, oot = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, iot = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, sot = "0%{opacity:0;} 100%{opacity:1;}", aot = "0%{opacity:1;} 100%{opacity:0;}", lot = Pc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, uot = Pc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, cot = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Hrt() ? [sot, aot] : [oot(n), iot(n)];
  return { animation: t ? `${Zl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Zl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
_e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? cot(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = _e.createElement(rot, { toast: e }), a = _e.createElement(uot, { ...e.ariaProps }, Wrt(e.message, e));
  return _e.createElement(lot, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : _e.createElement(_e.Fragment, null, i, a));
});
zrt(_e.createElement);
dL`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function bpe(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, d = { xs: 12, sm: 16, md: 20, lg: 24 }[i], y = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ yr.jsxs("button", { className: y, disabled: l || t, ...p, children: [
    /* @__PURE__ */ yr.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ yr.jsx(tl, { size: d, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ yr.jsxs("div", { className: "arkynButtonContent", children: [
      SR(d, a),
      c,
      SR(d, s)
    ] })
  ] });
}
function pot() {
  const e = uT(), t = Ree(), n = cT(), [r, o] = E(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  h(() => {
    var u, c;
    let p = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, p) || Object.entries(p).length !== 0 && o(p);
  }, [n, e]), h(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
He({});
function dot(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ yr.jsxs(
    "button",
    {
      disabled: a || t,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ yr.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ yr.jsx(tl, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ yr.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ yr.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function fot(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ yr.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ yr.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function hot(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const got = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
hot(got.CNPJ).length;
ka((e, t) => /* @__PURE__ */ yr.jsx("input", { ref: t, ...e }));
He({});
var ru = {};
Object.defineProperty(ru, "__esModule", {
  value: !0
});
var mot = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), tS = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, wpe = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: mot ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, RB = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var kb = 1; kb < 20; kb++)
  RB["f" + kb] = 111 + kb;
function fL(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Ope(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Cpe(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function vot(e, t) {
  return fL(e, t);
}
function yot(e, t) {
  return fL(e, { byKey: !0 }, t);
}
function Ope(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in tS)
    r[tS[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = FB(d), v = tS[f];
      if (d.length > 1 && !v && !wpe[d] && !RB[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = xpe(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Cpe(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function xpe(e) {
  e = FB(e);
  var t = RB[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function FB(e) {
  return e = e.toLowerCase(), e = wpe[e] || e, e;
}
ru.default = fL;
var nS = ru.isHotkey = fL;
ru.isCodeHotkey = vot;
ru.isKeyHotkey = yot;
ru.parseHotkey = Ope;
ru.compareHotkey = Cpe;
ru.toKeyCode = xpe;
ru.toKeyName = FB;
var bot = typeof Sr == "object" && Sr && Sr.Object === Object && Sr, wot = bot, Oot = wot, Cot = typeof self == "object" && self && self.Object === Object && self, xot = Oot || Cot || Function("return this")(), Lot = xot, Eot = Lot, kot = Eot.Symbol, Lpe = kot, VK = Lpe;
VK && VK.toStringTag;
var $K = Lpe;
$K && $K.toStringTag;
var ZK;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(ZK || (ZK = {}));
var zB = function(e) {
  return Object.freeze(e);
}, Pot = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, zB(this);
  }
  return e;
}(), Sot = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, zB(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), qK = typeof window < "u" ? window : {};
/msie|trident/i.test(qK.navigator && qK.navigator.userAgent);
var rS = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Pot((n ? t : e) || 0, (n ? e : t) || 0);
};
zB({
  devicePixelContentBoxSize: rS(),
  borderBoxSize: rS(),
  contentBoxSize: rS(),
  contentRect: new Sot(0, 0, 0, 0)
});
function Xg(e) {
  "@babel/helpers - typeof";
  return Xg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Xg(e);
}
function Mot(e, t) {
  if (Xg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Xg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Dot(e) {
  var t = Mot(e, "string");
  return Xg(t) === "symbol" ? t : String(t);
}
function Zh(e, t, n) {
  return t = Dot(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var _ot = /* @__PURE__ */ He(null), oS, iS;
parseInt(Oe.version.split(".")[0], 10);
var XK = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), sS = typeof navigator < "u" && /Android/.test(navigator.userAgent), Pb = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Tot = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (oS = navigator.userAgent.match(/Version\/(\d+)/)) !== null && oS !== void 0 && oS[1] && parseInt((iS = navigator.userAgent.match(/Version\/(\d+)/)) === null || iS === void 0 ? void 0 : iS[1], 10) < 17;
var jot = /* @__PURE__ */ new WeakMap(), Aot = /* @__PURE__ */ new WeakMap(), Iot = /* @__PURE__ */ new WeakMap(), Bot = /* @__PURE__ */ new WeakMap(), Not = /* @__PURE__ */ new WeakMap(), KK = /* @__PURE__ */ new WeakMap(), Rot = /* @__PURE__ */ new WeakMap(), GK = /* @__PURE__ */ new WeakMap(), Sb = /* @__PURE__ */ new WeakMap(), Fot = /* @__PURE__ */ new WeakMap(), zot = /* @__PURE__ */ new WeakMap(), Uot = /* @__PURE__ */ new WeakMap(), Epe = globalThis.Node, Wot = globalThis.Text, kpe = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, Hot = (e) => j1(e) && e.nodeType === 8, el = (e) => j1(e) && e.nodeType === 1, j1 = (e) => {
  var t = kpe(e);
  return !!t && e instanceof t.Node;
}, YK = (e) => {
  var t = e && e.anchorNode && kpe(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Vot = (e) => {
  var [t, n] = e;
  if (el(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Ppe(t, o, r ? "backward" : "forward"), r = o < n; el(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = Zot(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, $ot = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Ppe = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (Hot(o) || el(o) && o.childNodes.length === 0 || el(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, Zot = (e, t, n) => {
  var [r] = Ppe(e, t, n);
  return r;
}, JK = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Spe = (e, t, n) => {
  var {
    target: r
  } = t;
  if (el(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Ln.getWindow(e);
  if (o.contains(r))
    return Ln.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Spe(e, i, n);
}, QK = (e, t) => !!(e.compareDocumentPosition(t) & Epe.DOCUMENT_POSITION_PRECEDING), qot = (e, t) => !!(e.compareDocumentPosition(t) & Epe.DOCUMENT_POSITION_FOLLOWING), Xot = 0;
class Kot {
  constructor() {
    Zh(this, "id", void 0), this.id = "".concat(Xot++);
  }
}
var Ln = {
  androidPendingDiffs: (e) => Uot.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = zot.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Ln.toDOMNode(e, e), n = Ln.findDocumentOrShadowRoot(e);
    Sb.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Ln.findDocumentOrShadowRoot(e), r = JK(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && P0.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Ln.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Ln.toSlateNode(e, t.target), a = Ln.findPath(e, i);
    if (Dl.isElement(i) && br.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = br.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? br.before(e, u) : br.after(e, u);
      if (c) {
        var p = br.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = Ln.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = Ln.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = KK.get(t);
    return n || (n = new Kot(), KK.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = Aot.get(r);
      if (o == null) {
        if (br.isEditor(r))
          return n;
        break;
      }
      var i = jot.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Ts.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Sb.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Ln.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Ln.toDOMNode(e, e), r = Ln.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = JK(r), i = Ln.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || P0.select(e, br.start(e, [])), Sb.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Iot.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Ln.toDOMNode(e, e), i;
    try {
      i = el(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => j1(t) && Ln.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return br.hasPath(e, n.path) && br.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Ln.hasEditableTarget(e, t) || Ln.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => j1(t) && Ln.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Fot.get(e),
  isFocused: (e) => !!Sb.get(e),
  isReadOnly: (e) => !!GK.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (GK.get(e)) return !1;
    var n = Ln.hasTarget(e, t) && Ln.toSlateNode(e, t);
    return Dl.isElement(n) && br.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Rot.get(e), r = br.isEditor(t) ? Bot.get(e) : n == null ? void 0 : n.get(Ln.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Ts.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = br.node(e, t.path), r = Ln.toDOMNode(e, n), o;
    br.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof Wot ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Ts.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Yt.isBackward(t), i = Ln.toDOMPoint(e, n), a = Yt.isCollapsed(t) ? i : Ln.toDOMPoint(e, r), s = Ln.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = el(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = el(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = el(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Not.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : Vot(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = Ln.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = Ln.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (sS && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var R = U[k];
          if (Ln.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var N = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, H = [...N(V), ...N(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = H.find((M) => qot(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var X, G = [...N(V == null ? void 0 : V.previousElementSibling), ...N(V)];
          w = (X = G.findLast((M) => QK(L, M))) !== null && X !== void 0 ? X : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      sS && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Pb && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (sS && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && Ln.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = Ln.toSlateNode(e, Y), {
          path: J,
          offset: P
        } = br.start(e, Ln.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = Ln.toSlateNode(e, u), z = Ln.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = YK(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (YK(t)) {
        if (Pb && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Tot && $ot(s) || Pb ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Pb && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Ln.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = QK(s, u) || s === u && c < l, x = p ? w : Ln.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Yt.isExpanded(m) && Yt.isForward(m) && el(u) && br.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = br.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, Got = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, Yot = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, Jot = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Lo = (e) => {
  var t = Got[e], n = Yot[e], r = Jot[e], o = t && nS(t), i = n && nS(n), a = r && nS(r);
  return (s) => !!(o && o(s) || XK && i && i(s) || !XK && a && a(s));
};
Lo("bold"), Lo("compose"), Lo("moveBackward"), Lo("moveForward"), Lo("deleteBackward"), Lo("deleteForward"), Lo("deleteLineBackward"), Lo("deleteLineForward"), Lo("deleteWordBackward"), Lo("deleteWordForward"), Lo("extendBackward"), Lo("extendForward"), Lo("extendLineBackward"), Lo("extendLineForward"), Lo("italic"), Lo("moveLineBackward"), Lo("moveLineForward"), Lo("moveWordBackward"), Lo("moveWordForward"), Lo("redo"), Lo("insertSoftBreak"), Lo("splitBlock"), Lo("transposeCharacter"), Lo("undo");
var Qot = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Spe(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, eit = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class tit extends Kl {
  constructor() {
    super(...arguments), Zh(this, "context", null), Zh(this, "manager", null), Zh(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, eit);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = Qot(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Zh(tit, "contextType", _ot);
He({});
He({});
He({});
var li = {}, UB = {}, Gm = {}, Ym = {}, Mpe = "Expected a function", eG = NaN, nit = "[object Symbol]", rit = /^\s+|\s+$/g, oit = /^[-+]0x[0-9a-f]+$/i, iit = /^0b[01]+$/i, sit = /^0o[0-7]+$/i, ait = parseInt, lit = typeof Sr == "object" && Sr && Sr.Object === Object && Sr, uit = typeof self == "object" && self && self.Object === Object && self, cit = lit || uit || Function("return this")(), pit = Object.prototype, dit = pit.toString, fit = Math.max, hit = Math.min, aS = function() {
  return cit.Date.now();
};
function git(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Mpe);
  t = tG(t) || 0, A1(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? fit(tG(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? hit(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = aS();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(aS());
  }
  function m() {
    var C = aS(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function mit(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Mpe);
  return A1(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), git(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function A1(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function vit(e) {
  return !!e && typeof e == "object";
}
function yit(e) {
  return typeof e == "symbol" || vit(e) && dit.call(e) == nit;
}
function tG(e) {
  if (typeof e == "number")
    return e;
  if (yit(e))
    return eG;
  if (A1(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = A1(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(rit, "");
  var n = iit.test(e);
  return n || sit.test(e) ? ait(e.slice(2), n ? 2 : 8) : oit.test(e) ? eG : +e;
}
var bit = mit, Jm = {};
Object.defineProperty(Jm, "__esModule", {
  value: !0
});
Jm.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), l0.has(t) || l0.set(t, /* @__PURE__ */ new Set());
  var o = l0.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Jm.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), l0.get(t).delete(n.name || t);
};
var l0 = /* @__PURE__ */ new Map();
Object.defineProperty(Ym, "__esModule", {
  value: !0
});
var wit = bit, Oit = xit(wit), Cit = Jm;
function xit(e) {
  return e && e.__esModule ? e : { default: e };
}
var Lit = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Oit.default)(e, t);
}, Bo = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = Lit(function(r) {
        Bo.scrollHandler(e);
      }, t);
      Bo.scrollSpyContainers.push(e), (0, Cit.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return Bo.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Bo.scrollSpyContainers[Bo.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Bo.currentPositionX(e), Bo.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Bo.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Bo.scrollSpyContainers[Bo.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(Bo.currentPositionX(t), Bo.currentPositionY(t));
  },
  updateStates: function() {
    Bo.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Bo.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Bo.spySetState && Bo.spySetState.length && Bo.spySetState.indexOf(e) > -1 && Bo.spySetState.splice(Bo.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Bo.scrollHandler);
  },
  update: function() {
    return Bo.scrollSpyContainers.forEach(function(e) {
      return Bo.scrollHandler(e);
    });
  }
};
Ym.default = Bo;
var Yd = {}, Qm = {};
Object.defineProperty(Qm, "__esModule", {
  value: !0
});
var Eit = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, kit = function() {
  return window.location.hash.replace(/^#/, "");
}, Pit = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Sit = function(e) {
  return getComputedStyle(e).position !== "static";
}, lS = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, Mit = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Sit(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = lS(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return lS(t, s).offsetTop - lS(e, s).offsetTop;
};
Qm.default = {
  updateHash: Eit,
  getHash: kit,
  filterElementInContainer: Pit,
  scrollOffset: Mit
};
var hL = {}, WB = {};
Object.defineProperty(WB, "__esModule", {
  value: !0
});
WB.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var HB = {};
Object.defineProperty(HB, "__esModule", {
  value: !0
});
var Dit = Jm, _it = ["mousedown", "mousewheel", "touchmove", "keydown"];
HB.default = {
  subscribe: function(e) {
    return typeof document < "u" && _it.forEach(function(t) {
      return (0, Dit.addPassiveEventListener)(document, t, e);
    });
  }
};
var ev = {};
Object.defineProperty(ev, "__esModule", {
  value: !0
});
var A_ = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      A_.registered[e] = t;
    },
    remove: function(e) {
      A_.registered[e] = null;
    }
  }
};
ev.default = A_;
Object.defineProperty(hL, "__esModule", {
  value: !0
});
var Tit = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, jit = Qm;
gL(jit);
var Ait = WB, nG = gL(Ait), Iit = HB, Bit = gL(Iit), Nit = ev, $a = gL(Nit);
function gL(e) {
  return e && e.__esModule ? e : { default: e };
}
var Dpe = function(e) {
  return nG.default[e.smooth] || nG.default.defaultEasing;
}, Rit = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Fit = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, I_ = function() {
  return Fit() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), _pe = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Tpe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, jpe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, zit = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, Uit = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, Wit = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    $a.default.registered.end && $a.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    I_.call(window, i);
    return;
  }
  $a.default.registered.end && $a.default.registered.end(o.to, o.target, o.currentPosition);
}, VB = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, tv = function(e, t, n, r) {
  t.data = t.data || _pe(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (Bit.default.subscribe(o), VB(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Tpe(t) : jpe(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    $a.default.registered.end && $a.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = Rit(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Dpe(t), a = Wit.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      $a.default.registered.begin && $a.default.registered.begin(t.data.to, t.data.target), I_.call(window, a);
    }, t.delay);
    return;
  }
  $a.default.registered.begin && $a.default.registered.begin(t.data.to, t.data.target), I_.call(window, a);
}, mL = function(e) {
  return e = Tit({}, e), e.data = e.data || _pe(), e.absolute = !0, e;
}, Hit = function(e) {
  tv(0, mL(e));
}, Vit = function(e, t) {
  tv(e, mL(t));
}, $it = function(e) {
  e = mL(e), VB(e), tv(e.horizontal ? zit(e) : Uit(e), e);
}, Zit = function(e, t) {
  t = mL(t), VB(t);
  var n = t.horizontal ? Tpe(t) : jpe(t);
  tv(e + n, t);
};
hL.default = {
  animateTopScroll: tv,
  getAnimationType: Dpe,
  scrollToTop: Hit,
  scrollToBottom: $it,
  scrollTo: Vit,
  scrollMore: Zit
};
Object.defineProperty(Yd, "__esModule", {
  value: !0
});
var qit = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Xit = Qm, Kit = $B(Xit), Git = hL, Yit = $B(Git), Jit = ev, Mb = $B(Jit);
function $B(e) {
  return e && e.__esModule ? e : { default: e };
}
var Db = {}, rG = void 0;
Yd.default = {
  unmount: function() {
    Db = {};
  },
  register: function(e, t) {
    Db[e] = t;
  },
  unregister: function(e) {
    delete Db[e];
  },
  get: function(e) {
    return Db[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return rG = e;
  },
  getActiveLink: function() {
    return rG;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = qit({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = Kit.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Mb.default.registered.begin && Mb.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Mb.default.registered.end && Mb.default.registered.end(e, n);
      return;
    }
    Yit.default.animateTopScroll(s, t, e, n);
  }
};
var B_ = { exports: {} }, uS = { exports: {} }, sr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oG;
function Qit() {
  if (oG) return sr;
  oG = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return sr.AsyncMode = l, sr.ConcurrentMode = u, sr.ContextConsumer = s, sr.ContextProvider = a, sr.Element = t, sr.ForwardRef = c, sr.Fragment = r, sr.Lazy = f, sr.Memo = y, sr.Portal = n, sr.Profiler = i, sr.StrictMode = o, sr.Suspense = p, sr.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, sr.isConcurrentMode = x, sr.isContextConsumer = function(m) {
    return D(m) === s;
  }, sr.isContextProvider = function(m) {
    return D(m) === a;
  }, sr.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, sr.isForwardRef = function(m) {
    return D(m) === c;
  }, sr.isFragment = function(m) {
    return D(m) === r;
  }, sr.isLazy = function(m) {
    return D(m) === f;
  }, sr.isMemo = function(m) {
    return D(m) === y;
  }, sr.isPortal = function(m) {
    return D(m) === n;
  }, sr.isProfiler = function(m) {
    return D(m) === i;
  }, sr.isStrictMode = function(m) {
    return D(m) === o;
  }, sr.isSuspense = function(m) {
    return D(m) === p;
  }, sr.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, sr.typeOf = D, sr;
}
var vr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iG;
function est() {
  return iG || (iG = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === y || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === L || B.$$typeof === w || B.$$typeof === v);
    }
    function x(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var re = he && he.$$typeof;
                switch (re) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return re;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, R = c, N = r, V = f, $ = y, H = n, X = i, G = o, Y = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || x(B) === l;
    }
    function P(B) {
      return x(B) === u;
    }
    function _(B) {
      return x(B) === s;
    }
    function z(B) {
      return x(B) === a;
    }
    function M(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return x(B) === c;
    }
    function O(B) {
      return x(B) === r;
    }
    function I(B) {
      return x(B) === f;
    }
    function F(B) {
      return x(B) === y;
    }
    function j(B) {
      return x(B) === n;
    }
    function q(B) {
      return x(B) === i;
    }
    function A(B) {
      return x(B) === o;
    }
    function K(B) {
      return x(B) === p;
    }
    vr.AsyncMode = m, vr.ConcurrentMode = C, vr.ContextConsumer = S, vr.ContextProvider = U, vr.Element = k, vr.ForwardRef = R, vr.Fragment = N, vr.Lazy = V, vr.Memo = $, vr.Portal = H, vr.Profiler = X, vr.StrictMode = G, vr.Suspense = Y, vr.isAsyncMode = J, vr.isConcurrentMode = P, vr.isContextConsumer = _, vr.isContextProvider = z, vr.isElement = M, vr.isForwardRef = W, vr.isFragment = O, vr.isLazy = I, vr.isMemo = F, vr.isPortal = j, vr.isProfiler = q, vr.isStrictMode = A, vr.isSuspense = K, vr.isValidElementType = D, vr.typeOf = x;
  }()), vr;
}
var sG;
function Ape() {
  return sG || (sG = 1, process.env.NODE_ENV === "production" ? uS.exports = Qit() : uS.exports = est()), uS.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var cS, aG;
function tst() {
  if (aG) return cS;
  aG = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return cS = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, cS;
}
var pS, lG;
function ZB() {
  if (lG) return pS;
  lG = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return pS = e, pS;
}
var uG, cG;
function Ipe() {
  return cG || (cG = 1, uG = Function.call.bind(Object.prototype.hasOwnProperty)), uG;
}
var dS, pG;
function nst() {
  if (pG) return dS;
  pG = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = ZB(), n = {}, r = Ipe();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, dS = o, dS;
}
var fS, dG;
function rst() {
  if (dG) return fS;
  dG = 1;
  var e = Ape(), t = tst(), n = ZB(), r = Ipe(), o = nst(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return fS = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, I, F, j, q, A, K) {
        if (j = j || d, A = A || F, K !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = j + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return I[F] == null ? O ? I[F] === null ? new v("The " + q + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new v("The " + q + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : P(I, F, j, q, A);
      }
      var W = M.bind(null, !1);
      return W.isRequired = M.bind(null, !0), W;
    }
    function L(P) {
      function _(z, M, W, O, I, F) {
        var j = z[M], q = G(j);
        if (q !== P) {
          var A = Y(j);
          return new v(
            "Invalid " + O + " `" + I + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var j = G(F);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var A = P(F, q, W, O, I + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!s(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!e.isValidElementType(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, W, O, I) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, j = J(z[M]);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, W, O, I) {
        for (var F = z[M], j = 0; j < P.length; j++)
          if (f(F, P[j]))
            return null;
        var q = JSON.stringify(P, function(A, K) {
          var B = Y(K);
          return B === "symbol" ? String(K) : K;
        });
        return new v("Invalid " + O + " `" + I + "` of value `" + String(F) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var A = P(F, q, W, O, I + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(W, O, I, F, j) {
        for (var q = [], A = 0; A < P.length; A++) {
          var K = P[A], B = K(W, O, I, F, j, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + j + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(M);
    }
    function R() {
      function P(_, z, M, W, O) {
        return H(_[z]) ? null : new v("Invalid " + W + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function N(P, _, z, M, W) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return N(W, O, I, q, Y(A));
          var K = A(F, q, W, O, I + "." + q, n);
          if (K)
            return K;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var A in q) {
          var K = P[A];
          if (r(P, A) && typeof K != "function")
            return N(W, O, I, A, Y(K));
          if (!K)
            return new v(
              "Invalid " + O + " `" + I + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = K(F, A, W, O, I + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!H(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var W = M.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function X(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function G(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : X(_, P) ? "symbol" : _;
    }
    function Y(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = G(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = Y(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, fS;
}
var hS, fG;
function ost() {
  if (fG) return hS;
  fG = 1;
  var e = ZB();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, hS = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, hS;
}
if (process.env.NODE_ENV !== "production") {
  var ist = Ape(), sst = !0;
  B_.exports = rst()(ist.isElement, sst);
} else
  B_.exports = ost()();
var vL = B_.exports, yL = {};
Object.defineProperty(yL, "__esModule", {
  value: !0
});
var ast = Qm, gS = lst(ast);
function lst(e) {
  return e && e.__esModule ? e : { default: e };
}
var ust = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return gS.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && gS.default.getHash() !== e && gS.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
yL.default = ust;
Object.defineProperty(Gm, "__esModule", {
  value: !0
});
var _b = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, cst = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), pst = Oe, hG = nv(pst), dst = Ym, Tb = nv(dst), fst = Yd, hst = nv(fst), gst = vL, Eo = nv(gst), mst = yL, bu = nv(mst);
function nv(e) {
  return e && e.__esModule ? e : { default: e };
}
function vst(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function yst(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function bst(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var gG = {
  to: Eo.default.string.isRequired,
  containerId: Eo.default.string,
  container: Eo.default.object,
  activeClass: Eo.default.string,
  activeStyle: Eo.default.object,
  spy: Eo.default.bool,
  horizontal: Eo.default.bool,
  smooth: Eo.default.oneOfType([Eo.default.bool, Eo.default.string]),
  offset: Eo.default.number,
  delay: Eo.default.number,
  isDynamic: Eo.default.bool,
  onClick: Eo.default.func,
  duration: Eo.default.oneOfType([Eo.default.number, Eo.default.func]),
  absolute: Eo.default.bool,
  onSetActive: Eo.default.func,
  onSetInactive: Eo.default.func,
  ignoreCancelEvents: Eo.default.bool,
  hashSpy: Eo.default.bool,
  saveHashHistory: Eo.default.bool,
  spyThrottle: Eo.default.number
};
Gm.default = function(e, t) {
  var n = t || hst.default, r = function(i) {
    bst(a, i);
    function a(s) {
      vst(this, a);
      var l = yst(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return cst(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          Tb.default.isMounted(s) || Tb.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (bu.default.isMounted() || bu.default.mount(n), bu.default.mapContainer(this.props.to, s)), Tb.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Tb.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = _b({}, this.props.style, this.props.activeStyle) : l = _b({}, this.props.style);
        var u = _b({}, this.props);
        for (var c in gG)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, hG.default.createElement(e, u);
      }
    }]), a;
  }(hG.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, _b({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(bu.default.isMounted() && !bu.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var R = n.getActiveLink();
        if (y) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && bu.default.getHash() === c) {
            var N = i.props.saveHashHistory, V = N === void 0 ? !1 : N;
            bu.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, H = $ === void 0 ? !1 : $;
          i.props.hashSpy && bu.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = gG, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(UB, "__esModule", {
  value: !0
});
var wst = Oe, mG = Bpe(wst), Ost = Gm, Cst = Bpe(Ost);
function Bpe(e) {
  return e && e.__esModule ? e : { default: e };
}
function xst(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function vG(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Lst(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Est = function(e) {
  Lst(t, e);
  function t() {
    var n, r, o, i;
    xst(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = vG(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return mG.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), vG(o, i);
  }
  return t;
}(mG.default.Component);
UB.default = (0, Cst.default)(Est);
var qB = {};
Object.defineProperty(qB, "__esModule", {
  value: !0
});
var kst = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Pst = Oe, yG = Npe(Pst), Sst = Gm, Mst = Npe(Sst);
function Npe(e) {
  return e && e.__esModule ? e : { default: e };
}
function Dst(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function _st(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Tst(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var jst = function(e) {
  Tst(t, e);
  function t() {
    return Dst(this, t), _st(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return kst(t, [{
    key: "render",
    value: function() {
      return yG.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(yG.default.Component);
qB.default = (0, Mst.default)(jst);
var XB = {}, bL = {};
Object.defineProperty(bL, "__esModule", {
  value: !0
});
var Ast = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Ist = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Bst = Oe, bG = wL(Bst), Nst = nl;
wL(Nst);
var Rst = Yd, wG = wL(Rst), Fst = vL, OG = wL(Fst);
function wL(e) {
  return e && e.__esModule ? e : { default: e };
}
function zst(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ust(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Wst(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
bL.default = function(e) {
  var t = function(n) {
    Wst(r, n);
    function r(o) {
      zst(this, r);
      var i = Ust(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Ist(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        wG.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        wG.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return bG.default.createElement(e, Ast({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(bG.default.Component);
  return t.propTypes = {
    name: OG.default.string,
    id: OG.default.string
  }, t;
};
Object.defineProperty(XB, "__esModule", {
  value: !0
});
var CG = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Hst = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Vst = Oe, xG = KB(Vst), $st = bL, Zst = KB($st), qst = vL, LG = KB(qst);
function KB(e) {
  return e && e.__esModule ? e : { default: e };
}
function Xst(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Kst(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Gst(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Rpe = function(e) {
  Gst(t, e);
  function t() {
    return Xst(this, t), Kst(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Hst(t, [{
    key: "render",
    value: function() {
      var n = this, r = CG({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, xG.default.createElement(
        "div",
        CG({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(xG.default.Component);
Rpe.propTypes = {
  name: LG.default.string,
  id: LG.default.string
};
XB.default = (0, Zst.default)(Rpe);
var mS = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, EG = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function kG(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function PG(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function SG(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var jb = Oe, $c = Ym, vS = Yd, $o = vL, wu = yL, MG = {
  to: $o.string.isRequired,
  containerId: $o.string,
  container: $o.object,
  activeClass: $o.string,
  spy: $o.bool,
  smooth: $o.oneOfType([$o.bool, $o.string]),
  offset: $o.number,
  delay: $o.number,
  isDynamic: $o.bool,
  onClick: $o.func,
  duration: $o.oneOfType([$o.number, $o.func]),
  absolute: $o.bool,
  onSetActive: $o.func,
  onSetInactive: $o.func,
  ignoreCancelEvents: $o.bool,
  hashSpy: $o.bool,
  spyThrottle: $o.number
}, Yst = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || vS, r = function(i) {
      SG(a, i);
      function a(s) {
        kG(this, a);
        var l = PG(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return EG(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            $c.isMounted(s) || $c.mount(s, this.props.spyThrottle), this.props.hashSpy && (wu.isMounted() || wu.mount(n), wu.mapContainer(this.props.to, s)), this.props.spy && $c.addStateHandler(this.stateHandler), $c.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          $c.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = mS({}, this.props);
          for (var u in MG)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, jb.createElement(e, l);
        }
      }]), a;
    }(jb.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, mS({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(wu.isMounted() && !wu.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && wu.getHash() === l && wu.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), $c.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && wu.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), $c.updateStates();
        }
      };
    };
    return r.propTypes = MG, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      SG(r, n);
      function r(o) {
        kG(this, r);
        var i = PG(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return EG(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          vS.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          vS.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return jb.createElement(e, mS({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(jb.Component);
    return t.propTypes = {
      name: $o.string,
      id: $o.string
    }, t;
  }
}, Jst = Yst;
Object.defineProperty(li, "__esModule", {
  value: !0
});
li.Helpers = li.ScrollElement = li.ScrollLink = li.animateScroll = li.scrollSpy = li.Events = li.scroller = li.Element = li.Button = li.Link = void 0;
var Qst = UB, Fpe = cl(Qst), eat = qB, zpe = cl(eat), tat = XB, Upe = cl(tat), nat = Yd, Wpe = cl(nat), rat = ev, Hpe = cl(rat), oat = Ym, Vpe = cl(oat), iat = hL, $pe = cl(iat), sat = Gm, Zpe = cl(sat), aat = bL, qpe = cl(aat), lat = Jst, Xpe = cl(lat);
function cl(e) {
  return e && e.__esModule ? e : { default: e };
}
li.Link = Fpe.default;
li.Button = zpe.default;
li.Element = Upe.default;
li.scroller = Wpe.default;
li.Events = Hpe.default;
li.scrollSpy = Vpe.default;
li.animateScroll = $pe.default;
li.ScrollLink = Zpe.default;
li.ScrollElement = qpe.default;
li.Helpers = Xpe.default;
li.default = { Link: Fpe.default, Button: zpe.default, Element: Upe.default, scroller: Wpe.default, Events: Hpe.default, scrollSpy: Vpe.default, animateScroll: $pe.default, ScrollLink: Zpe.default, ScrollElement: qpe.default, Helpers: Xpe.default };
He({});
He({});
He({});
function Kg(e) {
  "@babel/helpers - typeof";
  return Kg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Kg(e);
}
function uat(e, t) {
  if (Kg(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Kg(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function cat(e) {
  var t = uat(e, "string");
  return Kg(t) == "symbol" ? t : t + "";
}
function Fe(e, t, n) {
  return (t = cat(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Kpe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var yS, DG;
function pat() {
  if (DG) return yS;
  DG = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return yS = t, yS;
}
var dat = pat(), vi = /* @__PURE__ */ Kpe(dat), Kt = He(null);
function fat() {
  vi(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Kt);
  return vi(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function hat(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function gat(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function mat(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return gat(e, i), o;
}
function vat(e, t, n) {
  var r = hat(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function yat(e) {
  google.maps.event.removeListener(e);
}
function Hn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(yat);
}
function Tn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = vat(o, i, n);
  return mat(t, r, o, i), a;
}
function bat(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = vt(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null), [A, K] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), K(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var B = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(B), B !== null && D && D(B), () => {
      B !== null && x && x(B);
    };
  }, []), yr.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: yr.jsx(Kt.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(bat);
function _G(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Gpe(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        _G(i, r, o, a, s, "next", l);
      }
      function s(l) {
        _G(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Ype(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return vi(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var Cp = typeof document < "u";
function Jpe(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return Cp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function TG(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Qpe() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return TG(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return TG(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Wf = !1;
function ede() {
  return yr.jsx("div", {
    children: "Loading..."
  });
}
var N_ = {
  id: "script-loader",
  version: "weekly"
};
class wat extends pe {
  constructor() {
    super(...arguments), Fe(this, "check", jn()), Fe(this, "state", {
      loaded: !1
    }), Fe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Fe(this, "isCleaningUp", /* @__PURE__ */ Gpe(function* () {
      function t(n) {
        if (!Wf)
          n();
        else if (Cp)
          var r = window.setInterval(function() {
            Wf || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Fe(this, "cleanup", () => {
      Wf = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Fe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Qpe(), vi(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Ype(this.props)
      };
      Jpe(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (Cp) {
      if (window.google && window.google.maps && !Wf) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), Cp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (Cp) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Wf = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return yr.jsxs(yr.Fragment, {
      children: [yr.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || yr.jsx(ede, {})]
    });
  }
}
Fe(wat, "defaultProps", N_);
function Oat(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function GB(e, t) {
  if (e == null) return {};
  var n, r, o = Oat(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var jG;
function Cat(e) {
  var {
    id: t = N_.id,
    version: n = N_.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = vt(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    Cp && u && Qpe();
  }, [u]), h(function() {
    f && vi(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Ype({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!Cp)
      return;
    function x() {
      y.current && (v(!0), jG = w);
    }
    if (window.google && window.google.maps && jG === w) {
      x();
      return;
    }
    Jpe({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = vt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var xat = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], Lat = yr.jsx(ede, {});
function Eat(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = GB(e, xat), {
    isLoaded: s,
    loadError: l
  } = Cat(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || Lat;
}
me(Eat);
var AG;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(AG || (AG = {}));
function IG(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function I1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IG(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IG(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var BG = {}, NG = {
  options(e, t) {
    e.setOptions(t);
  }
};
function kat(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Kt), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(I1(I1({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(kat);
class Pat extends pe {
  constructor() {
    super(...arguments), Fe(this, "state", {
      trafficLayer: null
    }), Fe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Fe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(I1(I1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Tn({
      updaterMap: NG,
      eventMap: BG,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: NG,
      eventMap: BG,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Hn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Fe(Pat, "contextType", Kt);
function Sat(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Kt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(Sat);
class Mat extends pe {
  constructor() {
    super(...arguments), Fe(this, "state", {
      bicyclingLayer: null
    }), Fe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Fe(Mat, "contextType", Kt);
function Dat(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Kt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(Dat);
class _at extends pe {
  constructor() {
    super(...arguments), Fe(this, "state", {
      transitLayer: null
    }), Fe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Fe(_at, "contextType", Kt);
function RG(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function B1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RG(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RG(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var FG = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, zG = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Tat(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Kt), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    vi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(B1(B1({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && L(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && k(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(Tat);
class jat extends pe {
  constructor(t) {
    super(t), Fe(this, "registeredEvents", []), Fe(this, "state", {
      drawingManager: null
    }), Fe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), vi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(B1(B1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Tn({
      updaterMap: zG,
      eventMap: FG,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: zG,
      eventMap: FG,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Hn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Fe(jat, "contextType", Kt);
function UG(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UG(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UG(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var WG = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, HG = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, N1 = {};
function Aat(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: R,
    onClickableChanged: N,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: H,
    onFlatChanged: X,
    onIconChanged: G,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, W = ge(Kt), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null), [re, Se] = E(null), [We, Ze] = E(null), [Me, rt] = E(null), [Ve, be] = E(null), [qe, ct] = E(null), [ye, xe] = E(null), [Ee, Ue] = E(null), [De, st] = E(null), [ve, wt] = E(null), [at, lt] = E(null), [pt, Ot] = E(null), [dt, Ct] = E(null), [Xe, ht] = E(null), [ot, xt] = E(null), [ft, Pt] = E(null), [Lt, St] = E(null), [Et, Mt] = E(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (re !== null && google.maps.event.removeListener(re), Se(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), Ze(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Me !== null && google.maps.event.removeListener(Me), rt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && R && (Ve !== null && google.maps.event.removeListener(Ve), be(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && L && (qe !== null && google.maps.event.removeListener(qe), ct(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (ye !== null && google.maps.event.removeListener(ye), xe(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && N && (Ee !== null && google.maps.event.removeListener(Ee), Ue(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && V && (De !== null && google.maps.event.removeListener(De), st(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), wt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && X && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(O, "flat_changed", X)));
  }, [X]), h(() => {
    O && G && (dt !== null && google.maps.event.removeListener(dt), Ct(google.maps.event.addListener(O, "icon_changed", G)));
  }, [G]), h(() => {
    O && Y && (Xe !== null && google.maps.event.removeListener(Xe), ht(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (ot !== null && google.maps.event.removeListener(ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (ft !== null && google.maps.event.removeListener(ft), Pt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Lt !== null && google.maps.event.removeListener(Lt), St(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (Et !== null && google.maps.event.removeListener(Et), Mt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var gt = fd(fd(fd({}, n || N1), r ? N1 : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(gt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof y < "u" && te.setOpacity(y), f && te.setShape(f), typeof v == "string" && te.setTitle(v), typeof b == "number" && te.setZIndex(b), w && j(google.maps.event.addListener(te, "dblclick", w)), x && A(google.maps.event.addListener(te, "dragend", x)), m && B(google.maps.event.addListener(te, "dragstart", m)), k && he(google.maps.event.addListener(te, "mousedown", k)), C && Se(google.maps.event.addListener(te, "mouseout", C)), S && Ze(google.maps.event.addListener(te, "mouseover", S)), U && rt(google.maps.event.addListener(te, "mouseup", U)), R && be(google.maps.event.addListener(te, "rightclick", R)), L && ct(google.maps.event.addListener(te, "click", L)), D && xe(google.maps.event.addListener(te, "drag", D)), N && Ue(google.maps.event.addListener(te, "clickable_changed", N)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), $ && wt(google.maps.event.addListener(te, "animation_changed", $)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), X && Ot(google.maps.event.addListener(te, "flat_changed", X)), G && Ct(google.maps.event.addListener(te, "icon_changed", G)), Y && ht(google.maps.event.addListener(te, "position_changed", Y)), Q && xt(google.maps.event.addListener(te, "shape_changed", Q)), J && Pt(google.maps.event.addListener(te, "title_changed", J)), P && St(google.maps.event.addListener(te, "visible_changed", P)), _ && Mt(google.maps.event.addListener(te, "zindex_changed", _)), I(te), z && z(te), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), re !== null && google.maps.event.removeListener(re), We !== null && google.maps.event.removeListener(We), Me !== null && google.maps.event.removeListener(Me), Ve !== null && google.maps.event.removeListener(Ve), qe !== null && google.maps.event.removeListener(qe), Ee !== null && google.maps.event.removeListener(Ee), De !== null && google.maps.event.removeListener(De), ve !== null && google.maps.event.removeListener(ve), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), Xe !== null && google.maps.event.removeListener(Xe), ft !== null && google.maps.event.removeListener(ft), Lt !== null && google.maps.event.removeListener(Lt), Et !== null && google.maps.event.removeListener(Et), M && M(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var _t = zt(() => i ? ut.map(i, (gt) => {
    if (!wi(gt))
      return gt;
    var te = gt;
    return Oi(te, {
      anchor: O
    });
  }) : null, [i, O]);
  return yr.jsx(yr.Fragment, {
    children: _t
  }) || null;
}
me(Aat);
class Iat extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Gpe(function* () {
      var n = fd(fd(fd({}, t.props.options || N1), t.props.clusterer ? N1 : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Tn({
        updaterMap: HG,
        eventMap: WG,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: HG,
      eventMap: WG,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Hn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Oi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Fe(Iat, "contextType", Kt);
var Bat = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), Nat = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new Bat(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function Rat(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Fat = 2e3, zat = 500, Uat = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Wat = "png", Hat = [53, 56, 66, 78, 90], Vat = "cluster", tde = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Uat, this.imageExtension = r.imageExtension || Wat, this.imageSizes = r.imageSizes || Hat, this.calculator = r.calculator || Rat, this.batchSize = r.batchSize || Fat, this.batchSizeIE = r.batchSizeIE || zat, this.clusterClass = r.clusterClass || Vat, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new Nat(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function VG(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $at(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VG(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VG(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Oa = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Yn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Zat = {};
function qat(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, R] = E(null), N = ge(Kt), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, Oa.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, Oa.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, Oa.onClick, w)));
  }, [w]), h(() => {
    k && D && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(k, Oa.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (G !== null && google.maps.event.removeListener(G), X(google.maps.event.addListener(k, Oa.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && Yn.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && Yn.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && Yn.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && Yn.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && Yn.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && Yn.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && Yn.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && Yn.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && Yn.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && Yn.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && Yn.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && Yn.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && Yn.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && Yn.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && Yn.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (N) {
      var z = $at({}, n || Zat), M = new tde(N, [], z);
      return r && Yn.averageCenter(M, r), o && Yn.batchSizeIE(M, o), i && Yn.calculator(M, i), a && Yn.clusterClass(M, a), s && Yn.enableRetinaIcons(M, s), l && Yn.gridSize(M, l), u && Yn.ignoreHidden(M, u), c && Yn.imageExtension(M, c), p && Yn.imagePath(M, p), d && Yn.imageSizes(M, d), y && Yn.maxZoom(M, y), f && Yn.minimumClusterSize(M, f), v && Yn.styles(M, v), b && Yn.title(M, b), L && Yn.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, Oa.onMouseOut, C)), m && _(google.maps.event.addListener(M, Oa.onMouseOver, m)), w && $(google.maps.event.addListener(M, Oa.onClick, w)), D && X(google.maps.event.addListener(M, Oa.onClusteringBegin, D)), x && Y(google.maps.event.addListener(M, Oa.onClusteringEnd, x)), R(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(qat);
class Xat extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []), Fe(this, "state", {
      markerClusterer: null
    }), Fe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new tde(this.context, [], this.props.options);
      this.registeredEvents = Tn({
        updaterMap: Yn,
        eventMap: Oa,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: Yn,
      eventMap: Oa,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Hn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Fe(Xat, "contextType", Kt);
function $G(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var nde = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || $G(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, $G));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Kat = ["position"], Gat = ["position"];
function ZG(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function R1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZG(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZG(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qG = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, XG = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Yat = {};
function Jat(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Kt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var N = r || Yat, {
        position: V
      } = N, $ = GB(N, Kat), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var X = new nde(R1(R1({}, $), H ? {
        position: H
      } : {}));
      R.current = document.createElement("div"), v(X), a && L(google.maps.event.addListener(X, "closeclick", a)), s && D(google.maps.event.addListener(X, "domready", s)), l && m(google.maps.event.addListener(X, "content_changed", l)), u && S(google.maps.event.addListener(X, "position_changed", u)), c && k(google.maps.event.addListener(X, "zindex_changed", c)), X.setContent(R.current), n ? X.open(y, n) : X.getPosition() ? X.open(y) : vi(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(X);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(Jat);
class Qat extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []), Fe(this, "containerElement", null), Fe(this, "state", {
      infoBox: null
    }), Fe(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : vi(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Fe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = GB(t, Gat), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new nde(R1(R1({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Tn({
      updaterMap: XG,
      eventMap: qG,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: XG,
      eventMap: qG,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Hn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
Fe(Qat, "contextType", Kt);
var KG, GG;
function elt() {
  return GG || (GG = 1, KG = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), KG;
}
var tlt = elt(), YG = /* @__PURE__ */ Kpe(tlt), JG = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], bS = 1, Hf = 8;
class YB {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== bS)
      throw new Error("Got v".concat(o, " data when expected v").concat(bS, "."));
    var i = JG[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new YB(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = JG.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Hf, t), this.coords = new this.ArrayType(this.data, Hf + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Hf + a + s + l), this.ids = new this.IndexArrayType(this.data, Hf, t), this.coords = new this.ArrayType(this.data, Hf + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (bS << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return R_(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          QG(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      QG(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function R_(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    rde(e, t, a, r, o, i), R_(e, t, n, r, a - 1, 1 - i), R_(e, t, n, a + 1, o, 1 - i);
  }
}
function rde(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      rde(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (Vf(e, t, r, n), t[2 * o + i] > y && Vf(e, t, r, o); f < v; ) {
      for (Vf(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? Vf(e, t, r, v) : (v++, Vf(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function Vf(e, t, n, r) {
  wS(e, n, r), wS(t, 2 * n, 2 * r), wS(t, 2 * n + 1, 2 * r + 1);
}
function wS(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function QG(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var nlt = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, eY = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Zc = 2, zu = 3, OS = 4, _u = 5, ode = 6;
class rlt {
  constructor(t) {
    this.options = Object.assign(Object.create(nlt), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = eY(Ab(u)), d = eY(Ib(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Ab(r), Ib(a), Ab(i), Ib(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + _u] > 1 ? tY(p, f, this.clusterProps) : this.points[p[f + zu]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + OS] === t && p.push(a[y + _u] > 1 ? tY(a, y, this.clusterProps) : this.points[a[y + zu]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new YB(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + _u] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = ide(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + zu]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = Ab(f), d = Ib(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + zu] : L = this.points[n[l + zu]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Zc] <= n)) {
        l[p + Zc] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + _u], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + Zc] > n && (b += l[w + _u]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + Zc] <= n)) {
              l[k + Zc] = n;
              var R = l[k + _u];
              D += l[k] * R, x += l[k + 1] * R, l[k + OS] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + OS] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + Zc] <= n)) {
                l[$ + Zc] = n;
                for (var H = 0; H < c; H++) u.push(l[$ + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + _u] > 1) {
      var o = this.clusterProps[t[n + ode]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + zu]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function tY(e, t, n) {
  return {
    type: "Feature",
    id: e[t + zu],
    properties: ide(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [olt(e[t]), ilt(e[t + 1])]
    }
  };
}
function ide(e, t, n) {
  var r = e[t + _u], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + ode], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + zu],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Ab(e) {
  return e / 360 + 0.5;
}
function Ib(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function olt(e) {
  return (e - 0.5) * 360;
}
function ilt(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function slt(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class qs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class F_ {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(qs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => qs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (qs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class alt {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return llt(n);
  }
}
var llt = (e) => {
  var t = e.map((n) => new F_({
    position: qs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class ult extends alt {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = slt(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new rlt(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!YG(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = qs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !YG(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new F_({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new F_({
      markers: [i],
      position: qs.getPosition(i)
    });
  }
}
class clt {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class plt {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (qs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function dlt(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class JB {
  constructor() {
    dlt(JB, google.maps.OverlayView);
  }
}
var qh;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(qh || (qh = {}));
var flt = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class hlt extends JB {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new ult(o),
      renderer: a = new plt(),
      onClusterClick: s = flt
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (qs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, qh.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || qs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => qs.setMap(l, null)));
      }
      google.maps.event.trigger(this, qh.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => qs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new clt(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => qs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, qh.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), qs.setMap(r.marker, n);
    });
  }
}
function nY(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rY(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nY(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nY(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function glt(e) {
  var t = fat(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new hlt(rY(rY({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function mlt(e) {
  var {
    children: t,
    options: n
  } = e, r = glt(n);
  return r !== null ? t(r) : null;
}
me(mlt);
var oY = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, iY = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function vlt(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Kt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return v(N), R.current = document.createElement("div"), a && L(google.maps.event.addListener(N, "closeclick", a)), s && D(google.maps.event.addListener(N, "domready", s)), l && m(google.maps.event.addListener(N, "content_changed", l)), u && S(google.maps.event.addListener(N, "position_changed", u)), c && k(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(R.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(y, n) : N.getPosition() ? N.open(y) : vi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(N), N.close();
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(vlt);
class ylt extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []), Fe(this, "containerElement", null), Fe(this, "state", {
      infoWindow: null
    }), Fe(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : vi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Fe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Tn({
      updaterMap: iY,
      eventMap: oY,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: iY,
      eventMap: oY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Hn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
Fe(ylt, "contextType", Kt);
function sY(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function F1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sY(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sY(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aY = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, lY = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, blt = {};
function wlt(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(Kt), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var j = new google.maps.Polyline(F1(F1({}, t || blt), {}, {
      map: D
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && S(google.maps.event.addListener(j, "dblclick", a)), s && k(google.maps.event.addListener(j, "dragend", s)), l && N(google.maps.event.addListener(j, "dragstart", l)), u && $(google.maps.event.addListener(j, "mousedown", u)), c && X(google.maps.event.addListener(j, "mousemove", c)), p && Y(google.maps.event.addListener(j, "mouseout", p)), d && J(google.maps.event.addListener(j, "mouseover", d)), y && _(google.maps.event.addListener(j, "mouseup", y)), f && M(google.maps.event.addListener(j, "rightclick", f)), v && O(google.maps.event.addListener(j, "click", v)), b && F(google.maps.event.addListener(j, "drag", b)), m(j), L && L(j), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
me(wlt);
class Olt extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []), Fe(this, "state", {
      polyline: null
    }), Fe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(F1(F1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Tn({
      updaterMap: lY,
      eventMap: aY,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: lY,
      eventMap: aY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Hn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Fe(Olt, "contextType", Kt);
function uY(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cY(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uY(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uY(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pY = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, dY = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Clt(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Kt), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var A = new google.maps.Polygon(cY(cY({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && k(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && $(google.maps.event.addListener(A, "dragstart", u)), c && X(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), b && F(google.maps.event.addListener(A, "click", b)), L && q(google.maps.event.addListener(A, "drag", L)), S(A), w && w(A), () => {
      U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), D && D(A), A.setMap(null);
    };
  }, []), null;
}
me(Clt);
class xlt extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Tn({
      updaterMap: dY,
      eventMap: pY,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: dY,
      eventMap: pY,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Hn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Fe(xlt, "contextType", Kt);
function fY(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function z1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fY(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fY(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hY = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, gY = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Llt(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Kt), [m, C] = E(null), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var K = new google.maps.Rectangle(z1(z1({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && K.setVisible(i), typeof o < "u" && K.setEditable(o), typeof r < "u" && K.setDraggable(r), typeof n < "u" && K.setBounds(n), a && U(google.maps.event.addListener(K, "dblclick", a)), s && R(google.maps.event.addListener(K, "dragend", s)), l && V(google.maps.event.addListener(K, "dragstart", l)), u && H(google.maps.event.addListener(K, "mousedown", u)), c && G(google.maps.event.addListener(K, "mousemove", c)), p && Q(google.maps.event.addListener(K, "mouseout", p)), d && P(google.maps.event.addListener(K, "mouseover", d)), y && z(google.maps.event.addListener(K, "mouseup", y)), f && W(google.maps.event.addListener(K, "rightclick", f)), v && I(google.maps.event.addListener(K, "click", v)), b && j(google.maps.event.addListener(K, "drag", b)), L && A(google.maps.event.addListener(K, "bounds_changed", L)), C(K), w && w(K), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(K), K.setMap(null);
    };
  }, []), null;
}
me(Llt);
class Elt extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []), Fe(this, "state", {
      rectangle: null
    }), Fe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(z1(z1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Tn({
      updaterMap: gY,
      eventMap: hY,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: gY,
      eventMap: hY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Hn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Fe(Elt, "contextType", Kt);
function mY(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function U1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mY(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mY(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vY = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, yY = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, klt = {};
function Plt(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Kt), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var re = new google.maps.Circle(U1(U1({}, t || klt), {}, {
      map: C
    }));
    return typeof r == "number" && re.setRadius(r), typeof n < "u" && re.setCenter(n), typeof r == "number" && re.setRadius(r), typeof a < "u" && re.setVisible(a), typeof i < "u" && re.setEditable(i), typeof o < "u" && re.setDraggable(o), s && R(google.maps.event.addListener(re, "dblclick", s)), l && V(google.maps.event.addListener(re, "dragend", l)), u && H(google.maps.event.addListener(re, "dragstart", u)), c && G(google.maps.event.addListener(re, "mousedown", c)), p && Q(google.maps.event.addListener(re, "mousemove", p)), d && P(google.maps.event.addListener(re, "mouseout", d)), y && z(google.maps.event.addListener(re, "mouseover", y)), f && W(google.maps.event.addListener(re, "mouseup", f)), v && I(google.maps.event.addListener(re, "rightclick", v)), b && j(google.maps.event.addListener(re, "click", b)), L && A(google.maps.event.addListener(re, "drag", L)), w && B(google.maps.event.addListener(re, "center_changed", w)), D && he(google.maps.event.addListener(re, "radius_changed", D)), U(re), x && x(re), () => {
      k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), m && m(re), re.setMap(null);
    };
  }, []), null;
}
me(Plt);
class Slt extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []), Fe(this, "state", {
      circle: null
    }), Fe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(U1(U1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Tn({
      updaterMap: yY,
      eventMap: vY,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: yY,
      eventMap: vY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Hn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Fe(Slt, "contextType", Kt);
function bY(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function W1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bY(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bY(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wY = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, OY = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Mlt(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(Kt), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var A = new google.maps.Data(W1(W1({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && k(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && $(google.maps.event.addListener(A, "mouseover", s)), l && X(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && q(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), j !== null && google.maps.event.removeListener(j), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(Mlt);
class Dlt extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []), Fe(this, "state", {
      data: null
    }), Fe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(W1(W1({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Tn({
        updaterMap: OY,
        eventMap: wY,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: OY,
      eventMap: wY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Hn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Fe(Dlt, "contextType", Kt);
function CY(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xY(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CY(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CY(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var LY = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, EY = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class _lt extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []), Fe(this, "state", {
      kmlLayer: null
    }), Fe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(xY(xY({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Tn({
      updaterMap: EY,
      eventMap: LY,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: EY,
      eventMap: LY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Hn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Fe(_lt, "contextType", Kt);
function sde(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Tlt(e, t) {
  return new t(e.lat, e.lng);
}
function jlt(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Alt(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Ilt(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Blt(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Nlt(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function ade(e, t, n, r) {
  return n !== void 0 ? Blt(e, t, Ilt(n, google.maps.LatLngBounds, jlt)) : Nlt(e, t, Alt(r, google.maps.LatLng, Tlt));
}
function Rlt(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function kY(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Flt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kY(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kY(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function zlt(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = Flt({}, this.container ? sde(this.container, o) : {
        x: 0,
        y: 0
      }), u = ade(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function PY(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ult(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PY(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PY(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function SY(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function MY(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Wlt(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Kt), c = zt(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = zt(() => zlt(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
me(Wlt);
class Jd extends pe {
  constructor(t) {
    super(t), Fe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Fe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      vi(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Fe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Fe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Ult({
        x: 0,
        y: 0
      }, this.containerRef.current ? sde(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = ade(r, o, this.props.bounds, this.props.position);
      if (!Rlt(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Fe(this, "draw", () => {
      this.onPositionElement();
    }), Fe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = jn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = SY(t.position), r = SY(this.props.position), o = MY(t.bounds), i = MY(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(yr.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
Fe(Jd, "FLOAT_PANE", "floatPane");
Fe(Jd, "MAP_PANE", "mapPane");
Fe(Jd, "MARKER_LAYER", "markerLayer");
Fe(Jd, "OVERLAY_LAYER", "overlayLayer");
Fe(Jd, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Fe(Jd, "contextType", Kt);
function Hlt() {
}
function DY(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _Y(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DY(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DY(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var TY = {
  onDblClick: "dblclick",
  onClick: "click"
}, jY = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Vlt(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Kt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = zt(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(Vlt);
class lde extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []), Fe(this, "state", {
      groundOverlay: null
    }), Fe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    vi(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, _Y(_Y({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Tn({
      updaterMap: jY,
      eventMap: TY,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: jY,
      eventMap: TY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Fe(lde, "defaultProps", {
  onLoad: Hlt
});
Fe(lde, "contextType", Kt);
function AY(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function H1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AY(Object(n), !0).forEach(function(r) {
      Fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AY(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var IY = {}, BY = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function $lt(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Kt), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || vi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    vi(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(H1(H1({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me($lt);
class Zlt extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []), Fe(this, "state", {
      heatmapLayer: null
    }), Fe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    vi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), vi(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(H1(H1({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Tn({
      updaterMap: BY,
      eventMap: IY,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: BY,
      eventMap: IY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Hn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Fe(Zlt, "contextType", Kt);
var NY = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, RY = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class qlt extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []), Fe(this, "state", {
      streetViewPanorama: null
    }), Fe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Tn({
      updaterMap: RY,
      eventMap: NY,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: RY,
      eventMap: NY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Hn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Fe(qlt, "contextType", Kt);
class Xlt extends pe {
  constructor() {
    super(...arguments), Fe(this, "state", {
      streetViewService: null
    }), Fe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Fe(Xlt, "contextType", Kt);
var FY = {
  onDirectionsChanged: "directions_changed"
}, zY = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Klt extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []), Fe(this, "state", {
      directionsRenderer: null
    }), Fe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Tn({
      updaterMap: zY,
      eventMap: FY,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: zY,
      eventMap: FY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Hn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Fe(Klt, "contextType", Kt);
var UY = {
  onPlacesChanged: "places_changed"
}, WY = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Glt extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []), Fe(this, "containerElement", jn()), Fe(this, "state", {
      searchBox: null
    }), Fe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (vi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Tn({
          updaterMap: WY,
          eventMap: UY,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: WY,
      eventMap: UY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Hn(this.registeredEvents));
  }
  render() {
    return yr.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
Fe(Glt, "contextType", Kt);
var HY = {
  onPlaceChanged: "place_changed"
}, VY = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class ude extends pe {
  constructor() {
    super(...arguments), Fe(this, "registeredEvents", []), Fe(this, "containerElement", jn()), Fe(this, "state", {
      autocomplete: null
    }), Fe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    vi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Tn({
        updaterMap: VY,
        eventMap: HY,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Hn(this.registeredEvents), this.registeredEvents = Tn({
      updaterMap: VY,
      eventMap: HY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Hn(this.registeredEvents);
  }
  render() {
    return yr.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
Fe(ude, "defaultProps", {
  className: ""
});
Fe(ude, "contextType", Kt);
let Ylt = { data: "" }, Jlt = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Ylt, Qlt = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, eut = /\/\*[^]*?\*\/|  +/g, $Y = /\n+/g, Yu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Yu(a, i) : i + "{" + Yu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Yu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Yu.p ? Yu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Sl = {}, cde = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + cde(e[n]);
    return t;
  }
  return e;
}, tut = (e, t, n, r, o) => {
  let i = cde(e), a = Sl[i] || (Sl[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Sl[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Qlt.exec(u.replace(eut, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace($Y, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace($Y, " ").trim();
      return d[0];
    })(e);
    Sl[a] = Yu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Sl.g ? Sl.g : null;
  return n && (Sl.g = Sl[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Sl[a], t, r, s), a;
}, nut = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Yu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function OL(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return tut(n.unshift ? n.raw ? nut(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Jlt(t.target), t.g, t.o, t.k);
}
let pde, z_, U_;
OL.bind({ g: 1 });
let ql = OL.bind({ k: 1 });
function rut(e, t, n, r) {
  Yu.p = t, pde = e, z_ = n, U_ = r;
}
function Sc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: z_ && z_() }, s), n.o = / *go\d+/.test(l), s.className = OL.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), U_ && u[0] && U_(s), pde(u, s);
    }
    return o;
  };
}
var out = (e) => typeof e == "function", iut = (e, t) => out(e) ? e(t) : e, sut = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), aut = ql`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, lut = ql`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, uut = ql`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, cut = Sc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${aut} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${lut} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${uut} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, put = ql`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, dut = Sc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${put} 1s linear infinite;
`, fut = ql`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, hut = ql`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, gut = Sc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${fut} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${hut} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, mut = Sc("div")`
  position: absolute;
`, vut = Sc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, yut = ql`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, but = Sc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${yut} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, wut = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? _e.createElement(but, null, t) : t : n === "blank" ? null : _e.createElement(vut, null, _e.createElement(dut, { ...r }), n !== "loading" && _e.createElement(mut, null, n === "error" ? _e.createElement(cut, { ...r }) : _e.createElement(gut, { ...r })));
}, Out = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Cut = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, xut = "0%{opacity:0;} 100%{opacity:1;}", Lut = "0%{opacity:1;} 100%{opacity:0;}", Eut = Sc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, kut = Sc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Put = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = sut() ? [xut, Lut] : [Out(n), Cut(n)];
  return { animation: t ? `${ql(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ql(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
_e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? Put(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = _e.createElement(wut, { toast: e }), a = _e.createElement(kut, { ...e.ariaProps }, iut(e.message, e));
  return _e.createElement(Eut, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : _e.createElement(_e.Fragment, null, i, a));
});
rut(_e.createElement);
OL`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function Sut(e) {
  const { error: t } = e, n = "arkynAudioUploadError";
  return t ? /* @__PURE__ */ oe.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ oe.jsx(oe.Fragment, {});
}
function Mut(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynAudioUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ oe.jsx("strong", { className: o.trim(), children: t });
}
function Dut(e) {
  const { onChange: t, value: n, disableDrag: r = !1, onDragging: o } = e, [i, a] = E(!1), s = vt(null), l = () => {
    a(!0);
  }, u = () => {
    a(!1);
  }, c = (f) => {
    if (r || !i || !s.current) return;
    const v = s.current.getBoundingClientRect(), b = f.clientX - v.left, L = Math.min(Math.max(b / v.width * 100, 0), 100);
    t(L);
  }, p = (f) => {
    if (!s.current) return;
    const v = s.current.getBoundingClientRect(), b = f.clientX - v.left, L = Math.min(Math.max(b / v.width * 100, 0), 100);
    t(L);
  };
  h(() => (i ? (o && o(!0), document.addEventListener("mousemove", c), document.addEventListener("mouseup", u)) : (o && o(!1), document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u)), () => {
    document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
  }), [i]);
  const y = `arkynSliderTrack ${i ? "isDragging" : "isNotDragging"}`;
  return /* @__PURE__ */ oe.jsxs(
    "div",
    {
      className: y,
      ref: s,
      onMouseDown: l,
      onClick: p,
      children: [
        /* @__PURE__ */ oe.jsx("div", { className: "arkynSliderFill", style: { width: `${n}%` } }),
        /* @__PURE__ */ oe.jsx("div", { className: "arkynSliderThumb", style: { left: `${n}%` } })
      ]
    }
  );
}
function _ut(e) {
  var S, U, k, R;
  const {
    filePath: t,
    disabled: n,
    acceptAudio: r,
    handleSelectFile: o,
    isLoading: i,
    reSendAudio: a,
    changeAudioButtonText: s
  } = e, [l, u] = E(0), c = vt(null), [p, d] = E(!1), [y, f] = E(!1);
  h(() => {
    const N = c.current;
    if (!N) return;
    const V = () => {
      const $ = N.duration, X = N.currentTime / $ * 100;
      u(X);
    };
    return N.addEventListener("timeupdate", V), () => {
      N.removeEventListener("timeupdate", V);
    };
  }, []);
  function v(N) {
    const V = c.current;
    if (!V) return;
    const $ = V.duration, H = N / 100 * $;
    V.currentTime = H;
  }
  function b() {
    var N;
    (N = c.current) == null || N.play(), f(!0);
  }
  function L() {
    var N;
    (N = c.current) == null || N.pause(), f(!1);
  }
  function w() {
    y ? L() : b();
  }
  const D = (S = c.current) == null ? void 0 : S.currentTime, x = (U = c.current) == null ? void 0 : U.duration;
  function m(N) {
    if (!N) return "00:00";
    const V = Math.floor(N / 60), $ = Math.floor(N % 60), H = String(V).padStart(2, "0"), X = String($).padStart(2, "0");
    return `${H}:${X}`;
  }
  p || !y ? (k = c.current) == null || k.pause() : y && ((R = c.current) == null || R.play());
  function C() {
    if (n) return;
    const N = document.createElement("input");
    N.type = "file", N.accept = r, N.onchange = (V) => {
      var H;
      const $ = (H = V.target.files) == null ? void 0 : H[0];
      $ && o($);
    }, N.click();
  }
  return /* @__PURE__ */ oe.jsxs("div", { className: "arkynAudioUploadHasFileContentContainer", children: [
    /* @__PURE__ */ oe.jsx("audio", { ref: c, src: t, onEnded: L }),
    /* @__PURE__ */ oe.jsxs("div", { className: "arkynAudioUploadAudioPlayer", children: [
      /* @__PURE__ */ oe.jsxs("button", { type: "button", onClick: w, children: [
        y && /* @__PURE__ */ oe.jsx(rhe, {}),
        !y && /* @__PURE__ */ oe.jsx(ohe, {})
      ] }),
      /* @__PURE__ */ oe.jsx("p", { children: m(D) }),
      /* @__PURE__ */ oe.jsx(
        Dut,
        {
          value: l,
          onChange: v,
          onDragging: d
        }
      ),
      /* @__PURE__ */ oe.jsx("p", { children: m(x) })
    ] }),
    /* @__PURE__ */ oe.jsx(Wbe, {}),
    /* @__PURE__ */ oe.jsxs("div", { className: "arkynAudioUploadButtonsContainer", children: [
      !!a && /* @__PURE__ */ oe.jsx(fot, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ oe.jsx(
        dot,
        {
          type: "button",
          "aria-label": "resend image",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: i,
          onClick: a,
          icon: Iee,
          disabled: n
        }
      ) }),
      /* @__PURE__ */ oe.jsx(
        bpe,
        {
          isLoading: i,
          onClick: C,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: n,
          children: s
        }
      )
    ] })
  ] });
}
function Tut(e) {
  const {
    dropAudioText: t,
    isLoading: n,
    acceptAudio: r,
    handleSelectFile: o,
    selectAudioButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ oe.jsxs("div", { onDrop: s, className: "arkynAudioUploadNoFileContent", children: [
    /* @__PURE__ */ oe.jsx(
      bpe,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ oe.jsx("p", { children: t })
  ] });
}
function $yt(e) {
  const {
    name: t,
    label: n,
    fileName: r = "file",
    method: o = "POST",
    onUpload: i,
    fileResponseName: a = "url",
    selectAudioButtonText: s = "Selecionar arquivo de áudio",
    dropAudioText: l = "Ou arraste e solte um arquivo de áudio aqui",
    changeAudioButtonText: u = "Trocar arquivo de áudio",
    acceptAudio: c = "audio/*",
    action: p,
    defaultValue: d = "",
    showAsterisk: y = !1,
    disabled: f = !1
  } = e, b = pot()[t], [L, w] = E(d), [D, x] = E(""), [m, C] = E(null), [S, U] = E(d), [k, R] = E(!1);
  async function N(Y) {
    if (f) return;
    R(!0), C(Y), x("");
    const Q = new FormData();
    Q.append(r, Y), await fetch(p, { method: o, body: Q }).then(async (J) => await J.json()).then((J) => {
      J != null && J.error ? x(J.error) : w(J == null ? void 0 : J[a]), i && i(J == null ? void 0 : J[a]);
    }).catch((J) => {
      console.error(J), x("Erro ao enviar audio");
    }).finally(() => R(!1));
  }
  function V(Y) {
    if (!f) {
      if (console.log(Y.type), Y.type.indexOf("audio") === -1) {
        x("O arquivo selecionado não é um arquivo de áudio");
        return;
      }
      U(URL.createObjectURL(Y)), N(Y);
    }
  }
  const $ = b || D, G = `arkynAudioUpload ${$ ? "hasError" : "noHasError"} ${S ? "hasAudio" : "noHasAudio"}`;
  return /* @__PURE__ */ oe.jsxs("div", { className: "arkynAudioUploadContainer", children: [
    n && /* @__PURE__ */ oe.jsx(Mut, { label: n, showAsterisk: y }),
    /* @__PURE__ */ oe.jsxs("div", { className: G, children: [
      /* @__PURE__ */ oe.jsx("input", { type: "hidden", name: t, value: L || "" }),
      !S && /* @__PURE__ */ oe.jsx(
        Tut,
        {
          disabled: f,
          isLoading: k,
          acceptAudio: c,
          dropAudioText: l,
          handleSelectFile: V,
          selectAudioButtonText: s
        }
      ),
      S && /* @__PURE__ */ oe.jsx(
        _ut,
        {
          filePath: S,
          acceptAudio: c,
          changeAudioButtonText: u,
          disabled: f,
          handleSelectFile: V,
          isLoading: k,
          reSendAudio: $ && m ? () => N(m) : void 0
        }
      )
    ] }),
    $ && /* @__PURE__ */ oe.jsx(Sut, { error: $ })
  ] });
}
function V1(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, y = { xs: 12, sm: 16, md: 20, lg: 24 }[i], b = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ oe.jsxs("button", { className: b, disabled: l || t, ...p, children: [
    /* @__PURE__ */ oe.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ oe.jsx(tl, { size: y, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ oe.jsxs("div", { className: "arkynButtonContent", children: [
      v0(y, a),
      c,
      v0(y, s)
    ] })
  ] });
}
function dde() {
  const e = uT(), t = Ree(), n = cT(), [r, o] = E(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  h(() => {
    var c, p;
    let u = ((p = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : p.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, e]), h(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const fde = He({});
function ZY(e) {
  var p;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = dde(), a = vt(null), s = ((p = a.current) == null ? void 0 : p.name) || "", l = (i == null ? void 0 : i[s]) || null, u = Jfe(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ oe.jsx(fde.Provider, { value: { error: l, id: u, inputRef: a }, children: /* @__PURE__ */ oe.jsx(
    "section",
    {
      id: r || s || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function _s() {
  return ge(fde);
}
function Zyt(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: a = null,
    onCheck: s,
    value: l,
    ...u
  } = e, { id: c, inputRef: p, error: d } = _s(), y = o || !!d, [f, v] = E(i || !1), b = typeof a == "boolean" ? a : f, D = `arkynCheckbox ${r} ${y ? "errorTrue" : "errorFalse"} ${b ? "checkedTrue" : "checkedFalse"} ${n}`;
  function x() {
    const m = f;
    v(!m), s && s(m ? "" : l || "checked");
  }
  return /* @__PURE__ */ oe.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: D,
      onClick: x,
      ...u,
      children: [
        /* @__PURE__ */ oe.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: p,
            value: b ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ oe.jsx(aT, {})
      ]
    }
  );
}
function qyt(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = _s();
  return t ? /* @__PURE__ */ oe.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ oe.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ oe.jsx(oe.Fragment, {});
}
function qY(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = _s(), a = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ oe.jsx("label", { className: a.trim(), htmlFor: o, ...r });
}
function jut(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, p = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ oe.jsxs(
    "button",
    {
      disabled: a || t,
      className: p.trim(),
      ...l,
      children: [
        /* @__PURE__ */ oe.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ oe.jsx(tl, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ oe.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ oe.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function Aut(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ oe.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ oe.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function Iut(e) {
  const {
    disabled: t,
    filePath: n,
    isLoading: r,
    acceptImage: o,
    changeImageButtonText: i,
    handleSelectFile: a,
    reSendImage: s
  } = e;
  function l() {
    if (t) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = o, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && a(p);
    }, u.click();
  }
  return /* @__PURE__ */ oe.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${n}")` },
      children: [
        s && /* @__PURE__ */ oe.jsx(Aut, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ oe.jsx(
          jut,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: r,
            onClick: s,
            icon: Iee,
            disabled: t
          }
        ) }),
        /* @__PURE__ */ oe.jsx(
          V1,
          {
            isLoading: r,
            onClick: l,
            variant: "outline",
            size: "sm",
            type: "button",
            disabled: t,
            children: i
          }
        )
      ]
    }
  );
}
function But(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ oe.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ oe.jsx(oe.Fragment, {});
}
function Nut(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ oe.jsx("strong", { className: o.trim(), children: t });
}
function Rut(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ oe.jsxs("div", { onDrop: s, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ oe.jsx(
      V1,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ oe.jsx("p", { children: t })
  ] });
}
function Fut(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: a = "file",
    method: s = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: p = "Selecionar imagem",
    dropImageText: d = "Ou arraste e solte a imagem aqui",
    onUpload: y,
    disabled: f = !1
  } = e, b = dde()[t], [L, w] = E(n), [D, x] = E(""), [m, C] = E(null), [S, U] = E(n), [k, R] = E(!1);
  async function N(Y) {
    if (f) return;
    R(!0), C(Y), x("");
    const Q = new FormData();
    Q.append(a, Y), await fetch(i, { method: s, body: Q }).then(async (J) => await J.json()).then((J) => {
      J != null && J.error ? x(J.error) : w(J == null ? void 0 : J[u]), y && y(J == null ? void 0 : J[u]);
    }).catch((J) => {
      console.error(J), x("Erro ao enviar imagem");
    }).finally(() => R(!1));
  }
  function V(Y) {
    f || (U(URL.createObjectURL(Y)), N(Y));
  }
  const $ = b || D, G = `arkynImageUpload ${$ ? "hasError" : "noHasError"} ${S ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ oe.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ oe.jsx(Nut, { label: r, showAsterisk: o }),
    /* @__PURE__ */ oe.jsxs("div", { className: G, children: [
      /* @__PURE__ */ oe.jsx("input", { type: "hidden", name: t, value: L || "" }),
      !S && /* @__PURE__ */ oe.jsx(
        Rut,
        {
          disabled: f,
          isLoading: k,
          acceptImage: l,
          dropImageText: d,
          handleSelectFile: V,
          selectImageButtonText: p
        }
      ),
      S && /* @__PURE__ */ oe.jsx(
        Iut,
        {
          disabled: f,
          isLoading: k,
          acceptImage: l,
          filePath: S,
          handleSelectFile: V,
          changeImageButtonText: c,
          reSendImage: $ && m ? () => N(m) : void 0
        }
      )
    ] }),
    $ && /* @__PURE__ */ oe.jsx(But, { error: $ })
  ] });
}
function tc(e, t, n) {
  if (!e) return /* @__PURE__ */ oe.jsx(oe.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ oe.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ oe.jsx("p", { className: n, children: /* @__PURE__ */ oe.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function QB(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function hde(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function gde(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const eN = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, mde = QB(eN.CNPJ).length;
function zut(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    defaultValue: d,
    readOnly: y,
    onFocus: f,
    onBlur: v,
    title: b,
    style: L,
    onChange: w,
    ...D
  } = e;
  function x(H) {
    let X = QB(H);
    const G = gde(X);
    if (!(X.length > mde))
      return X = hde(X, eN[G]), X;
  }
  const m = c ? "right" : "left", N = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || y || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, $ = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: N,
    prefix: tc(s, $, "prefix"),
    sufix: tc(l, $, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: x(d || ""),
    disabled: p,
    readOnly: y,
    onFocus: f,
    onBlur: v,
    title: b,
    style: L,
    onChange: w,
    loadingPosition: m,
    iconSize: $,
    Spinner: /* @__PURE__ */ oe.jsx(tl, { className: "spinner", size: $, strokeWidth: 2.5 }),
    ...D
  };
}
function Uut(e) {
  const [t, n] = E(!1), r = vt(null), { inputRef: o, id: i, error: a } = _s(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: y,
    sufix: f,
    iconSize: v,
    loadingPosition: b,
    isLoading: L,
    LeftIcon: w,
    readOnly: D,
    onFocus: x,
    onBlur: m,
    RightIcon: C,
    Spinner: S,
    onChange: U,
    value: k,
    defaultValue: R,
    ...N
  } = zut({ ...e, id: i, isError: l }, t), [V, $] = E(R), H = w && !L, X = C && !L, G = b === "left" && L, Y = b === "right" && L;
  function Q() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function J(z) {
    let M = QB(z.target.value);
    const W = gde(M);
    M.length > mde || (M = hde(M, eN[W]), z.target.value = M, $(M), U && U(z));
  }
  function P(z) {
    n(!0), x && x(z);
  }
  function _(z) {
    n(!1), m && m(z);
  }
  return /* @__PURE__ */ oe.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: Q,
      className: d,
      children: [
        y,
        G && S,
        H && /* @__PURE__ */ oe.jsx(w, { size: v, strokeWidth: 2.5 }),
        /* @__PURE__ */ oe.jsx(
          "input",
          {
            disabled: u || L,
            readOnly: D,
            ref: s,
            value: k || V,
            onFocus: P,
            onChange: J,
            onBlur: _,
            ...N
          }
        ),
        X && /* @__PURE__ */ oe.jsx(C, { size: v, strokeWidth: 2.5 }),
        Y && S,
        f
      ]
    }
  );
}
const Wut = 3, Hut = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? Wut : 0), Bb = 2, XY = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), W_ = (e) => {
  let t = e;
  return typeof e == "string" ? (t = XY(e), t % 1 !== 0 && (t = t.toFixed(Bb))) : t = Number.isInteger(e) ? Number(e) * 10 ** Bb : e.toFixed(Bb), XY(t) / 10 ** Bb;
}, KY = (e, t, n) => {
  if (!t) return [0, ""];
  const r = W_(t), o = Hut(e, r, n);
  return [r, o];
};
function Vut(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: b,
    // showCents = false,
    max: L = 1e9,
    locale: w = "pt-BR",
    currency: D = "BRL",
    ...x
  } = e, m = c ? "right" : "left", N = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, $ = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: N,
    prefix: tc(s, $, "prefix"),
    sufix: tc(l, $, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    locale: w,
    currency: D,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: b,
    max: L,
    // showCents,
    loadingPosition: m,
    iconSize: $,
    Spinner: /* @__PURE__ */ oe.jsx(tl, { className: "spinner", size: $, strokeWidth: 2.5 }),
    ...x
  };
}
function $ut(e) {
  const [t, n] = E(!1), [r, o] = E("0"), i = vt(null), { inputRef: a, id: s, error: l } = _s(), u = a || i, c = e.isError || !!l, {
    disabled: p,
    title: d,
    style: y,
    className: f,
    prefix: v,
    sufix: b,
    iconSize: L,
    loadingPosition: w,
    isLoading: D,
    LeftIcon: x,
    readOnly: m,
    onFocus: C,
    onBlur: S,
    RightIcon: U,
    Spinner: k,
    value: R,
    max: N,
    onChangeValue: V,
    onKeyPress: $,
    currency: H,
    locale: X,
    name: G,
    defaultValue: Y,
    ...Q
  } = Vut({ ...e, id: s, isError: c }, t), J = x && !D, P = U && !D, _ = w === "left" && D, z = w === "right" && D;
  function M() {
    p || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function W(q) {
    n(!0), C && C(q);
  }
  function O(q) {
    n(!1), S && S(q);
  }
  const I = (q) => {
    const [A, K] = KY(
      X,
      q,
      H
    );
    return !N || A <= N ? (o(K), [A, K]) : [W_(r), r];
  }, F = (q) => {
    q.preventDefault();
    const [A, K] = I(q.target.value);
    V && V(q, String(A), String(K));
  }, j = (q) => $ && $(q, q.key, q.key);
  return h(() => {
    const q = R || +Y || void 0, [, A] = KY(X, q, H);
    o(A);
  }, [H, Y, R]), /* @__PURE__ */ oe.jsxs(
    "section",
    {
      title: d,
      style: y,
      onClick: M,
      className: f,
      children: [
        v,
        _ && k,
        J && /* @__PURE__ */ oe.jsx(x, { size: L, strokeWidth: 2.5 }),
        /* @__PURE__ */ oe.jsx(
          "input",
          {
            value: r,
            onChange: F,
            onBlur: O,
            onFocus: W,
            onKeyUp: j,
            disabled: p || D,
            readOnly: m,
            ...Q
          }
        ),
        /* @__PURE__ */ oe.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: G,
            value: W_(r)
          }
        ),
        z && k,
        P && /* @__PURE__ */ oe.jsx(U, { size: L, strokeWidth: 2.5 }),
        b
      ]
    }
  );
}
function Zut(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: b,
    onChange: L,
    showMask: w = !1,
    type: D,
    ...x
  } = e, m = c ? "right" : "left", N = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, $ = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: N,
    prefix: tc(s, $, "prefix"),
    sufix: tc(l, $, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: b,
    onChange: L,
    loadingPosition: m,
    iconSize: $,
    showMask: w,
    Spinner: /* @__PURE__ */ oe.jsx(tl, { className: "spinner", size: $, strokeWidth: 2.5 }),
    ...x
  };
}
const qut = ka((e, t) => /* @__PURE__ */ oe.jsx("input", { ref: t, ...e }));
function Xut(e) {
  const [t, n] = E(!1), r = vt(null), { inputRef: o, id: i, error: a } = _s(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: y,
    sufix: f,
    iconSize: v,
    loadingPosition: b,
    isLoading: L,
    LeftIcon: w,
    readOnly: D,
    onFocus: x,
    onBlur: m,
    RightIcon: C,
    Spinner: S,
    ...U
  } = Zut({ ...e, id: i, isError: l }, t), k = w && !L, R = C && !L, N = b === "left" && L, V = b === "right" && L;
  function $() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function H(G) {
    n(!0), x && x(G);
  }
  function X(G) {
    n(!1), m && m(G);
  }
  return /* @__PURE__ */ oe.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: $,
      className: d,
      children: [
        y,
        N && S,
        k && /* @__PURE__ */ oe.jsx(w, { size: v, strokeWidth: 2.5 }),
        /* @__PURE__ */ oe.jsx(
          whe,
          {
            component: qut,
            ref: s,
            onFocus: H,
            onBlur: X,
            disabled: u,
            ...U
          }
        ),
        R && /* @__PURE__ */ oe.jsx(C, { size: v, strokeWidth: 2.5 }),
        V && S,
        f
      ]
    }
  );
}
function Kut(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: b,
    onChange: L,
    ...w
  } = e, D = c ? "right" : "left", k = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, N = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: k,
    prefix: tc(s, N, "prefix"),
    sufix: tc(l, N, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: b,
    onChange: L,
    loadingPosition: D,
    iconSize: N,
    Spinner: /* @__PURE__ */ oe.jsx(tl, { className: "spinner", size: N, strokeWidth: 2.5 }),
    ...w
  };
}
function Gut(e) {
  const [t, n] = E(!1), r = vt(null), { inputRef: o, id: i, error: a } = _s(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: y,
    sufix: f,
    iconSize: v,
    loadingPosition: b,
    isLoading: L,
    LeftIcon: w,
    readOnly: D,
    onFocus: x,
    onBlur: m,
    RightIcon: C,
    type: S,
    Spinner: U,
    ...k
  } = Kut({ ...e, id: i, isError: l }, t), R = w && !L, N = C && !L, V = b === "left" && L, $ = b === "right" && L;
  function H() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function X(Y) {
    n(!0), x && x(Y);
  }
  function G(Y) {
    n(!1), m && m(Y);
  }
  return S === "hidden" ? /* @__PURE__ */ oe.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: s,
      ...k
    }
  ) : /* @__PURE__ */ oe.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: H,
      className: d,
      children: [
        y,
        V && U,
        R && /* @__PURE__ */ oe.jsx(w, { size: v, strokeWidth: 2.5 }),
        /* @__PURE__ */ oe.jsx(
          "input",
          {
            disabled: u || L,
            readOnly: D,
            ref: s,
            onFocus: X,
            onBlur: G,
            type: S,
            ...k
          }
        ),
        N && /* @__PURE__ */ oe.jsx(C, { size: v, strokeWidth: 2.5 }),
        $ && U,
        f
      ]
    }
  );
}
function CL(e) {
  return e.type === "currency" ? /* @__PURE__ */ oe.jsx($ut, { ...e }) : e.type === "masked" ? /* @__PURE__ */ oe.jsx(Xut, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ oe.jsx(Uut, { ...e }) : /* @__PURE__ */ oe.jsx(Gut, { ...e });
}
function Yut(e) {
  const { iconSize: t, isLoading: n, disabled: r, readOnly: o, isFocused: i } = e, l = `arkynMultiSelectChevron ${r || o ? "notAnimate" : ""} ${i ? "focused" : ""}`;
  return n ? /* @__PURE__ */ oe.jsx(oe.Fragment, {}) : /* @__PURE__ */ oe.jsx(Bee, { className: l, size: t, strokeWidth: 2.5 });
}
function Jut(e) {
  const {
    children: t,
    handleContainerFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: a,
    className: s,
    readOnly: l,
    variant: u,
    size: c,
    id: p,
    prefixExists: d
  } = e, y = d ? "hasPrefix" : "", f = o ? "errored" : "", v = r || l || i ? "opacity" : "", b = a ? "focused" : "";
  return /* @__PURE__ */ oe.jsx(
    "section",
    {
      onClick: n,
      id: p,
      className: `arkynMultiSelectContainer ${y} ${u} ${c} ${v} ${f} ${b} ${s}`,
      children: t
    }
  );
}
function Qut(e) {
  const { children: t, size: n } = e, r = `arkynMultiSelectContent ${n}`;
  return /* @__PURE__ */ oe.jsx("div", { className: r, children: t });
}
function ect(e) {
  const { label: t, value: n, handleChangeValue: r } = e;
  return /* @__PURE__ */ oe.jsxs("div", { className: "arkynMultiSelectMark", children: [
    t,
    /* @__PURE__ */ oe.jsx(
      "button",
      {
        type: "button",
        onClick: (o) => {
          o.stopPropagation(), r(n);
        },
        children: /* @__PURE__ */ oe.jsx(lT, {})
      }
    )
  ] });
}
function tct(e) {
  const { label: t, optionHasSelected: n, handleChangeValue: r, value: o, size: i } = e, a = n(o) ? "active" : "", s = `arkynMultiSelectOption ${i} ${a}`;
  return /* @__PURE__ */ oe.jsxs("div", { onClick: () => r(o), className: s, children: [
    t,
    " ",
    /* @__PURE__ */ oe.jsx(aT, {})
  ] });
}
function nct(e) {
  const { children: t, isFocused: n, isSearchable: r, onSearch: o } = e;
  function i(a) {
    r && o(a.target.value);
  }
  return n ? /* @__PURE__ */ oe.jsxs("div", { className: "arkynMultiSelectOptionsContainer", children: [
    r && /* @__PURE__ */ oe.jsx(
      CL,
      {
        type: "search",
        name: "search-select",
        variant: "underline",
        leftIcon: Nee,
        onChange: i
      }
    ),
    t
  ] }) : /* @__PURE__ */ oe.jsx(oe.Fragment, {});
}
function rct(e) {
  const { isFocused: t, handleBlur: n } = e;
  return t ? /* @__PURE__ */ oe.jsx("aside", { className: "arkynMultiSelectOverlay", onClick: n }) : /* @__PURE__ */ oe.jsx(oe.Fragment, {});
}
function oct(e) {
  const { iconSize: t, isLoading: n } = e;
  return n ? /* @__PURE__ */ oe.jsx(
    tl,
    {
      className: "arkynMultiSelectSpinner",
      size: t,
      strokeWidth: 2.5
    }
  ) : /* @__PURE__ */ oe.jsx(oe.Fragment, {});
}
function Xyt(e) {
  const {
    name: t,
    options: n,
    className: r = "",
    placeholder: o = "Selecione...",
    closeOnSelect: i = !1,
    defaultValue: a = [],
    isError: s,
    isLoading: l = !1,
    readOnly: u = !1,
    isSearchable: c = !1,
    leftIcon: p,
    onSearch: d,
    onSelect: y,
    onBlur: f,
    notFoundText: v = "Sem opções disponíveis",
    onFocus: b,
    disabled: L = !1,
    prefix: w,
    size: D = "md",
    value: x,
    variant: m = "solid"
  } = e, C = _s(), S = vt(null), U = C.inputRef || S, k = C.id, R = s || !!C.error, V = { md: 20, lg: 20 }[D], $ = bte(w, V, "prefix"), [H, X] = E(""), [G, Y] = E(!1), [Q, J] = E(a), P = x || Q;
  function _(j) {
    return P.includes(j);
  }
  function z(j) {
    const q = n.find((A) => A.value === j);
    return (q == null ? void 0 : q.label) || "";
  }
  function M() {
    L || !(U != null && U.current) || G || (Y(!0), U.current.focus(), b && b());
  }
  function W() {
    Y(!1), f && U.current && U.current.blur();
  }
  function O(j) {
    X(j), d && d(j);
  }
  function I(j) {
    _(j) ? J(Q.filter((q) => q !== j)) : J([...Q, j]), y && y(Q), i && W();
  }
  const F = n.filter((j) => !!(e.onSearch || !e.isSearchable || j.label.toLowerCase().includes(H.toLowerCase())));
  return /* @__PURE__ */ oe.jsxs(
    Jut,
    {
      handleContainerFocus: M,
      disabled: L,
      isError: R,
      isFocused: G,
      isLoading: l,
      readOnly: u,
      size: D,
      variant: m,
      className: r,
      prefixExists: !!w,
      id: k,
      children: [
        /* @__PURE__ */ oe.jsx(
          "input",
          {
            ref: U,
            name: t,
            value: JSON.stringify(P),
            type: "hidden"
          }
        ),
        $,
        p && /* @__PURE__ */ oe.jsx(p, { size: V, strokeWidth: 2.5 }),
        /* @__PURE__ */ oe.jsxs(Qut, { size: D, children: [
          P.map((j) => /* @__PURE__ */ oe.jsx(
            ect,
            {
              label: z(j),
              value: j,
              handleChangeValue: I
            },
            j
          )),
          P.length <= 0 && /* @__PURE__ */ oe.jsx("p", { children: o })
        ] }),
        /* @__PURE__ */ oe.jsxs(
          nct,
          {
            isFocused: G,
            isSearchable: c,
            onSearch: O,
            children: [
              F.map(({ label: j, value: q }) => /* @__PURE__ */ oe.jsx(
                tct,
                {
                  label: j,
                  value: q,
                  size: D,
                  handleChangeValue: I,
                  optionHasSelected: _
                },
                q
              )),
              F.length <= 0 && /* @__PURE__ */ oe.jsx("p", { children: v })
            ]
          }
        ),
        /* @__PURE__ */ oe.jsx(
          Yut,
          {
            disabled: L,
            isFocused: G,
            readOnly: u,
            iconSize: V,
            isLoading: l
          }
        ),
        /* @__PURE__ */ oe.jsx(oct, { iconSize: V, isLoading: l }),
        /* @__PURE__ */ oe.jsx(rct, { handleBlur: W, isFocused: G })
      ]
    }
  );
}
const vde = He({});
function ict() {
  return ge(vde);
}
function Kyt(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: a = "",
    ...s
  } = e, [l, u] = E(t || ""), { inputRef: c, id: p } = _s();
  function d(f) {
    u(f), o && o(f);
  }
  const y = `arkynRadioGroup ${i} ${a}`;
  return /* @__PURE__ */ oe.jsxs(
    vde.Provider,
    {
      value: { onChange: d, value: r || l, size: i },
      children: [
        /* @__PURE__ */ oe.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: p,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ oe.jsx("div", { className: y.trim(), ...s })
      ]
    }
  );
}
function Gyt(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...a
  } = e, { onChange: s, size: l, value: u } = ict(), { error: c } = _s(), v = `arkynRadioBox ${n || l} ${u === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ oe.jsxs("label", { className: v.trim(), children: [
    /* @__PURE__ */ oe.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => s(t),
        onFocus: () => s(t),
        ...a
      }
    ),
    o
  ] });
}
var ou = {};
Object.defineProperty(ou, "__esModule", {
  value: !0
});
var sct = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), CS = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, yde = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: sct ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, tN = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Nb = 1; Nb < 20; Nb++)
  tN["f" + Nb] = 111 + Nb;
function xL(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return bde(a, t);
  }), o = function(s) {
    return r.some(function(l) {
      return wde(l, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function act(e, t) {
  return xL(e, t);
}
function lct(e, t) {
  return xL(e, { byKey: !0 }, t);
}
function bde(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in CS)
    r[CS[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = nN(d), v = CS[f];
      if (d.length > 1 && !v && !yde[d] && !tN[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = Ode(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function wde(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Ode(e) {
  e = nN(e);
  var t = tN[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function nN(e) {
  return e = e.toLowerCase(), e = yde[e] || e, e;
}
var uct = ou.default = xL, xS = ou.isHotkey = xL;
ou.isCodeHotkey = act;
ou.isKeyHotkey = lct;
ou.parseHotkey = bde;
ou.compareHotkey = wde;
ou.toKeyCode = Ode;
ou.toKeyName = nN;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function GY(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function cct(e) {
  var t, n;
  return GY(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(GY(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var pct = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return cct(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || Qu.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || Qu.isOperationList(e.undos[0].operations));
  }
}, LS = /* @__PURE__ */ new WeakMap(), $f = /* @__PURE__ */ new WeakMap(), xp = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return pct.isHistory(e.history) && ne.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return $f.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return LS.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = xp.isMerging(e);
    $f.set(e, !0), t(), $f.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = xp.isMerging(e);
    $f.set(e, !1), t(), $f.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = xp.isSaving(e);
    LS.set(e, !1), t(), LS.set(e, n);
  }
}, dct = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && $e.setSelection(t, i.selectionBefore), xp.withoutSaving(t, () => {
        ne.withoutNormalizing(t, () => {
          for (var a of i.operations)
            t.apply(a);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      xp.withoutSaving(t, () => {
        ne.withoutNormalizing(t, () => {
          var a = i.operations.map(Qu.inverse).reverse();
          for (var s of a)
            t.apply(s);
          i.selectionBefore && $e.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: a
    } = i, s = a[a.length - 1], l = s && s.operations[s.operations.length - 1], u = xp.isSaving(t), c = xp.isMerging(t);
    if (u == null && (u = hct(r)), u) {
      if (c == null && (s == null ? c = !1 : o.length !== 0 ? c = !0 : c = fct(r, l)), s && c)
        s.operations.push(r);
      else {
        var p = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", p);
      }
      for (; a.length > 100; )
        a.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, fct = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && ce.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && ce.equals(e.path, t.path)), hct = (e, t) => e.type !== "set_selection", gct = yct, Cde = "֑-߿יִ-﷽ﹰ-ﻼ", xde = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", mct = new RegExp("^[^" + xde + "]*[" + Cde + "]"), vct = new RegExp("^[^" + Cde + "]*[" + xde + "]");
function yct(e) {
  return e = String(e || ""), mct.test(e) ? "rtl" : vct.test(e) ? "ltr" : "neutral";
}
const Lde = /* @__PURE__ */ rO(gct);
function bct(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var rN = bct, wct = typeof Pr == "object" && Pr && Pr.Object === Object && Pr, Oct = wct, Cct = Oct, xct = typeof self == "object" && self && self.Object === Object && self, Lct = Cct || xct || Function("return this")(), Ede = Lct, Ect = Ede, kct = function() {
  return Ect.Date.now();
}, Pct = kct, Sct = /\s/;
function Mct(e) {
  for (var t = e.length; t-- && Sct.test(e.charAt(t)); )
    ;
  return t;
}
var Dct = Mct, _ct = Dct, Tct = /^\s+/;
function jct(e) {
  return e && e.slice(0, _ct(e) + 1).replace(Tct, "");
}
var Act = jct, Ict = Ede, Bct = Ict.Symbol, kde = Bct, YY = kde, Pde = Object.prototype, Nct = Pde.hasOwnProperty, Rct = Pde.toString, Zf = YY ? YY.toStringTag : void 0;
function Fct(e) {
  var t = Nct.call(e, Zf), n = e[Zf];
  try {
    e[Zf] = void 0;
    var r = !0;
  } catch {
  }
  var o = Rct.call(e);
  return r && (t ? e[Zf] = n : delete e[Zf]), o;
}
var zct = Fct, Uct = Object.prototype, Wct = Uct.toString;
function Hct(e) {
  return Wct.call(e);
}
var Vct = Hct, JY = kde, $ct = zct, Zct = Vct, qct = "[object Null]", Xct = "[object Undefined]", QY = JY ? JY.toStringTag : void 0;
function Kct(e) {
  return e == null ? e === void 0 ? Xct : qct : QY && QY in Object(e) ? $ct(e) : Zct(e);
}
var Gct = Kct;
function Yct(e) {
  return e != null && typeof e == "object";
}
var Jct = Yct, Qct = Gct, ept = Jct, tpt = "[object Symbol]";
function npt(e) {
  return typeof e == "symbol" || ept(e) && Qct(e) == tpt;
}
var rpt = npt, opt = Act, eJ = rN, ipt = rpt, tJ = NaN, spt = /^[-+]0x[0-9a-f]+$/i, apt = /^0b[01]+$/i, lpt = /^0o[0-7]+$/i, upt = parseInt;
function cpt(e) {
  if (typeof e == "number")
    return e;
  if (ipt(e))
    return tJ;
  if (eJ(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = eJ(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = opt(e);
  var n = apt.test(e);
  return n || lpt.test(e) ? upt(e.slice(2), n ? 2 : 8) : spt.test(e) ? tJ : +e;
}
var ppt = cpt, dpt = rN, ES = Pct, nJ = ppt, fpt = "Expected a function", hpt = Math.max, gpt = Math.min;
function mpt(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(fpt);
  t = nJ(t) || 0, dpt(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? hpt(nJ(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? gpt(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = ES();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(ES());
  }
  function m() {
    var C = ES(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return clearTimeout(s), s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
var Sde = mpt;
const vpt = /* @__PURE__ */ rO(Sde);
var ypt = Sde, bpt = rN, wpt = "Expected a function";
function Opt(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(wpt);
  return bpt(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), ypt(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var Cpt = Opt;
const xpt = /* @__PURE__ */ rO(Cpt), rJ = (e) => typeof e == "object" && e != null && e.nodeType === 1, oJ = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", kS = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return oJ(n.overflowY, t) || oJ(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, Rb = (e, t, n, r, o, i, a, s) => i < e && a > t || i > e && a < t ? 0 : i <= e && s <= n || a >= t && s >= n ? i - e - r : a > t && s < n || i < e && s > n ? a - t + o : 0, Lpt = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, iJ = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: a, block: s, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, p = typeof u == "function" ? u : (G) => G !== u;
  if (!rJ(e)) throw new TypeError("Invalid target");
  const d = document.scrollingElement || document.documentElement, y = [];
  let f = e;
  for (; rJ(f) && p(f); ) {
    if (f = Lpt(f), f === d) {
      y.push(f);
      break;
    }
    f != null && f === document.body && kS(f) && !kS(document.documentElement) || f != null && kS(f, c) && y.push(f);
  }
  const v = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, b = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: L, scrollY: w } = window, { height: D, width: x, top: m, right: C, bottom: S, left: U } = e.getBoundingClientRect(), { top: k, right: R, bottom: N, left: V } = ((G) => {
    const Y = window.getComputedStyle(G);
    return { top: parseFloat(Y.scrollMarginTop) || 0, right: parseFloat(Y.scrollMarginRight) || 0, bottom: parseFloat(Y.scrollMarginBottom) || 0, left: parseFloat(Y.scrollMarginLeft) || 0 };
  })(e);
  let $ = s === "start" || s === "nearest" ? m - k : s === "end" ? S + N : m + D / 2 - k + N, H = l === "center" ? U + x / 2 - V + R : l === "end" ? C + R : U - V;
  const X = [];
  for (let G = 0; G < y.length; G++) {
    const Y = y[G], { height: Q, width: J, top: P, right: _, bottom: z, left: M } = Y.getBoundingClientRect();
    if (a === "if-needed" && m >= 0 && U >= 0 && S <= b && C <= v && m >= P && S <= z && U >= M && C <= _) return X;
    const W = getComputedStyle(Y), O = parseInt(W.borderLeftWidth, 10), I = parseInt(W.borderTopWidth, 10), F = parseInt(W.borderRightWidth, 10), j = parseInt(W.borderBottomWidth, 10);
    let q = 0, A = 0;
    const K = "offsetWidth" in Y ? Y.offsetWidth - Y.clientWidth - O - F : 0, B = "offsetHeight" in Y ? Y.offsetHeight - Y.clientHeight - I - j : 0, le = "offsetWidth" in Y ? Y.offsetWidth === 0 ? 0 : J / Y.offsetWidth : 0, he = "offsetHeight" in Y ? Y.offsetHeight === 0 ? 0 : Q / Y.offsetHeight : 0;
    if (d === Y) q = s === "start" ? $ : s === "end" ? $ - b : s === "nearest" ? Rb(w, w + b, b, I, j, w + $, w + $ + D, D) : $ - b / 2, A = l === "start" ? H : l === "center" ? H - v / 2 : l === "end" ? H - v : Rb(L, L + v, v, O, F, L + H, L + H + x, x), q = Math.max(0, q + w), A = Math.max(0, A + L);
    else {
      q = s === "start" ? $ - P - I : s === "end" ? $ - z + j + B : s === "nearest" ? Rb(P, z, Q, I, j + B, $, $ + D, D) : $ - (P + Q / 2) + B / 2, A = l === "start" ? H - M - O : l === "center" ? H - (M + J / 2) + K / 2 : l === "end" ? H - _ + F + K : Rb(M, _, J, O, F + K, H, H + x, x);
      const { scrollLeft: re, scrollTop: Se } = Y;
      q = he === 0 ? 0 : Math.max(0, Math.min(Se + q / he, Y.scrollHeight - Q / he + B)), A = le === 0 ? 0 : Math.max(0, Math.min(re + A / le, Y.scrollWidth - J / le + K)), $ += Se - q, H += re - A;
    }
    X.push({ el: Y, top: q, left: A });
  }
  return X;
}, Ept = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function kpt(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior(iJ(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: a } of iJ(e, Ept(t))) {
    const s = i - n.top + n.bottom, l = a - n.left + n.right;
    o.scroll({ top: s, left: l, behavior: r });
  }
}
var kp = [], Ppt = function() {
  return kp.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Spt = function() {
  return kp.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, sJ = "ResizeObserver loop completed with undelivered notifications.", Mpt = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: sJ
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = sJ), window.dispatchEvent(e);
}, Gg;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Gg || (Gg = {}));
var Pp = function(e) {
  return Object.freeze(e);
}, Dpt = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Pp(this);
  }
  return e;
}(), Mde = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Pp(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), oN = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, Dde = function(e) {
  if (oN(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, a = o.offsetHeight;
  return !(i || a || e.getClientRects().length);
}, aJ = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, _pt = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, Xh = typeof window < "u" ? window : {}, Fb = /* @__PURE__ */ new WeakMap(), lJ = /auto|scroll/, Tpt = /^tb|vertical/, jpt = /msie|trident/i.test(Xh.navigator && Xh.navigator.userAgent), Ba = function(e) {
  return parseFloat(e || "0");
}, hd = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Dpt((n ? t : e) || 0, (n ? e : t) || 0);
}, uJ = Pp({
  devicePixelContentBoxSize: hd(),
  borderBoxSize: hd(),
  contentBoxSize: hd(),
  contentRect: new Mde(0, 0, 0, 0)
}), _de = function(e, t) {
  if (t === void 0 && (t = !1), Fb.has(e) && !t)
    return Fb.get(e);
  if (Dde(e))
    return Fb.set(e, uJ), uJ;
  var n = getComputedStyle(e), r = oN(e) && e.ownerSVGElement && e.getBBox(), o = !jpt && n.boxSizing === "border-box", i = Tpt.test(n.writingMode || ""), a = !r && lJ.test(n.overflowY || ""), s = !r && lJ.test(n.overflowX || ""), l = r ? 0 : Ba(n.paddingTop), u = r ? 0 : Ba(n.paddingRight), c = r ? 0 : Ba(n.paddingBottom), p = r ? 0 : Ba(n.paddingLeft), d = r ? 0 : Ba(n.borderTopWidth), y = r ? 0 : Ba(n.borderRightWidth), f = r ? 0 : Ba(n.borderBottomWidth), v = r ? 0 : Ba(n.borderLeftWidth), b = p + u, L = l + c, w = v + y, D = d + f, x = s ? e.offsetHeight - D - e.clientHeight : 0, m = a ? e.offsetWidth - w - e.clientWidth : 0, C = o ? b + w : 0, S = o ? L + D : 0, U = r ? r.width : Ba(n.width) - C - m, k = r ? r.height : Ba(n.height) - S - x, R = U + b + m + w, N = k + L + x + D, V = Pp({
    devicePixelContentBoxSize: hd(Math.round(U * devicePixelRatio), Math.round(k * devicePixelRatio), i),
    borderBoxSize: hd(R, N, i),
    contentBoxSize: hd(U, k, i),
    contentRect: new Mde(p, l, U, k)
  });
  return Fb.set(e, V), V;
}, Tde = function(e, t, n) {
  var r = _de(e, n), o = r.borderBoxSize, i = r.contentBoxSize, a = r.devicePixelContentBoxSize;
  switch (t) {
    case Gg.DEVICE_PIXEL_CONTENT_BOX:
      return a;
    case Gg.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, Apt = /* @__PURE__ */ function() {
  function e(t) {
    var n = _de(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = Pp([n.borderBoxSize]), this.contentBoxSize = Pp([n.contentBoxSize]), this.devicePixelContentBoxSize = Pp([n.devicePixelContentBoxSize]);
  }
  return e;
}(), jde = function(e) {
  if (Dde(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, Ipt = function() {
  var e = 1 / 0, t = [];
  kp.forEach(function(a) {
    if (a.activeTargets.length !== 0) {
      var s = [];
      a.activeTargets.forEach(function(u) {
        var c = new Apt(u.target), p = jde(u.target);
        s.push(c), u.lastReportedSize = Tde(u.target, u.observedBox), p < e && (e = p);
      }), t.push(function() {
        a.callback.call(a.observer, s, a.observer);
      }), a.activeTargets.splice(0, a.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, cJ = function(e) {
  kp.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (jde(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, Bpt = function() {
  var e = 0;
  for (cJ(e); Ppt(); )
    e = Ipt(), cJ(e);
  return Spt() && Mpt(), e > 0;
}, PS, Ade = [], Npt = function() {
  return Ade.splice(0).forEach(function(e) {
    return e();
  });
}, Rpt = function(e) {
  if (!PS) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return Npt();
    }).observe(n, r), PS = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  Ade.push(e), PS();
}, Fpt = function(e) {
  Rpt(function() {
    requestAnimationFrame(e);
  });
}, u0 = 0, zpt = function() {
  return !!u0;
}, Upt = 250, Wpt = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, pJ = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], dJ = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, SS = !1, Hpt = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = Upt), !SS) {
      SS = !0;
      var r = dJ(t);
      Fpt(function() {
        var o = !1;
        try {
          o = Bpt();
        } finally {
          if (SS = !1, t = r - dJ(), !zpt())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, Wpt);
    };
    document.body ? n() : Xh.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), pJ.forEach(function(n) {
      return Xh.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), pJ.forEach(function(n) {
      return Xh.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), H_ = new Hpt(), fJ = function(e) {
  !u0 && e > 0 && H_.start(), u0 += e, !u0 && H_.stop();
}, Vpt = function(e) {
  return !oN(e) && !_pt(e) && getComputedStyle(e).display === "inline";
}, $pt = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || Gg.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = Tde(this.target, this.observedBox, !0);
    return Vpt(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), Zpt = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), zb = /* @__PURE__ */ new WeakMap(), hJ = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Ub = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new Zpt(t, n);
    zb.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = zb.get(t), i = o.observationTargets.length === 0;
    hJ(o.observationTargets, n) < 0 && (i && kp.push(o), o.observationTargets.push(new $pt(n, r && r.box)), fJ(1), H_.schedule());
  }, e.unobserve = function(t, n) {
    var r = zb.get(t), o = hJ(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && kp.splice(kp.indexOf(r), 1), r.observationTargets.splice(o, 1), fJ(-1));
  }, e.disconnect = function(t) {
    var n = this, r = zb.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), qpt = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Ub.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!aJ(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Ub.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!aJ(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Ub.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Ub.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function Xpt(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function kd(e, t) {
  if (e == null) return {};
  var n = Xpt(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function Yg(e) {
  "@babel/helpers - typeof";
  return Yg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Yg(e);
}
function Kpt(e, t) {
  if (Yg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Yg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Gpt(e) {
  var t = Kpt(e, "string");
  return Yg(t) === "symbol" ? t : String(t);
}
function La(e, t, n) {
  return t = Gpt(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var iN = /* @__PURE__ */ He(null), Mc = () => {
  var e = ge(iN);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, MS, DS, Ide = parseInt(Oe.version.split(".")[0], 10), Bde = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, gJ = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Xi = typeof navigator < "u" && /Android/.test(navigator.userAgent), id = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), ip = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), Ypt = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), Nde = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), Jpt = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), Qpt = Xi && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), edt = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), tdt = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), ndt = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), c0 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((MS = navigator.userAgent.match(/Version\/(\d+)/)) !== null && MS !== void 0 && MS[1] && parseInt((DS = navigator.userAgent.match(/Version\/(\d+)/)) === null || DS === void 0 ? void 0 : DS[1], 10) < 17);
var Ou = (!Jpt || !Qpt) && !Ypt && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", gd = /* @__PURE__ */ new WeakMap(), sN = /* @__PURE__ */ new WeakMap(), aN = /* @__PURE__ */ new WeakMap(), Rde = /* @__PURE__ */ new WeakMap(), p0 = /* @__PURE__ */ new WeakMap(), V_ = /* @__PURE__ */ new WeakMap(), Jg = /* @__PURE__ */ new WeakMap(), Sp = /* @__PURE__ */ new WeakMap(), $1 = /* @__PURE__ */ new WeakMap(), LL = /* @__PURE__ */ new WeakMap(), $_ = /* @__PURE__ */ new WeakMap(), ec = /* @__PURE__ */ new WeakMap(), Lp = /* @__PURE__ */ new WeakMap(), Kh = /* @__PURE__ */ new WeakMap(), Z_ = /* @__PURE__ */ new WeakMap(), lN = /* @__PURE__ */ new WeakMap(), Ea = /* @__PURE__ */ new WeakMap(), Rl = /* @__PURE__ */ new WeakMap(), is = /* @__PURE__ */ new WeakMap(), Uu = /* @__PURE__ */ new WeakMap(), Wu = /* @__PURE__ */ new WeakMap(), Fde = /* @__PURE__ */ new WeakMap(), Pd = Symbol("placeholder"), zde = Symbol("mark-placeholder"), Ude = globalThis.Node, rdt = globalThis.Text, uN = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, odt = (e) => nc(e) && e.nodeType === 8, xa = (e) => nc(e) && e.nodeType === 1, nc = (e) => {
  var t = uN(e);
  return !!t && e instanceof t.Node;
}, q_ = (e) => {
  var t = e && e.anchorNode && uN(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Wde = (e) => nc(e) && e.nodeType === 3, idt = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, sdt = (e) => {
  var [t, n] = e;
  if (xa(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Hde(t, o, r ? "backward" : "forward"), r = o < n; xa(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = ldt(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, adt = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Hde = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (odt(o) || xa(o) && o.childNodes.length === 0 || xa(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, ldt = (e, t, n) => {
  var [r] = Hde(e, t, n);
  return r;
}, Vde = (e) => {
  var t = "";
  if (Wde(e) && e.nodeValue)
    return e.nodeValue;
  if (xa(e)) {
    for (var n of Array.from(e.childNodes))
      t += Vde(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, udt = /data-slate-fragment="(.+?)"/m, cdt = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(udt) || [];
  return n;
}, Gh = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), cN = (e, t, n) => {
  var {
    target: r
  } = t;
  if (xa(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Pe.getWindow(e);
  if (o.contains(r))
    return Pe.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : cN(e, i, n);
}, pdt = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, mJ = (e, t) => !!(e.compareDocumentPosition(t) & Ude.DOCUMENT_POSITION_PRECEDING), ddt = (e, t) => !!(e.compareDocumentPosition(t) & Ude.DOCUMENT_POSITION_FOLLOWING), fdt = 0;
class hdt {
  constructor() {
    La(this, "id", void 0), this.id = "".concat(fdt++);
  }
}
var Pe = {
  androidPendingDiffs: (e) => is.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = lN.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Pe.toDOMNode(e, e), n = Pe.findDocumentOrShadowRoot(e);
    ec.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Pe.findDocumentOrShadowRoot(e), r = Gh(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && $e.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Pe.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Pe.toSlateNode(e, t.target), a = Pe.findPath(e, i);
    if (yt.isElement(i) && ne.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = ne.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? ne.before(e, u) : ne.after(e, u);
      if (c) {
        var p = ne.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = Pe.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = Pe.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = $1.get(t);
    return n || (n = new hdt(), $1.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = aN.get(r);
      if (o == null) {
        if (ne.isEditor(r))
          return n;
        break;
      }
      var i = sN.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(bi.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!ec.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          Pe.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = Pe.toDOMNode(t, t), o = Pe.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = Gh(o), a = Pe.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(a);
        }
        t.selection || $e.select(t, ne.start(t, [])), ec.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Rde.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = Pe.toDOMNode(t, t), a;
    try {
      a = xa(n) ? n : n.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return a ? a.closest("[data-slate-editor]") === i && (!o || a.isContentEditable ? !0 : typeof a.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    a.closest('[contenteditable="false"]') === i || !!a.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => nc(t) && Pe.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return ne.hasPath(e, n.path) && ne.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Pe.hasEditableTarget(e, t) || Pe.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => nc(t) && Pe.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Lp.get(e),
  isFocused: (e) => !!ec.get(e),
  isReadOnly: (e) => !!$_.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if ($_.get(e)) return !1;
    var n = Pe.hasTarget(e, t) && Pe.toSlateNode(e, t);
    return yt.isElement(n) && ne.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = LL.get(e), r = ne.isEditor(t) ? p0.get(e) : n == null ? void 0 : n.get(Pe.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(bi.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = ne.node(e, t.path), r = Pe.toDOMNode(e, n), o;
    ne.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof rdt ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(bi.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Ce.isBackward(t), i = Pe.toDOMPoint(e, n), a = Ce.isCollapsed(t) ? i : Pe.toDOMPoint(e, r), s = Pe.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = xa(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = xa(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = xa(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Jg.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : sdt(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = Pe.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = Pe.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (Xi && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var R = U[k];
          if (Pe.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var N = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, H = [...N(V), ...N(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = H.find((M) => ddt(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var X, G = [...N(V == null ? void 0 : V.previousElementSibling), ...N(V)];
          w = (X = G.findLast((M) => mJ(L, M))) !== null && X !== void 0 ? X : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Xi && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      id && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Xi && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && Pe.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = Pe.toSlateNode(e, Y), {
          path: J,
          offset: P
        } = ne.start(e, Pe.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = Pe.toSlateNode(e, u), z = Pe.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = q_(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (q_(t)) {
        if (id && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Nde && adt(s) || id ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    id && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Pe.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = mJ(s, u) || s === u && c < l, x = p ? w : Pe.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Ce.isExpanded(m) && Ce.isForward(m) && xa(u) && ne.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = ne.unhangRange(e, m, {
      voids: !0
    })), m;
  }
};
function gdt(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!ne.hasPath(e, n))
    return !1;
  var o = it.get(e, n);
  if (!bt.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = ce.next(n);
  if (!ne.hasPath(e, i))
    return !1;
  var a = it.get(e, i);
  return bt.isText(a) && a.text.startsWith(r.text);
}
function $de(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function mdt(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function vdt(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function Zde(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), a = mdt(i, o), s = Math.min(i.length - a, o.length - a), l = vdt(i, o, s), u = {
    start: n + a,
    end: r - l,
    text: o.slice(a, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function ydt(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = $de(e, t, n), a = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), s = i.slice(r, a), l = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return Zde(e, {
    start: r,
    end: l,
    text: s
  });
}
function bdt(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function X_(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!ne.hasPath(e, n))
    return null;
  var o = it.get(e, n);
  if (!bt.isText(o))
    return null;
  var i = ne.above(e, {
    match: (s) => yt.isElement(s) && ne.isBlock(e, s),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var a = ne.next(e, {
      at: n,
      match: bt.isText
    });
    if (!a || !ce.isDescendant(a[1], i[1]))
      return null;
    r -= o.text.length, o = a[0], n = a[1];
  }
  return {
    path: n,
    offset: r
  };
}
function vJ(e, t) {
  var n = X_(e, t.anchor);
  if (!n)
    return null;
  if (Ce.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = X_(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function K_(e, t, n) {
  var r = is.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: p
    } = c;
    return ce.equals(p, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return Gt.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var a = {
      path: t.path,
      offset: i.start
    }, s = Gt.transform(a, n, {
      affinity: "backward"
    });
    return s ? {
      path: s.path,
      offset: s.offset + t.offset - i.start
    } : null;
  }
  var l = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, u = Gt.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && ce.equals(n.path, t.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function yJ(e, t, n) {
  var r = K_(e, t.anchor, n);
  if (!r)
    return null;
  if (Ce.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = K_(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function wdt(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !ce.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !ce.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !ce.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: ce.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: ce.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return ce.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: ce.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: ce.transform(n, t)
      };
  }
  var i = ce.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function bJ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bJ(Object(n), !0).forEach(function(r) {
      La(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bJ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Odt = 25, Cdt = 200, xdt = function() {
}, Ldt = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function Edt(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, a = null, s = null, l = 0, u = !1, c = () => {
    var V = Wu.get(t);
    if (Wu.delete(t), V) {
      var {
        selection: $
      } = t, H = vJ(t, V);
      H && (!$ || !Ce.equals(H, $)) && $e.select(t, H);
    }
  }, p = () => {
    var V = Uu.get(t);
    if (Uu.delete(t), !!V) {
      if (V.at) {
        var $ = Gt.isPoint(V.at) ? X_(t, V.at) : vJ(t, V.at);
        if (!$)
          return;
        var H = ne.range(t, $);
        (!t.selection || !Ce.equals(t.selection, H)) && $e.select(t, $);
      }
      V.run();
    }
  }, d = () => {
    if (a && (clearTimeout(a), a = null), s && (clearTimeout(s), s = null), !x() && !D()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), D() && (o = "action");
    var V = t.selection && ne.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    Rl.set(t, t.marks), xdt("flush", Uu.get(t), is.get(t));
    for (var $ = x(), H; H = (X = is.get(t)) === null || X === void 0 ? void 0 : X[0]; ) {
      var X, G, Y = Ea.get(t);
      Y !== void 0 && (Ea.delete(t), t.marks = Y), Y && u === !1 && (u = null);
      var Q = bdt(H);
      (!t.selection || !Ce.equals(t.selection, Q)) && $e.select(t, Q), H.diff.text ? ne.insertText(t, H.diff.text) : ne.deleteFragment(t), is.set(t, (G = is.get(t)) === null || G === void 0 ? void 0 : G.filter((_) => {
        var {
          id: z
        } = _;
        return z !== H.id;
      })), gdt(t, H) || ($ = !1, Uu.delete(t), Rl.delete(t), o = "action", Wu.delete(t), n.cancel(), r.cancel(), V == null || V.unref());
    }
    var J = V == null ? void 0 : V.unref();
    if (J && !Wu.get(t) && (!t.selection || !Ce.equals(J, t.selection)) && $e.select(t, J), D()) {
      p();
      return;
    }
    $ && n(), n.flush(), r.flush(), c();
    var P = Rl.get(t);
    Rl.delete(t), P !== void 0 && (t.marks = P, t.onChange());
  }, y = (V) => {
    i && clearTimeout(i), i = setTimeout(() => {
      Lp.set(t, !1), d();
    }, Odt);
  }, f = (V) => {
    Lp.set(t, !0), i && (clearTimeout(i), i = null);
  }, v = function() {
    var $ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, H = V_.get(t);
    if (H) {
      if (x() || $) {
        H.style.display = "none";
        return;
      }
      H.style.removeProperty("display");
    }
  }, b = (V, $) => {
    var H, X = (H = is.get(t)) !== null && H !== void 0 ? H : [];
    is.set(t, X);
    var G = it.leaf(t, V), Y = X.findIndex((P) => ce.equals(P.path, V));
    if (Y < 0) {
      var Q = Zde(G.text, $);
      Q && X.push({
        path: V,
        diff: $,
        id: l++
      }), v();
      return;
    }
    var J = ydt(G.text, X[Y].diff, $);
    if (!J) {
      X.splice(Y, 1), v();
      return;
    }
    X[Y] = Wb(Wb({}, X[Y]), {}, {
      diff: J
    });
  }, L = function($) {
    var {
      at: H
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, Wu.delete(t), n.cancel(), r.cancel(), D() && d(), Uu.set(t, {
      at: H,
      run: $
    }), s = setTimeout(d);
  }, w = (V) => {
    var $;
    if (a && (clearTimeout(a), a = null), !gd.get(t)) {
      var {
        inputType: H
      } = V, X = null, G = V.dataTransfer || V.data || void 0;
      u !== !1 && H !== "insertText" && H !== "insertCompositionText" && (u = !1);
      var [Y] = V.getTargetRanges();
      Y && (X = Pe.toSlateRange(t, Y, {
        exactMatch: !1,
        suppressThrow: !0
      }));
      var Q = Pe.getWindow(t), J = Q.getSelection();
      if (!X && J && (Y = J, X = Pe.toSlateRange(t, J, {
        exactMatch: !1,
        suppressThrow: !0
      })), X = ($ = X) !== null && $ !== void 0 ? $ : t.selection, !!X) {
        var P = !0;
        if (H.startsWith("delete")) {
          if (Ce.isExpanded(X)) {
            var [_, z] = Ce.edges(X), M = it.leaf(t, _.path);
            if (M.text.length === _.offset && z.offset === 0) {
              var W = ne.next(t, {
                at: _.path,
                match: bt.isText
              });
              W && ce.equals(W[1], z.path) && (X = {
                anchor: z,
                focus: z
              });
            }
          }
          var O = H.endsWith("Backward") ? "backward" : "forward", [I, F] = Ce.edges(X), [j, q] = ne.leaf(t, I.path), A = {
            text: "",
            start: I.offset,
            end: F.offset
          }, K = is.get(t), B = K == null ? void 0 : K.find((Ue) => ce.equals(Ue.path, q)), le = B ? [B.diff, A] : [A], he = $de(j.text, ...le);
          if (he.length === 0 && (P = !1), Ce.isExpanded(X)) {
            if (P && ce.equals(X.anchor.path, X.focus.path)) {
              var re = {
                path: X.anchor.path,
                offset: I.offset
              }, Se = ne.range(t, re, re);
              return S(Se), b(X.anchor.path, {
                text: "",
                end: F.offset,
                start: I.offset
              });
            }
            return L(() => ne.deleteFragment(t, {
              direction: O
            }), {
              at: X
            });
          }
        }
        switch (H) {
          case "deleteByComposition":
          case "deleteByCut":
          case "deleteByDrag":
            return L(() => ne.deleteFragment(t), {
              at: X
            });
          case "deleteContent":
          case "deleteContentForward": {
            var {
              anchor: We
            } = X;
            if (P && Ce.isCollapsed(X)) {
              var Ze = it.leaf(t, We.path);
              if (We.offset < Ze.text.length)
                return b(We.path, {
                  text: "",
                  start: We.offset,
                  end: We.offset + 1
                });
            }
            return L(() => ne.deleteForward(t), {
              at: X
            });
          }
          case "deleteContentBackward": {
            var Me, {
              anchor: rt
            } = X, Ve = q_(Y) ? Y.isCollapsed : !!((Me = Y) !== null && Me !== void 0 && Me.collapsed);
            return P && Ve && Ce.isCollapsed(X) && rt.offset > 0 ? b(rt.path, {
              text: "",
              start: rt.offset - 1,
              end: rt.offset
            }) : L(() => ne.deleteBackward(t), {
              at: X
            });
          }
          case "deleteEntireSoftLine":
            return L(() => {
              ne.deleteBackward(t, {
                unit: "line"
              }), ne.deleteForward(t, {
                unit: "line"
              });
            }, {
              at: X
            });
          case "deleteHardLineBackward":
            return L(() => ne.deleteBackward(t, {
              unit: "block"
            }), {
              at: X
            });
          case "deleteSoftLineBackward":
            return L(() => ne.deleteBackward(t, {
              unit: "line"
            }), {
              at: X
            });
          case "deleteHardLineForward":
            return L(() => ne.deleteForward(t, {
              unit: "block"
            }), {
              at: X
            });
          case "deleteSoftLineForward":
            return L(() => ne.deleteForward(t, {
              unit: "line"
            }), {
              at: X
            });
          case "deleteWordBackward":
            return L(() => ne.deleteBackward(t, {
              unit: "word"
            }), {
              at: X
            });
          case "deleteWordForward":
            return L(() => ne.deleteForward(t, {
              unit: "word"
            }), {
              at: X
            });
          case "insertLineBreak":
            return L(() => ne.insertSoftBreak(t), {
              at: X
            });
          case "insertParagraph":
            return L(() => ne.insertBreak(t), {
              at: X
            });
          case "insertCompositionText":
          case "deleteCompositionText":
          case "insertFromComposition":
          case "insertFromDrop":
          case "insertFromPaste":
          case "insertFromYank":
          case "insertReplacementText":
          case "insertText": {
            if (Ldt(G))
              return L(() => Pe.insertData(t, G), {
                at: X
              });
            var be = G ?? "";
            if (Ea.get(t) && (be = be.replace("\uFEFF", "")), H === "insertText" && /.*\n.*\n$/.test(be) && (be = be.slice(0, -1)), be.includes(`
`))
              return L(() => {
                var Ue = be.split(`
`);
                Ue.forEach((De, st) => {
                  De && ne.insertText(t, De), st !== Ue.length - 1 && ne.insertSoftBreak(t);
                });
              }, {
                at: X
              });
            if (ce.equals(X.anchor.path, X.focus.path)) {
              var [qe, ct] = Ce.edges(X), ye = {
                start: qe.offset,
                end: ct.offset,
                text: be
              };
              if (be && u && H === "insertCompositionText") {
                var xe = u.start + u.text.search(/\S|$/), Ee = ye.start + ye.text.search(/\S|$/);
                Ee === xe + 1 && ye.end === u.start + u.text.length ? (ye.start -= 1, u = null, R()) : u = !1;
              } else H === "insertText" ? u === null ? u = ye : u && Ce.isCollapsed(X) && u.end + u.text.length === qe.offset ? u = Wb(Wb({}, u), {}, {
                text: u.text + be
              }) : u = !1 : u = !1;
              if (P) {
                b(qe.path, ye);
                return;
              }
            }
            return L(() => ne.insertText(t, be), {
              at: X
            });
          }
        }
      }
    }
  }, D = () => !!Uu.get(t), x = () => {
    var V;
    return !!((V = is.get(t)) !== null && V !== void 0 && V.length);
  }, m = () => D() || x(), C = () => o, S = (V) => {
    Wu.set(t, V), a && (clearTimeout(a), a = null);
    var {
      selection: $
    } = t;
    if (V) {
      var H = !$ || !ce.equals($.anchor.path, V.anchor.path), X = !$ || !ce.equals($.anchor.path.slice(0, -1), V.anchor.path.slice(0, -1));
      (H && u || X) && (u = !1), (H || x()) && (a = setTimeout(d, Cdt));
    }
  }, U = () => {
    (D() || !x()) && d();
  }, k = (V) => {
    x() || (v(!0), setTimeout(v));
  }, R = () => {
    D() || (s = setTimeout(d));
  }, N = (V) => {
    if (!(x() || D()) && V.some((H) => cN(t, H, V))) {
      var $;
      ($ = Fde.get(t)) === null || $ === void 0 || $();
    }
  };
  return {
    flush: d,
    scheduleFlush: R,
    hasPendingDiffs: x,
    hasPendingAction: D,
    hasPendingChanges: m,
    isFlushing: C,
    handleUserSelect: S,
    handleCompositionEnd: y,
    handleCompositionStart: f,
    handleDOMBeforeInput: w,
    handleKeyDown: k,
    handleDomMutations: N,
    handleInput: U
  };
}
function kdt() {
  var e = vt(!1);
  return h(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var Qg = c0 ? ehe : h;
function Pdt(e, t, n) {
  var [r] = E(() => new MutationObserver(t));
  Qg(() => {
    r.takeRecords();
  }), h(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var Sdt = ["node"];
function wJ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mdt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wJ(Object(n), !0).forEach(function(r) {
      La(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wJ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ddt = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, _dt = Xi ? (e) => {
  var {
    node: t
  } = e, n = kd(e, Sdt);
  if (!Xi)
    return null;
  var r = Mc(), o = kdt(), [i] = E(() => Edt(Mdt({
    editor: r
  }, n)));
  return Pdt(t, i.handleDomMutations, Ddt), lN.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, Tdt = ["anchor", "focus"], jdt = ["anchor", "focus"], Adt = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), qde = (e, t) => {
  var n = kd(e, Tdt), r = kd(t, jdt);
  return e[Pd] === t[Pd] && Adt(n, r);
}, Idt = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!Ce.equals(r, o) || !qde(r, o))
      return !1;
  }
  return !0;
}, Bdt = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !qde(r, o))
      return !1;
  }
  return !0;
};
function OJ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ndt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OJ(Object(n), !0).forEach(function(r) {
      La(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OJ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Rdt = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = Mc(), a = Pe.findPath(i, o), s = ce.parent(a), l = !!n[zde];
  return i.isVoid(r) ? /* @__PURE__ */ Oe.createElement(_S, {
    length: it.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && ne.string(i, s) === "" ? /* @__PURE__ */ Oe.createElement(_S, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ Oe.createElement(_S, {
    isMarkPlaceholder: l
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ Oe.createElement(CJ, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ Oe.createElement(CJ, {
    text: n.text
  });
}, CJ = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = vt(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = E(o);
  return Qg(() => {
    var a = o();
    r.current && r.current.textContent !== a && (r.current.textContent = a);
  }), /* @__PURE__ */ Oe.createElement(Fdt, {
    ref: r
  }, i);
}, Fdt = /* @__PURE__ */ me(/* @__PURE__ */ ka((e, t) => /* @__PURE__ */ Oe.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), _S = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ Oe.createElement("span", Ndt({}, o), !(Xi || Bde) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ Oe.createElement("br", null) : null);
};
function xJ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xde(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xJ(Object(n), !0).forEach(function(r) {
      La(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xJ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zdt = Xi ? 300 : 0;
function Udt(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function LJ(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var Wdt = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: a = (w) => /* @__PURE__ */ Oe.createElement(Vdt, Xde({}, w))
  } = e, s = Mc(), l = vt(null), u = vt(null), [c, p] = E(!1), d = vt(null), y = ur((w) => {
    if (Udt(l, w == null), w == null) {
      var D;
      V_.delete(s), (D = t.onPlaceholderResize) === null || D === void 0 || D.call(t, null);
    } else {
      if (V_.set(s, w), !l.current) {
        var x = window.ResizeObserver || qpt;
        l.current = new x(() => {
          var m;
          (m = t.onPlaceholderResize) === null || m === void 0 || m.call(t, w);
        });
      }
      l.current.observe(w), u.current = w;
    }
  }, [u, t, s]), f = /* @__PURE__ */ Oe.createElement(Rdt, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), v = !!t[Pd];
  if (h(() => (v ? d.current || (d.current = setTimeout(() => {
    p(!0), d.current = null;
  }, zdt)) : (LJ(d), p(!1)), () => LJ(d)), [v, p]), v && c) {
    var b = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: ip ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: y
      }
    };
    f = /* @__PURE__ */ Oe.createElement(Oe.Fragment, null, i(b), f);
  }
  var L = {
    "data-slate-leaf": !0
  };
  return a({
    attributes: L,
    children: f,
    leaf: t,
    text: r
  });
}, Hdt = /* @__PURE__ */ Oe.memo(Wdt, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && bt.equals(t.leaf, e.leaf) && t.leaf[Pd] === e.leaf[Pd]), Vdt = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ Oe.createElement("span", Xde({}, t), n);
}, $dt = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: a
  } = e, s = Mc(), l = vt(null), u = bt.decorations(a, t), c = Pe.findKey(s, a), p = [], d = 0; d < u.length; d++) {
    var y = u[d];
    p.push(/* @__PURE__ */ Oe.createElement(Hdt, {
      isLast: n && d === u.length - 1,
      key: "".concat(c.id, "-").concat(d),
      renderPlaceholder: o,
      leaf: y,
      text: a,
      parent: r,
      renderLeaf: i
    }));
  }
  var f = ur((v) => {
    var b = LL.get(s);
    v ? (b == null || b.set(c, v), Sp.set(a, v), Jg.set(v, a)) : (b == null || b.delete(c), Sp.delete(a), l.current && Jg.delete(l.current)), l.current = v;
  }, [l, s, c, a]);
  return /* @__PURE__ */ Oe.createElement("span", {
    "data-slate-node": "text",
    ref: f
  }, p);
}, Kde = /* @__PURE__ */ Oe.memo($dt, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && Bdt(t.decorations, e.decorations));
function EJ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function G_(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EJ(Object(n), !0).forEach(function(r) {
      La(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EJ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Zdt = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (w) => /* @__PURE__ */ Oe.createElement(Xdt, G_({}, w)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = Mc(), l = Ydt(), u = s.isInline(n), c = Pe.findKey(s, n), p = ur((w) => {
    var D = LL.get(s);
    w ? (D == null || D.set(c, w), Sp.set(n, w), Jg.set(w, n)) : (D == null || D.delete(c), Sp.delete(n));
  }, [s, c, n]), d = Yde({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  }), y = {
    "data-slate-node": "element",
    ref: p
  };
  if (u && (y["data-slate-inline"] = !0), !u && ne.hasInlines(s, n)) {
    var f = it.string(n), v = Lde(f);
    v === "rtl" && (y.dir = v);
  }
  if (ne.isVoid(s, n)) {
    y["data-slate-void"] = !0, !l && u && (y.contentEditable = !1);
    var b = u ? "span" : "div", [[L]] = it.texts(n);
    d = /* @__PURE__ */ Oe.createElement(b, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ Oe.createElement(Kde, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: L
    })), sN.set(L, 0), aN.set(L, n);
  }
  return r({
    attributes: y,
    children: d,
    element: n
  });
}, qdt = /* @__PURE__ */ Oe.memo(Zdt, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && Idt(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && Ce.equals(e.selection, t.selection))), Xdt = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = Mc(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ Oe.createElement(i, G_(G_({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, Gde = /* @__PURE__ */ He(() => []), Kdt = () => ge(Gde), Gdt = /* @__PURE__ */ He(!1), Yde = (e) => {
  var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = Kdt(), l = Mc();
  gd.set(l, !1);
  for (var u = Pe.findPath(l, n), c = [], p = yt.isElement(n) && !l.isInline(n) && ne.hasInlines(l, n), d = 0; d < n.children.length; d++) {
    var y = u.concat(d), f = n.children[d], v = Pe.findKey(l, f), b = ne.range(l, y), L = a && Ce.intersection(b, a), w = s([f, y]);
    for (var D of t) {
      var x = Ce.intersection(D, b);
      x && w.push(x);
    }
    yt.isElement(f) ? c.push(/* @__PURE__ */ Oe.createElement(Gdt.Provider, {
      key: "provider-".concat(v.id),
      value: !!L
    }, /* @__PURE__ */ Oe.createElement(qdt, {
      decorations: w,
      element: f,
      key: v.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: L
    }))) : c.push(/* @__PURE__ */ Oe.createElement(Kde, {
      decorations: w,
      key: v.id,
      isLast: p && d === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: f
    })), sN.set(f, d), aN.set(f, n);
  }
  return c;
}, Jde = /* @__PURE__ */ He(!1), Ydt = () => ge(Jde), Qde = /* @__PURE__ */ He(null), EL = () => {
  var e = ge(Qde);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function Jdt() {
  var e = Mc(), t = vt(!1), n = vt(0), r = ur(() => {
    if (!t.current) {
      t.current = !0;
      var o = Pe.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return h(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var Qdt = 3, eft = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, tft = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, nft = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, ko = (e) => {
  var t = eft[e], n = tft[e], r = nft[e], o = t && xS(t), i = n && xS(n), a = r && xS(r);
  return (s) => !!(o && o(s) || gJ && i && i(s) || !gJ && a && a(s));
}, So = {
  isBold: ko("bold"),
  isCompose: ko("compose"),
  isMoveBackward: ko("moveBackward"),
  isMoveForward: ko("moveForward"),
  isDeleteBackward: ko("deleteBackward"),
  isDeleteForward: ko("deleteForward"),
  isDeleteLineBackward: ko("deleteLineBackward"),
  isDeleteLineForward: ko("deleteLineForward"),
  isDeleteWordBackward: ko("deleteWordBackward"),
  isDeleteWordForward: ko("deleteWordForward"),
  isExtendBackward: ko("extendBackward"),
  isExtendForward: ko("extendForward"),
  isExtendLineBackward: ko("extendLineBackward"),
  isExtendLineForward: ko("extendLineForward"),
  isItalic: ko("italic"),
  isMoveLineBackward: ko("moveLineBackward"),
  isMoveLineForward: ko("moveLineForward"),
  isMoveWordBackward: ko("moveWordBackward"),
  isMoveWordForward: ko("moveWordForward"),
  isRedo: ko("redo"),
  isSoftBreak: ko("insertSoftBreak"),
  isSplitBlock: ko("splitBlock"),
  isTransposeCharacter: ko("transposeCharacter"),
  isUndo: ko("undo")
}, rft = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => cN(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, oft = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class efe extends Kl {
  constructor() {
    super(...arguments), La(this, "context", null), La(this, "manager", null), La(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, oft);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = rft(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
La(efe, "contextType", iN);
var ift = Xi ? efe : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ Oe.createElement(Oe.Fragment, null, t);
}, sft = /* @__PURE__ */ He(!1), aft = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], lft = ["text"];
function kJ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Na(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kJ(Object(n), !0).forEach(function(r) {
      La(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kJ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var uft = (e) => /* @__PURE__ */ Oe.createElement(Oe.Fragment, null, Yde(e)), cft = /* @__PURE__ */ ka((e, t) => {
  var n = ur((I) => /* @__PURE__ */ Oe.createElement(pft, Na({}, I)), []), {
    autoFocus: r,
    decorate: o = dft,
    onDOMBeforeInput: i,
    placeholder: a,
    readOnly: s = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: p = fft,
    style: d = {},
    as: y = "div",
    disableDefaultStyles: f = !1
  } = e, v = kd(e, aft), b = EL(), [L, w] = E(!1), D = vt(null), x = vt([]), [m, C] = E(), S = vt(!1), {
    onUserInput: U,
    receivedUserInput: k
  } = Jdt(), [, R] = Qfe((I) => I + 1, 0);
  Fde.set(b, R), $_.set(b, s);
  var N = zt(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  h(() => {
    D.current && r && D.current.focus();
  }, [r]);
  var V = vt(), $ = zt(() => xpt(() => {
    if (gd.get(b)) {
      $();
      return;
    }
    var I = Pe.toDOMNode(b, b), F = I.getRootNode();
    if (!S.current && ip && F instanceof ShadowRoot) {
      S.current = !0;
      var j = pdt();
      j ? document.execCommand("indent") : $e.deselect(b), S.current = !1;
      return;
    }
    var q = V.current;
    if ((Xi || !Pe.isComposing(b)) && (!N.isUpdatingSelection || q != null && q.isFlushing()) && !N.isDraggingInternally) {
      var A = Pe.findDocumentOrShadowRoot(b), {
        activeElement: K
      } = A, B = Pe.toDOMNode(b, b), le = Gh(A);
      if (K === B ? (N.latestElement = K, ec.set(b, !0)) : ec.delete(b), !le)
        return $e.deselect(b);
      var {
        anchorNode: he,
        focusNode: re
      } = le, Se = Pe.hasEditableTarget(b, he) || Pe.isTargetInsideNonReadonlyVoid(b, he), We = Pe.hasTarget(b, re);
      if (Se && We) {
        var Ze = Pe.toSlateRange(b, le, {
          exactMatch: !1,
          suppressThrow: !0
        });
        Ze && (!Pe.isComposing(b) && !(q != null && q.hasPendingChanges()) && !(q != null && q.isFlushing()) ? $e.select(b, Ze) : q == null || q.handleUserSelect(Ze));
      }
      s && (!Se || !We) && $e.deselect(b);
    }
  }, 100), [b, s, N]), H = zt(() => vpt($, 0), [$]);
  V.current = _dt({
    node: D,
    onDOMSelectionChange: $,
    scheduleOnDOMSelectionChange: H
  }), Qg(() => {
    var I, F, j;
    D.current && (j = uN(D.current)) ? (Rde.set(b, j), p0.set(b, D.current), Sp.set(b, D.current), Jg.set(D.current, b)) : Sp.delete(b);
    var {
      selection: q
    } = b, A = Pe.findDocumentOrShadowRoot(b), K = Gh(A);
    if (!(!K || !Pe.isFocused(b) || (I = V.current) !== null && I !== void 0 && I.hasPendingAction())) {
      var B = (Se) => {
        var We = K.type !== "None";
        if (!(!q && !We)) {
          var Ze = K.focusNode, Me;
          if (id && K.rangeCount > 1) {
            var rt = K.getRangeAt(0), Ve = K.getRangeAt(K.rangeCount - 1);
            rt.startContainer === Ze ? Me = Ve.endContainer : Me = rt.startContainer;
          } else
            Me = K.anchorNode;
          var be = p0.get(b), qe = !1;
          if (be.contains(Me) && be.contains(Ze) && (qe = !0), We && qe && q && !Se) {
            var ct = Pe.toSlateRange(b, K, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (ct && Ce.equals(ct, q)) {
              var ye;
              if (!N.hasMarkPlaceholder || (ye = Me) !== null && ye !== void 0 && (ye = ye.parentElement) !== null && ye !== void 0 && ye.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (q && !Pe.hasRange(b, q)) {
            b.selection = Pe.toSlateRange(b, K, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          N.isUpdatingSelection = !0;
          var xe = q && Pe.toDOMRange(b, q);
          return xe ? (Pe.isComposing(b) && !Xi ? K.collapseToEnd() : Ce.isBackward(q) ? K.setBaseAndExtent(xe.endContainer, xe.endOffset, xe.startContainer, xe.startOffset) : K.setBaseAndExtent(xe.startContainer, xe.startOffset, xe.endContainer, xe.endOffset), p(b, xe)) : K.removeAllRanges(), xe;
        }
      };
      K.rangeCount <= 1 && B();
      var le = ((F = V.current) === null || F === void 0 ? void 0 : F.isFlushing()) === "action";
      if (!Xi || !le) {
        setTimeout(() => {
          N.isUpdatingSelection = !1;
        });
        return;
      }
      var he = null, re = requestAnimationFrame(() => {
        if (le) {
          var Se = (We) => {
            try {
              var Ze = Pe.toDOMNode(b, b);
              Ze.focus(), B(We);
            } catch {
            }
          };
          Se(), he = setTimeout(() => {
            Se(!0), N.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(re), he && clearTimeout(he);
      };
    }
  });
  var X = ur((I) => {
    var F = Pe.toDOMNode(b, b), j = F.getRootNode();
    if (S != null && S.current && ip && j instanceof ShadowRoot) {
      var q = I.getTargetRanges(), A = q[0], K = new window.Range();
      K.setStart(A.startContainer, A.startOffset), K.setEnd(A.endContainer, A.endOffset);
      var B = Pe.toSlateRange(b, K, {
        exactMatch: !1,
        suppressThrow: !1
      });
      $e.select(b, B), I.preventDefault(), I.stopImmediatePropagation();
      return;
    }
    if (U(), !s && Pe.hasEditableTarget(b, I.target) && !hft(I, i)) {
      var le;
      if (V.current)
        return V.current.handleDOMBeforeInput(I);
      H.flush(), $.flush();
      var {
        selection: he
      } = b, {
        inputType: re
      } = I, Se = I.dataTransfer || I.data || void 0, We = re === "insertCompositionText" || re === "deleteCompositionText";
      if (We && Pe.isComposing(b))
        return;
      var Ze = !1;
      if (re === "insertText" && he && Ce.isCollapsed(he) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      I.data && I.data.length === 1 && /[a-z ]/i.test(I.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      he.anchor.offset !== 0 && (Ze = !0, b.marks && (Ze = !1), !gd.get(b))) {
        var Me, rt, {
          anchor: Ve
        } = he, [be, qe] = Pe.toDOMPoint(b, Ve), ct = (Me = be.parentElement) === null || Me === void 0 ? void 0 : Me.closest("a"), ye = Pe.getWindow(b);
        if (Ze && ct && Pe.hasDOMNode(b, ct)) {
          var xe, Ee = ye == null ? void 0 : ye.document.createTreeWalker(ct, NodeFilter.SHOW_TEXT).lastChild();
          Ee === be && ((xe = Ee.textContent) === null || xe === void 0 ? void 0 : xe.length) === qe && (Ze = !1);
        }
        if (Ze && be.parentElement && (ye == null || (rt = ye.getComputedStyle(be.parentElement)) === null || rt === void 0 ? void 0 : rt.whiteSpace) === "pre") {
          var Ue = ne.above(b, {
            at: Ve.path,
            match: (lt) => yt.isElement(lt) && ne.isBlock(b, lt)
          });
          Ue && it.string(Ue[0]).includes("	") && (Ze = !1);
        }
      }
      if ((!re.startsWith("delete") || re.startsWith("deleteBy")) && !gd.get(b)) {
        var [De] = I.getTargetRanges();
        if (De) {
          var st = Pe.toSlateRange(b, De, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!he || !Ce.equals(he, st)) {
            Ze = !1;
            var ve = !We && b.selection && ne.rangeRef(b, b.selection);
            $e.select(b, st), ve && Kh.set(b, ve);
          }
        }
      }
      if (We)
        return;
      if (Ze || I.preventDefault(), he && Ce.isExpanded(he) && re.startsWith("delete")) {
        var wt = re.endsWith("Backward") ? "backward" : "forward";
        ne.deleteFragment(b, {
          direction: wt
        });
        return;
      }
      switch (re) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          ne.deleteFragment(b);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          ne.deleteForward(b);
          break;
        }
        case "deleteContentBackward": {
          ne.deleteBackward(b);
          break;
        }
        case "deleteEntireSoftLine": {
          ne.deleteBackward(b, {
            unit: "line"
          }), ne.deleteForward(b, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          ne.deleteBackward(b, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          ne.deleteBackward(b, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          ne.deleteForward(b, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          ne.deleteForward(b, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          ne.deleteBackward(b, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          ne.deleteForward(b, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          ne.insertSoftBreak(b);
          break;
        case "insertParagraph": {
          ne.insertBreak(b);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          re === "insertFromComposition" && Pe.isComposing(b) && (w(!1), Lp.set(b, !1)), (Se == null ? void 0 : Se.constructor.name) === "DataTransfer" ? Pe.insertData(b, Se) : typeof Se == "string" && (Ze ? x.current.push(() => ne.insertText(b, Se)) : ne.insertText(b, Se));
          break;
        }
      }
      var at = (le = Kh.get(b)) === null || le === void 0 ? void 0 : le.unref();
      Kh.delete(b), at && (!b.selection || !Ce.equals(b.selection, at)) && $e.select(b, at);
    }
  }, [b, $, U, i, s, H]), G = ur((I) => {
    I == null ? ($.cancel(), H.cancel(), p0.delete(b), Sp.delete(b), D.current && Ou && D.current.removeEventListener("beforeinput", X)) : Ou && I.addEventListener("beforeinput", X), D.current = I, typeof t == "function" ? t(I) : t && (t.current = I);
  }, [$, H, b, X, t]);
  Qg(() => {
    var I = Pe.getWindow(b);
    I.document.addEventListener("selectionchange", H);
    var F = () => {
      N.isDraggingInternally = !1;
    };
    return I.document.addEventListener("dragend", F), I.document.addEventListener("drop", F), () => {
      I.document.removeEventListener("selectionchange", H), I.document.removeEventListener("dragend", F), I.document.removeEventListener("drop", F);
    };
  }, [H, N]);
  var Y = o([b, []]), Q = a && b.children.length === 1 && Array.from(it.texts(b)).length === 1 && it.string(b) === "" && !L, J = ur((I) => {
    if (I && Q) {
      var F;
      C((F = I.getBoundingClientRect()) === null || F === void 0 ? void 0 : F.height);
    } else
      C(void 0);
  }, [Q]);
  if (Q) {
    var P = ne.start(b, []);
    Y.push({
      [Pd]: !0,
      placeholder: a,
      onPlaceholderResize: J,
      anchor: P,
      focus: P
    });
  }
  var {
    marks: _
  } = b;
  if (N.hasMarkPlaceholder = !1, b.selection && Ce.isCollapsed(b.selection) && _) {
    var {
      anchor: z
    } = b.selection, M = it.leaf(b, z.path), W = kd(M, lft);
    if (!bt.equals(M, _, {
      loose: !0
    })) {
      N.hasMarkPlaceholder = !0;
      var O = Object.fromEntries(Object.keys(W).map((I) => [I, null]));
      Y.push(Na(Na(Na({
        [zde]: !0
      }, O), _), {}, {
        anchor: z,
        focus: z
      }));
    }
  }
  return h(() => {
    setTimeout(() => {
      var {
        selection: I
      } = b;
      if (I) {
        var {
          anchor: F
        } = I, j = it.leaf(b, F.path);
        if (_ && !bt.equals(j, _, {
          loose: !0
        })) {
          Ea.set(b, _);
          return;
        }
      }
      Ea.delete(b);
    });
  }), /* @__PURE__ */ Oe.createElement(Jde.Provider, {
    value: s
  }, /* @__PURE__ */ Oe.createElement(sft.Provider, {
    value: L
  }, /* @__PURE__ */ Oe.createElement(Gde.Provider, {
    value: o
  }, /* @__PURE__ */ Oe.createElement(ift, {
    node: D,
    receivedUserInput: k
  }, /* @__PURE__ */ Oe.createElement(y, Na(Na({
    role: s ? void 0 : "textbox",
    "aria-multiline": s ? void 0 : !0
  }, v), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: Ou || !c0 ? v.spellCheck : !1,
    autoCorrect: Ou || !c0 ? v.autoCorrect : "false",
    autoCapitalize: Ou || !c0 ? v.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !s,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: G,
    style: Na(Na({}, f ? {} : Na({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, m ? {
      minHeight: m
    } : {})), d),
    onBeforeInput: ur((I) => {
      if (!Ou && !s && !qi(I, v.onBeforeInput) && Pe.hasSelectableTarget(b, I.target) && (I.preventDefault(), !Pe.isComposing(b))) {
        var F = I.data;
        ne.insertText(b, F);
      }
    }, [v.onBeforeInput, b, s]),
    onInput: ur((I) => {
      if (!qi(I, v.onInput)) {
        if (V.current) {
          V.current.handleInput();
          return;
        }
        for (var F of x.current)
          F();
        if (x.current = [], !Pe.isFocused(b)) {
          var j = I.nativeEvent, q = b;
          if (j.inputType === "historyUndo" && typeof q.undo == "function") {
            q.undo();
            return;
          }
          if (j.inputType === "historyRedo" && typeof q.redo == "function") {
            q.redo();
            return;
          }
        }
      }
    }, [v.onInput, b]),
    onBlur: ur((I) => {
      if (!(s || N.isUpdatingSelection || !Pe.hasSelectableTarget(b, I.target) || qi(I, v.onBlur))) {
        var F = Pe.findDocumentOrShadowRoot(b);
        if (N.latestElement !== F.activeElement) {
          var {
            relatedTarget: j
          } = I, q = Pe.toDOMNode(b, b);
          if (j !== q && !(xa(j) && j.hasAttribute("data-slate-spacer"))) {
            if (j != null && nc(j) && Pe.hasDOMNode(b, j)) {
              var A = Pe.toSlateNode(b, j);
              if (yt.isElement(A) && !b.isVoid(A))
                return;
            }
            if (ip) {
              var K = Gh(F);
              K == null || K.removeAllRanges();
            }
            ec.delete(b);
          }
        }
      }
    }, [s, N.isUpdatingSelection, N.latestElement, b, v.onBlur]),
    onClick: ur((I) => {
      if (Pe.hasTarget(b, I.target) && !qi(I, v.onClick) && nc(I.target)) {
        var F = Pe.toSlateNode(b, I.target), j = Pe.findPath(b, F);
        if (!ne.hasPath(b, j) || it.get(b, j) !== F)
          return;
        if (I.detail === Qdt && j.length >= 1) {
          var q = j;
          if (!(yt.isElement(F) && ne.isBlock(b, F))) {
            var A, K = ne.above(b, {
              match: (Ze) => yt.isElement(Ze) && ne.isBlock(b, Ze),
              at: j
            });
            q = (A = K == null ? void 0 : K[1]) !== null && A !== void 0 ? A : j.slice(0, 1);
          }
          var B = ne.range(b, q);
          $e.select(b, B);
          return;
        }
        if (s)
          return;
        var le = ne.start(b, j), he = ne.end(b, j), re = ne.void(b, {
          at: le
        }), Se = ne.void(b, {
          at: he
        });
        if (re && Se && ce.equals(re[1], Se[1])) {
          var We = ne.range(b, le);
          $e.select(b, We);
        }
      }
    }, [b, v.onClick, s]),
    onCompositionEnd: ur((I) => {
      if (Pe.hasSelectableTarget(b, I.target)) {
        var F;
        if (Pe.isComposing(b) && Promise.resolve().then(() => {
          w(!1), Lp.set(b, !1);
        }), (F = V.current) === null || F === void 0 || F.handleCompositionEnd(I), qi(I, v.onCompositionEnd) || Xi)
          return;
        if (!ip && !edt && !Bde && !ndt && !tdt && I.data) {
          var j = Ea.get(b);
          Ea.delete(b), j !== void 0 && (Rl.set(b, b.marks), b.marks = j), ne.insertText(b, I.data);
          var q = Rl.get(b);
          Rl.delete(b), q !== void 0 && (b.marks = q);
        }
      }
    }, [v.onCompositionEnd, b]),
    onCompositionUpdate: ur((I) => {
      Pe.hasSelectableTarget(b, I.target) && !qi(I, v.onCompositionUpdate) && (Pe.isComposing(b) || (w(!0), Lp.set(b, !0)));
    }, [v.onCompositionUpdate, b]),
    onCompositionStart: ur((I) => {
      if (Pe.hasSelectableTarget(b, I.target)) {
        var F;
        if ((F = V.current) === null || F === void 0 || F.handleCompositionStart(I), qi(I, v.onCompositionStart) || Xi)
          return;
        w(!0);
        var {
          selection: j
        } = b;
        if (j && Ce.isExpanded(j)) {
          ne.deleteFragment(b);
          return;
        }
      }
    }, [v.onCompositionStart, b]),
    onCopy: ur((I) => {
      Pe.hasSelectableTarget(b, I.target) && !qi(I, v.onCopy) && !PJ(I) && (I.preventDefault(), Pe.setFragmentData(b, I.clipboardData, "copy"));
    }, [v.onCopy, b]),
    onCut: ur((I) => {
      if (!s && Pe.hasSelectableTarget(b, I.target) && !qi(I, v.onCut) && !PJ(I)) {
        I.preventDefault(), Pe.setFragmentData(b, I.clipboardData, "cut");
        var {
          selection: F
        } = b;
        if (F)
          if (Ce.isExpanded(F))
            ne.deleteFragment(b);
          else {
            var j = it.parent(b, F.anchor.path);
            ne.isVoid(b, j) && $e.delete(b);
          }
      }
    }, [s, b, v.onCut]),
    onDragOver: ur((I) => {
      if (Pe.hasTarget(b, I.target) && !qi(I, v.onDragOver)) {
        var F = Pe.toSlateNode(b, I.target);
        yt.isElement(F) && ne.isVoid(b, F) && I.preventDefault();
      }
    }, [v.onDragOver, b]),
    onDragStart: ur((I) => {
      if (!s && Pe.hasTarget(b, I.target) && !qi(I, v.onDragStart)) {
        var F = Pe.toSlateNode(b, I.target), j = Pe.findPath(b, F), q = yt.isElement(F) && ne.isVoid(b, F) || ne.void(b, {
          at: j,
          voids: !0
        });
        if (q) {
          var A = ne.range(b, j);
          $e.select(b, A);
        }
        N.isDraggingInternally = !0, Pe.setFragmentData(b, I.dataTransfer, "drag");
      }
    }, [s, b, v.onDragStart, N]),
    onDrop: ur((I) => {
      if (!s && Pe.hasTarget(b, I.target) && !qi(I, v.onDrop)) {
        I.preventDefault();
        var F = b.selection, j = Pe.findEventRange(b, I), q = I.dataTransfer;
        $e.select(b, j), N.isDraggingInternally && F && !Ce.equals(F, j) && !ne.void(b, {
          at: j,
          voids: !0
        }) && $e.delete(b, {
          at: F
        }), Pe.insertData(b, q), Pe.isFocused(b) || Pe.focus(b);
      }
    }, [s, b, v.onDrop, N]),
    onDragEnd: ur((I) => {
      !s && N.isDraggingInternally && v.onDragEnd && Pe.hasTarget(b, I.target) && v.onDragEnd(I);
    }, [s, N, v, b]),
    onFocus: ur((I) => {
      if (!s && !N.isUpdatingSelection && Pe.hasEditableTarget(b, I.target) && !qi(I, v.onFocus)) {
        var F = Pe.toDOMNode(b, b), j = Pe.findDocumentOrShadowRoot(b);
        if (N.latestElement = j.activeElement, id && I.target !== F) {
          F.focus();
          return;
        }
        ec.set(b, !0);
      }
    }, [s, N, b, v.onFocus]),
    onKeyDown: ur((I) => {
      if (!s && Pe.hasEditableTarget(b, I.target)) {
        var F;
        (F = V.current) === null || F === void 0 || F.handleKeyDown(I);
        var {
          nativeEvent: j
        } = I;
        if (Pe.isComposing(b) && j.isComposing === !1 && (Lp.set(b, !1), w(!1)), qi(I, v.onKeyDown) || Pe.isComposing(b))
          return;
        var {
          selection: q
        } = b, A = b.children[q !== null ? q.focus.path[0] : 0], K = Lde(it.string(A)) === "rtl";
        if (So.isRedo(j)) {
          I.preventDefault();
          var B = b;
          typeof B.redo == "function" && B.redo();
          return;
        }
        if (So.isUndo(j)) {
          I.preventDefault();
          var le = b;
          typeof le.undo == "function" && le.undo();
          return;
        }
        if (So.isMoveLineBackward(j)) {
          I.preventDefault(), $e.move(b, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (So.isMoveLineForward(j)) {
          I.preventDefault(), $e.move(b, {
            unit: "line"
          });
          return;
        }
        if (So.isExtendLineBackward(j)) {
          I.preventDefault(), $e.move(b, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (So.isExtendLineForward(j)) {
          I.preventDefault(), $e.move(b, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (So.isMoveBackward(j)) {
          I.preventDefault(), q && Ce.isCollapsed(q) ? $e.move(b, {
            reverse: !K
          }) : $e.collapse(b, {
            edge: K ? "end" : "start"
          });
          return;
        }
        if (So.isMoveForward(j)) {
          I.preventDefault(), q && Ce.isCollapsed(q) ? $e.move(b, {
            reverse: K
          }) : $e.collapse(b, {
            edge: K ? "start" : "end"
          });
          return;
        }
        if (So.isMoveWordBackward(j)) {
          I.preventDefault(), q && Ce.isExpanded(q) && $e.collapse(b, {
            edge: "focus"
          }), $e.move(b, {
            unit: "word",
            reverse: !K
          });
          return;
        }
        if (So.isMoveWordForward(j)) {
          I.preventDefault(), q && Ce.isExpanded(q) && $e.collapse(b, {
            edge: "focus"
          }), $e.move(b, {
            unit: "word",
            reverse: K
          });
          return;
        }
        if (Ou) {
          if ((Nde || ip) && q && (So.isDeleteBackward(j) || So.isDeleteForward(j)) && Ce.isCollapsed(q)) {
            var he = it.parent(b, q.anchor.path);
            if (yt.isElement(he) && ne.isVoid(b, he) && (ne.isInline(b, he) || ne.isBlock(b, he))) {
              I.preventDefault(), ne.deleteBackward(b, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (So.isBold(j) || So.isItalic(j) || So.isTransposeCharacter(j)) {
            I.preventDefault();
            return;
          }
          if (So.isSoftBreak(j)) {
            I.preventDefault(), ne.insertSoftBreak(b);
            return;
          }
          if (So.isSplitBlock(j)) {
            I.preventDefault(), ne.insertBreak(b);
            return;
          }
          if (So.isDeleteBackward(j)) {
            I.preventDefault(), q && Ce.isExpanded(q) ? ne.deleteFragment(b, {
              direction: "backward"
            }) : ne.deleteBackward(b);
            return;
          }
          if (So.isDeleteForward(j)) {
            I.preventDefault(), q && Ce.isExpanded(q) ? ne.deleteFragment(b, {
              direction: "forward"
            }) : ne.deleteForward(b);
            return;
          }
          if (So.isDeleteLineBackward(j)) {
            I.preventDefault(), q && Ce.isExpanded(q) ? ne.deleteFragment(b, {
              direction: "backward"
            }) : ne.deleteBackward(b, {
              unit: "line"
            });
            return;
          }
          if (So.isDeleteLineForward(j)) {
            I.preventDefault(), q && Ce.isExpanded(q) ? ne.deleteFragment(b, {
              direction: "forward"
            }) : ne.deleteForward(b, {
              unit: "line"
            });
            return;
          }
          if (So.isDeleteWordBackward(j)) {
            I.preventDefault(), q && Ce.isExpanded(q) ? ne.deleteFragment(b, {
              direction: "backward"
            }) : ne.deleteBackward(b, {
              unit: "word"
            });
            return;
          }
          if (So.isDeleteWordForward(j)) {
            I.preventDefault(), q && Ce.isExpanded(q) ? ne.deleteFragment(b, {
              direction: "forward"
            }) : ne.deleteForward(b, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [s, b, v.onKeyDown]),
    onPaste: ur((I) => {
      !s && Pe.hasEditableTarget(b, I.target) && !qi(I, v.onPaste) && (!Ou || idt(I.nativeEvent) || ip) && (I.preventDefault(), Pe.insertData(b, I.clipboardData));
    }, [s, b, v.onPaste])
  }), /* @__PURE__ */ Oe.createElement(uft, {
    decorations: Y,
    node: b,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: b.selection
  }))))));
}), pft = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ Oe.createElement("span", Na({}, t), n, Xi && /* @__PURE__ */ Oe.createElement("br", null))
  );
}, dft = () => [], fft = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && Ce.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), kpt(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, qi = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, PJ = (e) => nc(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), hft = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, gft = /* @__PURE__ */ He(!1), mft = /* @__PURE__ */ He({});
function vft(e) {
  var t = vt([]).current, n = vt({
    editor: e
  }).current, r = ur((i) => {
    n.editor = i, t.forEach((a) => a(i));
  }, [t, n]), o = zt(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var yft = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], bft = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: a
  } = e, s = kd(e, yft), [l, u] = Oe.useState(() => {
    if (!it.isNodeList(a))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(bi.stringify(a)));
    if (!ne.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(bi.stringify(t)));
    return t.children = a, Object.assign(t, s), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: p
  } = vft(t), d = ur((v) => {
    var b;
    switch (r && r(t.children), v == null || (b = v.operation) === null || b === void 0 ? void 0 : b.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    u((L) => ({
      v: L.v + 1,
      editor: t
    })), p(t);
  }, [t, p, r, o, i]);
  h(() => (Z_.set(t, d), () => {
    Z_.set(t, () => {
    });
  }), [t, d]);
  var [y, f] = E(Pe.isFocused(t));
  return h(() => {
    f(Pe.isFocused(t));
  }, [t]), Qg(() => {
    var v = () => f(Pe.isFocused(t));
    return Ide >= 17 ? (document.addEventListener("focusin", v), document.addEventListener("focusout", v), () => {
      document.removeEventListener("focusin", v), document.removeEventListener("focusout", v);
    }) : (document.addEventListener("focus", v, !0), document.addEventListener("blur", v, !0), () => {
      document.removeEventListener("focus", v, !0), document.removeEventListener("blur", v, !0);
    });
  }, []), /* @__PURE__ */ Oe.createElement(mft.Provider, {
    value: c
  }, /* @__PURE__ */ Oe.createElement(Qde.Provider, {
    value: l
  }, /* @__PURE__ */ Oe.createElement(iN.Provider, {
    value: l.editor
  }, /* @__PURE__ */ Oe.createElement(gft.Provider, {
    value: y
  }, n))));
}, SJ = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, MJ = (e, t, n) => {
  var r = Pe.toDOMRange(e, t).getBoundingClientRect(), o = Pe.toDOMRange(e, n).getBoundingClientRect();
  return SJ(r, o) && SJ(o, r);
}, wft = (e, t) => {
  var n = ne.range(e, Ce.end(t)), r = Array.from(ne.positions(e, {
    at: t
  })), o = 0, i = r.length, a = Math.floor(i / 2);
  if (MJ(e, ne.range(e, r[o]), n))
    return ne.range(e, r[o], n);
  if (r.length < 2)
    return ne.range(e, r[r.length - 1], n);
  for (; a !== r.length && a !== o; )
    MJ(e, ne.range(e, r[a]), n) ? i = a : o = a, a = Math.floor((o + i) / 2);
  return ne.range(e, r[i], n);
};
function DJ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _J(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DJ(Object(n), !0).forEach(function(r) {
      La(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DJ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Oft = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: a,
    addMark: s,
    removeMark: l
  } = r;
  return LL.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var p, d;
    (p = lN.get(r)) === null || p === void 0 || p(), !Ea.get(r) && (d = is.get(r)) !== null && d !== void 0 && d.length && Ea.set(r, null), Rl.delete(r), s(u, c);
  }, r.removeMark = (u) => {
    var c;
    !Ea.get(r) && (c = is.get(r)) !== null && c !== void 0 && c.length && Ea.set(r, null), Rl.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return a(u);
    if (r.selection && Ce.isCollapsed(r.selection)) {
      var c = ne.above(r, {
        match: (f) => yt.isElement(f) && ne.isBlock(r, f),
        at: r.selection
      });
      if (c) {
        var [, p] = c, d = ne.range(r, p, r.selection.anchor), y = wft(r, d);
        Ce.isCollapsed(y) || $e.delete(r, {
          at: y
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], p = [], d = is.get(r);
    if (d != null && d.length) {
      var y = d.map((H) => wdt(H, u)).filter(Boolean);
      is.set(r, y);
    }
    var f = Wu.get(r);
    f && Wu.set(r, yJ(r, f, u));
    var v = Uu.get(r);
    if (v != null && v.at) {
      var b = Gt.isPoint(v == null ? void 0 : v.at) ? K_(r, v.at, u) : yJ(r, v.at, u);
      Uu.set(r, b ? _J(_J({}, v), {}, {
        at: b
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...rd(r, u.path));
        break;
      }
      case "set_selection": {
        var L;
        (L = Kh.get(r)) === null || L === void 0 || L.unref(), Kh.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...rd(r, ce.parent(u.path)));
        break;
      }
      case "merge_node": {
        var w = ce.previous(u.path);
        c.push(...rd(r, w));
        break;
      }
      case "move_node": {
        var D = ce.common(ce.parent(u.path), ce.parent(u.newPath));
        c.push(...rd(r, D));
        var x;
        ce.isBefore(u.path, u.newPath) ? (c.push(...rd(r, ce.parent(u.path))), x = u.newPath) : (c.push(...rd(r, ce.parent(u.newPath))), x = u.path);
        var m = it.get(t, ce.parent(x)), C = Pe.findKey(r, m), S = ne.pathRef(r, ce.parent(x));
        p.push([S, C]);
        break;
      }
    }
    switch (o(u), u.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "move_node":
      case "split_node":
        gd.set(r, !0);
    }
    for (var [U, k] of c) {
      var [R] = ne.node(r, U);
      $1.set(R, k);
    }
    for (var [N, V] of p) {
      if (N.current) {
        var [$] = ne.node(r, N.current);
        $1.set($, V);
      }
      N.unref();
    }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [p, d] = Ce.edges(c), y = ne.void(r, {
        at: p.path
      }), f = ne.void(r, {
        at: d.path
      });
      if (!(Ce.isCollapsed(c) && !y)) {
        var v = Pe.toDOMRange(r, c), b = v.cloneContents(), L = b.childNodes[0];
        if (b.childNodes.forEach((R) => {
          R.textContent && R.textContent.trim() !== "" && (L = R);
        }), f) {
          var [w] = f, D = v.cloneRange(), x = Pe.toDOMNode(r, w);
          D.setEndAfter(x), b = D.cloneContents();
        }
        if (y && (L = b.querySelector("[data-slate-spacer]")), Array.from(b.querySelectorAll("[data-slate-zero-width]")).forEach((R) => {
          var N = R.getAttribute("data-slate-zero-width") === "n";
          R.textContent = N ? `
` : "";
        }), Wde(L)) {
          var m = L.ownerDocument.createElement("span");
          m.style.whiteSpace = "pre", m.appendChild(L), b.appendChild(m), L = m;
        }
        var C = r.getFragment(), S = JSON.stringify(C), U = window.btoa(encodeURIComponent(S));
        L.setAttribute("data-slate-fragment", U), u.setData("application/".concat(n), U);
        var k = b.ownerDocument.createElement("div");
        return k.appendChild(b), k.setAttribute("hidden", "true"), b.ownerDocument.body.appendChild(k), u.setData("text/html", k.innerHTML), u.setData("text/plain", Vde(k)), b.ownerDocument.body.removeChild(k), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || cdt(u);
    if (c) {
      var p = decodeURIComponent(window.atob(c)), d = JSON.parse(p);
      return r.insertFragment(d), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var p = c.split(/\r\n|\r|\n/), d = !1;
      for (var y of p)
        d && $e.splitNodes(r, {
          always: !0
        }), r.insertText(y), d = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = Ide < 18 ? nl.unstable_batchedUpdates : (p) => p();
    c(() => {
      var p = Z_.get(r);
      p && p(u), i(u);
    });
  }, r;
}, rd = (e, t) => {
  var n = [];
  for (var [r, o] of ne.levels(e, {
    at: t
  })) {
    var i = Pe.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function tfe(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    ne.nodes(e, {
      at: ne.unhangRange(e, r),
      match: (i) => !ne.isEditor(i) && yt.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const TJ = ["listItem", "numberedList"], d0 = ["left", "center", "right", "justify"];
function Cft(e, t) {
  const n = d0.includes(t) ? "align" : "type", r = tfe(e, t, n), o = TJ.includes(t);
  $e.unwrapNodes(e, {
    match: (a) => !ne.isEditor(a) && yt.isElement(a) && TJ.includes(a.type) && !d0.includes(t),
    split: !0
  });
  let i;
  if (d0.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, $e.setNodes(e, i), !r && o) {
    const a = { type: t, children: [] };
    $e.wrapNodes(e, a);
  }
}
function qc({ format: e, icon: t }) {
  const n = EL(), r = d0.includes(e) ? "align" : "type", i = tfe(n, e, r) ? "activeTrue" : "activeFalse";
  function a(s) {
    s.preventDefault(), Cft(n, e);
  }
  return /* @__PURE__ */ oe.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: a,
      children: /* @__PURE__ */ oe.jsx(t, {})
    }
  );
}
function xft({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ oe.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ oe.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ oe.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ oe.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ oe.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ oe.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    case "image":
      return /* @__PURE__ */ oe.jsxs("div", { style: r, ...e, children: [
        /* @__PURE__ */ oe.jsx(
          "img",
          {
            className: "arkynElementImage",
            alt: "arkynElementImage",
            src: (n == null ? void 0 : n.src) || ""
          }
        ),
        t
      ] });
    default:
      return /* @__PURE__ */ oe.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
const nfe = He({});
function Lft(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, s = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ oe.jsx(nfe.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ oe.jsx(zee, { children: t && /* @__PURE__ */ oe.jsxs("aside", { className: s.trim(), ...i, children: [
    /* @__PURE__ */ oe.jsx(
      Jh.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ oe.jsx(
      Jh.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function Eft(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ oe.jsx("footer", { className: o.trim(), ...r });
}
function kft(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = ge(nfe), a = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ oe.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ oe.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ oe.jsx(lT, { size: 24 })
      }
    )
  ] });
}
const Y_ = He({});
function Pft() {
  if (!Y_)
    throw new Error("useTabContext must be used within a TabProvider");
  return ge(Y_);
}
function Sft(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [a, s] = E(r || ""), [l, u] = E(!0), c = vt(null), p = `arkynTabContainer ${o || ""}`, [d, y] = E({
    width: "0px",
    left: "0px",
    transition: "none"
  }), f = (b, L) => {
    const w = b.getBoundingClientRect(), D = c.current.getBoundingClientRect(), x = L ? void 0 : "none";
    u(!1), y({
      transition: x,
      width: `${w.width}px`,
      left: `${w.left - D.left}px`
    });
  };
  h(() => {
    const b = c.current;
    if (!b) return;
    let L = null;
    L = b.querySelector("button.activeTrue"), L && f(L);
  }, []);
  const v = (b) => {
    const L = b.target;
    L && (s(L.value), L.classList.add("activeTrue"), f(L, !0), n && n(L.value));
  };
  return /* @__PURE__ */ oe.jsxs("nav", { ref: c, className: p.trim(), ...i, children: [
    /* @__PURE__ */ oe.jsx(Y_.Provider, { value: { handleTabClick: v, showInitialTab: l, value: a }, children: t }),
    /* @__PURE__ */ oe.jsx("div", { className: "activeLine", style: d })
  ] });
}
function jJ(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: a, handleTabClick: s } = Pft(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && a ? "showBorderBottom" : ""} ${l} ${n}`;
  function p(d) {
    s(d), r && r(d);
  }
  return /* @__PURE__ */ oe.jsx(
    "button",
    {
      onClick: p,
      className: c.trim(),
      ...o,
      type: "button",
      children: t
    }
  );
}
function Mft(e) {
  const {
    action: t,
    tabLabels: n = ["Adicionar URL", "Upload de arquivo"],
    modalCancelButton: r = "Cancelar",
    modalConfirmButton: o = "Confirmar",
    modalInputImageLabel: i = "Imagem:",
    modalInputUrlLabel: a = "URL da imagem:",
    modalTitle: s = "Inserir imagem"
  } = e, l = EL(), [u, c] = E(!1), [p, d] = E(""), [y, f] = E("url");
  function v(b) {
    b.preventDefault(), !(!p || p === "") && (l.insertNodes([
      { type: "paragraph", children: [{ text: "" }] },
      { type: "image", src: p, children: [{ text: "" }] },
      { type: "paragraph", children: [{ text: "" }] }
    ]), c(!1));
  }
  return /* @__PURE__ */ oe.jsxs(oe.Fragment, { children: [
    /* @__PURE__ */ oe.jsx(
      "button",
      {
        type: "button",
        className: "arkynRichTextInsertImage",
        onMouseDown: () => c(!0),
        children: /* @__PURE__ */ oe.jsx(ihe, {})
      }
    ),
    /* @__PURE__ */ oe.jsxs(
      Lft,
      {
        isVisibled: u,
        makeInvisible: () => c(!1),
        children: [
          /* @__PURE__ */ oe.jsx(kft, { children: s }),
          /* @__PURE__ */ oe.jsxs("div", { className: "arkynRichTextInsertImageModalContent", children: [
            /* @__PURE__ */ oe.jsxs(Sft, { defaultActive: y, onClick: f, children: [
              /* @__PURE__ */ oe.jsx(jJ, { value: "url", children: n[0] }),
              /* @__PURE__ */ oe.jsx(jJ, { value: "file", children: n[1] })
            ] }),
            y === "url" && /* @__PURE__ */ oe.jsxs(oe.Fragment, { children: [
              /* @__PURE__ */ oe.jsxs(ZY, { children: [
                /* @__PURE__ */ oe.jsx(qY, { children: a }),
                /* @__PURE__ */ oe.jsx(
                  CL,
                  {
                    type: "text",
                    name: "richTextimageURL",
                    defaultValue: p,
                    onChange: (b) => d(b.target.value)
                  }
                )
              ] }),
              p && /* @__PURE__ */ oe.jsx(
                "img",
                {
                  className: "arkynRichTextInsertImageModalPreviewImage",
                  src: p,
                  alt: "preview"
                }
              )
            ] }),
            y === "file" && /* @__PURE__ */ oe.jsxs(ZY, { children: [
              /* @__PURE__ */ oe.jsx(qY, { children: i }),
              /* @__PURE__ */ oe.jsx(
                Fut,
                {
                  name: "richTextimageURL",
                  action: t,
                  defaultValue: p,
                  onUpload: (b) => d(b || "")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ oe.jsxs(Eft, { children: [
            /* @__PURE__ */ oe.jsx(
              V1,
              {
                type: "button",
                scheme: "danger",
                variant: "outline",
                onClick: () => c(!1),
                children: r
              }
            ),
            /* @__PURE__ */ oe.jsx(V1, { type: "button", onClick: v, children: o })
          ] })
        ]
      }
    )
  ] });
}
function Dft({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ oe.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ oe.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ oe.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ oe.jsx("u", { children: t })), /* @__PURE__ */ oe.jsx("span", { ...e, children: t });
}
function rfe(e, t) {
  const n = ne.marks(e);
  return n ? n[t] === !0 : !1;
}
function ofe(e, t) {
  rfe(e, t) ? ne.removeMark(e, t) : ne.addMark(e, t, !0);
}
function Hb({ format: e, icon: t }) {
  const n = EL(), o = rfe(n, e) ? "activeTrue" : "activeFalse";
  function i(a) {
    a.preventDefault(), ofe(n, e);
  }
  return /* @__PURE__ */ oe.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ oe.jsx(t, {})
    }
  );
}
function _ft({ children: e }) {
  return /* @__PURE__ */ oe.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
function AJ(e) {
  return e.map((t) => it.string(t)).join("");
}
const IJ = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, Vb = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
function Yyt(e) {
  const {
    name: t,
    hiddenButtons: n,
    imageConfig: r,
    defaultValue: o = "[]",
    enforceCharacterLimit: i = !1,
    onChangeCharactersCount: a,
    maxLimit: s = 2e3,
    onChange: l,
    isError: u
  } = e, c = zt(() => dct(Oft(nve())), []), { id: p, inputRef: d, error: y } = _s(), f = vt(null);
  function v() {
    try {
      const Y = JSON.parse(o);
      return !Array.isArray(Y) || Y.length <= 0 ? Vb : Y.every(
        (J) => typeof J == "object" && J !== null && "type" in J && "children" in J
      ) ? Y : Vb;
    } catch {
      return Vb;
    }
  }
  const b = AJ(v()), [L, w] = E(b.length), [D, x] = E(
    JSON.stringify(v()) || "[]"
  ), [m, C] = E(!1), S = d || f, U = u || !!y, k = ur(Dft, []), R = ur(xft, []);
  function N(Y) {
    const Q = AJ(Y);
    w(Q.length), a && a(Q.length), !(i && Q.length >= s) && (x(JSON.stringify(Y)), l && l(Y), c.children = Y, $e.setNodes(c, { children: Y }));
  }
  const V = m ? "focusTrue" : "focusFalse", H = `arkynRichText ${U || s < L ? "errorTrue" : "errorFalse"} ${V}`, X = s - L;
  function G(Y) {
    return !(n != null && n.includes(Y));
  }
  return /* @__PURE__ */ oe.jsxs(
    bft,
    {
      editor: c,
      initialValue: v(),
      onChange: N,
      onValueChange: N,
      children: [
        /* @__PURE__ */ oe.jsxs("div", { className: H, children: [
          /* @__PURE__ */ oe.jsxs(_ft, { children: [
            G("headingOne") && /* @__PURE__ */ oe.jsx(qc, { format: "headingOne", icon: she }),
            G("headingTwo") && /* @__PURE__ */ oe.jsx(qc, { format: "headingTwo", icon: ahe }),
            G("blockQuote") && /* @__PURE__ */ oe.jsx(qc, { format: "blockQuote", icon: lhe }),
            G("bold") && /* @__PURE__ */ oe.jsx(Hb, { format: "bold", icon: uhe }),
            G("italic") && /* @__PURE__ */ oe.jsx(Hb, { format: "italic", icon: che }),
            G("underline") && /* @__PURE__ */ oe.jsx(Hb, { format: "underline", icon: phe }),
            G("code") && /* @__PURE__ */ oe.jsx(Hb, { format: "code", icon: dhe }),
            G("left") && /* @__PURE__ */ oe.jsx(qc, { format: "left", icon: fhe }),
            G("right") && /* @__PURE__ */ oe.jsx(qc, { format: "right", icon: hhe }),
            G("center") && /* @__PURE__ */ oe.jsx(qc, { format: "center", icon: ghe }),
            G("justify") && /* @__PURE__ */ oe.jsx(qc, { format: "justify", icon: mhe }),
            r && G("image") && /* @__PURE__ */ oe.jsx(Mft, { ...r })
          ] }),
          /* @__PURE__ */ oe.jsx(
            cft,
            {
              className: "editorContainer",
              renderElement: R,
              renderLeaf: k,
              spellCheck: !0,
              id: p,
              onFocus: () => C(!0),
              onBlur: () => C(!1),
              onKeyDown: (Y) => {
                for (const Q in IJ)
                  if (uct(Q, Y)) {
                    Y.preventDefault();
                    const J = IJ[Q];
                    ofe(c, J);
                  }
              }
            }
          ),
          X < 0 && /* @__PURE__ */ oe.jsx("div", { className: "restatesCharacters", children: X })
        ] }),
        /* @__PURE__ */ oe.jsx("input", { type: "hidden", ref: S, name: t, value: D }),
        /* @__PURE__ */ oe.jsx("input", { type: "hidden", name: `${t}Count`, value: L })
      ]
    }
  );
}
function Tft(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: p,
    onBlur: d,
    title: y,
    style: f,
    closeOnSelect: v = !0,
    ...b
  } = e, m = `arkyn_select ${s ? "hasPrefix" : ""} ${a} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, S = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: m,
    prefix: bte(s, S, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: p,
    onBlur: d,
    title: y,
    closeOnSelect: v,
    style: f,
    iconSize: S,
    Spinner: /* @__PURE__ */ oe.jsx(tl, { className: "spinner", size: S, strokeWidth: 2.5 }),
    ...b
  };
}
function Jyt(e) {
  var I;
  const [t, n] = E(""), [r, o] = E(!1), { inputRef: i, id: a, error: s } = _s(), l = vt(null), u = i || l, c = e.isError || !!s, {
    disabled: p,
    title: d,
    style: y,
    className: f,
    prefix: v,
    iconSize: b,
    isLoading: L,
    LeftIcon: w,
    value: D = null,
    defaultValue: x = "",
    onFocus: m,
    onBlur: C,
    Spinner: S,
    name: U,
    placeholder: k,
    onSelect: R,
    options: N,
    optionMaxHeight: V,
    closeOnSelect: $,
    isSearchable: H,
    onSearch: X,
    ...G
  } = Tft({ ...e, id: a, isError: c }, r), [Y, Q] = E(x);
  function J() {
    p || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function P(F) {
    r || (o(!0), m && m(F));
  }
  function _() {
    o(!1), C && u.current && u.current.blur();
  }
  function z(F) {
    const { label: j, value: q } = F;
    Q(Y !== q ? q : ""), R && R({ label: j, value: q }), $ && _();
  }
  const M = typeof D == "string" ? D : Y, W = ((I = N.find((F) => F.value === M)) == null ? void 0 : I.label) || "", O = () => {
    if (!r && W) return !0;
    if (!r && !W) return !1;
    if (r && W) return !0;
    if (r && !W) return !1;
  };
  return /* @__PURE__ */ oe.jsxs(oe.Fragment, { children: [
    /* @__PURE__ */ oe.jsxs(
      "section",
      {
        title: d,
        style: y,
        onClick: J,
        className: `${f} placeholder_dark_${O()}`,
        children: [
          v,
          w && /* @__PURE__ */ oe.jsx(w, { size: b, strokeWidth: 2.5 }),
          /* @__PURE__ */ oe.jsx(
            "input",
            {
              disabled: p,
              readOnly: !0,
              placeholder: W || k,
              onFocus: P,
              ...G
            }
          ),
          /* @__PURE__ */ oe.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: U,
              value: M || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ oe.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: V },
              children: [
                H && /* @__PURE__ */ oe.jsx(
                  CL,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: Nee,
                    onChange: (F) => n(F.target.value)
                  }
                ),
                N.filter((F) => !!(e.onSearch || !e.isSearchable || F.label.toLowerCase().includes(t.toLowerCase()))).map(({ label: F, value: j }) => /* @__PURE__ */ oe.jsxs(
                  "div",
                  {
                    onClick: () => z({ label: F, value: j }),
                    className: M === j ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      F,
                      " ",
                      /* @__PURE__ */ oe.jsx(aT, {})
                    ]
                  },
                  j
                )),
                N.length <= 0 && /* @__PURE__ */ oe.jsx("p", { children: "Sem opções disponíveis" })
              ]
            }
          ),
          !L && /* @__PURE__ */ oe.jsx(
            Bee,
            {
              className: "arkyn_select_arrow",
              size: b,
              strokeWidth: 2.5
            }
          ),
          L && S
        ]
      }
    ),
    r && /* @__PURE__ */ oe.jsx("aside", { className: "arkyn_select_overlay", onClick: _ })
  ] });
}
function Qyt(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: a,
    className: s = "",
    onCheck: l,
    ...u
  } = e, [c, p] = E(n), { id: d, inputRef: y } = _s(), f = typeof r == "boolean" ? r : c;
  function v() {
    p(!c), l && l(f ? i : o || "checked");
  }
  const L = `arkynSwitch ${f ? "checkedTrue" : "checkedFalse"} ${t} ${s}`;
  return /* @__PURE__ */ oe.jsx("button", { type: "button", onClick: v, className: L, ...u, children: /* @__PURE__ */ oe.jsx(
    "input",
    {
      id: d,
      type: "hidden",
      name: a,
      ref: y,
      onClick: v,
      value: f ? o || "checked" : i
    }
  ) });
}
function ebt(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: a,
    onBlur: s,
    title: l,
    style: u,
    ...c
  } = e, [p, d] = E(!1), { inputRef: y, id: f, error: v } = _s(), b = vt(null), L = y || b, D = e.isError || !!v ? "errorTrue" : "errorFalse", C = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${D} ${p ? "focusedTrue" : "focusedFalse"} ${r}`;
  function S() {
    o || !(L != null && L.current) || (d(!0), L.current.focus());
  }
  function U(R) {
    d(!0), a && a(R);
  }
  function k(R) {
    d(!1), s && s(R);
  }
  return /* @__PURE__ */ oe.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: S,
      className: C,
      children: /* @__PURE__ */ oe.jsx(
        "textarea",
        {
          id: f,
          disabled: o,
          readOnly: i,
          ref: L,
          onFocus: U,
          onBlur: k,
          ...c
        }
      )
    }
  );
}
function tbt(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ oe.jsx("nav", { className: r, ...n });
}
function nbt(e) {
  const { pathname: t } = pT(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...a
  } = e, l = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ oe.jsxs("p", { className: l, children: [
    /* @__PURE__ */ oe.jsx(XS, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ oe.jsxs(bhe, { to: i, className: l, ...a, children: [
    /* @__PURE__ */ oe.jsx(XS, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function ife(e = "") {
  const t = pT(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([a, s]) => {
      s === void 0 ? n.delete(`${r}${a}`) : n.set(`${r}${a}`, String(s));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let a = n.toString();
      return a && (a = "?" + a), a;
    }
  };
}
function BJ(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function rbt(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    currentPage: a = 1,
    registerPerPage: s = 20,
    ...l
  } = e, u = Fee(), { getParam: c, getScopedSearch: p } = ife(t), d = Number(c("page")) || a, y = Number(c("per_page")) || s, f = Math.ceil(n / y), v = d > 1 ? BJ(d - 1 - i, d - 1) : [], b = d < f ? BJ(
    d,
    Math.min(d + i, f)
  ) : [];
  function L(w) {
    u(p({ page: w }));
  }
  return /* @__PURE__ */ oe.jsxs("div", { className: "arkynPagination", ...l, children: [
    /* @__PURE__ */ oe.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d <= 1,
        onClick: () => L(d - 1),
        children: /* @__PURE__ */ oe.jsx(vhe, {})
      }
    ),
    d > 1 + i && /* @__PURE__ */ oe.jsxs(oe.Fragment, { children: [
      /* @__PURE__ */ oe.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => L(1),
          children: "1"
        }
      ),
      d > 2 + i && /* @__PURE__ */ oe.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ oe.jsx(LN, {}) })
    ] }),
    v.length > 0 && v.map((w, D) => /* @__PURE__ */ oe.jsx(
      "button",
      {
        onClick: () => L(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      D
    )),
    /* @__PURE__ */ oe.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: d }),
    b.length > 0 && b.map((w, D) => /* @__PURE__ */ oe.jsx(
      "button",
      {
        onClick: () => L(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      D
    )),
    d + i < f && /* @__PURE__ */ oe.jsxs(oe.Fragment, { children: [
      d + 1 + i < f && /* @__PURE__ */ oe.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ oe.jsx(LN, {}) }),
      /* @__PURE__ */ oe.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => L(f),
          children: f
        }
      )
    ] }),
    /* @__PURE__ */ oe.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d >= f,
        onClick: () => L(d + 1),
        children: /* @__PURE__ */ oe.jsx(XS, {})
      }
    )
  ] });
}
const sfe = He({});
function obt(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...a
  } = e, s = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ oe.jsx(sfe.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ oe.jsx(zee, { children: t && /* @__PURE__ */ oe.jsxs("aside", { className: u.trim(), ...a, children: [
    /* @__PURE__ */ oe.jsx(
      Jh.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ oe.jsx(
      Jh.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${s})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${s})` },
        children: o
      }
    )
  ] }) }) });
}
function ibt(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = ge(sfe), a = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ oe.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ oe.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ oe.jsx(lT, { size: 24 })
      }
    )
  ] });
}
function sbt(e) {
  const {
    children: t,
    button: n,
    closeOnClick: r,
    className: o = "",
    orientation: i = "bottomLeft"
  } = e, [a, s] = E(!1), u = `arkynPopover ${i} ${a ? "visibleTrue" : "visibleFalse"} ${o}`;
  function c() {
    a || s(!0);
  }
  return /* @__PURE__ */ oe.jsxs("div", { className: u, onClick: c, children: [
    n,
    /* @__PURE__ */ oe.jsx(
      Jh.div,
      {
        style: { visibility: a ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: a ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && s(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    a && /* @__PURE__ */ oe.jsx("div", { onClick: () => s(!1), className: "arkynPopoverOverlay" })
  ] });
}
function abt(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ oe.jsx(Aee, {});
      case "danger":
        return /* @__PURE__ */ oe.jsx(jee, {});
      default:
        return /* @__PURE__ */ oe.jsx(Tee, {});
    }
  }
  return /* @__PURE__ */ oe.jsxs("div", { className: r, children: [
    /* @__PURE__ */ oe.jsxs("div", { children: [
      /* @__PURE__ */ oe.jsx("div", { className: "bg" }),
      /* @__PURE__ */ oe.jsx(o, {})
    ] }),
    /* @__PURE__ */ oe.jsx("p", { children: /* @__PURE__ */ oe.jsx("span", { children: t }) })
  ] });
}
var ui = {}, pN = {}, rv = {}, ov = {}, afe = "Expected a function", NJ = NaN, jft = "[object Symbol]", Aft = /^\s+|\s+$/g, Ift = /^[-+]0x[0-9a-f]+$/i, Bft = /^0b[01]+$/i, Nft = /^0o[0-7]+$/i, Rft = parseInt, Fft = typeof Pr == "object" && Pr && Pr.Object === Object && Pr, zft = typeof self == "object" && self && self.Object === Object && self, Uft = Fft || zft || Function("return this")(), Wft = Object.prototype, Hft = Wft.toString, Vft = Math.max, $ft = Math.min, TS = function() {
  return Uft.Date.now();
};
function Zft(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(afe);
  t = RJ(t) || 0, Z1(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Vft(RJ(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? $ft(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = TS();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(TS());
  }
  function m() {
    var C = TS(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function qft(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(afe);
  return Z1(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Zft(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Z1(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Xft(e) {
  return !!e && typeof e == "object";
}
function Kft(e) {
  return typeof e == "symbol" || Xft(e) && Hft.call(e) == jft;
}
function RJ(e) {
  if (typeof e == "number")
    return e;
  if (Kft(e))
    return NJ;
  if (Z1(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Z1(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Aft, "");
  var n = Bft.test(e);
  return n || Nft.test(e) ? Rft(e.slice(2), n ? 2 : 8) : Ift.test(e) ? NJ : +e;
}
var Gft = qft, iv = {};
Object.defineProperty(iv, "__esModule", {
  value: !0
});
iv.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), f0.has(n) || f0.set(n, /* @__PURE__ */ new Set());
  var i = f0.get(n);
  if (!i.has(o)) {
    var a = function() {
      var s = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return s;
    }();
    t.addEventListener(n, r, a ? { passive: !0 } : !1), i.add(o);
  }
};
iv.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), f0.get(n).delete(r.name || n);
};
var f0 = /* @__PURE__ */ new Map();
Object.defineProperty(ov, "__esModule", {
  value: !0
});
var Yft = Gft, Jft = eht(Yft), Qft = iv;
function eht(e) {
  return e && e.__esModule ? e : { default: e };
}
var tht = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Jft.default)(t, n);
}, No = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = tht(function(o) {
        No.scrollHandler(t);
      }, n);
      No.scrollSpyContainers.push(t), (0, Qft.addPassiveEventListener)(t, "scroll", r);
    }
  },
  isMounted: function(t) {
    return No.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.pageYOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = No.scrollSpyContainers[No.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(No.currentPositionX(t), No.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    No.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = No.scrollSpyContainers[No.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t), t(No.currentPositionX(n), No.currentPositionY(n));
  },
  updateStates: function() {
    No.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    No.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), No.spySetState && No.spySetState.length && No.spySetState.indexOf(t) > -1 && No.spySetState.splice(No.spySetState.indexOf(t), 1), document.removeEventListener("scroll", No.scrollHandler);
  },
  update: function() {
    return No.scrollSpyContainers.forEach(function(t) {
      return No.scrollHandler(t);
    });
  }
};
ov.default = No;
var Qd = {}, sv = {};
Object.defineProperty(sv, "__esModule", {
  value: !0
});
var nht = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, a = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", a) : history.replaceState(history.state, "", a);
}, rht = function() {
  return window.location.hash.replace(/^#/, "");
}, oht = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, iht = function(t) {
  return getComputedStyle(t).position !== "static";
}, jS = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, sht = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (iht(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = jS(n, o), a = i.offsetTop, s = i.offsetParent;
      if (s !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return a;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return jS(n, l).offsetTop - jS(t, l).offsetTop;
};
sv.default = {
  updateHash: nht,
  getHash: rht,
  filterElementInContainer: oht,
  scrollOffset: sht
};
var kL = {}, dN = {};
Object.defineProperty(dN, "__esModule", {
  value: !0
});
dN.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var fN = {};
Object.defineProperty(fN, "__esModule", {
  value: !0
});
var aht = iv, lht = ["mousedown", "mousewheel", "touchmove", "keydown"];
fN.default = {
  subscribe: function(t) {
    return typeof document < "u" && lht.forEach(function(n) {
      return (0, aht.addPassiveEventListener)(document, n, t);
    });
  }
};
var av = {};
Object.defineProperty(av, "__esModule", {
  value: !0
});
var J_ = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      J_.registered[t] = n;
    },
    remove: function(t) {
      J_.registered[t] = null;
    }
  }
};
av.default = J_;
Object.defineProperty(kL, "__esModule", {
  value: !0
});
var uht = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, cht = sv;
PL(cht);
var pht = dN, FJ = PL(pht), dht = fN, fht = PL(dht), hht = av, Za = PL(hht);
function PL(e) {
  return e && e.__esModule ? e : { default: e };
}
var lfe = function(t) {
  return FJ.default[t.smooth] || FJ.default.defaultEasing;
}, ght = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, mht = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Q_ = function() {
  return mht() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), ufe = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, cfe = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, pfe = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, vht = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, yht = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, bht = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Za.default.registered.end && Za.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Q_.call(window, i);
    return;
  }
  Za.default.registered.end && Za.default.registered.end(o.to, o.target, o.currentPosition);
}, hN = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, lv = function(t, n, r, o) {
  n.data = n.data || ufe(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (fht.default.subscribe(i), hN(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? cfe(n) : pfe(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    Za.default.registered.end && Za.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = ght(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var a = lfe(n), s = bht.bind(null, a, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      Za.default.registered.begin && Za.default.registered.begin(n.data.to, n.data.target), Q_.call(window, s);
    }, n.delay);
    return;
  }
  Za.default.registered.begin && Za.default.registered.begin(n.data.to, n.data.target), Q_.call(window, s);
}, SL = function(t) {
  return t = uht({}, t), t.data = t.data || ufe(), t.absolute = !0, t;
}, wht = function(t) {
  lv(0, SL(t));
}, Oht = function(t, n) {
  lv(t, SL(n));
}, Cht = function(t) {
  t = SL(t), hN(t), lv(t.horizontal ? vht(t) : yht(t), t);
}, xht = function(t, n) {
  n = SL(n), hN(n);
  var r = n.horizontal ? cfe(n) : pfe(n);
  lv(t + r, n);
};
kL.default = {
  animateTopScroll: lv,
  getAnimationType: lfe,
  scrollToTop: wht,
  scrollToBottom: Cht,
  scrollTo: Oht,
  scrollMore: xht
};
Object.defineProperty(Qd, "__esModule", {
  value: !0
});
var Lht = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Eht = sv, kht = gN(Eht), Pht = kL, Sht = gN(Pht), Mht = av, $b = gN(Mht);
function gN(e) {
  return e && e.__esModule ? e : { default: e };
}
var Zb = {}, zJ = void 0;
Qd.default = {
  unmount: function() {
    Zb = {};
  },
  register: function(t, n) {
    Zb[t] = n;
  },
  unregister: function(t) {
    delete Zb[t];
  },
  get: function(t) {
    return Zb[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return zJ = t;
  },
  getActiveLink: function() {
    return zJ;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = Lht({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, a = void 0;
    o ? a = document.getElementById(o) : i && i.nodeType ? a = i : a = document, n.absolute = !0;
    var s = n.horizontal, l = kht.default.scrollOffset(a, r, s) + (n.offset || 0);
    if (!n.smooth) {
      $b.default.registered.begin && $b.default.registered.begin(t, r), a === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : a.scrollTop = l, $b.default.registered.end && $b.default.registered.end(t, r);
      return;
    }
    Sht.default.animateTopScroll(l, n, t, r);
  }
};
var eT = { exports: {} }, qb = { exports: {} }, ar = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var UJ;
function Dht() {
  if (UJ) return ar;
  UJ = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return ar.AsyncMode = l, ar.ConcurrentMode = u, ar.ContextConsumer = s, ar.ContextProvider = a, ar.Element = t, ar.ForwardRef = c, ar.Fragment = r, ar.Lazy = f, ar.Memo = y, ar.Portal = n, ar.Profiler = i, ar.StrictMode = o, ar.Suspense = p, ar.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, ar.isConcurrentMode = x, ar.isContextConsumer = function(m) {
    return D(m) === s;
  }, ar.isContextProvider = function(m) {
    return D(m) === a;
  }, ar.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, ar.isForwardRef = function(m) {
    return D(m) === c;
  }, ar.isFragment = function(m) {
    return D(m) === r;
  }, ar.isLazy = function(m) {
    return D(m) === f;
  }, ar.isMemo = function(m) {
    return D(m) === y;
  }, ar.isPortal = function(m) {
    return D(m) === n;
  }, ar.isProfiler = function(m) {
    return D(m) === i;
  }, ar.isStrictMode = function(m) {
    return D(m) === o;
  }, ar.isSuspense = function(m) {
    return D(m) === p;
  }, ar.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, ar.typeOf = D, ar;
}
var lr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WJ;
function _ht() {
  return WJ || (WJ = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === y || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === L || B.$$typeof === w || B.$$typeof === v);
    }
    function x(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var re = he && he.$$typeof;
                switch (re) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return re;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, R = c, N = r, V = f, $ = y, H = n, X = i, G = o, Y = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || x(B) === l;
    }
    function P(B) {
      return x(B) === u;
    }
    function _(B) {
      return x(B) === s;
    }
    function z(B) {
      return x(B) === a;
    }
    function M(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return x(B) === c;
    }
    function O(B) {
      return x(B) === r;
    }
    function I(B) {
      return x(B) === f;
    }
    function F(B) {
      return x(B) === y;
    }
    function j(B) {
      return x(B) === n;
    }
    function q(B) {
      return x(B) === i;
    }
    function A(B) {
      return x(B) === o;
    }
    function K(B) {
      return x(B) === p;
    }
    lr.AsyncMode = m, lr.ConcurrentMode = C, lr.ContextConsumer = S, lr.ContextProvider = U, lr.Element = k, lr.ForwardRef = R, lr.Fragment = N, lr.Lazy = V, lr.Memo = $, lr.Portal = H, lr.Profiler = X, lr.StrictMode = G, lr.Suspense = Y, lr.isAsyncMode = J, lr.isConcurrentMode = P, lr.isContextConsumer = _, lr.isContextProvider = z, lr.isElement = M, lr.isForwardRef = W, lr.isFragment = O, lr.isLazy = I, lr.isMemo = F, lr.isPortal = j, lr.isProfiler = q, lr.isStrictMode = A, lr.isSuspense = K, lr.isValidElementType = D, lr.typeOf = x;
  }()), lr;
}
var HJ;
function dfe() {
  return HJ || (HJ = 1, process.env.NODE_ENV === "production" ? qb.exports = Dht() : qb.exports = _ht()), qb.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var AS, VJ;
function Tht() {
  if (VJ) return AS;
  VJ = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return AS = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, AS;
}
var IS, $J;
function mN() {
  if ($J) return IS;
  $J = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return IS = e, IS;
}
var BS, ZJ;
function ffe() {
  return ZJ || (ZJ = 1, BS = Function.call.bind(Object.prototype.hasOwnProperty)), BS;
}
var NS, qJ;
function jht() {
  if (qJ) return NS;
  qJ = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = mN(), n = {}, r = ffe();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, NS = o, NS;
}
var RS, XJ;
function Aht() {
  if (XJ) return RS;
  XJ = 1;
  var e = dfe(), t = Tht(), n = mN(), r = ffe(), o = jht(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return RS = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, I, F, j, q, A, K) {
        if (j = j || d, A = A || F, K !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = j + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return I[F] == null ? O ? I[F] === null ? new v("The " + q + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new v("The " + q + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : P(I, F, j, q, A);
      }
      var W = M.bind(null, !1);
      return W.isRequired = M.bind(null, !0), W;
    }
    function L(P) {
      function _(z, M, W, O, I, F) {
        var j = z[M], q = G(j);
        if (q !== P) {
          var A = Y(j);
          return new v(
            "Invalid " + O + " `" + I + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var j = G(F);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var A = P(F, q, W, O, I + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!s(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, W, O) {
        var I = _[z];
        if (!e.isValidElementType(I)) {
          var F = G(I);
          return new v("Invalid " + W + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, W, O, I) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, j = J(z[M]);
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, W, O, I) {
        for (var F = z[M], j = 0; j < P.length; j++)
          if (f(F, P[j]))
            return null;
        var q = JSON.stringify(P, function(K, B) {
          var le = Y(B);
          return le === "symbol" ? String(B) : B;
        });
        return new v("Invalid " + O + " `" + I + "` of value `" + String(F) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, W, O, I) {
        if (typeof P != "function")
          return new v("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var A = P(F, q, W, O, I + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(W, O, I, F, j) {
        for (var q = [], A = 0; A < P.length; A++) {
          var K = P[A], B = K(W, O, I, F, j, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + j + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(M);
    }
    function R() {
      function P(_, z, M, W, O) {
        return H(_[z]) ? null : new v("Invalid " + W + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function N(P, _, z, M, W) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return N(W, O, I, q, Y(A));
          var K = A(F, q, W, O, I + "." + q, n);
          if (K)
            return K;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, W, O, I) {
        var F = z[M], j = G(F);
        if (j !== "object")
          return new v("Invalid " + O + " `" + I + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var A in q) {
          var K = P[A];
          if (r(P, A) && typeof K != "function")
            return N(W, O, I, A, Y(K));
          if (!K)
            return new v(
              "Invalid " + O + " `" + I + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = K(F, A, W, O, I + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!H(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var W = M.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function X(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function G(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : X(_, P) ? "symbol" : _;
    }
    function Y(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = G(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = Y(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, RS;
}
var FS, KJ;
function Iht() {
  if (KJ) return FS;
  KJ = 1;
  var e = mN();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, FS = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, FS;
}
if (process.env.NODE_ENV !== "production") {
  var Bht = dfe(), Nht = !0;
  eT.exports = Aht()(Bht.isElement, Nht);
} else
  eT.exports = Iht()();
var ML = eT.exports, DL = {};
Object.defineProperty(DL, "__esModule", {
  value: !0
});
var Rht = sv, zS = Fht(Rht);
function Fht(e) {
  return e && e.__esModule ? e : { default: e };
}
var zht = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return zS.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && zS.default.getHash() !== t && zS.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
DL.default = zht;
Object.defineProperty(rv, "__esModule", {
  value: !0
});
var Xb = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Uht = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Wht = Oe, GJ = uv(Wht), Hht = ov, Kb = uv(Hht), Vht = Qd, $ht = uv(Vht), Zht = ML, Po = uv(Zht), qht = DL, Cu = uv(qht);
function uv(e) {
  return e && e.__esModule ? e : { default: e };
}
function Xht(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Kht(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Ght(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var YJ = {
  to: Po.default.string.isRequired,
  containerId: Po.default.string,
  container: Po.default.object,
  activeClass: Po.default.string,
  activeStyle: Po.default.object,
  spy: Po.default.bool,
  horizontal: Po.default.bool,
  smooth: Po.default.oneOfType([Po.default.bool, Po.default.string]),
  offset: Po.default.number,
  delay: Po.default.number,
  isDynamic: Po.default.bool,
  onClick: Po.default.func,
  duration: Po.default.oneOfType([Po.default.number, Po.default.func]),
  absolute: Po.default.bool,
  onSetActive: Po.default.func,
  onSetInactive: Po.default.func,
  ignoreCancelEvents: Po.default.bool,
  hashSpy: Po.default.bool,
  saveHashHistory: Po.default.bool,
  spyThrottle: Po.default.number
};
rv.default = function(e, t) {
  var n = t || $ht.default, r = function(i) {
    Ght(a, i);
    function a(s) {
      Xht(this, a);
      var l = Kht(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return Uht(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          Kb.default.isMounted(l) || Kb.default.mount(l, this.props.spyThrottle), this.props.hashSpy && (Cu.default.isMounted() || Cu.default.mount(n), Cu.default.mapContainer(this.props.to, l)), Kb.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Kb.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = Xb({}, this.props.style, this.props.activeStyle) : u = Xb({}, this.props.style);
        var c = Xb({}, this.props);
        for (var p in YJ)
          c.hasOwnProperty(p) && delete c[p];
        return c.className = l, c.style = u, c.onClick = this.handleClick, GJ.default.createElement(e, c);
      }
    }]), a;
  }(GJ.default.PureComponent), o = function() {
    var a = this;
    this.scrollTo = function(s, l) {
      n.scrollTo(s, Xb({}, a.state, l));
    }, this.handleClick = function(s) {
      a.props.onClick && a.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), a.scrollTo(a.props.to, a.props);
    }, this.spyHandler = function(s, l) {
      var u = a.getScrollSpyContainer();
      if (!(Cu.default.isMounted() && !Cu.default.isInitialized())) {
        var c = a.props.horizontal, p = a.props.to, d = null, y = void 0, f = void 0;
        if (c) {
          var v = 0, b = 0, L = 0;
          if (u.getBoundingClientRect) {
            var w = u.getBoundingClientRect();
            L = w.left;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var D = d.getBoundingClientRect();
            v = D.left - L + s, b = v + D.width;
          }
          var x = s - a.props.offset;
          y = x >= Math.floor(v) && x < Math.floor(b), f = x < Math.floor(v) || x >= Math.floor(b);
        } else {
          var m = 0, C = 0, S = 0;
          if (u.getBoundingClientRect) {
            var U = u.getBoundingClientRect();
            S = U.top;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var k = d.getBoundingClientRect();
            m = k.top - S + l, C = m + k.height;
          }
          var R = l - a.props.offset;
          y = R >= Math.floor(m) && R < Math.floor(C), f = R < Math.floor(m) || R >= Math.floor(C);
        }
        var N = n.getActiveLink();
        if (f) {
          if (p === N && n.setActiveLink(void 0), a.props.hashSpy && Cu.default.getHash() === p) {
            var V = a.props.saveHashHistory, $ = V === void 0 ? !1 : V;
            Cu.default.changeHash("", $);
          }
          a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive(p, d));
        }
        if (y && (N !== p || a.state.active === !1)) {
          n.setActiveLink(p);
          var H = a.props.saveHashHistory, X = H === void 0 ? !1 : H;
          a.props.hashSpy && Cu.default.changeHash(p, X), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(p, d));
        }
      }
    };
  };
  return r.propTypes = YJ, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(pN, "__esModule", {
  value: !0
});
var Yht = Oe, JJ = hfe(Yht), Jht = rv, Qht = hfe(Jht);
function hfe(e) {
  return e && e.__esModule ? e : { default: e };
}
function egt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function QJ(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function tgt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ngt = function(e) {
  tgt(t, e);
  function t() {
    var n, r, o, i;
    egt(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = QJ(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return JJ.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), QJ(o, i);
  }
  return t;
}(JJ.default.Component);
pN.default = (0, Qht.default)(ngt);
var vN = {};
Object.defineProperty(vN, "__esModule", {
  value: !0
});
var rgt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ogt = Oe, eQ = gfe(ogt), igt = rv, sgt = gfe(igt);
function gfe(e) {
  return e && e.__esModule ? e : { default: e };
}
function agt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lgt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ugt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var cgt = function(e) {
  ugt(t, e);
  function t() {
    return agt(this, t), lgt(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return rgt(t, [{
    key: "render",
    value: function() {
      return eQ.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(eQ.default.Component);
vN.default = (0, sgt.default)(cgt);
var yN = {}, _L = {};
Object.defineProperty(_L, "__esModule", {
  value: !0
});
var pgt = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, dgt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), fgt = Oe, tQ = TL(fgt), hgt = nl;
TL(hgt);
var ggt = Qd, nQ = TL(ggt), mgt = ML, rQ = TL(mgt);
function TL(e) {
  return e && e.__esModule ? e : { default: e };
}
function vgt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ygt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function bgt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
_L.default = function(e) {
  var t = function(n) {
    bgt(r, n);
    function r(o) {
      vgt(this, r);
      var i = ygt(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return dgt(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        nQ.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        nQ.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return tQ.default.createElement(e, pgt({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(tQ.default.Component);
  return t.propTypes = {
    name: rQ.default.string,
    id: rQ.default.string
  }, t;
};
Object.defineProperty(yN, "__esModule", {
  value: !0
});
var oQ = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, wgt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Ogt = Oe, iQ = bN(Ogt), Cgt = _L, xgt = bN(Cgt), Lgt = ML, sQ = bN(Lgt);
function bN(e) {
  return e && e.__esModule ? e : { default: e };
}
function Egt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function kgt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Pgt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var mfe = function(e) {
  Pgt(t, e);
  function t() {
    return Egt(this, t), kgt(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return wgt(t, [{
    key: "render",
    value: function() {
      var r = this, o = oQ({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, iQ.default.createElement(
        "div",
        oQ({}, o, { ref: function(a) {
          r.props.parentBindings.domNode = a;
        } }),
        this.props.children
      );
    }
  }]), t;
}(iQ.default.Component);
mfe.propTypes = {
  name: sQ.default.string,
  id: sQ.default.string
};
yN.default = (0, xgt.default)(mfe);
var US = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, aQ = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function lQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function uQ(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function cQ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Gb = Oe, Xc = ov, WS = Qd, Zo = ML, xu = DL, pQ = {
  to: Zo.string.isRequired,
  containerId: Zo.string,
  container: Zo.object,
  activeClass: Zo.string,
  spy: Zo.bool,
  smooth: Zo.oneOfType([Zo.bool, Zo.string]),
  offset: Zo.number,
  delay: Zo.number,
  isDynamic: Zo.bool,
  onClick: Zo.func,
  duration: Zo.oneOfType([Zo.number, Zo.func]),
  absolute: Zo.bool,
  onSetActive: Zo.func,
  onSetInactive: Zo.func,
  ignoreCancelEvents: Zo.bool,
  hashSpy: Zo.bool,
  spyThrottle: Zo.number
}, Sgt = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || WS, o = function(a) {
      cQ(s, a);
      function s(l) {
        lQ(this, s);
        var u = uQ(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return aQ(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            Xc.isMounted(u) || Xc.mount(u, this.props.spyThrottle), this.props.hashSpy && (xu.isMounted() || xu.mount(r), xu.mapContainer(this.props.to, u)), this.props.spy && Xc.addStateHandler(this.stateHandler), Xc.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Xc.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = US({}, this.props);
          for (var p in pQ)
            c.hasOwnProperty(p) && delete c[p];
          return c.className = u, c.onClick = this.handleClick, Gb.createElement(t, c);
        }
      }]), s;
    }(Gb.Component), i = function() {
      var s = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, US({}, s.state, u));
      }, this.handleClick = function(l) {
        s.props.onClick && s.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), s.scrollTo(s.props.to, s.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== s.props.to && (s.state !== null && s.state.active && s.props.onSetInactive && s.props.onSetInactive(), s.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = s.getScrollSpyContainer();
        if (!(xu.isMounted() && !xu.isInitialized())) {
          var c = s.props.to, p = null, d = 0, y = 0, f = 0;
          if (u.getBoundingClientRect) {
            var v = u.getBoundingClientRect();
            f = v.top;
          }
          if (!p || s.props.isDynamic) {
            if (p = r.get(c), !p)
              return;
            var b = p.getBoundingClientRect();
            d = b.top - f + l, y = d + b.height;
          }
          var L = l - s.props.offset, w = L >= Math.floor(d) && L < Math.floor(y), D = L < Math.floor(d) || L >= Math.floor(y), x = r.getActiveLink();
          if (D)
            return c === x && r.setActiveLink(void 0), s.props.hashSpy && xu.getHash() === c && xu.changeHash(), s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive()), Xc.updateStates();
          if (w && x !== c)
            return r.setActiveLink(c), s.props.hashSpy && xu.changeHash(c), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(c)), Xc.updateStates();
        }
      };
    };
    return o.propTypes = pQ, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      cQ(o, r);
      function o(i) {
        lQ(this, o);
        var a = uQ(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return a.childBindings = {
          domNode: null
        }, a;
      }
      return aQ(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(a) {
          this.props.name !== a.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          WS.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(a) {
          WS.register(a, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Gb.createElement(t, US({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(Gb.Component);
    return n.propTypes = {
      name: Zo.string,
      id: Zo.string
    }, n;
  }
}, Mgt = Sgt;
Object.defineProperty(ui, "__esModule", {
  value: !0
});
ui.Helpers = ui.ScrollElement = ui.ScrollLink = Pfe = ui.animateScroll = ui.scrollSpy = ui.Events = ui.scroller = ui.Element = ui.Button = ui.Link = void 0;
var Dgt = pN, vfe = pl(Dgt), _gt = vN, yfe = pl(_gt), Tgt = yN, bfe = pl(Tgt), jgt = Qd, wfe = pl(jgt), Agt = av, Ofe = pl(Agt), Igt = ov, Cfe = pl(Igt), Bgt = kL, xfe = pl(Bgt), Ngt = rv, Lfe = pl(Ngt), Rgt = _L, Efe = pl(Rgt), Fgt = Mgt, kfe = pl(Fgt);
function pl(e) {
  return e && e.__esModule ? e : { default: e };
}
ui.Link = vfe.default;
ui.Button = yfe.default;
ui.Element = bfe.default;
ui.scroller = wfe.default;
ui.Events = Ofe.default;
ui.scrollSpy = Cfe.default;
var Pfe = ui.animateScroll = xfe.default;
ui.ScrollLink = Lfe.default;
ui.ScrollElement = Efe.default;
ui.Helpers = kfe.default;
ui.default = { Link: vfe.default, Button: yfe.default, Element: bfe.default, scroller: wfe.default, Events: Ofe.default, scrollSpy: Cfe.default, animateScroll: xfe.default, ScrollLink: Lfe.default, ScrollElement: Efe.default, Helpers: kfe.default };
const wN = He({}), Sfe = He({});
function zgt() {
  const e = ge(Sfe);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function dQ(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function lbt() {
  const e = uT(), { closeModal: t, closeAll: n, modalIsOpen: r } = ge(wN), { showToast: o } = zgt(), { getParam: i } = ife(), { pathname: a } = pT(), s = Fee(), l = i("closeAllModals"), u = cT();
  h(() => {
    var d, y;
    const c = ((y = (d = u[0]) == null ? void 0 : d.data) == null ? void 0 : y.closeModalKey) || "", p = r(c);
    c && p && t(c);
  }, [u]), h(() => {
    l === "true" && (n(), s(a));
  }, [l]), h(() => {
    const c = e == null ? void 0 : e.closeModalKey;
    c && t(c);
  }, [e]), h(() => {
    const c = e == null ? void 0 : e.closeAllModals;
    typeof c == "boolean" && c && n();
  }, [e]), h(() => {
    const c = e == null ? void 0 : e.toast, p = e == null ? void 0 : e.message;
    dQ(c) && o(c), !dQ(c) && p && o({ message: p, type: "danger" });
  }, [e]), h(() => {
    var c, p;
    if (typeof ((c = e == null ? void 0 : e.data) == null ? void 0 : c.scrollTo) == "string") {
      const d = document.getElementById((p = e == null ? void 0 : e.data) == null ? void 0 : p.scrollTo);
      d && Pfe.scrollTo(d.offsetTop - 200);
    }
  }, [e]);
}
const Mfe = He({});
function ubt(e) {
  const t = ge(Mfe);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, a = r(e), s = n(e);
    return { drawerIsOpen: a, drawerData: s, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function Ugt() {
  return () => {
  };
}
function Wgt() {
  return the(
    Ugt,
    () => !0,
    () => !1
  );
}
function cbt(e) {
  const t = ge(wN);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, a = r(e), s = n(e);
    return { modalIsOpen: a, modalData: s, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function pbt(e) {
  const { children: t = !1 } = e, [n, r] = E([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function a(l, u) {
    const c = o(l);
    r(c ? (p) => [...p.filter((y) => y.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function s(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ oe.jsx(
    Mfe.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: a, closeDrawer: s },
      children: t
    }
  );
}
function em(e) {
  "@babel/helpers - typeof";
  return em = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, em(e);
}
function Hgt(e, t) {
  if (em(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (em(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Vgt(e) {
  var t = Hgt(e, "string");
  return em(t) == "symbol" ? t : t + "";
}
function ke(e, t, n) {
  return (t = Vgt(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Dfe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var HS, fQ;
function $gt() {
  if (fQ) return HS;
  fQ = 1;
  var e = process.env.NODE_ENV, t = function(r, o, i, a, s, l, u, c) {
    if (e !== "production" && o === void 0)
      throw new Error("invariant requires an error message argument");
    if (!r) {
      var p;
      if (o === void 0)
        p = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [i, a, s, l, u, c], y = 0;
        p = new Error(o.replace(/%s/g, function() {
          return d[y++];
        })), p.name = "Invariant Violation";
      }
      throw p.framesToPop = 1, p;
    }
  };
  return HS = t, HS;
}
var Zgt = $gt(), yi = /* @__PURE__ */ Dfe(Zgt), Ut = He(null);
function qgt() {
  yi(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Ut);
  return yi(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Xgt(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function Kgt(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Ggt(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Kgt(e, i), o;
}
function Ygt(e, t, n) {
  var r = Xgt(n, function(i, a, s) {
    return typeof e[s] == "function" && i.push(google.maps.event.addListener(t, a, e[s])), i;
  }, []);
  return r;
}
function Jgt(e) {
  google.maps.event.removeListener(e);
}
function mn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(Jgt);
}
function sn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = Ygt(o, i, n);
  return Ggt(t, r, o, i), a;
}
var hQ = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, gQ = {
  extraMapTypes(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center(e, t) {
    e.setCenter(t);
  },
  clickableIcons(e, t) {
    e.setClickableIcons(t);
  },
  heading(e, t) {
    e.setHeading(t);
  },
  mapTypeId(e, t) {
    e.setMapTypeId(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  streetView(e, t) {
    e.setStreetView(t);
  },
  tilt(e, t) {
    e.setTilt(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
function Qgt(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = vt(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null), [A, K] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), K(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var B = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(B), B !== null && D && D(B), () => {
      B !== null && x && x(B);
    };
  }, []), oe.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: oe.jsx(Ut.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(Qgt);
let emt = class extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      map: null
    }), ke(this, "registeredEvents", []), ke(this, "mapRef", null), ke(this, "getInstance", () => this.mapRef === null ? null : new google.maps.Map(this.mapRef, this.props.options)), ke(this, "panTo", (t) => {
      var n = this.getInstance();
      n && n.panTo(t);
    }), ke(this, "setMapCallback", () => {
      this.state.map !== null && this.props.onLoad && this.props.onLoad(this.state.map);
    }), ke(this, "getRef", (t) => {
      this.mapRef = t;
    });
  }
  componentDidMount() {
    var t = this.getInstance();
    this.registeredEvents = sn({
      updaterMap: gQ,
      eventMap: hQ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        map: t
      };
    }, this.setMapCallback);
  }
  componentDidUpdate(t) {
    this.state.map !== null && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: gQ,
      eventMap: hQ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.map
    }));
  }
  componentWillUnmount() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), mn(this.registeredEvents));
  }
  render() {
    return oe.jsx("div", {
      id: this.props.id,
      ref: this.getRef,
      style: this.props.mapContainerStyle,
      className: this.props.mapContainerClassName,
      children: oe.jsx(Ut.Provider, {
        value: this.state.map,
        children: this.state.map !== null ? this.props.children : null
      })
    });
  }
};
function mQ(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function _fe(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        mQ(i, r, o, a, s, "next", l);
      }
      function s(l) {
        mQ(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Tfe(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return yi(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var Ep = typeof document < "u";
function jfe(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return Ep ? new Promise(function(i, a) {
    var s = document.getElementById(n), l = window;
    if (s) {
      var u = s.getAttribute("data-state");
      if (s.src === t && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, p = s.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, s.onerror = function(y) {
          p && p(y), a(y);
        };
        return;
      } else
        s.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(f) {
      d.setAttribute("data-state", "error"), a(f);
    }, l.initMap = function() {
      d.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function vQ(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Afe() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return vQ(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return vQ(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
var qf = !1;
function Ife() {
  return oe.jsx("div", {
    children: "Loading..."
  });
}
var tT = {
  id: "script-loader",
  version: "weekly"
};
class Bfe extends pe {
  constructor() {
    super(...arguments), ke(this, "check", jn()), ke(this, "state", {
      loaded: !1
    }), ke(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ke(this, "isCleaningUp", /* @__PURE__ */ _fe(function* () {
      function t(n) {
        if (!qf)
          n();
        else if (Ep)
          var r = window.setInterval(function() {
            qf || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ke(this, "cleanup", () => {
      qf = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(r) {
        return typeof r.src == "string" && r.src.includes("maps.googleapis");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(r) {
        return r.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(r) {
        return r.innerText !== void 0 && r.innerText.length > 0 && r.innerText.includes(".gm-");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      });
    }), ke(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Afe(), yi(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Tfe(this.props)
      };
      jfe(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (Ep) {
      if (window.google && window.google.maps && !qf) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), Ep && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (Ep) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, qf = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return oe.jsxs(oe.Fragment, {
      children: [oe.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || oe.jsx(Ife, {})]
    });
  }
}
ke(Bfe, "defaultProps", tT);
function tmt(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function ON(e, t) {
  if (e == null) return {};
  var n, r, o = tmt(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var yQ;
function nmt(e) {
  var {
    id: t = tT.id,
    version: n = tT.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = vt(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    Ep && u && Afe();
  }, [u]), h(function() {
    f && yi(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Tfe({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!Ep)
      return;
    function m() {
      y.current && (v(!0), yQ = w);
    }
    if (window.google && window.google.maps && yQ === w) {
      m();
      return;
    }
    jfe({
      id: t,
      url: w,
      nonce: r
    }).then(m).catch(function(S) {
      y.current && L(S), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(S);
    });
  }, [t, w, r]);
  var D = vt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var rmt = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], omt = oe.jsx(Ife, {});
function imt(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = ON(e, rmt), {
    isLoaded: s,
    loadError: l
  } = nmt(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || omt;
}
me(imt);
var bQ;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(bQ || (bQ = {}));
function wQ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function q1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wQ(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wQ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var OQ = {}, CQ = {
  options(e, t) {
    e.setOptions(t);
  }
};
function smt(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Ut), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(q1(q1({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(smt);
class amt extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      trafficLayer: null
    }), ke(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(q1(q1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = sn({
      updaterMap: CQ,
      eventMap: OQ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: CQ,
      eventMap: OQ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), mn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(amt, "contextType", Ut);
function lmt(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ut), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(lmt);
class umt extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      bicyclingLayer: null
    }), ke(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(umt, "contextType", Ut);
function cmt(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ut), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(cmt);
class pmt extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      transitLayer: null
    }), ke(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(pmt, "contextType", Ut);
function xQ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function X1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xQ(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xQ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var LQ = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, EQ = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function dmt(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Ut), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    yi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(X1(X1({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && L(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && k(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(dmt);
class fmt extends pe {
  constructor(t) {
    super(t), ke(this, "registeredEvents", []), ke(this, "state", {
      drawingManager: null
    }), ke(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), yi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(X1(X1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = sn({
      updaterMap: EQ,
      eventMap: LQ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: EQ,
      eventMap: LQ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), mn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ke(fmt, "contextType", Ut);
function kQ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function md(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kQ(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kQ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PQ = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, SQ = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, K1 = {};
function hmt(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: R,
    onClickableChanged: N,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: H,
    onFlatChanged: X,
    onIconChanged: G,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, W = ge(Ut), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null), [re, Se] = E(null), [We, Ze] = E(null), [Me, rt] = E(null), [Ve, be] = E(null), [qe, ct] = E(null), [ye, xe] = E(null), [Ee, Ue] = E(null), [De, st] = E(null), [ve, wt] = E(null), [at, lt] = E(null), [pt, Ot] = E(null), [dt, Ct] = E(null), [Xe, ht] = E(null), [ot, xt] = E(null), [ft, Pt] = E(null), [Lt, St] = E(null), [Et, Mt] = E(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (re !== null && google.maps.event.removeListener(re), Se(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), Ze(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Me !== null && google.maps.event.removeListener(Me), rt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && R && (Ve !== null && google.maps.event.removeListener(Ve), be(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && L && (qe !== null && google.maps.event.removeListener(qe), ct(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (ye !== null && google.maps.event.removeListener(ye), xe(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && N && (Ee !== null && google.maps.event.removeListener(Ee), Ue(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && V && (De !== null && google.maps.event.removeListener(De), st(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), wt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && X && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(O, "flat_changed", X)));
  }, [X]), h(() => {
    O && G && (dt !== null && google.maps.event.removeListener(dt), Ct(google.maps.event.addListener(O, "icon_changed", G)));
  }, [G]), h(() => {
    O && Y && (Xe !== null && google.maps.event.removeListener(Xe), ht(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (ot !== null && google.maps.event.removeListener(ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (ft !== null && google.maps.event.removeListener(ft), Pt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Lt !== null && google.maps.event.removeListener(Lt), St(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (Et !== null && google.maps.event.removeListener(Et), Mt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var gt = md(md(md({}, n || K1), r ? K1 : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(gt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof y < "u" && te.setOpacity(y), f && te.setShape(f), typeof v == "string" && te.setTitle(v), typeof b == "number" && te.setZIndex(b), w && j(google.maps.event.addListener(te, "dblclick", w)), x && A(google.maps.event.addListener(te, "dragend", x)), m && B(google.maps.event.addListener(te, "dragstart", m)), k && he(google.maps.event.addListener(te, "mousedown", k)), C && Se(google.maps.event.addListener(te, "mouseout", C)), S && Ze(google.maps.event.addListener(te, "mouseover", S)), U && rt(google.maps.event.addListener(te, "mouseup", U)), R && be(google.maps.event.addListener(te, "rightclick", R)), L && ct(google.maps.event.addListener(te, "click", L)), D && xe(google.maps.event.addListener(te, "drag", D)), N && Ue(google.maps.event.addListener(te, "clickable_changed", N)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), $ && wt(google.maps.event.addListener(te, "animation_changed", $)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), X && Ot(google.maps.event.addListener(te, "flat_changed", X)), G && Ct(google.maps.event.addListener(te, "icon_changed", G)), Y && ht(google.maps.event.addListener(te, "position_changed", Y)), Q && xt(google.maps.event.addListener(te, "shape_changed", Q)), J && Pt(google.maps.event.addListener(te, "title_changed", J)), P && St(google.maps.event.addListener(te, "visible_changed", P)), _ && Mt(google.maps.event.addListener(te, "zindex_changed", _)), I(te), z && z(te), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), re !== null && google.maps.event.removeListener(re), We !== null && google.maps.event.removeListener(We), Me !== null && google.maps.event.removeListener(Me), Ve !== null && google.maps.event.removeListener(Ve), qe !== null && google.maps.event.removeListener(qe), Ee !== null && google.maps.event.removeListener(Ee), De !== null && google.maps.event.removeListener(De), ve !== null && google.maps.event.removeListener(ve), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), Xe !== null && google.maps.event.removeListener(Xe), ft !== null && google.maps.event.removeListener(ft), Lt !== null && google.maps.event.removeListener(Lt), Et !== null && google.maps.event.removeListener(Et), M && M(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var _t = zt(() => i ? ut.map(i, (gt) => {
    if (!wi(gt))
      return gt;
    var te = gt;
    return Oi(te, {
      anchor: O
    });
  }) : null, [i, O]);
  return oe.jsx(oe.Fragment, {
    children: _t
  }) || null;
}
me(hmt);
class Nfe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return _fe(function* () {
      var n = md(md(md({}, t.props.options || K1), t.props.clusterer ? K1 : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = sn({
        updaterMap: SQ,
        eventMap: PQ,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: SQ,
      eventMap: PQ,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), mn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Oi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ke(Nfe, "contextType", Ut);
var gmt = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), mmt = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new gmt(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function vmt(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var ymt = 2e3, bmt = 500, wmt = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Omt = "png", Cmt = [53, 56, 66, 78, 90], xmt = "cluster", Rfe = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || wmt, this.imageExtension = r.imageExtension || Omt, this.imageSizes = r.imageSizes || Cmt, this.calculator = r.calculator || vmt, this.batchSize = r.batchSize || ymt, this.batchSizeIE = r.batchSizeIE || bmt, this.clusterClass = r.clusterClass || xmt, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new mmt(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var a = i;
          this.prototype[a] = o.prototype[a];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function MQ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lmt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? MQ(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MQ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ca = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Jn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Emt = {};
function kmt(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, R] = E(null), N = ge(Ut), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, Ca.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, Ca.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, Ca.onClick, w)));
  }, [w]), h(() => {
    k && D && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(k, Ca.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (G !== null && google.maps.event.removeListener(G), X(google.maps.event.addListener(k, Ca.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && Jn.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && Jn.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && Jn.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && Jn.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && Jn.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && Jn.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && Jn.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && Jn.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && Jn.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && Jn.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && Jn.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && Jn.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && Jn.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && Jn.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && Jn.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (N) {
      var z = Lmt({}, n || Emt), M = new Rfe(N, [], z);
      return r && Jn.averageCenter(M, r), o && Jn.batchSizeIE(M, o), i && Jn.calculator(M, i), a && Jn.clusterClass(M, a), s && Jn.enableRetinaIcons(M, s), l && Jn.gridSize(M, l), u && Jn.ignoreHidden(M, u), c && Jn.imageExtension(M, c), p && Jn.imagePath(M, p), d && Jn.imageSizes(M, d), y && Jn.maxZoom(M, y), f && Jn.minimumClusterSize(M, f), v && Jn.styles(M, v), b && Jn.title(M, b), L && Jn.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, Ca.onMouseOut, C)), m && _(google.maps.event.addListener(M, Ca.onMouseOver, m)), w && $(google.maps.event.addListener(M, Ca.onClick, w)), D && X(google.maps.event.addListener(M, Ca.onClusteringBegin, D)), x && Y(google.maps.event.addListener(M, Ca.onClusteringEnd, x)), R(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(kmt);
class Pmt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      markerClusterer: null
    }), ke(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Rfe(this.context, [], this.props.options);
      this.registeredEvents = sn({
        updaterMap: Jn,
        eventMap: Ca,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: Jn,
      eventMap: Ca,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), mn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ke(Pmt, "contextType", Ut);
function DQ(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Ffe = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(c) {
        c.returnValue = !1, c.preventDefault && c.preventDefault(), t.enableEventPropagation || DQ(c);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, DQ));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Smt = ["position"], Mmt = ["position"];
function _Q(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function G1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _Q(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _Q(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var TQ = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, jQ = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Dmt = {};
function _mt(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Ut), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var N = r || Dmt, {
        position: V
      } = N, $ = ON(N, Smt), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var X = new Ffe(G1(G1({}, $), H ? {
        position: H
      } : {}));
      R.current = document.createElement("div"), v(X), a && L(google.maps.event.addListener(X, "closeclick", a)), s && D(google.maps.event.addListener(X, "domready", s)), l && m(google.maps.event.addListener(X, "content_changed", l)), u && S(google.maps.event.addListener(X, "position_changed", u)), c && k(google.maps.event.addListener(X, "zindex_changed", c)), X.setContent(R.current), n ? X.open(y, n) : X.getPosition() ? X.open(y) : yi(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(X);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(_mt);
class Tmt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", null), ke(this, "state", {
      infoBox: null
    }), ke(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : yi(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ke(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = ON(t, Mmt), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Ffe(G1(G1({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = sn({
      updaterMap: jQ,
      eventMap: TQ,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: jQ,
      eventMap: TQ,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), mn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
ke(Tmt, "contextType", Ut);
var VS, AQ;
function jmt() {
  return AQ || (AQ = 1, VS = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), VS;
}
var Amt = jmt(), IQ = /* @__PURE__ */ Dfe(Amt), BQ = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], $S = 1, Xf = 8;
class CN {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== $S)
      throw new Error("Got v".concat(o, " data when expected v").concat($S, "."));
    var i = BQ[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new CN(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = BQ.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Xf, t), this.coords = new this.ArrayType(this.data, Xf + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Xf + a + s + l), this.ids = new this.IndexArrayType(this.data, Xf, t), this.coords = new this.ArrayType(this.data, Xf + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, ($S << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return nT(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          NQ(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      NQ(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function nT(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    zfe(e, t, a, r, o, i), nT(e, t, n, r, a - 1, 1 - i), nT(e, t, n, a + 1, o, 1 - i);
  }
}
function zfe(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      zfe(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (Kf(e, t, r, n), t[2 * o + i] > y && Kf(e, t, r, o); f < v; ) {
      for (Kf(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? Kf(e, t, r, v) : (v++, Kf(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function Kf(e, t, n, r) {
  ZS(e, n, r), ZS(t, 2 * n, 2 * r), ZS(t, 2 * n + 1, 2 * r + 1);
}
function ZS(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function NQ(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Imt = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, RQ = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Kc = 2, Hu = 3, qS = 4, Tu = 5, Ufe = 6;
class Bmt {
  constructor(t) {
    this.options = Object.assign(Object.create(Imt), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = RQ(Yb(u)), d = RQ(Jb(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Yb(r), Jb(a), Yb(i), Jb(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Tu] > 1 ? FQ(p, f, this.clusterProps) : this.points[p[f + Hu]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + qS] === t && p.push(a[y + Tu] > 1 ? FQ(a, y, this.clusterProps) : this.points[a[y + Hu]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new CN(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Tu] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Wfe(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Hu]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = Yb(f), d = Jb(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + Hu] : L = this.points[n[l + Hu]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Kc] <= n)) {
        l[p + Kc] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Tu], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + Kc] > n && (b += l[w + Tu]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + Kc] <= n)) {
              l[k + Kc] = n;
              var R = l[k + Tu];
              D += l[k] * R, x += l[k + 1] * R, l[k + qS] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + qS] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + Kc] <= n)) {
                l[$ + Kc] = n;
                for (var H = 0; H < c; H++) u.push(l[$ + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Tu] > 1) {
      var o = this.clusterProps[t[n + Ufe]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Hu]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function FQ(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Hu],
    properties: Wfe(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [Nmt(e[t]), Rmt(e[t + 1])]
    }
  };
}
function Wfe(e, t, n) {
  var r = e[t + Tu], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Ufe], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Hu],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Yb(e) {
  return e / 360 + 0.5;
}
function Jb(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function Nmt(e) {
  return (e - 0.5) * 360;
}
function Rmt(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Fmt(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Xs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class rT {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Xs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Xs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Xs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class zmt {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return Umt(n);
  }
}
var Umt = (e) => {
  var t = e.map((n) => new rT({
    position: Xs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class Wmt extends zmt {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = Fmt(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Bmt(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!IQ(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Xs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !IQ(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new rT({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new rT({
      markers: [i],
      position: Xs.getPosition(i)
    });
  }
}
class Hmt {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Vmt {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Xs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function $mt(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class xN {
  constructor() {
    $mt(xN, google.maps.OverlayView);
  }
}
var Yh;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Yh || (Yh = {}));
var Zmt = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class qmt extends xN {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new Wmt(o),
      renderer: a = new Vmt(),
      onClusterClick: s = Zmt
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Xs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Yh.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Xs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Xs.setMap(l, null)));
      }
      google.maps.event.trigger(this, Yh.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Xs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Hmt(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Xs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Yh.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Xs.setMap(r.marker, n);
    });
  }
}
function zQ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function UQ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zQ(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zQ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Xmt(e) {
  var t = qgt(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new qmt(UQ(UQ({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Kmt(e) {
  var {
    children: t,
    options: n
  } = e, r = Xmt(n);
  return r !== null ? t(r) : null;
}
me(Kmt);
var WQ = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, HQ = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Gmt(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Ut), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), R = vt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return v(N), R.current = document.createElement("div"), a && L(google.maps.event.addListener(N, "closeclick", a)), s && D(google.maps.event.addListener(N, "domready", s)), l && m(google.maps.event.addListener(N, "content_changed", l)), u && S(google.maps.event.addListener(N, "position_changed", u)), c && k(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(R.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(y, n) : N.getPosition() ? N.open(y) : yi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(N), N.close();
    };
  }, []), R.current ? An(ut.only(t), R.current) : null;
}
me(Gmt);
class Ymt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", null), ke(this, "state", {
      infoWindow: null
    }), ke(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : yi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ke(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = sn({
      updaterMap: HQ,
      eventMap: WQ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: HQ,
      eventMap: WQ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (mn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? An(ut.only(this.props.children), this.containerElement) : null;
  }
}
ke(Ymt, "contextType", Ut);
function VQ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Y1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VQ(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VQ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $Q = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, ZQ = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Jmt = {};
function Qmt(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(Ut), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var j = new google.maps.Polyline(Y1(Y1({}, t || Jmt), {}, {
      map: D
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && S(google.maps.event.addListener(j, "dblclick", a)), s && k(google.maps.event.addListener(j, "dragend", s)), l && N(google.maps.event.addListener(j, "dragstart", l)), u && $(google.maps.event.addListener(j, "mousedown", u)), c && X(google.maps.event.addListener(j, "mousemove", c)), p && Y(google.maps.event.addListener(j, "mouseout", p)), d && J(google.maps.event.addListener(j, "mouseover", d)), y && _(google.maps.event.addListener(j, "mouseup", y)), f && M(google.maps.event.addListener(j, "rightclick", f)), v && O(google.maps.event.addListener(j, "click", v)), b && F(google.maps.event.addListener(j, "drag", b)), m(j), L && L(j), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
me(Qmt);
class evt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      polyline: null
    }), ke(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Y1(Y1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = sn({
      updaterMap: ZQ,
      eventMap: $Q,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: ZQ,
      eventMap: $Q,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), mn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ke(evt, "contextType", Ut);
function qQ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function XQ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qQ(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qQ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var KQ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, GQ = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function tvt(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Ut), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var A = new google.maps.Polygon(XQ(XQ({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && k(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && $(google.maps.event.addListener(A, "dragstart", u)), c && X(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), b && F(google.maps.event.addListener(A, "click", b)), L && q(google.maps.event.addListener(A, "drag", L)), S(A), w && w(A), () => {
      U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), D && D(A), A.setMap(null);
    };
  }, []), null;
}
me(tvt);
class nvt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = sn({
      updaterMap: GQ,
      eventMap: KQ,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: GQ,
      eventMap: KQ,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), mn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ke(nvt, "contextType", Ut);
function YQ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function J1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YQ(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YQ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var JQ = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, QQ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function rvt(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Ut), [m, C] = E(null), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var K = new google.maps.Rectangle(J1(J1({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && K.setVisible(i), typeof o < "u" && K.setEditable(o), typeof r < "u" && K.setDraggable(r), typeof n < "u" && K.setBounds(n), a && U(google.maps.event.addListener(K, "dblclick", a)), s && R(google.maps.event.addListener(K, "dragend", s)), l && V(google.maps.event.addListener(K, "dragstart", l)), u && H(google.maps.event.addListener(K, "mousedown", u)), c && G(google.maps.event.addListener(K, "mousemove", c)), p && Q(google.maps.event.addListener(K, "mouseout", p)), d && P(google.maps.event.addListener(K, "mouseover", d)), y && z(google.maps.event.addListener(K, "mouseup", y)), f && W(google.maps.event.addListener(K, "rightclick", f)), v && I(google.maps.event.addListener(K, "click", v)), b && j(google.maps.event.addListener(K, "drag", b)), L && A(google.maps.event.addListener(K, "bounds_changed", L)), C(K), w && w(K), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(K), K.setMap(null);
    };
  }, []), null;
}
me(rvt);
class ovt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      rectangle: null
    }), ke(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(J1(J1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = sn({
      updaterMap: QQ,
      eventMap: JQ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: QQ,
      eventMap: JQ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), mn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ke(ovt, "contextType", Ut);
function eee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Q1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tee = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, nee = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, ivt = {};
function svt(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Ut), [S, U] = E(null), [k, R] = E(null), [N, V] = E(null), [$, H] = E(null), [X, G] = E(null), [Y, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, W] = E(null), [O, I] = E(null), [F, j] = E(null), [q, A] = E(null), [K, B] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), H(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (X !== null && google.maps.event.removeListener(X), G(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), I(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (K !== null && google.maps.event.removeListener(K), B(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var re = new google.maps.Circle(Q1(Q1({}, t || ivt), {}, {
      map: C
    }));
    return typeof r == "number" && re.setRadius(r), typeof n < "u" && re.setCenter(n), typeof r == "number" && re.setRadius(r), typeof a < "u" && re.setVisible(a), typeof i < "u" && re.setEditable(i), typeof o < "u" && re.setDraggable(o), s && R(google.maps.event.addListener(re, "dblclick", s)), l && V(google.maps.event.addListener(re, "dragend", l)), u && H(google.maps.event.addListener(re, "dragstart", u)), c && G(google.maps.event.addListener(re, "mousedown", c)), p && Q(google.maps.event.addListener(re, "mousemove", p)), d && P(google.maps.event.addListener(re, "mouseout", d)), y && z(google.maps.event.addListener(re, "mouseover", y)), f && W(google.maps.event.addListener(re, "mouseup", f)), v && I(google.maps.event.addListener(re, "rightclick", v)), b && j(google.maps.event.addListener(re, "click", b)), L && A(google.maps.event.addListener(re, "drag", L)), w && B(google.maps.event.addListener(re, "center_changed", w)), D && he(google.maps.event.addListener(re, "radius_changed", D)), U(re), x && x(re), () => {
      k !== null && google.maps.event.removeListener(k), N !== null && google.maps.event.removeListener(N), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), K !== null && google.maps.event.removeListener(K), le !== null && google.maps.event.removeListener(le), m && m(re), re.setMap(null);
    };
  }, []), null;
}
me(svt);
class avt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      circle: null
    }), ke(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Q1(Q1({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = sn({
      updaterMap: nee,
      eventMap: tee,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: nee,
      eventMap: tee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), mn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ke(avt, "contextType", Ut);
function ree(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function eO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ree(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ree(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oee = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, iee = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function lvt(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(Ut), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [R, N] = E(null), [V, $] = E(null), [H, X] = E(null), [G, Y] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [W, O] = E(null), [I, F] = E(null), [j, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (G !== null && google.maps.event.removeListener(G), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (I !== null && google.maps.event.removeListener(I), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var A = new google.maps.Data(eO(eO({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && k(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && $(google.maps.event.addListener(A, "mouseover", s)), l && X(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && q(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), j !== null && google.maps.event.removeListener(j), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(lvt);
class uvt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      data: null
    }), ke(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(eO(eO({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = sn({
        updaterMap: iee,
        eventMap: oee,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: iee,
      eventMap: oee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), mn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ke(uvt, "contextType", Ut);
function see(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aee(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? see(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : see(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lee = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, uee = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class cvt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      kmlLayer: null
    }), ke(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(aee(aee({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = sn({
      updaterMap: uee,
      eventMap: lee,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: uee,
      eventMap: lee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), mn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(cvt, "contextType", Ut);
function Hfe(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function pvt(e, t) {
  return new t(e.lat, e.lng);
}
function dvt(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function fvt(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function hvt(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function gvt(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function mvt(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Vfe(e, t, n, r) {
  return n !== void 0 ? gvt(e, t, hvt(n, google.maps.LatLngBounds, dvt)) : mvt(e, t, fvt(r, google.maps.LatLng, pvt));
}
function vvt(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function cee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yvt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function bvt(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = yvt({}, this.container ? Hfe(this.container, o) : {
        x: 0,
        y: 0
      }), u = Vfe(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function pee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wvt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function dee(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function fee(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Ovt(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Ut), c = zt(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = zt(() => bvt(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
me(Ovt);
class ef extends pe {
  constructor(t) {
    super(t), ke(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ke(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      yi(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ke(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ke(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = wvt({
        x: 0,
        y: 0
      }, this.containerRef.current ? Hfe(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Vfe(r, o, this.props.bounds, this.props.position);
      if (!vvt(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ke(this, "draw", () => {
      this.onPositionElement();
    }), ke(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = jn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = dee(t.position), r = dee(this.props.position), o = fee(t.bounds), i = fee(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(oe.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
ke(ef, "FLOAT_PANE", "floatPane");
ke(ef, "MAP_PANE", "mapPane");
ke(ef, "MARKER_LAYER", "markerLayer");
ke(ef, "OVERLAY_LAYER", "overlayLayer");
ke(ef, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ke(ef, "contextType", Ut);
function Cvt() {
}
function hee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gee(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mee = {
  onDblClick: "dblclick",
  onClick: "click"
}, vee = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function xvt(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Ut), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = zt(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(xvt);
class $fe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      groundOverlay: null
    }), ke(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    yi(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, gee(gee({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = sn({
      updaterMap: vee,
      eventMap: mee,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: vee,
      eventMap: mee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ke($fe, "defaultProps", {
  onLoad: Cvt
});
ke($fe, "contextType", Ut);
function yee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var bee = {}, wee = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Lvt(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Ut), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || yi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    yi(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(tO(tO({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(Lvt);
class Evt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      heatmapLayer: null
    }), ke(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    yi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), yi(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(tO(tO({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = sn({
      updaterMap: wee,
      eventMap: bee,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: wee,
      eventMap: bee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), mn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Evt, "contextType", Ut);
var Oee = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, Cee = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class kvt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      streetViewPanorama: null
    }), ke(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = sn({
      updaterMap: Cee,
      eventMap: Oee,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: Cee,
      eventMap: Oee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), mn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ke(kvt, "contextType", Ut);
class Pvt extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      streetViewService: null
    }), ke(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ke(Pvt, "contextType", Ut);
var xee = {
  onDirectionsChanged: "directions_changed"
}, Lee = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Svt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      directionsRenderer: null
    }), ke(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = sn({
      updaterMap: Lee,
      eventMap: xee,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: Lee,
      eventMap: xee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), mn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Svt, "contextType", Ut);
var Eee = {
  onPlacesChanged: "places_changed"
}, kee = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Zfe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", jn()), ke(this, "state", {
      searchBox: null
    }), ke(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (yi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = sn({
          updaterMap: kee,
          eventMap: Eee,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: kee,
      eventMap: Eee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), mn(this.registeredEvents));
  }
  render() {
    return oe.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
ke(Zfe, "contextType", Ut);
var Pee = {
  onPlaceChanged: "place_changed"
}, See = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class qfe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", jn()), ke(this, "state", {
      autocomplete: null
    }), ke(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    yi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = sn({
        updaterMap: See,
        eventMap: Pee,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    mn(this.registeredEvents), this.registeredEvents = sn({
      updaterMap: See,
      eventMap: Pee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && mn(this.registeredEvents);
  }
  render() {
    return oe.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
ke(qfe, "defaultProps", {
  className: ""
});
ke(qfe, "contextType", Ut);
function fbt({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ oe.jsx(
    Bfe,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function hbt(e) {
  const { children: t = !1 } = e, [n, r] = E([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((p) => p.key === u)) == null ? void 0 : c.data;
  }
  function a(u, c) {
    const p = o(u);
    r(p ? (d) => [...d.filter((f) => f.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function s(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ oe.jsx(
    wN.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: a, closeModal: s, closeAll: l },
      children: t
    }
  );
}
let Mvt = { data: "" }, Dvt = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Mvt, _vt = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Tvt = /\/\*[^]*?\*\/|  +/g, Mee = /\n+/g, Ju = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Ju(a, i) : i + "{" + Ju(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Ju(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Ju.p ? Ju.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ml = {}, Xfe = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Xfe(e[n]);
    return t;
  }
  return e;
}, jvt = (e, t, n, r, o) => {
  let i = Xfe(e), a = Ml[i] || (Ml[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ml[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = _vt.exec(u.replace(Tvt, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(Mee, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(Mee, " ").trim();
      return d[0];
    })(e);
    Ml[a] = Ju(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ml.g ? Ml.g : null;
  return n && (Ml.g = Ml[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ml[a], t, r, s), a;
}, Avt = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Ju(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function jL(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return jvt(n.unshift ? n.raw ? Avt(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Dvt(t.target), t.g, t.o, t.k);
}
let Kfe, oT, iT;
jL.bind({ g: 1 });
let Xl = jL.bind({ k: 1 });
function Ivt(e, t, n, r) {
  Ju.p = t, Kfe = e, oT = n, iT = r;
}
function Dc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: oT && oT() }, s), n.o = / *go\d+/.test(l), s.className = jL.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), iT && u[0] && iT(s), Kfe(u, s);
    }
    return o;
  };
}
var Bvt = (e) => typeof e == "function", nO = (e, t) => Bvt(e) ? e(t) : e, Nvt = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), Gfe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Rvt = 20, h0 = /* @__PURE__ */ new Map(), Fvt = 1e3, Dee = (e) => {
  if (h0.has(e)) return;
  let t = setTimeout(() => {
    h0.delete(e), nd({ type: 4, toastId: e });
  }, Fvt);
  h0.set(e, t);
}, zvt = (e) => {
  let t = h0.get(e);
  t && clearTimeout(t);
}, sT = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, Rvt) };
    case 1:
      return t.toast.id && zvt(t.toast.id), { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return e.toasts.find((i) => i.id === n.id) ? sT(e, { type: 1, toast: n }) : sT(e, { type: 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return r ? Dee(r) : e.toasts.forEach((i) => {
        Dee(i.id);
      }), { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, g0 = [], m0 = { toasts: [], pausedAt: void 0 }, nd = (e) => {
  m0 = sT(m0, e), g0.forEach((t) => {
    t(m0);
  });
}, Uvt = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, Wvt = (e = {}) => {
  let [t, n] = E(m0);
  h(() => (g0.push(n), () => {
    let o = g0.indexOf(n);
    o > -1 && g0.splice(o, 1);
  }), [t]);
  let r = t.toasts.map((o) => {
    var i, a;
    return { ...e, ...e[o.type], ...o, duration: o.duration || ((i = e[o.type]) == null ? void 0 : i.duration) || (e == null ? void 0 : e.duration) || Uvt[o.type], style: { ...e.style, ...(a = e[o.type]) == null ? void 0 : a.style, ...o.style } };
  });
  return { ...t, toasts: r };
}, Hvt = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || Nvt() }), cv = (e) => (t, n) => {
  let r = Hvt(t, e, n);
  return nd({ type: 2, toast: r }), r.id;
}, Ks = (e, t) => cv("blank")(e, t);
Ks.error = cv("error");
Ks.success = cv("success");
Ks.loading = cv("loading");
Ks.custom = cv("custom");
Ks.dismiss = (e) => {
  nd({ type: 3, toastId: e });
};
Ks.remove = (e) => nd({ type: 4, toastId: e });
Ks.promise = (e, t, n) => {
  let r = Ks.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return e.then((o) => (Ks.success(nO(t.success, o), { id: r, ...n, ...n == null ? void 0 : n.success }), o)).catch((o) => {
    Ks.error(nO(t.error, o), { id: r, ...n, ...n == null ? void 0 : n.error });
  }), e;
};
var Vvt = (e, t) => {
  nd({ type: 1, toast: { id: e, height: t } });
}, $vt = () => {
  nd({ type: 5, time: Date.now() });
}, Zvt = (e) => {
  let { toasts: t, pausedAt: n } = Wvt(e);
  h(() => {
    if (n) return;
    let i = Date.now(), a = t.map((s) => {
      if (s.duration === 1 / 0) return;
      let l = (s.duration || 0) + s.pauseDuration - (i - s.createdAt);
      if (l < 0) {
        s.visible && Ks.dismiss(s.id);
        return;
      }
      return setTimeout(() => Ks.dismiss(s.id), l);
    });
    return () => {
      a.forEach((s) => s && clearTimeout(s));
    };
  }, [t, n]);
  let r = ur(() => {
    n && nd({ type: 6, time: Date.now() });
  }, [n]), o = ur((i, a) => {
    let { reverseOrder: s = !1, gutter: l = 8, defaultPosition: u } = a || {}, c = t.filter((y) => (y.position || u) === (i.position || u) && y.height), p = c.findIndex((y) => y.id === i.id), d = c.filter((y, f) => f < p && y.visible).length;
    return c.filter((y) => y.visible).slice(...s ? [d + 1] : [0, d]).reduce((y, f) => y + (f.height || 0) + l, 0);
  }, [t]);
  return { toasts: t, handlers: { updateHeight: Vvt, startPause: $vt, endPause: r, calculateOffset: o } };
}, qvt = Xl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Xvt = Xl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Kvt = Xl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Gvt = Dc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${qvt} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Xvt} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Kvt} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Yvt = Xl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Jvt = Dc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Yvt} 1s linear infinite;
`, Qvt = Xl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, eyt = Xl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, tyt = Dc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Qvt} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${eyt} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, nyt = Dc("div")`
  position: absolute;
`, ryt = Dc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, oyt = Xl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, iyt = Dc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${oyt} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, syt = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? _e.createElement(iyt, null, t) : t : n === "blank" ? null : _e.createElement(ryt, null, _e.createElement(Jvt, { ...r }), n !== "loading" && _e.createElement(nyt, null, n === "error" ? _e.createElement(Gvt, { ...r }) : _e.createElement(tyt, { ...r })));
}, ayt = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, lyt = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, uyt = "0%{opacity:0;} 100%{opacity:1;}", cyt = "0%{opacity:1;} 100%{opacity:0;}", pyt = Dc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, dyt = Dc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, fyt = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Gfe() ? [uyt, cyt] : [ayt(n), lyt(n)];
  return { animation: t ? `${Xl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Xl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, hyt = _e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? fyt(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = _e.createElement(syt, { toast: e }), a = _e.createElement(dyt, { ...e.ariaProps }, nO(e.message, e));
  return _e.createElement(pyt, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : _e.createElement(_e.Fragment, null, i, a));
});
Ivt(_e.createElement);
var gyt = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = _e.useCallback((a) => {
    if (a) {
      let s = () => {
        let l = a.getBoundingClientRect().height;
        r(e, l);
      };
      s(), new MutationObserver(s).observe(a, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return _e.createElement("div", { ref: i, className: t, style: n }, o);
}, myt = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: Gfe() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, vyt = jL`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, Qb = 16, yyt = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: a }) => {
  let { toasts: s, handlers: l } = Zvt(n);
  return _e.createElement("div", { style: { position: "fixed", zIndex: 9999, top: Qb, left: Qb, right: Qb, bottom: Qb, pointerEvents: "none", ...i }, className: a, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, s.map((u) => {
    let c = u.position || t, p = l.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }), d = myt(c, p);
    return _e.createElement(gyt, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? vyt : "", style: d }, u.type === "custom" ? nO(u.message, u) : o ? o(u) : _e.createElement(hyt, { toast: u, position: c }));
  }));
}, _ee = Ks;
function gbt({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return _ee.success(n.message, {
          style: {
            background: "#10B981",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#059669",
            secondary: "#ffffff"
          }
        });
      case "danger":
        return _ee.error(n.message, {
          style: {
            background: "#E11D48",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#BE123C",
            secondary: "#ffffff"
          }
        });
    }
  }
  return /* @__PURE__ */ oe.jsxs(Sfe.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ oe.jsx(
      yyt,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
function byt({ children: e, fallback: t = null }) {
  return Wgt() ? /* @__PURE__ */ oe.jsx(oe.Fragment, { children: e() }) : /* @__PURE__ */ oe.jsx(oe.Fragment, { children: t });
}
function mbt({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ oe.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ oe.jsx(
    emt,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ oe.jsx(Nfe, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ oe.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ oe.jsx(yhe, {}) });
}
function vbt({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = E(null), a = (l) => i(l), s = () => {
    var y, f, v, b;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function p(L) {
      const w = c.find((D) => D.types[0] === L);
      return w ? w.long_name : "";
    }
    function d(L) {
      const w = c.find((D) => D.types[0] === L);
      return w ? w.short_name : "";
    }
    if (u) {
      const L = p("route"), w = p("street_number"), D = p("sublocality_level_1"), x = p("administrative_area_level_2"), m = p("administrative_area_level_1"), C = d("administrative_area_level_1"), S = p("postal_code"), U = (f = (y = u.geometry) == null ? void 0 : y.location) == null ? void 0 : f.lat(), k = (b = (v = u.geometry) == null ? void 0 : v.location) == null ? void 0 : b.lng();
      t && t({
        street: L,
        city: x,
        state: m,
        district: D,
        cep: S,
        streetNumber: w,
        stateShortName: C,
        coordinates: { lat: U, lng: k }
      });
    }
  };
  return /* @__PURE__ */ oe.jsx(
    Zfe,
    {
      onLoad: a,
      onPlacesChanged: s,
      options: n,
      children: /* @__PURE__ */ oe.jsx(CL, { type: "text", onChange: (l) => e(l.target.value), ...r })
    }
  );
}
function Yfe(e) {
  const { dataLayer: t, dataLayerName: n } = e;
  return `
  window.${n} = window.${n} || [];
  window.${n}.push(${JSON.stringify(t)})`;
}
function wyt(e) {
  const { id: t, events: n, dataLayer: r, dataLayerName: o, preview: i, auth: a } = e, s = `&gtm_auth=${a}`, l = `&gtm_preview=${i}`;
  t || console.warn("GTM Id is required");
  const u = `
    <iframe src="https://www.googletagmanager.com/ns.html?id=${t}${s}${l}&gtm_cookies_win=x"
      height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>`, c = `
    (function(w,d,s,l,i){w[l]=w[l]||[];
      w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', ${JSON.stringify(
    n
  ).slice(1, -1)}});
      var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
      j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'${s}${l}&gtm_cookies_win=x';
      f.parentNode.insertBefore(j,f);
    })(window,document,'script','${o}','${t}');`, p = Yfe({ dataLayer: r, dataLayerName: o });
  return {
    iframe: u,
    script: c,
    dataLayerVar: p
  };
}
let Oyt = class {
  initializeDataScript(t) {
    const n = document.createElement("script");
    return n.innerHTML = t, n;
  }
  initializeGTMElements(t) {
    const n = wyt(t), r = () => {
      const a = document.createElement("noscript");
      return a.innerHTML = n.iframe, a;
    }, o = () => {
      const a = document.createElement("script");
      return a.innerHTML = n.script, a;
    }, i = this.initializeDataScript(n.dataLayerVar);
    return {
      noScript: r,
      script: o,
      dataScript: i
    };
  }
  initializeDataLayer(t) {
    const { dataLayer: n, dataLayerName: r } = t;
    if (window[r]) return window[r].push(n);
    const o = Yfe({ dataLayer: n, dataLayerName: r }), i = this.initializeDataScript(o);
    document.head.insertBefore(i, document.head.childNodes[0]);
  }
  initialize(t) {
    const {
      events: n,
      gtmId: r,
      dataLayer: o,
      auth: i = "",
      preview: a = "",
      dataLayerName: s = "dataLayer"
    } = t, l = this.initializeGTMElements({
      id: r,
      events: n,
      dataLayer: o || void 0,
      dataLayerName: s,
      auth: i,
      preview: a
    });
    o && document.head.appendChild(l.dataScript), document.head.insertBefore(l.script(), document.head.childNodes[0]), document.body.insertBefore(l.noScript(), document.body.childNodes[0]);
  }
};
function Cyt(e) {
  return new Oyt().initialize(e), /* @__PURE__ */ oe.jsx(oe.Fragment, {});
}
function bbt(e) {
  const {
    gtmId: t,
    auth: n = "",
    preview: r = "",
    dataLayerName: o = "dataLayer",
    events: i = {},
    dataLayer: a = {}
  } = e;
  return /* @__PURE__ */ oe.jsx(byt, { children: () => /* @__PURE__ */ oe.jsx(
    Cyt,
    {
      auth: n,
      dataLayer: a,
      dataLayerName: o,
      events: i,
      gtmId: t,
      preview: r
    }
  ) });
}
export {
  Myt as AlertContainer,
  Dyt as AlertContent,
  _yt as AlertDescription,
  Tyt as AlertIcon,
  xhe as AlertTitle,
  $yt as AudioUpload,
  Byt as Badge,
  tbt as BreadcrumbContainer,
  nbt as BreadcrumbLink,
  V1 as Button,
  Nyt as Card,
  Zyt as Checkbox,
  byt as ClientOnly,
  Ryt as Divider,
  obt as DrawerContainer,
  ibt as DrawerHeader,
  pbt as DrawerProvider,
  ZY as FormController,
  qyt as FormError,
  qY as FormLabel,
  mbt as GoogleMap,
  fbt as GoogleProvider,
  vbt as GoogleSearchPlaces,
  bbt as GoogleTagManager,
  jut as IconButton,
  Fut as ImageUpload,
  CL as Input,
  Lft as ModalContainer,
  Eft as ModalFooter,
  kft as ModalHeader,
  hbt as ModalProvider,
  Xyt as MultiSelect,
  rbt as Pagination,
  sbt as Popover,
  Gyt as RadioBox,
  Kyt as RadioGroup,
  Yyt as RichText,
  Jyt as Select,
  Fyt as Skeleton,
  Dut as Slider,
  Qyt as Switch,
  jJ as TabButton,
  Sft as TabContainer,
  zyt as TableBody,
  Uyt as TableCaption,
  Wyt as TableContainer,
  Hyt as TableFooter,
  Vyt as TableHeader,
  ebt as Textarea,
  abt as Toast,
  gbt as ToastProvider,
  Aut as Tooltip,
  jyt as getHtmlFromRichTextValue,
  Ayt as getRichTextValueFromHtml,
  Iyt as isHtml,
  bte as morpheme,
  lbt as useAutomation,
  ubt as useDrawer,
  dde as useFieldErrors,
  _s as useFormController,
  Wgt as useHydrated,
  cbt as useModal,
  ife as useScopedParams,
  zgt as useToast
};
