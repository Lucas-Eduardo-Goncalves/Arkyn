var CI = Object.defineProperty;
var EI = (e, t, n) => t in e ? CI(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var lu = (e, t, n) => EI(e, typeof t != "symbol" ? t + "" : t, n);
import * as Ue from "react";
import Oe, { createContext as Ve, useContext as _e, Children as Ct, forwardRef as Tr, useState as _, useEffect as y, memo as De, useRef as Ye, useMemo as qn, isValidElement as mi, cloneElement as vi, Component as Kd, PureComponent as Ee, createRef as eo, useId as xI, useCallback as Yt, useLayoutEffect as OI, useReducer as kI, useSyncExternalStore as _I } from "react";
import { Info as PP, AlertTriangle as LI, XCircle as SP, CheckCircle2 as MP, Loader2 as vo, Pause as DI, Play as PI, RefreshCw as tv, Check as Xd, FileImage as SI, FileAudio as MI, FileArchive as TI, File as jI, ChevronDown as nv, X as rv, Search as TP, Image as AI, Heading1 as BI, Heading2 as II, Quote as FI, Bold as RI, Italic as NI, Underline as zI, Code as $I, AlignLeft as UI, AlignRight as HI, AlignCenter as WI, AlignJustify as VI, ChevronRight as kg, ChevronLeft as ZI, Ellipsis as Ib, MapPinned as qI } from "lucide-react";
import { useActionData as ov, useNavigation as jP, useFetchers as iv, useLocation as sv, Link as GI, useNavigate as AP } from "@remix-run/react";
import { InputMask as Ml } from "@react-input/mask";
import { AnimatePresence as BP, motion as Qa } from "framer-motion";
import * as yi from "react-dom";
import Tl, { createPortal as dr } from "react-dom";
var rn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Jd(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var _g = { exports: {} }, ra = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Fb;
function YI() {
  if (Fb) return ra;
  Fb = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, d = {}, p = null, g = null;
    u !== void 0 && (p = "" + u), l.key !== void 0 && (p = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (d[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) d[c] === void 0 && (d[c] = l[c]);
    return { $$typeof: t, type: a, key: p, ref: g, props: d, _owner: o.current };
  }
  return ra.Fragment = n, ra.jsx = s, ra.jsxs = s, ra;
}
var oa = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Rb;
function KI() {
  return Rb || (Rb = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var $ = f && b[f] || b[m];
      return typeof $ == "function" ? $ : null;
    }
    var C = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var $ = arguments.length, Q = new Array($ > 1 ? $ - 1 : 0), re = 1; re < $; re++)
          Q[re - 1] = arguments[re];
        P("error", b, Q);
      }
    }
    function P(b, $, Q) {
      {
        var re = C.ReactDebugCurrentFrame, ge = re.getStackAddendum();
        ge !== "" && ($ += "%s", Q = Q.concat([ge]));
        var me = Q.map(function(le) {
          return String(le);
        });
        me.unshift("Warning: " + $), Function.prototype.apply.call(console[b], console, me);
      }
    }
    var E = !1, v = !1, x = !1, L = !1, z = !1, k;
    k = Symbol.for("react.module.reference");
    function R(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || z || b === o || b === u || b === c || L || b === g || E || v || x || typeof b == "object" && b !== null && (b.$$typeof === p || b.$$typeof === d || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === k || b.getModuleId !== void 0));
    }
    function A(b, $, Q) {
      var re = b.displayName;
      if (re)
        return re;
      var ge = $.displayName || $.name || "";
      return ge !== "" ? Q + "(" + ge + ")" : Q;
    }
    function U(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var $ = b;
            return U($) + ".Consumer";
          case s:
            var Q = b;
            return U(Q._context) + ".Provider";
          case l:
            return A(b, b.render, "ForwardRef");
          case d:
            var re = b.displayName || null;
            return re !== null ? re : V(b.type) || "Memo";
          case p: {
            var ge = b, me = ge._payload, le = ge._init;
            try {
              return V(le(me));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var N = Object.assign, Z = 0, K, X, te, ee, D, j, G;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function Y() {
      {
        if (Z === 0) {
          K = console.log, X = console.info, te = console.warn, ee = console.error, D = console.group, j = console.groupCollapsed, G = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: N({}, b, {
              value: K
            }),
            info: N({}, b, {
              value: X
            }),
            warn: N({}, b, {
              value: te
            }),
            error: N({}, b, {
              value: ee
            }),
            group: N({}, b, {
              value: D
            }),
            groupCollapsed: N({}, b, {
              value: j
            }),
            groupEnd: N({}, b, {
              value: G
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = C.ReactCurrentDispatcher, W;
    function T(b, $, Q) {
      {
        if (W === void 0)
          try {
            throw Error();
          } catch (ge) {
            var re = ge.stack.trim().match(/\n( *(at )?)/);
            W = re && re[1] || "";
          }
        return `
` + W + b;
      }
    }
    var q = !1, I;
    {
      var J = typeof WeakMap == "function" ? WeakMap : Map;
      I = new J();
    }
    function H(b, $) {
      if (!b || q)
        return "";
      {
        var Q = I.get(b);
        if (Q !== void 0)
          return Q;
      }
      var re;
      q = !0;
      var ge = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var me;
      me = M.current, M.current = null, Y();
      try {
        if ($) {
          var le = function() {
            throw Error();
          };
          if (Object.defineProperty(le.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(le, []);
            } catch (ze) {
              re = ze;
            }
            Reflect.construct(b, [], le);
          } else {
            try {
              le.call();
            } catch (ze) {
              re = ze;
            }
            b.call(le.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ze) {
            re = ze;
          }
          b();
        }
      } catch (ze) {
        if (ze && re && typeof ze.stack == "string") {
          for (var se = ze.stack.split(`
`), Be = re.stack.split(`
`), ke = se.length - 1, Le = Be.length - 1; ke >= 1 && Le >= 0 && se[ke] !== Be[Le]; )
            Le--;
          for (; ke >= 1 && Le >= 0; ke--, Le--)
            if (se[ke] !== Be[Le]) {
              if (ke !== 1 || Le !== 1)
                do
                  if (ke--, Le--, Le < 0 || se[ke] !== Be[Le]) {
                    var We = `
` + se[ke].replace(" at new ", " at ");
                    return b.displayName && We.includes("<anonymous>") && (We = We.replace("<anonymous>", b.displayName)), typeof b == "function" && I.set(b, We), We;
                  }
                while (ke >= 1 && Le >= 0);
              break;
            }
        }
      } finally {
        q = !1, M.current = me, O(), Error.prepareStackTrace = ge;
      }
      var dn = b ? b.displayName || b.name : "", Ht = dn ? T(dn) : "";
      return typeof b == "function" && I.set(b, Ht), Ht;
    }
    function ce(b, $, Q) {
      return H(b, !1);
    }
    function ye(b) {
      var $ = b.prototype;
      return !!($ && $.isReactComponent);
    }
    function ie(b, $, Q) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return H(b, ye(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ce(b.render);
          case d:
            return ie(b.type, $, Q);
          case p: {
            var re = b, ge = re._payload, me = re._init;
            try {
              return ie(me(ge), $, Q);
            } catch {
            }
          }
        }
      return "";
    }
    var Te = Object.prototype.hasOwnProperty, Re = {}, Ne = C.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var $ = b._owner, Q = ie(b.type, b._source, $ ? $.type : null);
        Ne.setExtraStackFrame(Q);
      } else
        Ne.setExtraStackFrame(null);
    }
    function Ke(b, $, Q, re, ge) {
      {
        var me = Function.call.bind(Te);
        for (var le in b)
          if (me(b, le)) {
            var se = void 0;
            try {
              if (typeof b[le] != "function") {
                var Be = Error((re || "React class") + ": " + Q + " type `" + le + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[le] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Be.name = "Invariant Violation", Be;
              }
              se = b[le]($, le, re, Q, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ke) {
              se = ke;
            }
            se && !(se instanceof Error) && (Ie(ge), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", re || "React class", Q, le, typeof se), Ie(null)), se instanceof Error && !(se.message in Re) && (Re[se.message] = !0, Ie(ge), w("Failed %s type: %s", Q, se.message), Ie(null));
          }
      }
    }
    var Ze = Array.isArray;
    function Se(b) {
      return Ze(b);
    }
    function qe(b) {
      {
        var $ = typeof Symbol == "function" && Symbol.toStringTag, Q = $ && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return Q;
      }
    }
    function rt(b) {
      try {
        return Pe(b), !1;
      } catch {
        return !0;
      }
    }
    function Pe(b) {
      return "" + b;
    }
    function Me(b) {
      if (rt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qe(b)), Pe(b);
    }
    var Ge = C.ReactCurrentOwner, He = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, $e, ot;
    function Fe(b) {
      if (Te.call(b, "ref")) {
        var $ = Object.getOwnPropertyDescriptor(b, "ref").get;
        if ($ && $.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function Kt(b) {
      if (Te.call(b, "key")) {
        var $ = Object.getOwnPropertyDescriptor(b, "key").get;
        if ($ && $.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function lt(b, $) {
      typeof b.ref == "string" && Ge.current;
    }
    function ht(b, $) {
      {
        var Q = function() {
          $e || ($e = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", $));
        };
        Q.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: Q,
          configurable: !0
        });
      }
    }
    function Dt(b, $) {
      {
        var Q = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", $));
        };
        Q.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: Q,
          configurable: !0
        });
      }
    }
    var ln = function(b, $, Q, re, ge, me, le) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: $,
        ref: Q,
        props: le,
        // Record the component responsible for creating this element.
        _owner: me
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: re
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ge
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function Pt(b, $, Q, re, ge) {
      {
        var me, le = {}, se = null, Be = null;
        Q !== void 0 && (Me(Q), se = "" + Q), Kt($) && (Me($.key), se = "" + $.key), Fe($) && (Be = $.ref, lt($, ge));
        for (me in $)
          Te.call($, me) && !He.hasOwnProperty(me) && (le[me] = $[me]);
        if (b && b.defaultProps) {
          var ke = b.defaultProps;
          for (me in ke)
            le[me] === void 0 && (le[me] = ke[me]);
        }
        if (se || Be) {
          var Le = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && ht(le, Le), Be && Dt(le, Le);
        }
        return ln(b, se, Be, ge, re, Ge.current, le);
      }
    }
    var St = C.ReactCurrentOwner, ut = C.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var $ = b._owner, Q = ie(b.type, b._source, $ ? $.type : null);
        ut.setExtraStackFrame(Q);
      } else
        ut.setExtraStackFrame(null);
    }
    var un;
    un = !1;
    function cn(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Nt() {
      {
        if (St.current) {
          var b = V(St.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function Gn(b) {
      return "";
    }
    var zt = {};
    function Yn(b) {
      {
        var $ = Nt();
        if (!$) {
          var Q = typeof b == "string" ? b : b.displayName || b.name;
          Q && ($ = `

Check the top-level render call using <` + Q + ">.");
        }
        return $;
      }
    }
    function $t(b, $) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var Q = Yn($);
        if (zt[Q])
          return;
        zt[Q] = !0;
        var re = "";
        b && b._owner && b._owner !== St.current && (re = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Q, re), Xe(null);
      }
    }
    function Sn(b, $) {
      {
        if (typeof b != "object")
          return;
        if (Se(b))
          for (var Q = 0; Q < b.length; Q++) {
            var re = b[Q];
            cn(re) && $t(re, $);
          }
        else if (cn(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ge = h(b);
          if (typeof ge == "function" && ge !== b.entries)
            for (var me = ge.call(b), le; !(le = me.next()).done; )
              cn(le.value) && $t(le.value, $);
        }
      }
    }
    function pr(b) {
      {
        var $ = b.type;
        if ($ == null || typeof $ == "string")
          return;
        var Q;
        if (typeof $ == "function")
          Q = $.propTypes;
        else if (typeof $ == "object" && ($.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        $.$$typeof === d))
          Q = $.propTypes;
        else
          return;
        if (Q) {
          var re = V($);
          Ke(Q, b.props, "prop", re, b);
        } else if ($.PropTypes !== void 0 && !un) {
          un = !0;
          var ge = V($);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ge || "Unknown");
        }
        typeof $.getDefaultProps == "function" && !$.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ut(b) {
      {
        for (var $ = Object.keys(b.props), Q = 0; Q < $.length; Q++) {
          var re = $[Q];
          if (re !== "children" && re !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", re), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var oe = {};
    function to(b, $, Q, re, ge, me) {
      {
        var le = R(b);
        if (!le) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Be = Gn();
          Be ? se += Be : se += Nt();
          var ke;
          b === null ? ke = "null" : Se(b) ? ke = "array" : b !== void 0 && b.$$typeof === t ? (ke = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : ke = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ke, se);
        }
        var Le = Pt(b, $, Q, ge, me);
        if (Le == null)
          return Le;
        if (le) {
          var We = $.children;
          if (We !== void 0)
            if (re)
              if (Se(We)) {
                for (var dn = 0; dn < We.length; dn++)
                  Sn(We[dn], b);
                Object.freeze && Object.freeze(We);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Sn(We, b);
        }
        if (Te.call($, "key")) {
          var Ht = V(b), ze = Object.keys($).filter(function(Fi) {
            return Fi !== "key";
          }), fr = ze.length > 0 ? "{key: someKey, " + ze.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!oe[Ht + fr]) {
            var Ii = ze.length > 0 ? "{" + ze.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, fr, Ht, Ii, Ht), oe[Ht + fr] = !0;
          }
        }
        return b === r ? Ut(Le) : pr(Le), Le;
      }
    }
    function Ti(b, $, Q) {
      return to(b, $, Q, !0);
    }
    function ji(b, $, Q) {
      return to(b, $, Q, !1);
    }
    var Ai = ji, Bi = Ti;
    oa.Fragment = r, oa.jsx = Ai, oa.jsxs = Bi;
  }()), oa;
}
process.env.NODE_ENV === "production" ? _g.exports = YI() : _g.exports = KI();
var B = _g.exports;
function XI(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ B.jsx("div", { className: r.trim(), ...n });
}
const IP = Ve({});
function JI() {
  return _e(IP);
}
function Kle(e) {
  const { schema: t, children: n, className: r, ...o } = e, a = !((u) => {
    let c = !1;
    const d = (p) => {
      Array.isArray(p) ? p.forEach(d) : p && typeof p == "object" && "type" in p && (p.type === XI ? c = !0 : p.props && p.props.children && d(p.props.children));
    };
    return d(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${t} ${a} ${r}`;
  return /* @__PURE__ */ B.jsx(IP.Provider, { value: e, children: /* @__PURE__ */ B.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function Xle(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ B.jsx("div", { className: r.trim(), ...n });
}
function Jle(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ B.jsx("div", { className: r.trim(), ...n });
}
function Qle(e) {
  const { className: t, ...n } = e, { schema: r } = JI(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ B.jsx(MP, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ B.jsx(SP, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ B.jsx(LI, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ B.jsx(PP, { className: o, ...n });
  }
}
function Fc(e, t) {
  return t ? /* @__PURE__ */ B.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ B.jsx(B.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Nb(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function tr(e) {
  var t, n;
  return Nb(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(Nb(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var FP = Symbol.for("immer-nothing"), zb = Symbol.for("immer-draftable"), zr = Symbol.for("immer-state"), QI = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Or(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = QI[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Ns = Object.getPrototypeOf;
function ps(e) {
  return !!e && !!e[zr];
}
function fs(e) {
  var t;
  return e ? RP(e) || Array.isArray(e) || !!e[zb] || !!((t = e.constructor) != null && t[zb]) || ep(e) || tp(e) : !1;
}
var eF = Object.prototype.constructor.toString();
function RP(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Ns(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === eF;
}
function Rc(e, t) {
  Qd(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Qd(e) {
  const t = e[zr];
  return t ? t.type_ : Array.isArray(e) ? 1 : ep(e) ? 2 : tp(e) ? 3 : 0;
}
function Lg(e, t) {
  return Qd(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function NP(e, t, n) {
  const r = Qd(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function tF(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function ep(e) {
  return e instanceof Map;
}
function tp(e) {
  return e instanceof Set;
}
function qi(e) {
  return e.copy_ || e.base_;
}
function Dg(e, t) {
  if (ep(e))
    return new Map(e);
  if (tp(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = RP(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[zr];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(Ns(e), r);
  } else {
    const r = Ns(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function av(e, t = !1) {
  return np(e) || ps(e) || !fs(e) || (Qd(e) > 1 && (e.set = e.add = e.clear = e.delete = nF), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => av(r, !0))), e;
}
function nF() {
  Or(2);
}
function np(e) {
  return Object.isFrozen(e);
}
var rF = {};
function hs(e) {
  const t = rF[e];
  return t || Or(0, e), t;
}
var el;
function zP() {
  return el;
}
function oF(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function $b(e, t) {
  t && (hs("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Pg(e) {
  Sg(e), e.drafts_.forEach(iF), e.drafts_ = null;
}
function Sg(e) {
  e === el && (el = e.parent_);
}
function Ub(e) {
  return el = oF(el, e);
}
function iF(e) {
  const t = e[zr];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function Hb(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[zr].modified_ && (Pg(t), Or(4)), fs(e) && (e = Nc(t, e), t.parent_ || zc(t, e)), t.patches_ && hs("Patches").generateReplacementPatches_(
    n[zr].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Nc(t, n, []), Pg(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== FP ? e : void 0;
}
function Nc(e, t, n) {
  if (np(t))
    return t;
  const r = t[zr];
  if (!r)
    return Rc(
      t,
      (o, i) => Wb(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return zc(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Rc(
      i,
      (a, l) => Wb(e, r, o, a, l, n, s)
    ), zc(e, o, !1), n && e.patches_ && hs("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Wb(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && Or(5), ps(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Lg(t.assigned_, r) ? i.concat(r) : void 0, l = Nc(e, o, a);
    if (NP(n, r, l), ps(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (fs(o) && !np(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Nc(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && zc(e, o);
  }
}
function zc(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && av(t, n);
}
function sF(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : zP(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = lv;
  n && (o = [r], i = tl);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var lv = {
  get(e, t) {
    if (t === zr)
      return e;
    const n = qi(e);
    if (!Lg(n, t))
      return aF(e, n, t);
    const r = n[t];
    return e.finalized_ || !fs(r) ? r : r === Pf(e.base_, t) ? (Sf(e), e.copy_[t] = Tg(r, e)) : r;
  },
  has(e, t) {
    return t in qi(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(qi(e));
  },
  set(e, t, n) {
    const r = $P(qi(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Pf(qi(e), t), i = o == null ? void 0 : o[zr];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (tF(n, o) && (n !== void 0 || Lg(e.base_, t)))
        return !0;
      Sf(e), Mg(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Pf(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Sf(e), Mg(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = qi(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Or(11);
  },
  getPrototypeOf(e) {
    return Ns(e.base_);
  },
  setPrototypeOf() {
    Or(12);
  }
}, tl = {};
Rc(lv, (e, t) => {
  tl[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
tl.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Or(13), tl.set.call(this, e, t, void 0);
};
tl.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Or(14), lv.set.call(this, e[0], t, n, e[0]);
};
function Pf(e, t) {
  const n = e[zr];
  return (n ? qi(n) : e)[t];
}
function aF(e, t, n) {
  var o;
  const r = $P(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function $P(e, t) {
  if (!(t in e))
    return;
  let n = Ns(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Ns(n);
  }
}
function Mg(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Mg(e.parent_));
}
function Sf(e) {
  e.copy_ || (e.copy_ = Dg(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var lF = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(l = i, ...u) {
          return s.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && Or(6), r !== void 0 && typeof r != "function" && Or(7);
      let o;
      if (fs(t)) {
        const i = Ub(this), s = Tg(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? Pg(i) : Sg(i);
        }
        return $b(i, r), Hb(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === FP && (o = void 0), this.autoFreeze_ && av(o, !0), r) {
          const i = [], s = [];
          hs("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        Or(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (s, ...a) => this.produceWithPatches(s, (l) => t(l, ...a));
      let r, o;
      return [this.produce(t, n, (s, a) => {
        r = s, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    fs(e) || Or(8), ps(e) && (e = uF(e));
    const t = Ub(this), n = Tg(e, void 0);
    return n[zr].isManual_ = !0, Sg(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[zr];
    (!n || !n.isManual_) && Or(9);
    const { scope_: r } = n;
    return $b(r, t), Hb(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = hs("Patches").applyPatches_;
    return ps(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Tg(e, t) {
  const n = ep(e) ? hs("MapSet").proxyMap_(e, t) : tp(e) ? hs("MapSet").proxySet_(e, t) : sF(e, t);
  return (t ? t.scope_ : zP()).drafts_.push(n), n;
}
function uF(e) {
  return ps(e) || Or(10, e), UP(e);
}
function UP(e) {
  if (!fs(e) || np(e))
    return e;
  const t = e[zr];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Dg(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Dg(e, !0);
  return Rc(n, (r, o) => {
    NP(n, r, UP(o));
  }), t && (t.finalized_ = !1), n;
}
var $r = new lF(), uv = $r.produce;
$r.produceWithPatches.bind(
  $r
);
$r.setAutoFreeze.bind($r);
$r.setUseStrictShallowCopy.bind($r);
$r.applyPatches.bind($r);
var Vb = $r.createDraft.bind($r), Zb = $r.finishDraft.bind($r), cF = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ne.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, dF = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ct.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, pF = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ae.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, $c = /* @__PURE__ */ new WeakMap(), Uc = /* @__PURE__ */ new WeakMap(), ja = /* @__PURE__ */ new WeakMap(), HP = /* @__PURE__ */ new WeakMap(), qb = /* @__PURE__ */ new WeakMap(), Gb = /* @__PURE__ */ new WeakMap(), Yb = /* @__PURE__ */ new WeakMap(), ne = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = ne.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return ne.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return ne.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return ne.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return ne.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && ne.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return ne.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && ne.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && ne.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && ne.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && ne.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && ne.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!ne.isAncestor(t, e) && !ne.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (ne.equals(i, r) || ne.endsBefore(i, r) || ne.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (ne.equals(s, r) || ne.isAncestor(s, r))
          return null;
        ne.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        ne.equals(a, r) || ne.endsBefore(a, r) ? r[a.length - 1] -= 1 : ne.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (ne.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else ne.endsBefore(u, r) ? r[u.length - 1] += 1 : ne.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: d,
          newPath: p
        } = t;
        if (ne.equals(d, p))
          return r;
        if (ne.isAncestor(d, r) || ne.equals(d, r)) {
          var g = p.slice();
          return ne.endsBefore(d, p) && d.length < p.length && (g[d.length - 1] -= 1), g.concat(r.slice(d.length));
        } else ne.isSibling(d, p) && (ne.isAncestor(p, r) || ne.equals(p, r)) ? ne.endsBefore(d, r) ? r[d.length - 1] -= 1 : r[d.length - 1] += 1 : ne.endsBefore(p, r) || ne.equals(p, r) || ne.isAncestor(p, r) ? (ne.endsBefore(d, r) && (r[d.length - 1] -= 1), r[p.length - 1] += 1) : ne.endsBefore(d, r) && (ne.equals(p, r) && (r[p.length - 1] += 1), r[d.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function nl(e) {
  "@babel/helpers - typeof";
  return nl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, nl(e);
}
function fF(e, t) {
  if (nl(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (nl(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function hF(e) {
  var t = fF(e, "string");
  return nl(t) === "symbol" ? t : String(t);
}
function vr(e, t, n) {
  return t = hF(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Kb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ia(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Kb(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Kb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gF = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = xe.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of ae.points(t))
          t[l] = ct.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: d
      } = n;
      if (d.length === 0) break;
      var p = xe.leaf(e, u), g = p.text.slice(0, c), f = p.text.slice(c);
      if (p.text = g + d + f, t)
        for (var [m, h] of ae.points(t))
          t[h] = ct.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: C
      } = n, w = xe.get(e, C), P = ne.previous(C), E = xe.get(e, P), v = xe.parent(e, C), x = C[C.length - 1];
      if (Ae.isText(w) && Ae.isText(E))
        E.text += w.text;
      else if (!Ae.isText(w) && !Ae.isText(E))
        E.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(C, "] to nodes of different interfaces: ").concat(er.stringify(w), " ").concat(er.stringify(E)));
      if (v.children.splice(x, 1), t)
        for (var [L, z] of ae.points(t))
          t[z] = ct.transform(L, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: R
      } = n;
      if (ne.isAncestor(k, R))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(R, "] because the destination is inside itself."));
      var A = xe.get(e, k), U = xe.parent(e, k), V = k[k.length - 1];
      U.children.splice(V, 1);
      var N = ne.transform(k, n), Z = xe.get(e, ne.parent(N)), K = N[N.length - 1];
      if (Z.children.splice(K, 0, A), t)
        for (var [X, te] of ae.points(t))
          t[te] = ct.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, D = ee[ee.length - 1], j = xe.parent(e, ee);
      if (j.children.splice(D, 1), t)
        for (var [G, S] of ae.points(t)) {
          var Y = ct.transform(G, n);
          if (t != null && Y != null)
            t[S] = Y;
          else {
            var O = void 0, M = void 0;
            for (var [W, T] of xe.texts(e))
              if (ne.compare(T, ee) === -1)
                O = [W, T];
              else {
                M = [W, T];
                break;
              }
            var q = !1;
            O && M && (ne.equals(M[1], ee) ? q = !ne.hasPrevious(M[1]) : q = ne.common(O[1], ee).length < ne.common(M[1], ee).length), O && !q ? (G.path = O[1], G.offset = O[0].text.length) : M ? (G.path = M[1], G.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: I,
        offset: J,
        text: H
      } = n;
      if (H.length === 0) break;
      var ce = xe.leaf(e, I), ye = ce.text.slice(0, J), ie = ce.text.slice(J + H.length);
      if (ce.text = ye + ie, t)
        for (var [Te, Re] of ae.points(t))
          t[Re] = ct.transform(Te, n);
      break;
    }
    case "set_node": {
      var {
        path: Ne,
        properties: Ie,
        newProperties: Ke
      } = n;
      if (Ne.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ze = xe.get(e, Ne);
      for (var Se in Ke) {
        if (Se === "children" || Se === "text")
          throw new Error('Cannot set the "'.concat(Se, '" property of nodes!'));
        var qe = Ke[Se];
        qe == null ? delete Ze[Se] : Ze[Se] = qe;
      }
      for (var rt in Ie)
        Ke.hasOwnProperty(rt) || delete Ze[rt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Pe
      } = n;
      if (Pe == null)
        t = Pe;
      else {
        if (t == null) {
          if (!ae.isRange(Pe))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(er.stringify(Pe), " when there is no current selection."));
          t = ia({}, Pe);
        }
        for (var Me in Pe) {
          var Ge = Pe[Me];
          if (Ge == null) {
            if (Me === "anchor" || Me === "focus")
              throw new Error('Cannot remove the "'.concat(Me, '" selection property'));
            delete t[Me];
          } else
            t[Me] = Ge;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: He,
        position: $e,
        properties: ot
      } = n;
      if (He.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(He, "] because the root node cannot be split."));
      var Fe = xe.get(e, He), Kt = xe.parent(e, He), lt = He[He.length - 1], ht;
      if (Ae.isText(Fe)) {
        var Dt = Fe.text.slice(0, $e), ln = Fe.text.slice($e);
        Fe.text = Dt, ht = ia(ia({}, ot), {}, {
          text: ln
        });
      } else {
        var Pt = Fe.children.slice(0, $e), St = Fe.children.slice($e);
        Fe.children = Pt, ht = ia(ia({}, ot), {}, {
          children: St
        });
      }
      if (Kt.children.splice(lt + 1, 0, ht), t)
        for (var [ut, Xe] of ae.points(t))
          t[Xe] = ct.transform(ut, n);
      break;
    }
  }
  return t;
}, mF = {
  transform(e, t) {
    e.children = Vb(e.children);
    var n = e.selection && Vb(e.selection);
    try {
      n = gF(e, n, t);
    } finally {
      e.children = Zb(e.children), n ? e.selection = ps(n) ? Zb(n) : n : e.selection = null;
    }
  }
}, vF = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, yF = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, WP = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (tr(r) && tr(o)) {
      if (!WP(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function bF(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Ao(e, t) {
  if (e == null) return {};
  var n = bF(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var wF = ["anchor", "focus"];
function Xb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function CF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Xb(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Xb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ae = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return ae.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = ae.edges(e);
    return t;
  },
  equals(e, t) {
    return ct.equals(e.anchor, t.anchor) && ct.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (ae.isRange(t)) {
      if (ae.includes(e, t.anchor) || ae.includes(e, t.focus))
        return !0;
      var [n, r] = ae.edges(e), [o, i] = ae.edges(t);
      return ct.isBefore(n, o) && ct.isAfter(r, i);
    }
    var [s, a] = ae.edges(e), l = !1, u = !1;
    return ct.isPoint(t) ? (l = ct.compare(t, s) >= 0, u = ct.compare(t, a) <= 0) : (l = ne.compare(t, s.path) >= 0, u = ne.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Ao(e, wF), [r, o] = ae.edges(e), [i, s] = ae.edges(t), a = ct.isBefore(r, i) ? i : r, l = ct.isBefore(o, s) ? o : s;
    return ct.isBefore(l, a) ? null : CF({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return ct.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return ct.equals(t, n);
  },
  isExpanded(e) {
    return !ae.isCollapsed(e);
  },
  isForward(e) {
    return !ae.isBackward(e);
  },
  isRange(e) {
    return tr(e) && ct.isPoint(e.anchor) && ct.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = ae.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return uv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = ae.isCollapsed(r);
        ae.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? ae.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = ct.transform(r.anchor, t, {
        affinity: i
      }), u = ct.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, Jb = (e) => tr(e) && xe.isNodeList(e.children) && !F.isEditor(e), je = {
  isAncestor(e) {
    return tr(e) && xe.isNodeList(e.children);
  },
  isElement: Jb,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => je.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return Jb(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, EF = ["children"], xF = ["text"], Qb = /* @__PURE__ */ new WeakMap(), xe = {
  ancestor(e, t) {
    var n = xe.get(e, t);
    if (Ae.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(er.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ne.ancestors(t, n)) {
        var o = xe.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Ae.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(er.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(er.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = xe.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = xe.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = ne.common(t, n), o = xe.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = xe.get(e, t);
    if (F.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(er.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of xe.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of xe.nodes(e, t))
        je.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (je.isAncestor(e)) {
      var t = Ao(e, EF);
      return t;
    } else {
      var t = Ao(e, xF);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = xe.get(e, n); r && !(Ae.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Ae.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(er.stringify(e)));
    var n = uv({
      children: e.children
    }, (r) => {
      var [o, i] = ae.edges(t), s = xe.nodes(r, {
        reverse: !0,
        pass: (p) => {
          var [, g] = p;
          return !ae.includes(t, g);
        }
      });
      for (var [, a] of s) {
        if (!ae.includes(t, a)) {
          var l = xe.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (ne.equals(a, i.path)) {
          var c = xe.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (ne.equals(a, o.path)) {
          var d = xe.leaf(r, a);
          d.text = d.text.slice(o.offset);
        }
      }
      F.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ae.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(er.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ae.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Ae.isText(e) || je.isElement(e) || F.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = Qb.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => xe.isNode(r));
    return Qb.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = xe.get(e, n); r && !(Ae.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = xe.get(e, t);
    if (!Ae.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(er.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ne.levels(t, n)) {
        var o = xe.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return je.isElement(e) && je.isElementProps(t) && je.matches(e, t) || Ae.isText(e) && Ae.isTextProps(t) && Ae.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? ne.isBefore(a, i) : ne.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !Ae.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          ne.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = xe.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = ne.next(a);
          if (xe.has(e, c)) {
            a = c, l = xe.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var d = ne.previous(a);
          a = d, l = xe.get(e, a);
          continue;
        }
        a = ne.parent(a), l = xe.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = ne.parent(t), r = xe.get(e, n);
    if (Ae.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Ae.isText(e) ? e.text : e.children.map(xe.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of xe.nodes(e, t))
        Ae.isText(n) && (yield [n, r]);
    }();
  }
};
function e0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? e0(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : e0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pi = {
  isNodeOperation(e) {
    return pi.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!tr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return ne.isPath(e.path) && xe.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ne.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && ne.isPath(e.path) && tr(e.properties);
      case "move_node":
        return ne.isPath(e.path) && ne.isPath(e.newPath);
      case "remove_node":
        return ne.isPath(e.path) && xe.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ne.isPath(e.path);
      case "set_node":
        return ne.isPath(e.path) && tr(e.properties) && tr(e.newProperties);
      case "set_selection":
        return e.properties === null && ae.isRange(e.newProperties) || e.newProperties === null && ae.isRange(e.properties) || tr(e.properties) && tr(e.newProperties);
      case "split_node":
        return ne.isPath(e.path) && typeof e.position == "number" && tr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => pi.isOperation(t));
  },
  isSelectionOperation(e) {
    return pi.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return pi.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return yn(yn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return yn(yn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return yn(yn({}, e), {}, {
          type: "split_node",
          path: ne.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (ne.equals(t, n))
          return e;
        if (ne.isSibling(n, t))
          return yn(yn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = ne.transform(n, e), o = ne.transform(ne.next(n), e);
        return yn(yn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return yn(yn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return yn(yn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return yn(yn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? yn(yn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? yn(yn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : yn(yn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return yn(yn({}, e), {}, {
          type: "merge_node",
          path: ne.next(e.path)
        });
    }
  }
}, t0 = /* @__PURE__ */ new WeakMap(), OF = (e) => {
  var t = t0.get(e);
  if (t !== void 0)
    return t;
  if (!tr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || tr(e.marks)) && (e.selection === null || ae.isRange(e.selection)) && xe.isNodeList(e.children) && pi.isOperationList(e.operations);
  return t0.set(e, n), n;
}, F = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return OF(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, kF = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(ne.isPath);
  }
};
function n0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function r0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? n0(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : n0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ct = {
  compare(e, t) {
    var n = ne.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return ct.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return ct.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && ne.equals(e.path, t.path);
  },
  isPoint(e) {
    return tr(e) && typeof e.offset == "number" && ne.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return uv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = ne.transform(i, t, n);
          break;
        }
        case "insert_text": {
          ne.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          ne.equals(t.path, i) && (r.offset += t.position), r.path = ne.transform(i, t, n);
          break;
        }
        case "remove_text": {
          ne.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (ne.equals(t.path, i) || ne.isAncestor(t.path, i))
            return null;
          r.path = ne.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (ne.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = ne.transform(i, t, r0(r0({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = ne.transform(i, t, n);
          break;
        }
      }
    });
  }
}, o0 = void 0, er = {
  setScrubber(e) {
    o0 = e;
  },
  stringify(e) {
    return JSON.stringify(e, o0);
  }
}, _F = ["text"], LF = ["anchor", "focus"];
function i0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Eo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? i0(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : i0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ae = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = Ao(i, _F);
      return s;
    }
    return WP(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return tr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Ae.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Eo({}, e)];
    for (var r of t) {
      var o = Ao(r, LF), [i, s] = ae.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var d of n) {
        var {
          length: p
        } = d.text, g = l;
        if (l += p, u <= g && l <= c) {
          Object.assign(d, o), a.push(d);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          a.push(d);
          continue;
        }
        var f = d, m = void 0, h = void 0;
        if (c < l) {
          var C = c - g;
          h = Eo(Eo({}, f), {}, {
            text: f.text.slice(C)
          }), f = Eo(Eo({}, f), {}, {
            text: f.text.slice(0, C)
          });
        }
        if (u > g) {
          var w = u - g;
          m = Eo(Eo({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Eo(Eo({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && a.push(m), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, cv = (e) => e.selection ? e.selection : e.children.length > 0 ? F.end(e, []) : [0], Vs = (e, t) => {
  var [n] = F.node(e, t);
  return (r) => r === n;
}, dv = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? jF(t) : t, i = Je.None, s = Je.None, a = 0, l = null, u = null;
  for (var c of o) {
    var d = c.codePointAt(0);
    if (!d) break;
    var p = VF(c, d);
    if ([i, s] = r ? [s, p] : [p, i], Ss(i, Je.ZWJ) && Ss(s, Je.ExtPict) && (r ? l = s0(t.substring(0, a)) : l = s0(t.substring(0, t.length - a)), !l) || Ss(i, Je.RI) && Ss(s, Je.RI) && (u !== null ? u = !u : r ? u = !0 : u = KF(t.substring(0, t.length - a)), !u) || i !== Je.None && s !== Je.None && qF(i, s))
      break;
    a += c.length;
  }
  return a || 1;
}, DF = /\s/, PF = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, SF = /['\u2018\u2019]/, MF = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = dv(t, n), [s, a] = pv(t, i, n);
    if (TF(s, a, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = a;
  }
  return r;
}, pv = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, TF = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (DF.test(t))
    return !1;
  if (SF.test(t)) {
    var o = dv(n, r), [i, s] = pv(n, o, r);
    if (e(i, s, r))
      return !0;
  }
  return !PF.test(t);
}, jF = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (BF(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (AF(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, AF = (e) => e >= 55296 && e <= 56319, BF = (e) => e >= 56320 && e <= 57343, Je;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Je || (Je = {}));
var IF = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, FF = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, RF = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, NF = /^[\u1100-\u115F\uA960-\uA97C]$/, zF = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, $F = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, UF = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, HF = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, WF = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, VF = (e, t) => {
  var n = Je.Any;
  return e.search(IF) !== -1 && (n |= Je.Extend), t === 8205 && (n |= Je.ZWJ), t >= 127462 && t <= 127487 && (n |= Je.RI), e.search(FF) !== -1 && (n |= Je.Prepend), e.search(RF) !== -1 && (n |= Je.SpacingMark), e.search(NF) !== -1 && (n |= Je.L), e.search(zF) !== -1 && (n |= Je.V), e.search($F) !== -1 && (n |= Je.T), e.search(UF) !== -1 && (n |= Je.LV), e.search(HF) !== -1 && (n |= Je.LVT), e.search(WF) !== -1 && (n |= Je.ExtPict), n;
};
function Ss(e, t) {
  return (e & t) !== 0;
}
var ZF = [
  // GB6
  [Je.L, Je.L | Je.V | Je.LV | Je.LVT],
  // GB7
  [Je.LV | Je.V, Je.V | Je.T],
  // GB8
  [Je.LVT | Je.T, Je.T],
  // GB9
  [Je.Any, Je.Extend | Je.ZWJ],
  // GB9a
  [Je.Any, Je.SpacingMark],
  // GB9b
  [Je.Prepend, Je.Any],
  // GB11
  [Je.ZWJ, Je.ExtPict],
  // GB12 and GB13
  [Je.RI, Je.RI]
];
function qF(e, t) {
  return ZF.findIndex((n) => Ss(e, n[0]) && Ss(t, n[1])) === -1;
}
var GF = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, s0 = (e) => e.search(GF) !== -1, YF = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, KF = (e) => {
  var t = e.match(YF);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, XF = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    F.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = cv(e)
      } = n;
      if (ne.isPath(o) && (o = F.range(e, o)), ae.isRange(o))
        if (ae.isCollapsed(o))
          o = o.anchor;
        else {
          var i = ae.end(o);
          if (!r && F.void(e, {
            at: i
          }))
            return;
          var s = ae.start(o), a = F.pointRef(e, s), l = F.pointRef(e, i);
          ve.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, ve.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && F.void(e, {
        at: o
      }) || F.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: d,
          offset: p
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: d,
          offset: p,
          text: t
        });
      }
    });
  }
};
function a0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a0(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ve = uu(uu(uu(uu({}, mF), vF), yF), XF), Lc = /* @__PURE__ */ new WeakMap(), JF = (e) => Lc.get(e) || !1, QF = (e, t, n) => {
  var r = Lc.get(e) || !1;
  Lc.set(e, !0);
  try {
    t(), n();
  } finally {
    Lc.set(e, r);
  }
};
function VP(e, t, n) {
  var r = $c.get(e) || [], o = Uc.get(e) || /* @__PURE__ */ new Set(), i, s, a = (d) => {
    if (d) {
      var p = d.join(",");
      s.has(p) || (s.add(p), i.push(d));
    }
  };
  if (n) {
    i = [], s = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      a(u);
    }
  } else
    i = r, s = o;
  for (var c of t)
    a(c);
  $c.set(e, i), Uc.set(e, s);
}
var eR = (e, t) => {
  for (var n of F.pathRefs(e))
    cF.transform(n, t);
  for (var r of F.pointRefs(e))
    dF.transform(r, t);
  for (var o of F.rangeRefs(e))
    pF.transform(o, t);
  if (!JF(e)) {
    var i = ne.operationCanTransformPath(t) ? (s) => ne.transform(s, t) : void 0;
    VP(e, e.getDirtyPaths(t), i);
  }
  ve.transform(e, t), e.operations.push(t), F.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), ja.get(e) || (ja.set(e, !0), Promise.resolve().then(() => {
    ja.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, tR = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return ne.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = ne.levels(o), s = Ae.isText(r) ? [] : Array.from(xe.nodes(r), (R) => {
        var [, A] = R;
        return o.concat(A);
      });
      return [...i, ...s];
    }
    case "merge_node": {
      var {
        path: a
      } = t, l = ne.ancestors(a), u = ne.previous(a);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: d
      } = t;
      if (ne.equals(c, d))
        return [];
      var p = [], g = [];
      for (var f of ne.ancestors(c)) {
        var m = ne.transform(f, t);
        p.push(m);
      }
      for (var h of ne.ancestors(d)) {
        var C = ne.transform(h, t);
        g.push(C);
      }
      var w = g[g.length - 1], P = d[d.length - 1], E = w.concat(P);
      return [...p, ...g, E];
    }
    case "remove_node": {
      var {
        path: v
      } = t, x = ne.ancestors(v);
      return [...x];
    }
    case "split_node": {
      var {
        path: L
      } = t, z = ne.levels(L), k = ne.next(L);
      return [...z, k];
    }
    default:
      return [];
  }
}, nR = (e) => {
  var {
    selection: t
  } = e;
  return t ? xe.fragment(e, t) : [];
}, rR = (e, t) => {
  var [n, r] = t;
  if (!Ae.isText(n)) {
    if (je.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      ve.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = F.isEditor(n) ? !1 : je.isElement(n) && (e.isInline(n) || n.children.length === 0 || Ae.isText(n.children[0]) || e.isInline(n.children[0])), s = 0, a = 0; a < n.children.length; a++, s++) {
      var l = xe.get(e, r);
      if (!Ae.isText(l)) {
        var u = l.children[s], c = l.children[s - 1], d = a === n.children.length - 1, p = Ae.isText(u) || je.isElement(u) && e.isInline(u);
        if (p !== i)
          ve.removeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--;
        else if (je.isElement(u)) {
          if (e.isInline(u)) {
            if (c == null || !Ae.isText(c)) {
              var g = {
                text: ""
              };
              ve.insertNodes(e, g, {
                at: r.concat(s),
                voids: !0
              }), s++;
            } else if (d) {
              var f = {
                text: ""
              };
              ve.insertNodes(e, f, {
                at: r.concat(s + 1),
                voids: !0
              }), s++;
            }
          }
        } else {
          if (!Ae.isText(u) && !("children" in u)) {
            var m = u;
            m.children = [];
          }
          c != null && Ae.isText(c) && (Ae.equals(u, c, {
            loose: !0
          }) ? (ve.mergeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--) : c.text === "" ? (ve.removeNodes(e, {
            at: r.concat(s - 1),
            voids: !0
          }), s--) : u.text === "" && (ve.removeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--));
        }
      }
    }
  }
}, oR = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, iR = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: s
  } = n;
  if (i) {
    var a = F.path(t, i), l = o === "lowest";
    for (var [u, c] of F.levels(t, {
      at: a,
      voids: r,
      match: s,
      reverse: l
    }))
      if (!Ae.isText(u)) {
        if (ae.isRange(i)) {
          if (ne.isAncestor(c, i.anchor.path) && ne.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!ne.equals(a, c))
          return [u, c];
      }
  }
};
function l0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function u0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? l0(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : l0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sR = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (d, p) => {
      if (!Ae.isText(d))
        return !1;
      var [g, f] = F.parent(e, p);
      return !e.isVoid(g) || e.markableVoid(g);
    }, i = ae.isExpanded(r), s = !1;
    if (!i) {
      var [a, l] = F.node(e, r);
      if (a && o(a, l)) {
        var [u] = F.parent(e, l);
        s = u && e.markableVoid(u);
      }
    }
    if (i || s)
      ve.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = u0(u0({}, F.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, ja.get(e) || e.onChange();
    }
  }
};
function c0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function d0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? c0(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aR = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = F.point(t, n, {
    edge: "end"
  }), i = F.end(t, []), s = {
    anchor: o,
    focus: i
  }, {
    distance: a = 1
  } = r, l = 0, u;
  for (var c of F.positions(t, d0(d0({}, r), {}, {
    at: s
  }))) {
    if (l > a)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function p0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function f0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? p0(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : p0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lR = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = F.start(t, []), i = F.point(t, n, {
    edge: "start"
  }), s = {
    anchor: o,
    focus: i
  }, {
    distance: a = 1
  } = r, l = 0, u;
  for (var c of F.positions(t, f0(f0({}, r), {}, {
    at: s,
    reverse: !0
  }))) {
    if (l > a)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, uR = (e, t) => {
  var {
    selection: n
  } = e;
  n && ae.isCollapsed(n) && ve.delete(e, {
    unit: t,
    reverse: !0
  });
}, cR = (e, t) => {
  var {
    selection: n
  } = e;
  n && ae.isCollapsed(n) && ve.delete(e, {
    unit: t
  });
}, dR = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && ae.isExpanded(r) && ve.delete(t, {
    reverse: n === "backward"
  });
}, pR = (e, t) => [F.start(e, t), F.end(e, t)];
function h0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function g0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? h0(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : h0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var fR = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return F.above(t, g0(g0({}, n), {}, {
    match: (r) => je.isElement(r) && F.isElementReadOnly(t, r)
  }));
}, hR = (e, t) => F.point(e, t, {
  edge: "end"
}), gR = (e, t) => {
  var n = F.path(e, t, {
    edge: "start"
  });
  return F.node(e, n);
}, mR = (e, t) => {
  var n = F.range(e, t);
  return xe.fragment(e, n);
};
function m0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function v0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? m0(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : m0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vR = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return F.above(t, v0(v0({}, n), {}, {
    match: (r) => je.isElement(r) && F.isVoid(t, r)
  }));
}, yR = (e, t) => t.children.some((n) => je.isElement(n) && F.isBlock(e, n)), bR = (e, t) => t.children.some((n) => Ae.isText(n) || F.isInline(e, n)), wR = (e, t) => xe.has(e, t), CR = (e, t) => t.children.every((n) => Ae.isText(n)), ER = (e) => {
  ve.splitNodes(e, {
    always: !0
  });
}, xR = (e, t, n) => {
  ve.insertNodes(e, t, n);
}, OR = (e) => {
  ve.splitNodes(e, {
    always: !0
  });
};
function y0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? y0(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : y0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _R = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var s = kR({
        text: n
      }, i);
      ve.insertNodes(t, s, {
        at: r.at,
        voids: r.voids
      });
    } else
      ve.insertText(t, n, r);
    t.marks = null;
  }
}, LR = (e, t) => !e.isInline(t), DR = (e, t, n) => F.isStart(e, t, n) || F.isEnd(e, t, n), PR = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && Ae.isText(r) && r.text === "" && !e.isVoid(t);
}, SR = (e, t, n) => {
  var r = F.end(e, n);
  return ct.equals(t, r);
}, MR = (e) => {
  var t = HP.get(e);
  return t === void 0 ? !0 : t;
}, TR = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = F.start(e, n);
  return ct.equals(t, r);
}, jR = (e, t) => {
  var n = F.path(e, t, {
    edge: "end"
  });
  return F.node(e, n);
}, AR = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = F.path(t, n, r), i = xe.leaf(t, o);
  return [i, o];
};
function BR(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var s = [], a = F.path(e, n);
      for (var [l, u] of xe.levels(e, a))
        if (i(l, u) && (s.push([l, u]), !o && je.isElement(l) && F.isVoid(e, l)))
          break;
      r && s.reverse(), yield* s;
    }
  }();
}
var IR = ["text"], FR = ["text"], RR = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (ae.isExpanded(r)) {
    var s = F.isEnd(t, o, o.path);
    if (s) {
      var a = F.after(t, o);
      a && (o = a);
    }
    var [l] = F.nodes(t, {
      match: Ae.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = Ao(u, IR);
      return c;
    } else
      return {};
  }
  var {
    path: d
  } = o, [p] = F.leaf(t, d);
  if (o.offset === 0) {
    var g = F.previous(t, {
      at: d,
      match: Ae.isText
    }), f = F.above(t, {
      match: (E) => je.isElement(E) && F.isVoid(t, E) && t.markableVoid(E)
    });
    if (!f) {
      var m = F.above(t, {
        match: (E) => je.isElement(E) && F.isBlock(t, E)
      });
      if (g && m) {
        var [h, C] = g, [, w] = m;
        ne.isAncestor(w, C) && (p = h);
      }
    }
  }
  var P = Ao(p, FR);
  return P;
}, NR = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: s = t.selection
  } = n;
  if (s) {
    var a = F.after(t, s, {
      voids: o
    });
    if (a) {
      var [, l] = F.last(t, []), u = [a.path, l];
      if (ne.isPath(s) && s.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (ne.isPath(s)) {
          var [c] = F.parent(t, s);
          i = (p) => c.children.includes(p);
        } else
          i = () => !0;
      var [d] = F.nodes(t, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return d;
    }
  }
}, zR = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = F.path(t, n, r), i = xe.get(t, o);
  return [i, o];
};
function $R(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: s = !1,
      ignoreNonSelectable: a = !1
    } = t, {
      match: l
    } = t;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if (kF.isSpan(n))
        u = n[0], c = n[1];
      else {
        var d = F.path(e, n, {
          edge: "start"
        }), p = F.path(e, n, {
          edge: "end"
        });
        u = i ? p : d, c = i ? d : p;
      }
      var g = xe.nodes(e, {
        reverse: i,
        from: u,
        to: c,
        pass: (E) => {
          var [v] = E;
          return je.isElement(v) ? !!(!s && (F.isVoid(e, v) || F.isElementReadOnly(e, v)) || a && !F.isSelectable(e, v)) : !1;
        }
      }), f = [], m;
      for (var [h, C] of g)
        if (!(a && je.isElement(h) && !F.isSelectable(e, h))) {
          var w = m && ne.compare(C, m[1]) === 0;
          if (!(r === "highest" && w)) {
            if (!l(h, C)) {
              if (o && !w && Ae.isText(h))
                return;
              continue;
            }
            if (r === "lowest" && w) {
              m = [h, C];
              continue;
            }
            var P = r === "lowest" ? m : [h, C];
            P && (o ? f.push(P) : yield P), m = [h, C];
          }
        }
      r === "lowest" && m && (o ? f.push(m) : yield m), o && (yield* f);
    }
  }();
}
var UR = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => $c.get(c) || [], s = (c) => Uc.get(c) || /* @__PURE__ */ new Set(), a = (c) => {
    var d = i(c).pop(), p = d.join(",");
    return s(c).delete(p), d;
  };
  if (F.isNormalizing(t)) {
    if (r) {
      var l = Array.from(xe.nodes(t), (c) => {
        var [, d] = c;
        return d;
      }), u = new Set(l.map((c) => c.join(",")));
      $c.set(t, l), Uc.set(t, u);
    }
    i(t).length !== 0 && F.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (xe.has(t, c)) {
          var d = F.node(t, c), [p, g] = d;
          je.isElement(p) && p.children.length === 0 && t.normalizeNode(d, {
            operation: o
          });
        }
      for (var f = i(t), m = f.length, h = 0; f.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: f,
          iteration: h,
          initialDirtyPathsLength: m,
          operation: o
        }))
          return;
        var C = a(t);
        if (xe.has(t, C)) {
          var w = F.node(t, C);
          t.normalizeNode(w, {
            operation: o
          });
        }
        h++, f = i(t);
      }
    });
  }
}, HR = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = F.path(t, n, r), i = ne.parent(o), s = F.node(t, i);
  return s;
}, WR = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = F.pathRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = F.pathRefs(t);
  return s.add(i), i;
}, VR = (e) => {
  var t = qb.get(e);
  return t || (t = /* @__PURE__ */ new Set(), qb.set(e, t)), t;
}, ZR = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (ne.isPath(n)) {
    if (i === "start") {
      var [, s] = xe.first(t, n);
      n = s;
    } else if (i === "end") {
      var [, a] = xe.last(t, n);
      n = a;
    }
  }
  return ae.isRange(n) && (i === "start" ? n = ae.start(n) : i === "end" ? n = ae.end(n) : n = ne.common(n.anchor.path, n.focus.path)), ct.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, qR = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = F.pointRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = F.pointRefs(t);
  return s.add(i), i;
}, GR = (e) => {
  var t = Gb.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Gb.set(e, t)), t;
}, YR = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (ne.isPath(n)) {
    var i;
    if (o === "end") {
      var [, s] = xe.last(t, n);
      i = s;
    } else {
      var [, a] = xe.first(t, n);
      i = a;
    }
    var l = xe.get(t, i);
    if (!Ae.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (ae.isRange(n)) {
    var [u, c] = ae.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function KR(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: s = !1
    } = t;
    if (!n)
      return;
    var a = F.range(e, n), [l, u] = ae.edges(a), c = o ? u : l, d = !1, p = "", g = 0, f = 0, m = 0;
    for (var [h, C] of F.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: s
    })) {
      if (je.isElement(h)) {
        if (!i && (e.isVoid(h) || e.isElementReadOnly(h))) {
          yield F.start(e, C);
          continue;
        }
        if (e.isInline(h)) continue;
        if (F.hasInlines(e, h)) {
          var w = ne.isAncestor(C, u.path) ? u : F.end(e, C), P = ne.isAncestor(C, l.path) ? l : F.start(e, C);
          p = F.string(e, {
            anchor: P,
            focus: w
          }, {
            voids: i
          }), d = !0;
        }
      }
      if (Ae.isText(h)) {
        var E = ne.equals(C, c.path);
        for (E ? (f = o ? c.offset : h.text.length - c.offset, m = c.offset) : (f = h.text.length, m = o ? f : 0), (E || d || r === "offset") && (yield {
          path: C,
          offset: m
        }, d = !1); ; ) {
          if (g === 0) {
            if (p === "") break;
            g = v(p, r, o), p = pv(p, g, o)[1];
          }
          if (m = o ? m - g : m + g, f = f - g, f < 0) {
            g = -f;
            break;
          }
          g = 0, yield {
            path: C,
            offset: m
          };
        }
      }
    }
    function v(x, L, z) {
      return L === "character" ? dv(x, z) : L === "word" ? MF(x, z) : L === "line" || L === "block" ? x.length : 1;
    }
  }();
}
var XR = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: s = t.selection
  } = n;
  if (s) {
    var a = F.before(t, s, {
      voids: o
    });
    if (a) {
      var [, l] = F.first(t, []), u = [a.path, l];
      if (ne.isPath(s) && s.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (ne.isPath(s)) {
          var [c] = F.parent(t, s);
          i = (p) => c.children.includes(p);
        } else
          i = () => !0;
      var [d] = F.nodes(t, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return d;
    }
  }
}, JR = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = F.rangeRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = F.rangeRefs(t);
  return s.add(i), i;
}, QR = (e) => {
  var t = Yb.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Yb.set(e, t)), t;
}, eN = (e, t, n) => {
  if (ae.isRange(t) && !n)
    return t;
  var r = F.start(e, t), o = F.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function b0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? b0(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : b0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nN = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, d) => {
      if (!Ae.isText(c))
        return !1;
      var [p, g] = F.parent(e, d);
      return !e.isVoid(p) || e.markableVoid(p);
    }, o = ae.isExpanded(n), i = !1;
    if (!o) {
      var [s, a] = F.node(e, n);
      if (s && r(s, a)) {
        var [l] = F.parent(e, a);
        i = l && e.markableVoid(l);
      }
    }
    if (o || i)
      ve.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = tN({}, F.marks(e) || {});
      delete u[t], e.marks = u, ja.get(e) || e.onChange();
    }
  }
}, rN = (e, t) => {
  HP.set(e, t);
}, oN = (e, t) => F.point(e, t, {
  edge: "start"
}), iN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = F.range(t, n), [s, a] = ae.edges(i), l = "";
  for (var [u, c] of F.nodes(t, {
    at: i,
    match: Ae.isText,
    voids: o
  })) {
    var d = u.text;
    ne.equals(c, a.path) && (d = d.slice(0, a.offset)), ne.equals(c, s.path) && (d = d.slice(s.offset)), l += d;
  }
  return l;
}, sN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, s] = ae.edges(n);
  if (i.offset !== 0 || s.offset !== 0 || ae.isCollapsed(n) || ne.hasPrevious(s.path))
    return n;
  var a = F.above(t, {
    at: s,
    match: (f) => je.isElement(f) && F.isBlock(t, f),
    voids: o
  }), l = a ? a[1] : [], u = F.start(t, i), c = {
    anchor: u,
    focus: s
  }, d = !0;
  for (var [p, g] of F.nodes(t, {
    at: c,
    match: Ae.isText,
    reverse: !0,
    voids: o
  })) {
    if (d) {
      d = !1;
      continue;
    }
    if (p.text !== "" || ne.isBefore(g, l)) {
      s = {
        path: g,
        offset: p.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: s
  };
}, aN = (e, t) => {
  var n = F.isNormalizing(e);
  F.setNormalizing(e, !1);
  try {
    t();
  } finally {
    F.setNormalizing(e, n);
  }
  F.normalize(e);
}, lN = (e, t, n) => {
  var [r, o] = t;
  return je.isElement(r) && F.isEmpty(e, r) || Ae.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, uN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  F.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: s = "character",
      distance: a = 1,
      voids: l = !1
    } = n, {
      at: u = t.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var d = !1;
      if (ae.isRange(u) && ae.isCollapsed(u) && (d = !0, u = u.anchor), ct.isPoint(u)) {
        var p = F.void(t, {
          at: u,
          mode: "highest"
        });
        if (!l && p) {
          var [, g] = p;
          u = g;
        } else {
          var f = {
            unit: s,
            distance: a
          }, m = i ? F.before(t, u, f) || F.start(t, []) : F.after(t, u, f) || F.end(t, []);
          u = {
            anchor: u,
            focus: m
          }, c = !0;
        }
      }
      if (ne.isPath(u)) {
        ve.removeNodes(t, {
          at: u,
          voids: l
        });
        return;
      }
      if (!ae.isCollapsed(u)) {
        if (!c) {
          var [, h] = ae.edges(u), C = F.end(t, []);
          ct.equals(h, C) || (u = F.unhangRange(t, u, {
            voids: l
          }));
        }
        var [w, P] = ae.edges(u), E = F.above(t, {
          match: (ye) => je.isElement(ye) && F.isBlock(t, ye),
          at: w,
          voids: l
        }), v = F.above(t, {
          match: (ye) => je.isElement(ye) && F.isBlock(t, ye),
          at: P,
          voids: l
        }), x = E && v && !ne.equals(E[1], v[1]), L = ne.equals(w.path, P.path), z = l ? null : (r = F.void(t, {
          at: w,
          mode: "highest"
        })) !== null && r !== void 0 ? r : F.elementReadOnly(t, {
          at: w,
          mode: "highest"
        }), k = l ? null : (o = F.void(t, {
          at: P,
          mode: "highest"
        })) !== null && o !== void 0 ? o : F.elementReadOnly(t, {
          at: P,
          mode: "highest"
        });
        if (z) {
          var R = F.before(t, w);
          R && E && ne.isAncestor(E[1], R.path) && (w = R);
        }
        if (k) {
          var A = F.after(t, P);
          A && v && ne.isAncestor(v[1], A.path) && (P = A);
        }
        var U = [], V;
        for (var N of F.nodes(t, {
          at: u,
          voids: l
        })) {
          var [Z, K] = N;
          V && ne.compare(K, V) === 0 || (!l && je.isElement(Z) && (F.isVoid(t, Z) || F.isElementReadOnly(t, Z)) || !ne.isCommon(K, w.path) && !ne.isCommon(K, P.path)) && (U.push(N), V = K);
        }
        var X = Array.from(U, (ye) => {
          var [, ie] = ye;
          return F.pathRef(t, ie);
        }), te = F.pointRef(t, w), ee = F.pointRef(t, P), D = "";
        if (!L && !z) {
          var j = te.current, [G] = F.leaf(t, j), {
            path: S
          } = j, {
            offset: Y
          } = w, O = G.text.slice(Y);
          O.length > 0 && (t.apply({
            type: "remove_text",
            path: S,
            offset: Y,
            text: O
          }), D = O);
        }
        if (X.reverse().map((ye) => ye.unref()).filter((ye) => ye !== null).forEach((ye) => ve.removeNodes(t, {
          at: ye,
          voids: l
        })), !k) {
          var M = ee.current, [W] = F.leaf(t, M), {
            path: T
          } = M, q = L ? w.offset : 0, I = W.text.slice(q, P.offset);
          I.length > 0 && (t.apply({
            type: "remove_text",
            path: T,
            offset: q,
            text: I
          }), D = I);
        }
        !L && x && ee.current && te.current && ve.mergeNodes(t, {
          at: ee.current,
          hanging: !0,
          voids: l
        }), d && i && s === "character" && D.length > 1 && D.match(/[\u0E00-\u0E7F]+/) && ve.insertText(t, D.slice(0, D.length - a));
        var J = te.unref(), H = ee.unref(), ce = i ? J || H : H || J;
        n.at == null && ce && ve.select(t, ce);
      }
    }
  });
}, cN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  F.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: s = cv(t),
      batchDirty: a = !0
    } = r;
    if (n.length) {
      if (ae.isRange(s))
        if (o || (s = F.unhangRange(t, s, {
          voids: i
        })), ae.isCollapsed(s))
          s = s.anchor;
        else {
          var [, l] = ae.edges(s);
          if (!i && F.void(t, {
            at: l
          }))
            return;
          var u = F.pointRef(t, l);
          ve.delete(t, {
            at: s
          }), s = u.unref();
        }
      else ne.isPath(s) && (s = F.start(t, s));
      if (!(!i && F.void(t, {
        at: s
      }))) {
        var c = F.above(t, {
          at: s,
          match: (O) => je.isElement(O) && F.isInline(t, O),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, d] = c;
          if (F.isEnd(t, s, d)) {
            var p = F.after(t, d);
            s = p;
          } else if (F.isStart(t, s, d)) {
            var g = F.before(t, d);
            s = g;
          }
        }
        var f = F.above(t, {
          match: (O) => je.isElement(O) && F.isBlock(t, O),
          at: s,
          voids: i
        }), [, m] = f, h = F.isStart(t, s, m), C = F.isEnd(t, s, m), w = h && C, P = !h || h && C, E = !C, [, v] = xe.first({
          children: n
        }, []), [, x] = xe.last({
          children: n
        }, []), L = [], z = (O) => {
          var [M, W] = O, T = W.length === 0;
          return T ? !1 : w ? !0 : !(P && ne.isAncestor(W, v) && je.isElement(M) && !t.isVoid(M) && !t.isInline(M) || E && ne.isAncestor(W, x) && je.isElement(M) && !t.isVoid(M) && !t.isInline(M));
        };
        for (var k of xe.nodes({
          children: n
        }, {
          pass: z
        }))
          z(k) && L.push(k);
        var R = [], A = [], U = [], V = !0, N = !1;
        for (var [Z] of L)
          je.isElement(Z) && !t.isInline(Z) ? (V = !1, N = !0, A.push(Z)) : V ? R.push(Z) : U.push(Z);
        var [K] = F.nodes(t, {
          at: s,
          match: (O) => Ae.isText(O) || F.isInline(t, O),
          mode: "highest",
          voids: i
        }), [, X] = K, te = F.isStart(t, s, X), ee = F.isEnd(t, s, X), D = F.pathRef(t, C && !U.length ? ne.next(m) : m), j = F.pathRef(t, ee ? ne.next(X) : X);
        ve.splitNodes(t, {
          at: s,
          match: (O) => N ? je.isElement(O) && F.isBlock(t, O) : Ae.isText(O) || F.isInline(t, O),
          mode: N ? "lowest" : "highest",
          always: N && (!h || R.length > 0) && (!C || U.length > 0),
          voids: i
        });
        var G = F.pathRef(t, !te || te && ee ? ne.next(X) : X);
        if (ve.insertNodes(t, R, {
          at: G.current,
          match: (O) => Ae.isText(O) || F.isInline(t, O),
          mode: "highest",
          voids: i,
          batchDirty: a
        }), w && !R.length && A.length && !U.length && ve.delete(t, {
          at: m,
          voids: i
        }), ve.insertNodes(t, A, {
          at: D.current,
          match: (O) => je.isElement(O) && F.isBlock(t, O),
          mode: "lowest",
          voids: i,
          batchDirty: a
        }), ve.insertNodes(t, U, {
          at: j.current,
          match: (O) => Ae.isText(O) || F.isInline(t, O),
          mode: "highest",
          voids: i,
          batchDirty: a
        }), !r.at) {
          var S;
          if (U.length > 0 && j.current ? S = ne.previous(j.current) : A.length > 0 && D.current ? S = ne.previous(D.current) : G.current && (S = ne.previous(G.current)), S) {
            var Y = F.end(t, S);
            ve.select(t, Y);
          }
        }
        G.unref(), D.unref(), j.unref();
      }
    }
  });
}, dN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      ve.select(t, o.anchor);
    else if (r === "focus")
      ve.select(t, o.focus);
    else if (r === "start") {
      var [i] = ae.edges(o);
      ve.select(t, i);
    } else if (r === "end") {
      var [, s] = ae.edges(o);
      ve.select(t, s);
    }
  } else return;
}, pN = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, fN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: s = !1
  } = n, {
    edge: a = null
  } = n;
  if (r) {
    a === "start" && (a = ae.isBackward(r) ? "focus" : "anchor"), a === "end" && (a = ae.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, d = {};
    if (a == null || a === "anchor") {
      var p = s ? F.before(t, l, c) : F.after(t, l, c);
      p && (d.anchor = p);
    }
    if (a == null || a === "focus") {
      var g = s ? F.before(t, u, c) : F.after(t, u, c);
      g && (d.focus = g);
    }
    ve.setSelection(t, d);
  }
}, hN = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = F.range(e, t), n) {
    ve.setSelection(e, t);
    return;
  }
  if (!ae.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(er.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function w0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function C0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? w0(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : w0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = ae.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = ae.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: s,
      focus: a
    } = o, l = i === "anchor" ? s : a;
    ve.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: C0(C0({}, l), n)
    });
  }
}, mN = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !ct.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !ct.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, vN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  F.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: s = "lowest",
      batchDirty: a = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (xe.isNode(n) && (n = [n]), n.length !== 0) {
      var [d] = n;
      if (l || (l = cv(t), c !== !1 && (c = !0)), c == null && (c = !1), ae.isRange(l))
        if (o || (l = F.unhangRange(t, l, {
          voids: i
        })), ae.isCollapsed(l))
          l = l.anchor;
        else {
          var [, p] = ae.edges(l), g = F.pointRef(t, p);
          ve.delete(t, {
            at: l
          }), l = g.unref();
        }
      if (ct.isPoint(l)) {
        u == null && (Ae.isText(d) ? u = (R) => Ae.isText(R) : t.isInline(d) ? u = (R) => Ae.isText(R) || F.isInline(t, R) : u = (R) => je.isElement(R) && F.isBlock(t, R));
        var [f] = F.nodes(t, {
          at: l.path,
          match: u,
          mode: s,
          voids: i
        });
        if (f) {
          var [, m] = f, h = F.pathRef(t, m), C = F.isEnd(t, l, m);
          ve.splitNodes(t, {
            at: l,
            match: u,
            mode: s,
            voids: i
          });
          var w = h.unref();
          l = C ? ne.next(w) : w;
        } else
          return;
      }
      var P = ne.parent(l), E = l[l.length - 1];
      if (!(!i && F.void(t, {
        at: P
      }))) {
        if (a) {
          var v = [], x = ne.levels(P);
          QF(t, () => {
            var R = function() {
              var V = P.concat(E);
              E++;
              var N = {
                type: "insert_node",
                path: V,
                node: A
              };
              t.apply(N), l = ne.next(l), v.push(N), Ae.isText ? x.push(...Array.from(xe.nodes(A), (Z) => {
                var [, K] = Z;
                return V.concat(K);
              })) : x.push(V);
            };
            for (var A of n)
              R();
          }, () => {
            VP(t, x, (R) => {
              var A = R;
              for (var U of v)
                if (ne.operationCanTransformPath(U) && (A = ne.transform(A, U), !A))
                  return null;
              return A;
            });
          });
        } else
          for (var L of n) {
            var z = P.concat(E);
            E++, t.apply({
              type: "insert_node",
              path: z,
              node: L
            }), l = ne.next(l);
          }
        if (l = ne.previous(l), c) {
          var k = F.end(t, l);
          k && ve.select(t, k);
        }
      }
    }
  });
}, yN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  F.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: s
    } = n;
    if (s == null && (s = ne.isPath(r) ? Vs(t, r) : (E) => je.isElement(E) && F.isBlock(t, E)), !!r) {
      var a = F.nodes(t, {
        at: r,
        match: s,
        mode: o,
        voids: i
      }), l = Array.from(a, (E) => {
        var [, v] = E;
        return F.pathRef(t, v);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var d = F.node(t, ne.parent(c)), [p, g] = d, f = c[c.length - 1], {
          length: m
        } = p.children;
        if (m === 1) {
          var h = ne.next(g);
          ve.moveNodes(t, {
            at: c,
            to: h,
            voids: i
          }), ve.removeNodes(t, {
            at: g,
            voids: i
          });
        } else if (f === 0)
          ve.moveNodes(t, {
            at: c,
            to: g,
            voids: i
          });
        else if (f === m - 1) {
          var C = ne.next(g);
          ve.moveNodes(t, {
            at: c,
            to: C,
            voids: i
          });
        } else {
          var w = ne.next(c), P = ne.next(g);
          ve.splitNodes(t, {
            at: w,
            voids: i
          }), ve.moveNodes(t, {
            at: c,
            to: P,
            voids: i
          });
        }
      }
    }
  });
}, bN = ["text"], wN = ["children"], ZP = (e, t) => {
  if (je.isElement(t)) {
    var n = t;
    return F.isVoid(e, t) ? !0 : n.children.length === 1 ? ZP(e, n.children[0]) : !1;
  } else return !F.isEditor(t);
}, CN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  F.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: s = !1,
      mode: a = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (ne.isPath(o)) {
          var [l] = F.parent(t, o);
          r = (R) => l.children.includes(R);
        } else
          r = (R) => je.isElement(R) && F.isBlock(t, R);
      if (!i && ae.isRange(o) && (o = F.unhangRange(t, o, {
        voids: s
      })), ae.isRange(o))
        if (ae.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = ae.edges(o), c = F.pointRef(t, u);
          ve.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && ve.select(t, o);
        }
      var [d] = F.nodes(t, {
        at: o,
        match: r,
        voids: s,
        mode: a
      }), p = F.previous(t, {
        at: o,
        match: r,
        voids: s,
        mode: a
      });
      if (!(!d || !p)) {
        var [g, f] = d, [m, h] = p;
        if (!(f.length === 0 || h.length === 0)) {
          var C = ne.next(h), w = ne.common(f, h), P = ne.isSibling(f, h), E = Array.from(F.levels(t, {
            at: f
          }), (R) => {
            var [A] = R;
            return A;
          }).slice(w.length).slice(0, -1), v = F.above(t, {
            at: f,
            mode: "highest",
            match: (R) => E.includes(R) && ZP(t, R)
          }), x = v && F.pathRef(t, v[1]), L, z;
          if (Ae.isText(g) && Ae.isText(m)) {
            var k = Ao(g, bN);
            z = m.text.length, L = k;
          } else if (je.isElement(g) && je.isElement(m)) {
            var k = Ao(g, wN);
            z = m.children.length, L = k;
          } else
            throw new Error("Cannot merge the node at path [".concat(f, "] with the previous sibling because it is not the same kind: ").concat(er.stringify(g), " ").concat(er.stringify(m)));
          P || ve.moveNodes(t, {
            at: f,
            to: C,
            voids: s
          }), x && ve.removeNodes(t, {
            at: x.current,
            voids: s
          }), F.shouldMergeNodesRemovePrevNode(t, p, d) ? ve.removeNodes(t, {
            at: h,
            voids: s
          }) : t.apply({
            type: "merge_node",
            path: C,
            position: z,
            properties: L
          }), x && x.unref();
        }
      }
    }
  });
}, EN = (e, t) => {
  F.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: s
    } = t;
    if (r) {
      s == null && (s = ne.isPath(r) ? Vs(e, r) : (g) => je.isElement(g) && F.isBlock(e, g));
      var a = F.pathRef(e, n), l = F.nodes(e, {
        at: r,
        match: s,
        mode: o,
        voids: i
      }), u = Array.from(l, (g) => {
        var [, f] = g;
        return F.pathRef(e, f);
      });
      for (var c of u) {
        var d = c.unref(), p = a.current;
        d.length !== 0 && e.apply({
          type: "move_node",
          path: d,
          newPath: p
        }), a.current && ne.isSibling(p, d) && ne.isAfter(p, d) && (a.current = ne.next(a.current));
      }
      a.unref();
    }
  });
}, xN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  F.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: s = t.selection,
      match: a
    } = n;
    if (s) {
      a == null && (a = ne.isPath(s) ? Vs(t, s) : (g) => je.isElement(g) && F.isBlock(t, g)), !r && ae.isRange(s) && (s = F.unhangRange(t, s, {
        voids: o
      }));
      var l = F.nodes(t, {
        at: s,
        match: a,
        mode: i,
        voids: o
      }), u = Array.from(l, (g) => {
        var [, f] = g;
        return F.pathRef(t, f);
      });
      for (var c of u) {
        var d = c.unref();
        if (d) {
          var [p] = F.node(t, d);
          t.apply({
            type: "remove_node",
            path: d,
            node: p
          });
        }
      }
    }
  });
}, ON = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  F.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: s,
      merge: a
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: d = !1
    } = r;
    if (i) {
      if (o == null && (o = ne.isPath(i) ? Vs(t, i) : (z) => je.isElement(z) && F.isBlock(t, z)), !l && ae.isRange(i) && (i = F.unhangRange(t, i, {
        voids: d
      })), c && ae.isRange(i)) {
        if (ae.isCollapsed(i) && F.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var p = F.rangeRef(t, i, {
          affinity: "inward"
        }), [g, f] = ae.edges(i), m = u === "lowest" ? "lowest" : "highest", h = F.isEnd(t, f, f.path);
        ve.splitNodes(t, {
          at: f,
          match: o,
          mode: m,
          voids: d,
          always: !h
        });
        var C = F.isStart(t, g, g.path);
        ve.splitNodes(t, {
          at: g,
          match: o,
          mode: m,
          voids: d,
          always: !C
        }), i = p.unref(), r.at == null && ve.select(t, i);
      }
      s || (s = (z, k) => z !== k);
      for (var [w, P] of F.nodes(t, {
        at: i,
        match: o,
        mode: u,
        voids: d
      })) {
        var E = {}, v = {};
        if (P.length !== 0) {
          var x = !1;
          for (var L in n)
            L === "children" || L === "text" || s(n[L], w[L]) && (x = !0, w.hasOwnProperty(L) && (E[L] = w[L]), a ? n[L] != null && (v[L] = a(w[L], n[L])) : n[L] != null && (v[L] = n[L]));
          x && t.apply({
            type: "set_node",
            path: P,
            properties: E,
            newProperties: v
          });
        }
      }
    }
  });
}, kN = (e, t) => {
  if (ae.isCollapsed(t))
    return t.anchor;
  var [, n] = ae.edges(t), r = F.pointRef(e, n);
  return ve.delete(e, {
    at: t
  }), r.unref();
}, _N = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  F.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: s = t.selection,
      height: a = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (ee) => je.isElement(ee) && F.isBlock(t, ee)), ae.isRange(s) && (s = kN(t, s)), ne.isPath(s)) {
      var u = s, c = F.point(t, u), [d] = F.parent(t, u);
      i = (ee) => ee === d, a = c.path.length - u.length + 1, s = c, l = !0;
    }
    if (s) {
      var p = F.pointRef(t, s, {
        affinity: "backward"
      }), g;
      try {
        var [f] = F.nodes(t, {
          at: s,
          match: i,
          mode: r,
          voids: o
        });
        if (!f)
          return;
        var m = F.void(t, {
          at: s,
          mode: "highest"
        }), h = 0;
        if (!o && m) {
          var [C, w] = m;
          if (je.isElement(C) && t.isInline(C)) {
            var P = F.after(t, w);
            if (!P) {
              var E = {
                text: ""
              }, v = ne.next(w);
              ve.insertNodes(t, E, {
                at: v,
                voids: o
              }), P = F.point(t, v);
            }
            s = P, l = !0;
          }
          var x = s.path.length - w.length;
          a = x + 1, l = !0;
        }
        g = F.pointRef(t, s);
        var L = s.path.length - a, [, z] = f, k = s.path.slice(0, L), R = a === 0 ? s.offset : s.path[L] + h;
        for (var [A, U] of F.levels(t, {
          at: k,
          reverse: !0,
          voids: o
        })) {
          var V = !1;
          if (U.length < z.length || U.length === 0 || !o && je.isElement(A) && F.isVoid(t, A))
            break;
          var N = p.current, Z = F.isEnd(t, N, U);
          if (l || !p || !F.isEdge(t, N, U)) {
            V = !0;
            var K = xe.extractProps(A);
            t.apply({
              type: "split_node",
              path: U,
              position: R,
              properties: K
            });
          }
          R = U[U.length - 1] + (V || Z ? 1 : 0);
        }
        if (n.at == null) {
          var X = g.current || F.end(t, []);
          ve.select(t, X);
        }
      } finally {
        var te;
        p.unref(), (te = g) === null || te === void 0 || te.unref();
      }
    }
  });
}, LN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  ve.setNodes(t, o, r);
}, DN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  F.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: s = t.selection,
      match: a
    } = n;
    if (s) {
      a == null && (a = ne.isPath(s) ? Vs(t, s) : (g) => je.isElement(g) && F.isBlock(t, g)), ne.isPath(s) && (s = F.range(t, s));
      var l = ae.isRange(s) ? F.rangeRef(t, s) : null, u = F.nodes(t, {
        at: s,
        match: a,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (g) => {
          var [, f] = g;
          return F.pathRef(t, f);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), d = function() {
        var f = p.unref(), [m] = F.node(t, f), h = F.range(t, f);
        o && l && (h = ae.intersection(l.current, h)), ve.liftNodes(t, {
          at: h,
          match: (C) => je.isAncestor(m) && m.children.includes(C),
          voids: i
        });
      };
      for (var p of c)
        d();
      l && l.unref();
    }
  });
};
function E0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function x0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? E0(Object(n), !0).forEach(function(r) {
      vr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : E0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  F.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: s = !1
    } = r, {
      match: a,
      at: l = t.selection
    } = r;
    if (l) {
      if (a == null && (ne.isPath(l) ? a = Vs(t, l) : t.isInline(n) ? a = (h) => je.isElement(h) && F.isInline(t, h) || Ae.isText(h) : a = (h) => je.isElement(h) && F.isBlock(t, h)), i && ae.isRange(l)) {
        var [u, c] = ae.edges(l), d = F.rangeRef(t, l, {
          affinity: "inward"
        });
        ve.splitNodes(t, {
          at: c,
          match: a,
          voids: s
        }), ve.splitNodes(t, {
          at: u,
          match: a,
          voids: s
        }), l = d.unref(), r.at == null && ve.select(t, l);
      }
      var p = Array.from(F.nodes(t, {
        at: l,
        match: t.isInline(n) ? (h) => je.isElement(h) && F.isBlock(t, h) : (h) => F.isEditor(h),
        mode: "lowest",
        voids: s
      })), g = function() {
        var C = ae.isRange(l) ? ae.intersection(l, F.range(t, m)) : l;
        if (!C)
          return 0;
        var w = Array.from(F.nodes(t, {
          at: C,
          match: a,
          mode: o,
          voids: s
        }));
        if (w.length > 0) {
          var [P] = w, E = w[w.length - 1], [, v] = P, [, x] = E;
          if (v.length === 0 && x.length === 0)
            return 0;
          var L = ne.equals(v, x) ? ne.parent(v) : ne.common(v, x), z = F.range(t, v, x), k = F.node(t, L), [R] = k, A = L.length + 1, U = ne.next(x.slice(0, A)), V = x0(x0({}, n), {}, {
            children: []
          });
          ve.insertNodes(t, V, {
            at: U,
            voids: s
          }), ve.moveNodes(t, {
            at: z,
            match: (N) => je.isAncestor(R) && R.children.includes(N),
            to: U.concat(0),
            voids: s
          });
        }
      }, f;
      for (var [, m] of p)
        f = g();
    }
  });
}, SN = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eR(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sR(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return uR(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cR(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dR(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nR(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ER(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return OR(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cN(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xR(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _R(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rR(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nN(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return tR(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return oR(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return iR(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return aR(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lR(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dN(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return uN(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pN(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pR(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fR(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hR(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gR(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mR(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return RR(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yR(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bR(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wR(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return CR(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vN(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return LR(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return DR(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return PR(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return SR(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return MR(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return TR(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jR(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return AR(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return BR(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yN(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return CN(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fN(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return EN(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return NR(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zR(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $R(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return UR(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return HR(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ZR(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return WR(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return VR(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return YR(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qR(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return GR(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return KR(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return XR(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eN(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return JR(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return QR(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xN(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hN(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ON(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rN(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gN(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mN(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _N(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return oN(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return iN(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sN(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return LN(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return DN(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vR(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return aN(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return PN(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lN(e, ...r);
    }
  };
  return e;
};
const qP = (e) => {
  if (Ae.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if (je.isElement(e)) {
    const t = e.children.map((r) => qP(r)).join(""), n = e.align || "left";
    switch (e.type) {
      case "image":
        return `<img src="${e.src}" class="align_${n}" />`;
      case "paragraph":
        return `<p class="align_${n}">${t}</p>`;
      case "blockQuote":
        return `<blockquote class="align_${n}">${t}</blockquote>`;
      case "bulletedList":
        return `<ul class="align_${n}">${t}</ul>`;
      case "headingOne":
        return `<h1 class="align_${n}">${t}</h1>`;
      case "headingTwo":
        return `<h2 class="align_${n}">${t}</h2>`;
      case "listItem":
        return `<li class="align_${n}">${t}</li>`;
      case "numberedList":
        return `<ol class="align_${n}">${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, eue = (e) => e.map((t) => qP(t)).join("");
var GP = {}, fv = {}, hv = {}, Os = {}, gv = {}, mv = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(mv);
var mt = {}, bi = rn && rn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Aa = rn && rn.__assign || function() {
  return Aa = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Aa.apply(this, arguments);
};
Object.defineProperty(mt, "__esModule", { value: !0 });
mt.cloneNode = mt.hasChildren = mt.isDocument = mt.isDirective = mt.isComment = mt.isText = mt.isCDATA = mt.isTag = mt.Element = mt.Document = mt.CDATA = mt.NodeWithChildren = mt.ProcessingInstruction = mt.Comment = mt.Text = mt.DataNode = mt.Node = void 0;
var Dr = mv, vv = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), yv(this, t);
    }, e;
  }()
);
mt.Node = vv;
var rp = (
  /** @class */
  function(e) {
    bi(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(vv)
);
mt.DataNode = rp;
var YP = (
  /** @class */
  function(e) {
    bi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Dr.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rp)
);
mt.Text = YP;
var KP = (
  /** @class */
  function(e) {
    bi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Dr.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rp)
);
mt.Comment = KP;
var XP = (
  /** @class */
  function(e) {
    bi(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Dr.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rp)
);
mt.ProcessingInstruction = XP;
var op = (
  /** @class */
  function(e) {
    bi(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(vv)
);
mt.NodeWithChildren = op;
var JP = (
  /** @class */
  function(e) {
    bi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Dr.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(op)
);
mt.CDATA = JP;
var QP = (
  /** @class */
  function(e) {
    bi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Dr.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(op)
);
mt.Document = QP;
var eS = (
  /** @class */
  function(e) {
    bi(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Dr.ElementType.Script : n === "style" ? Dr.ElementType.Style : Dr.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(op)
);
mt.Element = eS;
function tS(e) {
  return (0, Dr.isTag)(e);
}
mt.isTag = tS;
function nS(e) {
  return e.type === Dr.ElementType.CDATA;
}
mt.isCDATA = nS;
function rS(e) {
  return e.type === Dr.ElementType.Text;
}
mt.isText = rS;
function oS(e) {
  return e.type === Dr.ElementType.Comment;
}
mt.isComment = oS;
function iS(e) {
  return e.type === Dr.ElementType.Directive;
}
mt.isDirective = iS;
function sS(e) {
  return e.type === Dr.ElementType.Root;
}
mt.isDocument = sS;
function MN(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
mt.hasChildren = MN;
function yv(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (rS(e))
    n = new YP(e.data);
  else if (oS(e))
    n = new KP(e.data);
  else if (tS(e)) {
    var r = t ? Mf(e.children) : [], o = new eS(e.name, Aa({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Aa({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Aa({}, e["x-attribsPrefix"])), n = o;
  } else if (nS(e)) {
    var r = t ? Mf(e.children) : [], i = new JP(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (sS(e)) {
    var r = t ? Mf(e.children) : [], s = new QP(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (iS(e)) {
    var a = new XP(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
mt.cloneNode = yv;
function Mf(e) {
  for (var t = e.map(function(r) {
    return yv(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = rn && rn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var d = Object.getOwnPropertyDescriptor(l, u);
    (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, d);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = rn && rn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = mv, o = mt;
  n(mt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, d = new o.Element(l, u, void 0, c);
        this.addNode(d), this.tagStack.push(d);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(gv);
var aS = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(aS);
Object.defineProperty(Os, "__esModule", { value: !0 });
Os.formatAttributes = lS;
Os.escapeSpecialCharacters = AN;
Os.revertEscapedCharacters = uS;
Os.formatDOM = cS;
var cu = gv, rl = aS;
function TN(e) {
  return rl.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function lS(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function jN(e) {
  e = e.toLowerCase();
  var t = TN(e);
  return t || e;
}
function AN(e) {
  return e.replace(rl.CARRIAGE_RETURN_REGEX, rl.CARRIAGE_RETURN_PLACEHOLDER);
}
function uS(e) {
  return e.replace(rl.CARRIAGE_RETURN_PLACEHOLDER_REGEX, rl.CARRIAGE_RETURN);
}
function cS(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = jN(a.nodeName);
        o = new cu.Element(l, lS(a.attributes)), o.children = cS(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new cu.Text(uS(a.nodeValue));
        break;
      case 8:
        o = new cu.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new cu.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(hv, "__esModule", { value: !0 });
hv.default = NN;
var BN = Os, O0 = "html", k0 = "head", du = "body", IN = /<([a-zA-Z]+[0-9]?)/, _0 = /<head[^]*>/i, L0 = /<body[^]*>/i, Hc = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, jg = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, D0 = typeof window == "object" && window.DOMParser;
if (typeof D0 == "function") {
  var FN = new D0(), RN = "text/html";
  jg = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), FN.parseFromString(e, RN);
  }, Hc = jg;
}
if (typeof document == "object" && document.implementation) {
  var pu = document.implementation.createHTMLDocument();
  Hc = function(e, t) {
    if (t) {
      var n = pu.documentElement.querySelector(t);
      return n && (n.innerHTML = e), pu;
    }
    return pu.documentElement.innerHTML = e, pu;
  };
}
var fu = typeof document == "object" && document.createElement("template"), Ag;
fu && fu.content && (Ag = function(e) {
  return fu.innerHTML = e, fu.content.childNodes;
});
function NN(e) {
  var t, n;
  e = (0, BN.escapeSpecialCharacters)(e);
  var r = e.match(IN), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case O0: {
      var i = jg(e);
      if (!_0.test(e)) {
        var s = i.querySelector(k0);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!L0.test(e)) {
        var s = i.querySelector(du);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(O0);
    }
    case k0:
    case du: {
      var a = Hc(e).querySelectorAll(o);
      return L0.test(e) && _0.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (Ag)
        return Ag(e);
      var s = Hc(e, du).querySelector(du);
      return s.childNodes;
    }
  }
}
var zN = rn && rn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(fv, "__esModule", { value: !0 });
fv.default = WN;
var $N = zN(hv), UN = Os, HN = /<(![a-zA-Z\s]+)>/;
function WN(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(HN), n = t ? t[1] : void 0;
  return (0, UN.formatDOM)((0, $N.default)(e), null, n);
}
var ip = {}, ro = {}, sp = {}, VN = 0;
sp.SAME = VN;
var ZN = 1;
sp.CAMELCASE = ZN;
sp.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const dS = 0, wi = 1, ap = 2, lp = 3, bv = 4, pS = 5, fS = 6;
function qN(e) {
  return or.hasOwnProperty(e) ? or[e] : null;
}
function yr(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === ap || t === lp || t === bv, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const or = {}, GN = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
GN.forEach((e) => {
  or[e] = new yr(
    e,
    dS,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  or[e] = new yr(
    e,
    wi,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  or[e] = new yr(
    e,
    ap,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  or[e] = new yr(
    e,
    ap,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  or[e] = new yr(
    e,
    lp,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  or[e] = new yr(
    e,
    lp,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  or[e] = new yr(
    e,
    bv,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  or[e] = new yr(
    e,
    fS,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  or[e] = new yr(
    e,
    pS,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const wv = /[\-\:]([a-z])/g, Cv = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(wv, Cv);
  or[t] = new yr(
    t,
    wi,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(wv, Cv);
  or[t] = new yr(
    t,
    wi,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(wv, Cv);
  or[t] = new yr(
    t,
    wi,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  or[e] = new yr(
    e,
    wi,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const YN = "xlinkHref";
or[YN] = new yr(
  "xlinkHref",
  wi,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  or[e] = new yr(
    e,
    wi,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: KN,
  SAME: XN,
  possibleStandardNames: P0
} = sp, JN = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", QN = JN + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", e2 = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + QN + "]*$")
), t2 = Object.keys(
  P0
).reduce((e, t) => {
  const n = P0[t];
  return n === XN ? e[t] = t : n === KN ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
ro.BOOLEAN = lp;
ro.BOOLEANISH_STRING = ap;
ro.NUMERIC = pS;
ro.OVERLOADED_BOOLEAN = bv;
ro.POSITIVE_NUMERIC = fS;
ro.RESERVED = dS;
ro.STRING = wi;
ro.getPropertyInfo = qN;
ro.isCustomAttribute = e2;
ro.possibleStandardNames = t2;
var Ev = {}, xv = {}, S0 = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, n2 = /\n/g, r2 = /^\s*/, o2 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, i2 = /^:\s*/, s2 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, a2 = /^[;\s]*/, l2 = /^\s+|\s+$/g, u2 = `
`, M0 = "/", T0 = "*", Ji = "", c2 = "comment", d2 = "declaration", p2 = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(n2);
    m && (n += m.length);
    var h = f.lastIndexOf(u2);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new s(f), u(), m;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var h = m[0];
      return o(h), e = e.slice(h.length), m;
    }
  }
  function u() {
    l(r2);
  }
  function c(f) {
    var m;
    for (f = f || []; m = d(); )
      m !== !1 && f.push(m);
    return f;
  }
  function d() {
    var f = i();
    if (!(M0 != e.charAt(0) || T0 != e.charAt(1))) {
      for (var m = 2; Ji != e.charAt(m) && (T0 != e.charAt(m) || M0 != e.charAt(m + 1)); )
        ++m;
      if (m += 2, Ji === e.charAt(m - 1))
        return a("End of comment missing");
      var h = e.slice(2, m - 2);
      return r += 2, o(h), e = e.slice(m), r += 2, f({
        type: c2,
        comment: h
      });
    }
  }
  function p() {
    var f = i(), m = l(o2);
    if (m) {
      if (d(), !l(i2)) return a("property missing ':'");
      var h = l(s2), C = f({
        type: d2,
        property: j0(m[0].replace(S0, Ji)),
        value: h ? j0(h[0].replace(S0, Ji)) : Ji
      });
      return l(a2), C;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = p(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function j0(e) {
  return e ? e.replace(l2, Ji) : Ji;
}
var f2 = rn && rn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(xv, "__esModule", { value: !0 });
xv.default = g2;
var h2 = f2(p2);
function g2(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, h2.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var up = {};
Object.defineProperty(up, "__esModule", { value: !0 });
up.camelCase = void 0;
var m2 = /^--[a-zA-Z0-9_-]+$/, v2 = /-([a-z])/g, y2 = /^[^-]+$/, b2 = /^-(webkit|moz|ms|o|khtml)-/, w2 = /^-(ms)-/, C2 = function(e) {
  return !e || y2.test(e) || m2.test(e);
}, E2 = function(e, t) {
  return t.toUpperCase();
}, A0 = function(e, t) {
  return "".concat(t, "-");
}, x2 = function(e, t) {
  return t === void 0 && (t = {}), C2(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(w2, A0) : e = e.replace(b2, A0), e.replace(v2, E2));
};
up.camelCase = x2;
var O2 = rn && rn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, k2 = O2(xv), _2 = up;
function Bg(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, k2.default)(e, function(r, o) {
    r && o && (n[(0, _2.camelCase)(r, t)] = o);
  }), n;
}
Bg.default = Bg;
var L2 = Bg;
(function(e) {
  var t = rn && rn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Oe, r = t(L2), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, d) {
    return c.includes("-") ? !o.has(c) : !!(d && typeof d.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, d) {
    if (typeof c == "string") {
      if (!c.trim()) {
        d.style = {};
        return;
      }
      try {
        d.style = (0, r.default)(c, s);
      } catch {
        d.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Ev);
Object.defineProperty(ip, "__esModule", { value: !0 });
ip.default = M2;
var _a = ro, B0 = Ev, D2 = ["checked", "value"], P2 = ["input", "select", "textarea"], S2 = {
  reset: !0,
  submit: !0
};
function M2(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && S2[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, _a.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = I0(s);
    if (a) {
      var l = (0, _a.getPropertyInfo)(a);
      switch (D2.includes(a) && P2.includes(t) && !r && (a = I0("default" + s)), n[a] = i, l && l.type) {
        case _a.BOOLEAN:
          n[a] = !0;
          break;
        case _a.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    B0.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, B0.setStyleProp)(e.style, n), n;
}
function I0(e) {
  return _a.possibleStandardNames[e];
}
var Ov = {}, T2 = rn && rn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ov, "__esModule", { value: !0 });
Ov.default = hS;
var Tf = Oe, j2 = T2(ip), Ba = Ev, A2 = {
  cloneElement: Tf.cloneElement,
  createElement: Tf.createElement,
  isValidElement: Tf.isValidElement
};
function hS(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Ba.returnFirstArg, i = t.library || A2, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var d = e[c];
    if (r) {
      var p = t.replace(d, c);
      if (l(p)) {
        u > 1 && (p = s(p, {
          key: p.key || c
        })), n.push(o(p, d, c));
        continue;
      }
    }
    if (d.type === "text") {
      var g = !d.data.trim().length;
      if (g && d.parent && !(0, Ba.canTextBeChildOfNode)(d.parent) || t.trim && g)
        continue;
      n.push(o(d.data, d, c));
      continue;
    }
    var f = d, m = {};
    B2(f) ? ((0, Ba.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, j2.default)(f.attribs, f.name));
    var h = void 0;
    switch (d.type) {
      case "script":
      case "style":
        d.children[0] && (m.dangerouslySetInnerHTML = {
          __html: d.children[0].data
        });
        break;
      case "tag":
        d.name === "textarea" && d.children[0] ? m.defaultValue = d.children[0].data : d.children && d.children.length && (h = hS(d.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(a(d.name, m, h), d, c));
  }
  return n.length === 1 ? n[0] : n;
}
function B2(e) {
  return Ba.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Ba.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = rn && rn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(fv);
  e.htmlToDOM = n.default;
  var r = t(ip);
  e.attributesToProps = r.default;
  var o = t(Ov);
  e.domToReact = o.default;
  var i = gv;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(GP);
const F0 = /* @__PURE__ */ Jd(GP), I2 = F0.default || F0, Ig = (e) => {
  var r;
  if (typeof e == "string")
    return { text: e };
  const t = Array.isArray(e.props.children) ? e.props.children.map((o) => Ig(o)) : [{ text: e.props.children || "" }], n = (r = e.props.className) == null ? void 0 : r.replace("align_", "");
  switch (e.type) {
    case "img":
      return {
        type: "image",
        align: n,
        src: e.props.src,
        children: [{ text: "" }]
      };
    case "p":
      return { type: "paragraph", align: n, children: t };
    case "blockquote":
      return { type: "blockQuote", align: n, children: t };
    case "ul":
      return { type: "bulletedList", align: n, children: t };
    case "ol":
      return { type: "numberedList", align: n, children: t };
    case "li":
      return { type: "listItem", align: n, children: t };
    case "h1":
      return { type: "headingOne", align: n, children: t };
    case "h2":
      return { type: "headingTwo", align: n, children: t };
    case "strong":
      return { text: e.props.children, bold: !0 };
    case "code":
      return { text: e.props.children, code: !0 };
    case "em":
      return { text: e.props.children, italic: !0 };
    case "u":
      return { text: e.props.children, underline: !0 };
    default:
      return { text: e.props.children || "" };
  }
}, tue = (e) => {
  const t = I2(e);
  return Array.isArray(t) ? t.map((n) => typeof n == "string" ? { text: n } : Ig(n)) : typeof t == "string" ? [{ text: t }] : [Ig(t)];
}, nue = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function gS(e, t, n) {
  if (!e) return /* @__PURE__ */ B.jsx(B.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ B.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ B.jsx("p", { className: n, children: /* @__PURE__ */ B.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function rue(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: s = "",
    children: a,
    ...l
  } = e, c = { md: 12, lg: 14 }[r], d = `arkynBadge ${t} ${n} ${r} ${s}`;
  return /* @__PURE__ */ B.jsxs("div", { className: d.trim(), ...l, children: [
    Fc(c, o),
    a,
    Fc(c, i)
  ] });
}
function oue(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ B.jsx("div", { className: r.trim(), ...n });
}
function mS(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ B.jsx("div", { className: o.trim(), ...r });
}
function iue(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ B.jsx("aside", { className: r.trim(), ...n });
}
function sue(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, s = Ct.count(r) === 0;
  return /* @__PURE__ */ B.jsx("tbody", { className: i.trim(), ...o, children: s ? /* @__PURE__ */ B.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ B.jsx("td", { colSpan: 100, children: /* @__PURE__ */ B.jsx("div", { children: t }) }) }) : r });
}
function aue(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ B.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ B.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function lue(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ B.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ B.jsx("table", { children: t }) });
}
function uue(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ B.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ B.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ B.jsx("tr", { children: /* @__PURE__ */ B.jsx("th", { colSpan: 100, children: /* @__PURE__ */ B.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function cue(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ B.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ B.jsx("tr", { children: n }),
    /* @__PURE__ */ B.jsx("tr", { className: "spacingRow" })
  ] });
}
var on = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function F2(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Fg = { exports: {} }, sa = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var R0;
function R2() {
  if (R0) return sa;
  R0 = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, d = {}, p = null, g = null;
    u !== void 0 && (p = "" + u), l.key !== void 0 && (p = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (d[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) d[c] === void 0 && (d[c] = l[c]);
    return { $$typeof: t, type: a, key: p, ref: g, props: d, _owner: o.current };
  }
  return sa.Fragment = n, sa.jsx = s, sa.jsxs = s, sa;
}
var hu = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var N0;
function N2() {
  return N0 || (N0 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var $ = f && b[f] || b[m];
      return typeof $ == "function" ? $ : null;
    }
    var C = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var $ = arguments.length, Q = new Array($ > 1 ? $ - 1 : 0), re = 1; re < $; re++)
          Q[re - 1] = arguments[re];
        P("error", b, Q);
      }
    }
    function P(b, $, Q) {
      {
        var re = C.ReactDebugCurrentFrame, ge = re.getStackAddendum();
        ge !== "" && ($ += "%s", Q = Q.concat([ge]));
        var me = Q.map(function(le) {
          return String(le);
        });
        me.unshift("Warning: " + $), Function.prototype.apply.call(console[b], console, me);
      }
    }
    var E = !1, v = !1, x = !1, L = !1, z = !1, k;
    k = Symbol.for("react.module.reference");
    function R(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || z || b === o || b === u || b === c || L || b === g || E || v || x || typeof b == "object" && b !== null && (b.$$typeof === p || b.$$typeof === d || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === k || b.getModuleId !== void 0));
    }
    function A(b, $, Q) {
      var re = b.displayName;
      if (re)
        return re;
      var ge = $.displayName || $.name || "";
      return ge !== "" ? Q + "(" + ge + ")" : Q;
    }
    function U(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var $ = b;
            return U($) + ".Consumer";
          case s:
            var Q = b;
            return U(Q._context) + ".Provider";
          case l:
            return A(b, b.render, "ForwardRef");
          case d:
            var re = b.displayName || null;
            return re !== null ? re : V(b.type) || "Memo";
          case p: {
            var ge = b, me = ge._payload, le = ge._init;
            try {
              return V(le(me));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var N = Object.assign, Z = 0, K, X, te, ee, D, j, G;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function Y() {
      {
        if (Z === 0) {
          K = console.log, X = console.info, te = console.warn, ee = console.error, D = console.group, j = console.groupCollapsed, G = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: N({}, b, {
              value: K
            }),
            info: N({}, b, {
              value: X
            }),
            warn: N({}, b, {
              value: te
            }),
            error: N({}, b, {
              value: ee
            }),
            group: N({}, b, {
              value: D
            }),
            groupCollapsed: N({}, b, {
              value: j
            }),
            groupEnd: N({}, b, {
              value: G
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = C.ReactCurrentDispatcher, W;
    function T(b, $, Q) {
      {
        if (W === void 0)
          try {
            throw Error();
          } catch (ge) {
            var re = ge.stack.trim().match(/\n( *(at )?)/);
            W = re && re[1] || "";
          }
        return `
` + W + b;
      }
    }
    var q = !1, I;
    {
      var J = typeof WeakMap == "function" ? WeakMap : Map;
      I = new J();
    }
    function H(b, $) {
      if (!b || q)
        return "";
      {
        var Q = I.get(b);
        if (Q !== void 0)
          return Q;
      }
      var re;
      q = !0;
      var ge = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var me;
      me = M.current, M.current = null, Y();
      try {
        if ($) {
          var le = function() {
            throw Error();
          };
          if (Object.defineProperty(le.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(le, []);
            } catch (ze) {
              re = ze;
            }
            Reflect.construct(b, [], le);
          } else {
            try {
              le.call();
            } catch (ze) {
              re = ze;
            }
            b.call(le.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ze) {
            re = ze;
          }
          b();
        }
      } catch (ze) {
        if (ze && re && typeof ze.stack == "string") {
          for (var se = ze.stack.split(`
`), Be = re.stack.split(`
`), ke = se.length - 1, Le = Be.length - 1; ke >= 1 && Le >= 0 && se[ke] !== Be[Le]; )
            Le--;
          for (; ke >= 1 && Le >= 0; ke--, Le--)
            if (se[ke] !== Be[Le]) {
              if (ke !== 1 || Le !== 1)
                do
                  if (ke--, Le--, Le < 0 || se[ke] !== Be[Le]) {
                    var We = `
` + se[ke].replace(" at new ", " at ");
                    return b.displayName && We.includes("<anonymous>") && (We = We.replace("<anonymous>", b.displayName)), typeof b == "function" && I.set(b, We), We;
                  }
                while (ke >= 1 && Le >= 0);
              break;
            }
        }
      } finally {
        q = !1, M.current = me, O(), Error.prepareStackTrace = ge;
      }
      var dn = b ? b.displayName || b.name : "", Ht = dn ? T(dn) : "";
      return typeof b == "function" && I.set(b, Ht), Ht;
    }
    function ce(b, $, Q) {
      return H(b, !1);
    }
    function ye(b) {
      var $ = b.prototype;
      return !!($ && $.isReactComponent);
    }
    function ie(b, $, Q) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return H(b, ye(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ce(b.render);
          case d:
            return ie(b.type, $, Q);
          case p: {
            var re = b, ge = re._payload, me = re._init;
            try {
              return ie(me(ge), $, Q);
            } catch {
            }
          }
        }
      return "";
    }
    var Te = Object.prototype.hasOwnProperty, Re = {}, Ne = C.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var $ = b._owner, Q = ie(b.type, b._source, $ ? $.type : null);
        Ne.setExtraStackFrame(Q);
      } else
        Ne.setExtraStackFrame(null);
    }
    function Ke(b, $, Q, re, ge) {
      {
        var me = Function.call.bind(Te);
        for (var le in b)
          if (me(b, le)) {
            var se = void 0;
            try {
              if (typeof b[le] != "function") {
                var Be = Error((re || "React class") + ": " + Q + " type `" + le + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[le] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Be.name = "Invariant Violation", Be;
              }
              se = b[le]($, le, re, Q, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ke) {
              se = ke;
            }
            se && !(se instanceof Error) && (Ie(ge), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", re || "React class", Q, le, typeof se), Ie(null)), se instanceof Error && !(se.message in Re) && (Re[se.message] = !0, Ie(ge), w("Failed %s type: %s", Q, se.message), Ie(null));
          }
      }
    }
    var Ze = Array.isArray;
    function Se(b) {
      return Ze(b);
    }
    function qe(b) {
      {
        var $ = typeof Symbol == "function" && Symbol.toStringTag, Q = $ && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return Q;
      }
    }
    function rt(b) {
      try {
        return Pe(b), !1;
      } catch {
        return !0;
      }
    }
    function Pe(b) {
      return "" + b;
    }
    function Me(b) {
      if (rt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qe(b)), Pe(b);
    }
    var Ge = C.ReactCurrentOwner, He = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, $e, ot;
    function Fe(b) {
      if (Te.call(b, "ref")) {
        var $ = Object.getOwnPropertyDescriptor(b, "ref").get;
        if ($ && $.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function Kt(b) {
      if (Te.call(b, "key")) {
        var $ = Object.getOwnPropertyDescriptor(b, "key").get;
        if ($ && $.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function lt(b, $) {
      typeof b.ref == "string" && Ge.current;
    }
    function ht(b, $) {
      {
        var Q = function() {
          $e || ($e = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", $));
        };
        Q.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: Q,
          configurable: !0
        });
      }
    }
    function Dt(b, $) {
      {
        var Q = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", $));
        };
        Q.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: Q,
          configurable: !0
        });
      }
    }
    var ln = function(b, $, Q, re, ge, me, le) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: $,
        ref: Q,
        props: le,
        // Record the component responsible for creating this element.
        _owner: me
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: re
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ge
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function Pt(b, $, Q, re, ge) {
      {
        var me, le = {}, se = null, Be = null;
        Q !== void 0 && (Me(Q), se = "" + Q), Kt($) && (Me($.key), se = "" + $.key), Fe($) && (Be = $.ref, lt($));
        for (me in $)
          Te.call($, me) && !He.hasOwnProperty(me) && (le[me] = $[me]);
        if (b && b.defaultProps) {
          var ke = b.defaultProps;
          for (me in ke)
            le[me] === void 0 && (le[me] = ke[me]);
        }
        if (se || Be) {
          var Le = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && ht(le, Le), Be && Dt(le, Le);
        }
        return ln(b, se, Be, ge, re, Ge.current, le);
      }
    }
    var St = C.ReactCurrentOwner, ut = C.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var $ = b._owner, Q = ie(b.type, b._source, $ ? $.type : null);
        ut.setExtraStackFrame(Q);
      } else
        ut.setExtraStackFrame(null);
    }
    var un;
    un = !1;
    function cn(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Nt() {
      {
        if (St.current) {
          var b = V(St.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function Gn(b) {
      return "";
    }
    var zt = {};
    function Yn(b) {
      {
        var $ = Nt();
        if (!$) {
          var Q = typeof b == "string" ? b : b.displayName || b.name;
          Q && ($ = `

Check the top-level render call using <` + Q + ">.");
        }
        return $;
      }
    }
    function $t(b, $) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var Q = Yn($);
        if (zt[Q])
          return;
        zt[Q] = !0;
        var re = "";
        b && b._owner && b._owner !== St.current && (re = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Q, re), Xe(null);
      }
    }
    function Sn(b, $) {
      {
        if (typeof b != "object")
          return;
        if (Se(b))
          for (var Q = 0; Q < b.length; Q++) {
            var re = b[Q];
            cn(re) && $t(re, $);
          }
        else if (cn(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ge = h(b);
          if (typeof ge == "function" && ge !== b.entries)
            for (var me = ge.call(b), le; !(le = me.next()).done; )
              cn(le.value) && $t(le.value, $);
        }
      }
    }
    function pr(b) {
      {
        var $ = b.type;
        if ($ == null || typeof $ == "string")
          return;
        var Q;
        if (typeof $ == "function")
          Q = $.propTypes;
        else if (typeof $ == "object" && ($.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        $.$$typeof === d))
          Q = $.propTypes;
        else
          return;
        if (Q) {
          var re = V($);
          Ke(Q, b.props, "prop", re, b);
        } else if ($.PropTypes !== void 0 && !un) {
          un = !0;
          var ge = V($);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ge || "Unknown");
        }
        typeof $.getDefaultProps == "function" && !$.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ut(b) {
      {
        for (var $ = Object.keys(b.props), Q = 0; Q < $.length; Q++) {
          var re = $[Q];
          if (re !== "children" && re !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", re), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var oe = {};
    function to(b, $, Q, re, ge, me) {
      {
        var le = R(b);
        if (!le) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Be = Gn();
          Be ? se += Be : se += Nt();
          var ke;
          b === null ? ke = "null" : Se(b) ? ke = "array" : b !== void 0 && b.$$typeof === t ? (ke = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : ke = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ke, se);
        }
        var Le = Pt(b, $, Q, ge, me);
        if (Le == null)
          return Le;
        if (le) {
          var We = $.children;
          if (We !== void 0)
            if (re)
              if (Se(We)) {
                for (var dn = 0; dn < We.length; dn++)
                  Sn(We[dn], b);
                Object.freeze && Object.freeze(We);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Sn(We, b);
        }
        if (Te.call($, "key")) {
          var Ht = V(b), ze = Object.keys($).filter(function(Fi) {
            return Fi !== "key";
          }), fr = ze.length > 0 ? "{key: someKey, " + ze.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!oe[Ht + fr]) {
            var Ii = ze.length > 0 ? "{" + ze.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, fr, Ht, Ii, Ht), oe[Ht + fr] = !0;
          }
        }
        return b === r ? Ut(Le) : pr(Le), Le;
      }
    }
    function Ti(b, $, Q) {
      return to(b, $, Q, !0);
    }
    function ji(b, $, Q) {
      return to(b, $, Q, !1);
    }
    var Ai = ji, Bi = Ti;
    hu.Fragment = r, hu.jsx = Ai, hu.jsxs = Bi;
  }()), hu;
}
process.env.NODE_ENV === "production" ? Fg.exports = R2() : Fg.exports = N2();
var Rt = Fg.exports;
Ve({});
function z0(e, t) {
  return t ? /* @__PURE__ */ Rt.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ Rt.jsx(Rt.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function $0(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function lr(e) {
  var t, n;
  return $0(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !($0(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var vS = Symbol.for("immer-nothing"), U0 = Symbol.for("immer-draftable"), Ur = Symbol.for("immer-state"), z2 = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function kr(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = z2[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var zs = Object.getPrototypeOf;
function gs(e) {
  return !!e && !!e[Ur];
}
function ms(e) {
  var t;
  return e ? yS(e) || Array.isArray(e) || !!e[U0] || !!((t = e.constructor) != null && t[U0]) || dp(e) || pp(e) : !1;
}
var $2 = Object.prototype.constructor.toString();
function yS(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = zs(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === $2;
}
function Wc(e, t) {
  cp(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function cp(e) {
  const t = e[Ur];
  return t ? t.type_ : Array.isArray(e) ? 1 : dp(e) ? 2 : pp(e) ? 3 : 0;
}
function Rg(e, t) {
  return cp(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function bS(e, t, n) {
  const r = cp(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function U2(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function dp(e) {
  return e instanceof Map;
}
function pp(e) {
  return e instanceof Set;
}
function Gi(e) {
  return e.copy_ || e.base_;
}
function Ng(e, t) {
  if (dp(e))
    return new Map(e);
  if (pp(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = yS(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ur];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(zs(e), r);
  } else {
    const r = zs(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function kv(e, t = !1) {
  return fp(e) || gs(e) || !ms(e) || (cp(e) > 1 && (e.set = e.add = e.clear = e.delete = H2), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => kv(r, !0))), e;
}
function H2() {
  kr(2);
}
function fp(e) {
  return Object.isFrozen(e);
}
var W2 = {};
function vs(e) {
  const t = W2[e];
  return t || kr(0, e), t;
}
var ol;
function wS() {
  return ol;
}
function V2(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function H0(e, t) {
  t && (vs("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function zg(e) {
  $g(e), e.drafts_.forEach(Z2), e.drafts_ = null;
}
function $g(e) {
  e === ol && (ol = e.parent_);
}
function W0(e) {
  return ol = V2(ol, e);
}
function Z2(e) {
  const t = e[Ur];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function V0(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ur].modified_ && (zg(t), kr(4)), ms(e) && (e = Vc(t, e), t.parent_ || Zc(t, e)), t.patches_ && vs("Patches").generateReplacementPatches_(
    n[Ur].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Vc(t, n, []), zg(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== vS ? e : void 0;
}
function Vc(e, t, n) {
  if (fp(t))
    return t;
  const r = t[Ur];
  if (!r)
    return Wc(
      t,
      (o, i) => Z0(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Zc(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Wc(
      i,
      (a, l) => Z0(e, r, o, a, l, n, s)
    ), Zc(e, o, !1), n && e.patches_ && vs("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Z0(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && kr(5), gs(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Rg(t.assigned_, r) ? i.concat(r) : void 0, l = Vc(e, o, a);
    if (bS(n, r, l), gs(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (ms(o) && !fp(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Vc(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Zc(e, o);
  }
}
function Zc(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && kv(t, n);
}
function q2(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : wS(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = _v;
  n && (o = [r], i = il);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var _v = {
  get(e, t) {
    if (t === Ur)
      return e;
    const n = Gi(e);
    if (!Rg(n, t))
      return G2(e, n, t);
    const r = n[t];
    return e.finalized_ || !ms(r) ? r : r === jf(e.base_, t) ? (Af(e), e.copy_[t] = Hg(r, e)) : r;
  },
  has(e, t) {
    return t in Gi(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Gi(e));
  },
  set(e, t, n) {
    const r = CS(Gi(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = jf(Gi(e), t), i = o == null ? void 0 : o[Ur];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (U2(n, o) && (n !== void 0 || Rg(e.base_, t)))
        return !0;
      Af(e), Ug(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return jf(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Af(e), Ug(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Gi(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    kr(11);
  },
  getPrototypeOf(e) {
    return zs(e.base_);
  },
  setPrototypeOf() {
    kr(12);
  }
}, il = {};
Wc(_v, (e, t) => {
  il[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
il.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && kr(13), il.set.call(this, e, t, void 0);
};
il.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && kr(14), _v.set.call(this, e[0], t, n, e[0]);
};
function jf(e, t) {
  const n = e[Ur];
  return (n ? Gi(n) : e)[t];
}
function G2(e, t, n) {
  var r;
  const o = CS(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function CS(e, t) {
  if (!(t in e))
    return;
  let n = zs(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = zs(n);
  }
}
function Ug(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Ug(e.parent_));
}
function Af(e) {
  e.copy_ || (e.copy_ = Ng(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Y2 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && kr(6), r !== void 0 && typeof r != "function" && kr(7);
      let o;
      if (ms(t)) {
        const i = W0(this), s = Hg(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? zg(i) : $g(i);
        }
        return H0(i, r), V0(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === vS && (o = void 0), this.autoFreeze_ && kv(o, !0), r) {
          const i = [], s = [];
          vs("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        kr(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ms(e) || kr(8), gs(e) && (e = K2(e));
    const t = W0(this), n = Hg(e, void 0);
    return n[Ur].isManual_ = !0, $g(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ur];
    (!n || !n.isManual_) && kr(9);
    const { scope_: r } = n;
    return H0(r, t), V0(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = vs("Patches").applyPatches_;
    return gs(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Hg(e, t) {
  const n = dp(e) ? vs("MapSet").proxyMap_(e, t) : pp(e) ? vs("MapSet").proxySet_(e, t) : q2(e, t);
  return (t ? t.scope_ : wS()).drafts_.push(n), n;
}
function K2(e) {
  return gs(e) || kr(10, e), ES(e);
}
function ES(e) {
  if (!ms(e) || fp(e))
    return e;
  const t = e[Ur];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Ng(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Ng(e, !0);
  return Wc(n, (r, o) => {
    bS(n, r, ES(o));
  }), t && (t.finalized_ = !1), n;
}
var Hr = new Y2(), Lv = Hr.produce;
Hr.produceWithPatches.bind(
  Hr
);
Hr.setAutoFreeze.bind(Hr);
Hr.setUseStrictShallowCopy.bind(Hr);
Hr.applyPatches.bind(Hr);
var q0 = Hr.createDraft.bind(Hr), G0 = Hr.finishDraft.bind(Hr), be = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = be.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return be.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return be.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return be.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return be.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && be.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return be.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && be.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && be.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && be.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && be.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && be.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!be.isAncestor(t, e) && !be.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (be.equals(i, r) || be.endsBefore(i, r) || be.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (be.equals(s, r) || be.isAncestor(s, r))
          return null;
        be.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        be.equals(a, r) || be.endsBefore(a, r) ? r[a.length - 1] -= 1 : be.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (be.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else be.endsBefore(u, r) ? r[u.length - 1] += 1 : be.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: d,
          newPath: p
        } = t;
        if (be.equals(d, p))
          return r;
        if (be.isAncestor(d, r) || be.equals(d, r)) {
          var g = p.slice();
          return be.endsBefore(d, p) && d.length < p.length && (g[d.length - 1] -= 1), g.concat(r.slice(d.length));
        } else be.isSibling(d, p) && (be.isAncestor(p, r) || be.equals(p, r)) ? be.endsBefore(d, r) ? r[d.length - 1] -= 1 : r[d.length - 1] += 1 : be.endsBefore(p, r) || be.equals(p, r) || be.isAncestor(p, r) ? (be.endsBefore(d, r) && (r[d.length - 1] -= 1), r[p.length - 1] += 1) : be.endsBefore(d, r) && (be.equals(p, r) && (r[p.length - 1] += 1), r[d.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function sl(e) {
  "@babel/helpers - typeof";
  return sl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, sl(e);
}
function X2(e, t) {
  if (sl(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (sl(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function J2(e) {
  var t = X2(e, "string");
  return sl(t) === "symbol" ? t : String(t);
}
function Zs(e, t, n) {
  return t = J2(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Y0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aa(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Y0(Object(n), !0).forEach(function(r) {
      Zs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Y0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Q2 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Qe.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of dt.points(t))
          t[l] = gn.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: d
      } = n;
      if (d.length === 0) break;
      var p = Qe.leaf(e, u), g = p.text.slice(0, c), f = p.text.slice(c);
      if (p.text = g + d + f, t)
        for (var [m, h] of dt.points(t))
          t[h] = gn.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: C
      } = n, w = Qe.get(e, C), P = be.previous(C), E = Qe.get(e, P), v = Qe.parent(e, C), x = C[C.length - 1];
      if (zn.isText(w) && zn.isText(E))
        E.text += w.text;
      else if (!zn.isText(w) && !zn.isText(E))
        E.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(C, "] to nodes of different interfaces: ").concat(jr.stringify(w), " ").concat(jr.stringify(E)));
      if (v.children.splice(x, 1), t)
        for (var [L, z] of dt.points(t))
          t[z] = gn.transform(L, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: R
      } = n;
      if (be.isAncestor(k, R))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(R, "] because the destination is inside itself."));
      var A = Qe.get(e, k), U = Qe.parent(e, k), V = k[k.length - 1];
      U.children.splice(V, 1);
      var N = be.transform(k, n), Z = Qe.get(e, be.parent(N)), K = N[N.length - 1];
      if (Z.children.splice(K, 0, A), t)
        for (var [X, te] of dt.points(t))
          t[te] = gn.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, D = ee[ee.length - 1], j = Qe.parent(e, ee);
      if (j.children.splice(D, 1), t)
        for (var [G, S] of dt.points(t)) {
          var Y = gn.transform(G, n);
          if (t != null && Y != null)
            t[S] = Y;
          else {
            var O = void 0, M = void 0;
            for (var [W, T] of Qe.texts(e))
              if (be.compare(T, ee) === -1)
                O = [W, T];
              else {
                M = [W, T];
                break;
              }
            var q = !1;
            O && M && (be.equals(M[1], ee) ? q = !be.hasPrevious(M[1]) : q = be.common(O[1], ee).length < be.common(M[1], ee).length), O && !q ? (G.path = O[1], G.offset = O[0].text.length) : M ? (G.path = M[1], G.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: I,
        offset: J,
        text: H
      } = n;
      if (H.length === 0) break;
      var ce = Qe.leaf(e, I), ye = ce.text.slice(0, J), ie = ce.text.slice(J + H.length);
      if (ce.text = ye + ie, t)
        for (var [Te, Re] of dt.points(t))
          t[Re] = gn.transform(Te, n);
      break;
    }
    case "set_node": {
      var {
        path: Ne,
        properties: Ie,
        newProperties: Ke
      } = n;
      if (Ne.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ze = Qe.get(e, Ne);
      for (var Se in Ke) {
        if (Se === "children" || Se === "text")
          throw new Error('Cannot set the "'.concat(Se, '" property of nodes!'));
        var qe = Ke[Se];
        qe == null ? delete Ze[Se] : Ze[Se] = qe;
      }
      for (var rt in Ie)
        Ke.hasOwnProperty(rt) || delete Ze[rt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Pe
      } = n;
      if (Pe == null)
        t = Pe;
      else {
        if (t == null) {
          if (!dt.isRange(Pe))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(jr.stringify(Pe), " when there is no current selection."));
          t = aa({}, Pe);
        }
        for (var Me in Pe) {
          var Ge = Pe[Me];
          if (Ge == null) {
            if (Me === "anchor" || Me === "focus")
              throw new Error('Cannot remove the "'.concat(Me, '" selection property'));
            delete t[Me];
          } else
            t[Me] = Ge;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: He,
        position: $e,
        properties: ot
      } = n;
      if (He.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(He, "] because the root node cannot be split."));
      var Fe = Qe.get(e, He), Kt = Qe.parent(e, He), lt = He[He.length - 1], ht;
      if (zn.isText(Fe)) {
        var Dt = Fe.text.slice(0, $e), ln = Fe.text.slice($e);
        Fe.text = Dt, ht = aa(aa({}, ot), {}, {
          text: ln
        });
      } else {
        var Pt = Fe.children.slice(0, $e), St = Fe.children.slice($e);
        Fe.children = Pt, ht = aa(aa({}, ot), {}, {
          children: St
        });
      }
      if (Kt.children.splice(lt + 1, 0, ht), t)
        for (var [ut, Xe] of dt.points(t))
          t[Xe] = gn.transform(ut, n);
      break;
    }
  }
  return t;
}, ez = {
  transform(e, t) {
    e.children = q0(e.children);
    var n = e.selection && q0(e.selection);
    try {
      n = Q2(e, n, t);
    } finally {
      e.children = G0(e.children), n ? e.selection = gs(n) ? G0(n) : n : e.selection = null;
    }
  }
}, tz = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, nz = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, xS = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (lr(r) && lr(o)) {
      if (!xS(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function rz(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function al(e, t) {
  if (e == null) return {};
  var n = rz(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var oz = ["anchor", "focus"];
function K0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? K0(Object(n), !0).forEach(function(r) {
      Zs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : K0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return dt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = dt.edges(e);
    return t;
  },
  equals(e, t) {
    return gn.equals(e.anchor, t.anchor) && gn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (dt.isRange(t)) {
      if (dt.includes(e, t.anchor) || dt.includes(e, t.focus))
        return !0;
      var [n, r] = dt.edges(e), [o, i] = dt.edges(t);
      return gn.isBefore(n, o) && gn.isAfter(r, i);
    }
    var [s, a] = dt.edges(e), l = !1, u = !1;
    return gn.isPoint(t) ? (l = gn.compare(t, s) >= 0, u = gn.compare(t, a) <= 0) : (l = be.compare(t, s.path) >= 0, u = be.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = al(e, oz), [r, o] = dt.edges(e), [i, s] = dt.edges(t), a = gn.isBefore(r, i) ? i : r, l = gn.isBefore(o, s) ? o : s;
    return gn.isBefore(l, a) ? null : iz({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return gn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return gn.equals(t, n);
  },
  isExpanded(e) {
    return !dt.isCollapsed(e);
  },
  isForward(e) {
    return !dt.isBackward(e);
  },
  isRange(e) {
    return lr(e) && gn.isPoint(e.anchor) && gn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = dt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Lv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = dt.isCollapsed(r);
        dt.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? dt.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = gn.transform(r.anchor, t, {
        affinity: i
      }), u = gn.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, X0 = (e) => lr(e) && Qe.isNodeList(e.children) && !en.isEditor(e), So = {
  isAncestor(e) {
    return lr(e) && Qe.isNodeList(e.children);
  },
  isElement: X0,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => So.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return X0(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, sz = ["children"], az = ["text"], J0 = /* @__PURE__ */ new WeakMap(), Qe = {
  ancestor(e, t) {
    var n = Qe.get(e, t);
    if (zn.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(jr.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of be.ancestors(t, n)) {
        var o = Qe.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (zn.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(jr.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(jr.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Qe.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = Qe.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = be.common(t, n), o = Qe.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Qe.get(e, t);
    if (en.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(jr.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Qe.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Qe.nodes(e, t))
        So.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (So.isAncestor(e)) {
      var t = al(e, sz);
      return t;
    } else {
      var t = al(e, az);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Qe.get(e, n); r && !(zn.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (zn.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(jr.stringify(e)));
    var n = Lv({
      children: e.children
    }, (r) => {
      var [o, i] = dt.edges(t), s = Qe.nodes(r, {
        reverse: !0,
        pass: (p) => {
          var [, g] = p;
          return !dt.includes(t, g);
        }
      });
      for (var [, a] of s) {
        if (!dt.includes(t, a)) {
          var l = Qe.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (be.equals(a, i.path)) {
          var c = Qe.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (be.equals(a, o.path)) {
          var d = Qe.leaf(r, a);
          d.text = d.text.slice(o.offset);
        }
      }
      en.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (zn.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(jr.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (zn.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return zn.isText(e) || So.isElement(e) || en.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = J0.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Qe.isNode(r));
    return J0.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Qe.get(e, n); r && !(zn.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Qe.get(e, t);
    if (!zn.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(jr.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of be.levels(t, n)) {
        var o = Qe.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return So.isElement(e) && So.isElementProps(t) && So.matches(e, t) || zn.isText(e) && zn.isTextProps(t) && zn.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? be.isBefore(a, i) : be.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !zn.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          be.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = Qe.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = be.next(a);
          if (Qe.has(e, c)) {
            a = c, l = Qe.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var d = be.previous(a);
          a = d, l = Qe.get(e, a);
          continue;
        }
        a = be.parent(a), l = Qe.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = be.parent(t), r = Qe.get(e, n);
    if (zn.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return zn.isText(e) ? e.text : e.children.map(Qe.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Qe.nodes(e, t))
        zn.isText(n) && (yield [n, r]);
    }();
  }
};
function Q0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Q0(Object(n), !0).forEach(function(r) {
      Zs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Q0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var La = {
  isNodeOperation(e) {
    return La.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!lr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return be.isPath(e.path) && Qe.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && be.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && be.isPath(e.path) && lr(e.properties);
      case "move_node":
        return be.isPath(e.path) && be.isPath(e.newPath);
      case "remove_node":
        return be.isPath(e.path) && Qe.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && be.isPath(e.path);
      case "set_node":
        return be.isPath(e.path) && lr(e.properties) && lr(e.newProperties);
      case "set_selection":
        return e.properties === null && dt.isRange(e.newProperties) || e.newProperties === null && dt.isRange(e.properties) || lr(e.properties) && lr(e.newProperties);
      case "split_node":
        return be.isPath(e.path) && typeof e.position == "number" && lr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => La.isOperation(t));
  },
  isSelectionOperation(e) {
    return La.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return La.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return bn(bn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return bn(bn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return bn(bn({}, e), {}, {
          type: "split_node",
          path: be.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (be.equals(t, n))
          return e;
        if (be.isSibling(n, t))
          return bn(bn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = be.transform(n, e), o = be.transform(be.next(n), e);
        return bn(bn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return bn(bn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return bn(bn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return bn(bn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? bn(bn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? bn(bn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : bn(bn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return bn(bn({}, e), {}, {
          type: "merge_node",
          path: be.next(e.path)
        });
    }
  }
}, ew = /* @__PURE__ */ new WeakMap(), lz = (e) => {
  var t = ew.get(e);
  if (t !== void 0)
    return t;
  if (!lr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || lr(e.marks)) && (e.selection === null || dt.isRange(e.selection)) && Qe.isNodeList(e.children) && La.isOperationList(e.operations);
  return ew.set(e, n), n;
}, en = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return lz(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function tw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tw(Object(n), !0).forEach(function(r) {
      Zs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gn = {
  compare(e, t) {
    var n = be.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return gn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return gn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && be.equals(e.path, t.path);
  },
  isPoint(e) {
    return lr(e) && typeof e.offset == "number" && be.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Lv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = be.transform(i, t, n);
          break;
        }
        case "insert_text": {
          be.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          be.equals(t.path, i) && (r.offset += t.position), r.path = be.transform(i, t, n);
          break;
        }
        case "remove_text": {
          be.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (be.equals(t.path, i) || be.isAncestor(t.path, i))
            return null;
          r.path = be.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (be.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = be.transform(i, t, nw(nw({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = be.transform(i, t, n);
          break;
        }
      }
    });
  }
}, rw = void 0, jr = {
  setScrubber(e) {
    rw = e;
  },
  stringify(e) {
    return JSON.stringify(e, rw);
  }
}, uz = ["text"], cz = ["anchor", "focus"];
function ow(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ow(Object(n), !0).forEach(function(r) {
      Zs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ow(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zn = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = al(i, uz);
      return s;
    }
    return xS(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return lr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => zn.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [xo({}, e)];
    for (var r of t) {
      var o = al(r, cz), [i, s] = dt.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var d of n) {
        var {
          length: p
        } = d.text, g = l;
        if (l += p, u <= g && l <= c) {
          Object.assign(d, o), a.push(d);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          a.push(d);
          continue;
        }
        var f = d, m = void 0, h = void 0;
        if (c < l) {
          var C = c - g;
          h = xo(xo({}, f), {}, {
            text: f.text.slice(C)
          }), f = xo(xo({}, f), {}, {
            text: f.text.slice(0, C)
          });
        }
        if (u > g) {
          var w = u - g;
          m = xo(xo({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = xo(xo({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && a.push(m), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, dz = (e) => e.selection ? e.selection : e.children.length > 0 ? en.end(e, []) : [0], pn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(pn || (pn = {}));
pn.L, pn.L | pn.V | pn.LV | pn.LVT, pn.LV | pn.V, pn.V | pn.T, pn.LVT | pn.T, pn.T, pn.Any, pn.Extend | pn.ZWJ, pn.Any, pn.SpacingMark, pn.Prepend, pn.Any, pn.ZWJ, pn.ExtPict, pn.RI, pn.RI;
var pz = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    en.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = dz(e)
      } = n;
      if (be.isPath(o) && (o = en.range(e, o)), dt.isRange(o))
        if (dt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = dt.end(o);
          if (!r && en.void(e, {
            at: i
          }))
            return;
          var s = dt.start(o), a = en.pointRef(e, s), l = en.pointRef(e, i);
          qc.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, qc.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && en.void(e, {
        at: o
      }) || en.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: d,
          offset: p
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: d,
          offset: p,
          text: t
        });
      }
    });
  }
};
function iw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iw(Object(n), !0).forEach(function(r) {
      Zs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qc = gu(gu(gu(gu({}, ez), tz), nz), pz), OS = {}, Dv = {}, Pv = {}, ks = {}, Sv = {}, Mv = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Mv);
var vt = {}, Ci = on && on.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Ia = on && on.__assign || function() {
  return Ia = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ia.apply(this, arguments);
};
Object.defineProperty(vt, "__esModule", { value: !0 });
vt.cloneNode = vt.hasChildren = vt.isDocument = vt.isDirective = vt.isComment = vt.isText = vt.isCDATA = vt.isTag = vt.Element = vt.Document = vt.CDATA = vt.NodeWithChildren = vt.ProcessingInstruction = vt.Comment = vt.Text = vt.DataNode = vt.Node = void 0;
var Pr = Mv, Tv = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), jv(this, t);
    }, e;
  }()
);
vt.Node = Tv;
var hp = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Tv)
);
vt.DataNode = hp;
var kS = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Pr.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(hp)
);
vt.Text = kS;
var _S = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Pr.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(hp)
);
vt.Comment = _S;
var LS = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Pr.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(hp)
);
vt.ProcessingInstruction = LS;
var gp = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Tv)
);
vt.NodeWithChildren = gp;
var DS = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Pr.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gp)
);
vt.CDATA = DS;
var PS = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Pr.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gp)
);
vt.Document = PS;
var SS = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Pr.ElementType.Script : n === "style" ? Pr.ElementType.Style : Pr.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gp)
);
vt.Element = SS;
function MS(e) {
  return (0, Pr.isTag)(e);
}
vt.isTag = MS;
function TS(e) {
  return e.type === Pr.ElementType.CDATA;
}
vt.isCDATA = TS;
function jS(e) {
  return e.type === Pr.ElementType.Text;
}
vt.isText = jS;
function AS(e) {
  return e.type === Pr.ElementType.Comment;
}
vt.isComment = AS;
function BS(e) {
  return e.type === Pr.ElementType.Directive;
}
vt.isDirective = BS;
function IS(e) {
  return e.type === Pr.ElementType.Root;
}
vt.isDocument = IS;
function fz(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
vt.hasChildren = fz;
function jv(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (jS(e))
    n = new kS(e.data);
  else if (AS(e))
    n = new _S(e.data);
  else if (MS(e)) {
    var r = t ? Bf(e.children) : [], o = new SS(e.name, Ia({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Ia({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Ia({}, e["x-attribsPrefix"])), n = o;
  } else if (TS(e)) {
    var r = t ? Bf(e.children) : [], i = new DS(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (IS(e)) {
    var r = t ? Bf(e.children) : [], s = new PS(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (BS(e)) {
    var a = new LS(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
vt.cloneNode = jv;
function Bf(e) {
  for (var t = e.map(function(r) {
    return jv(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = on && on.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var d = Object.getOwnPropertyDescriptor(l, u);
    (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, d);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = on && on.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Mv, o = vt;
  n(vt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, d = new o.Element(l, u, void 0, c);
        this.addNode(d), this.tagStack.push(d);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(Sv);
var FS = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(FS);
Object.defineProperty(ks, "__esModule", { value: !0 });
ks.formatAttributes = RS;
ks.escapeSpecialCharacters = mz;
ks.revertEscapedCharacters = NS;
ks.formatDOM = zS;
var mu = Sv, ll = FS;
function hz(e) {
  return ll.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function RS(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function gz(e) {
  e = e.toLowerCase();
  var t = hz(e);
  return t || e;
}
function mz(e) {
  return e.replace(ll.CARRIAGE_RETURN_REGEX, ll.CARRIAGE_RETURN_PLACEHOLDER);
}
function NS(e) {
  return e.replace(ll.CARRIAGE_RETURN_PLACEHOLDER_REGEX, ll.CARRIAGE_RETURN);
}
function zS(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = gz(a.nodeName);
        o = new mu.Element(l, RS(a.attributes)), o.children = zS(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new mu.Text(NS(a.nodeValue));
        break;
      case 8:
        o = new mu.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new mu.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(Pv, "__esModule", { value: !0 });
Pv.default = Cz;
var vz = ks, sw = "html", aw = "head", vu = "body", yz = /<([a-zA-Z]+[0-9]?)/, lw = /<head[^]*>/i, uw = /<body[^]*>/i, Gc = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Wg = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, cw = typeof window == "object" && window.DOMParser;
if (typeof cw == "function") {
  var bz = new cw(), wz = "text/html";
  Wg = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), bz.parseFromString(e, wz);
  }, Gc = Wg;
}
if (typeof document == "object" && document.implementation) {
  var yu = document.implementation.createHTMLDocument();
  Gc = function(e, t) {
    if (t) {
      var n = yu.documentElement.querySelector(t);
      return n && (n.innerHTML = e), yu;
    }
    return yu.documentElement.innerHTML = e, yu;
  };
}
var bu = typeof document == "object" && document.createElement("template"), Vg;
bu && bu.content && (Vg = function(e) {
  return bu.innerHTML = e, bu.content.childNodes;
});
function Cz(e) {
  var t, n;
  e = (0, vz.escapeSpecialCharacters)(e);
  var r = e.match(yz), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case sw: {
      var i = Wg(e);
      if (!lw.test(e)) {
        var s = i.querySelector(aw);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!uw.test(e)) {
        var s = i.querySelector(vu);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(sw);
    }
    case aw:
    case vu: {
      var a = Gc(e).querySelectorAll(o);
      return uw.test(e) && lw.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (Vg)
        return Vg(e);
      var s = Gc(e, vu).querySelector(vu);
      return s.childNodes;
    }
  }
}
var Ez = on && on.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Dv, "__esModule", { value: !0 });
Dv.default = _z;
var xz = Ez(Pv), Oz = ks, kz = /<(![a-zA-Z\s]+)>/;
function _z(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(kz), n = t ? t[1] : void 0;
  return (0, Oz.formatDOM)((0, xz.default)(e), null, n);
}
var mp = {}, oo = {}, vp = {}, Lz = 0;
vp.SAME = Lz;
var Dz = 1;
vp.CAMELCASE = Dz;
vp.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const $S = 0, Ei = 1, yp = 2, bp = 3, Av = 4, US = 5, HS = 6;
function Pz(e) {
  return ir.hasOwnProperty(e) ? ir[e] : null;
}
function br(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === yp || t === bp || t === Av, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const ir = {}, Sz = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Sz.forEach((e) => {
  ir[e] = new br(
    e,
    $S,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ir[e] = new br(
    e,
    Ei,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ir[e] = new br(
    e,
    yp,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ir[e] = new br(
    e,
    yp,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ir[e] = new br(
    e,
    bp,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ir[e] = new br(
    e,
    bp,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ir[e] = new br(
    e,
    Av,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ir[e] = new br(
    e,
    HS,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ir[e] = new br(
    e,
    US,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Bv = /[\-\:]([a-z])/g, Iv = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Bv, Iv);
  ir[t] = new br(
    t,
    Ei,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Bv, Iv);
  ir[t] = new br(
    t,
    Ei,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Bv, Iv);
  ir[t] = new br(
    t,
    Ei,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ir[e] = new br(
    e,
    Ei,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Mz = "xlinkHref";
ir[Mz] = new br(
  "xlinkHref",
  Ei,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ir[e] = new br(
    e,
    Ei,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Tz,
  SAME: jz,
  possibleStandardNames: dw
} = vp, Az = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Bz = Az + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Iz = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Bz + "]*$")
), Fz = Object.keys(
  dw
).reduce((e, t) => {
  const n = dw[t];
  return n === jz ? e[t] = t : n === Tz ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
oo.BOOLEAN = bp;
oo.BOOLEANISH_STRING = yp;
oo.NUMERIC = US;
oo.OVERLOADED_BOOLEAN = Av;
oo.POSITIVE_NUMERIC = HS;
oo.RESERVED = $S;
oo.STRING = Ei;
oo.getPropertyInfo = Pz;
oo.isCustomAttribute = Iz;
oo.possibleStandardNames = Fz;
var Fv = {}, Rv = {}, pw = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Rz = /\n/g, Nz = /^\s*/, zz = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, $z = /^:\s*/, Uz = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Hz = /^[;\s]*/, Wz = /^\s+|\s+$/g, Vz = `
`, fw = "/", hw = "*", Qi = "", Zz = "comment", qz = "declaration", Gz = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(Rz);
    m && (n += m.length);
    var h = f.lastIndexOf(Vz);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new s(f), u(), m;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var h = m[0];
      return o(h), e = e.slice(h.length), m;
    }
  }
  function u() {
    l(Nz);
  }
  function c(f) {
    var m;
    for (f = f || []; m = d(); )
      m !== !1 && f.push(m);
    return f;
  }
  function d() {
    var f = i();
    if (!(fw != e.charAt(0) || hw != e.charAt(1))) {
      for (var m = 2; Qi != e.charAt(m) && (hw != e.charAt(m) || fw != e.charAt(m + 1)); )
        ++m;
      if (m += 2, Qi === e.charAt(m - 1))
        return a("End of comment missing");
      var h = e.slice(2, m - 2);
      return r += 2, o(h), e = e.slice(m), r += 2, f({
        type: Zz,
        comment: h
      });
    }
  }
  function p() {
    var f = i(), m = l(zz);
    if (m) {
      if (d(), !l($z)) return a("property missing ':'");
      var h = l(Uz), C = f({
        type: qz,
        property: gw(m[0].replace(pw, Qi)),
        value: h ? gw(h[0].replace(pw, Qi)) : Qi
      });
      return l(Hz), C;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = p(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function gw(e) {
  return e ? e.replace(Wz, Qi) : Qi;
}
var Yz = on && on.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Rv, "__esModule", { value: !0 });
Rv.default = Xz;
var Kz = Yz(Gz);
function Xz(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Kz.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var wp = {};
Object.defineProperty(wp, "__esModule", { value: !0 });
wp.camelCase = void 0;
var Jz = /^--[a-zA-Z0-9_-]+$/, Qz = /-([a-z])/g, e$ = /^[^-]+$/, t$ = /^-(webkit|moz|ms|o|khtml)-/, n$ = /^-(ms)-/, r$ = function(e) {
  return !e || e$.test(e) || Jz.test(e);
}, o$ = function(e, t) {
  return t.toUpperCase();
}, mw = function(e, t) {
  return "".concat(t, "-");
}, i$ = function(e, t) {
  return t === void 0 && (t = {}), r$(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(n$, mw) : e = e.replace(t$, mw), e.replace(Qz, o$));
};
wp.camelCase = i$;
var s$ = on && on.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, a$ = s$(Rv), l$ = wp;
function Zg(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, a$.default)(e, function(r, o) {
    r && o && (n[(0, l$.camelCase)(r, t)] = o);
  }), n;
}
Zg.default = Zg;
var u$ = Zg;
(function(e) {
  var t = on && on.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Oe, r = t(u$), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, d) {
    return c.includes("-") ? !o.has(c) : !!(d && typeof d.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, d) {
    if (typeof c == "string") {
      if (!c.trim()) {
        d.style = {};
        return;
      }
      try {
        d.style = (0, r.default)(c, s);
      } catch {
        d.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Fv);
Object.defineProperty(mp, "__esModule", { value: !0 });
mp.default = f$;
var Da = oo, vw = Fv, c$ = ["checked", "value"], d$ = ["input", "select", "textarea"], p$ = {
  reset: !0,
  submit: !0
};
function f$(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && p$[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Da.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = yw(s);
    if (a) {
      var l = (0, Da.getPropertyInfo)(a);
      switch (c$.includes(a) && d$.includes(t) && !r && (a = yw("default" + s)), n[a] = i, l && l.type) {
        case Da.BOOLEAN:
          n[a] = !0;
          break;
        case Da.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    vw.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, vw.setStyleProp)(e.style, n), n;
}
function yw(e) {
  return Da.possibleStandardNames[e];
}
var Nv = {}, h$ = on && on.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Nv, "__esModule", { value: !0 });
Nv.default = WS;
var If = Oe, g$ = h$(mp), Fa = Fv, m$ = {
  cloneElement: If.cloneElement,
  createElement: If.createElement,
  isValidElement: If.isValidElement
};
function WS(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Fa.returnFirstArg, i = t.library || m$, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var d = e[c];
    if (r) {
      var p = t.replace(d, c);
      if (l(p)) {
        u > 1 && (p = s(p, {
          key: p.key || c
        })), n.push(o(p, d, c));
        continue;
      }
    }
    if (d.type === "text") {
      var g = !d.data.trim().length;
      if (g && d.parent && !(0, Fa.canTextBeChildOfNode)(d.parent) || t.trim && g)
        continue;
      n.push(o(d.data, d, c));
      continue;
    }
    var f = d, m = {};
    v$(f) ? ((0, Fa.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, g$.default)(f.attribs, f.name));
    var h = void 0;
    switch (d.type) {
      case "script":
      case "style":
        d.children[0] && (m.dangerouslySetInnerHTML = {
          __html: d.children[0].data
        });
        break;
      case "tag":
        d.name === "textarea" && d.children[0] ? m.defaultValue = d.children[0].data : d.children && d.children.length && (h = WS(d.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(a(d.name, m, h), d, c));
  }
  return n.length === 1 ? n[0] : n;
}
function v$(e) {
  return Fa.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Fa.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = on && on.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(Dv);
  e.htmlToDOM = n.default;
  var r = t(mp);
  e.attributesToProps = r.default;
  var o = t(Nv);
  e.domToReact = o.default;
  var i = Sv;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(OS);
const bw = /* @__PURE__ */ F2(OS);
bw.default;
function y$(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ Rt.jsx("div", { className: o.trim(), ...r });
}
var sn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function b$(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var qg = { exports: {} }, la = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ww;
function w$() {
  if (ww) return la;
  ww = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, d = {}, p = null, g = null;
    u !== void 0 && (p = "" + u), l.key !== void 0 && (p = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (d[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) d[c] === void 0 && (d[c] = l[c]);
    return { $$typeof: t, type: a, key: p, ref: g, props: d, _owner: o.current };
  }
  return la.Fragment = n, la.jsx = s, la.jsxs = s, la;
}
var wu = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cw;
function C$() {
  return Cw || (Cw = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var $ = f && b[f] || b[m];
      return typeof $ == "function" ? $ : null;
    }
    var C = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var $ = arguments.length, Q = new Array($ > 1 ? $ - 1 : 0), re = 1; re < $; re++)
          Q[re - 1] = arguments[re];
        P("error", b, Q);
      }
    }
    function P(b, $, Q) {
      {
        var re = C.ReactDebugCurrentFrame, ge = re.getStackAddendum();
        ge !== "" && ($ += "%s", Q = Q.concat([ge]));
        var me = Q.map(function(le) {
          return String(le);
        });
        me.unshift("Warning: " + $), Function.prototype.apply.call(console[b], console, me);
      }
    }
    var E = !1, v = !1, x = !1, L = !1, z = !1, k;
    k = Symbol.for("react.module.reference");
    function R(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || z || b === o || b === u || b === c || L || b === g || E || v || x || typeof b == "object" && b !== null && (b.$$typeof === p || b.$$typeof === d || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === k || b.getModuleId !== void 0));
    }
    function A(b, $, Q) {
      var re = b.displayName;
      if (re)
        return re;
      var ge = $.displayName || $.name || "";
      return ge !== "" ? Q + "(" + ge + ")" : Q;
    }
    function U(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var $ = b;
            return U($) + ".Consumer";
          case s:
            var Q = b;
            return U(Q._context) + ".Provider";
          case l:
            return A(b, b.render, "ForwardRef");
          case d:
            var re = b.displayName || null;
            return re !== null ? re : V(b.type) || "Memo";
          case p: {
            var ge = b, me = ge._payload, le = ge._init;
            try {
              return V(le(me));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var N = Object.assign, Z = 0, K, X, te, ee, D, j, G;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function Y() {
      {
        if (Z === 0) {
          K = console.log, X = console.info, te = console.warn, ee = console.error, D = console.group, j = console.groupCollapsed, G = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: N({}, b, {
              value: K
            }),
            info: N({}, b, {
              value: X
            }),
            warn: N({}, b, {
              value: te
            }),
            error: N({}, b, {
              value: ee
            }),
            group: N({}, b, {
              value: D
            }),
            groupCollapsed: N({}, b, {
              value: j
            }),
            groupEnd: N({}, b, {
              value: G
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = C.ReactCurrentDispatcher, W;
    function T(b, $, Q) {
      {
        if (W === void 0)
          try {
            throw Error();
          } catch (ge) {
            var re = ge.stack.trim().match(/\n( *(at )?)/);
            W = re && re[1] || "";
          }
        return `
` + W + b;
      }
    }
    var q = !1, I;
    {
      var J = typeof WeakMap == "function" ? WeakMap : Map;
      I = new J();
    }
    function H(b, $) {
      if (!b || q)
        return "";
      {
        var Q = I.get(b);
        if (Q !== void 0)
          return Q;
      }
      var re;
      q = !0;
      var ge = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var me;
      me = M.current, M.current = null, Y();
      try {
        if ($) {
          var le = function() {
            throw Error();
          };
          if (Object.defineProperty(le.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(le, []);
            } catch (ze) {
              re = ze;
            }
            Reflect.construct(b, [], le);
          } else {
            try {
              le.call();
            } catch (ze) {
              re = ze;
            }
            b.call(le.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ze) {
            re = ze;
          }
          b();
        }
      } catch (ze) {
        if (ze && re && typeof ze.stack == "string") {
          for (var se = ze.stack.split(`
`), Be = re.stack.split(`
`), ke = se.length - 1, Le = Be.length - 1; ke >= 1 && Le >= 0 && se[ke] !== Be[Le]; )
            Le--;
          for (; ke >= 1 && Le >= 0; ke--, Le--)
            if (se[ke] !== Be[Le]) {
              if (ke !== 1 || Le !== 1)
                do
                  if (ke--, Le--, Le < 0 || se[ke] !== Be[Le]) {
                    var We = `
` + se[ke].replace(" at new ", " at ");
                    return b.displayName && We.includes("<anonymous>") && (We = We.replace("<anonymous>", b.displayName)), typeof b == "function" && I.set(b, We), We;
                  }
                while (ke >= 1 && Le >= 0);
              break;
            }
        }
      } finally {
        q = !1, M.current = me, O(), Error.prepareStackTrace = ge;
      }
      var dn = b ? b.displayName || b.name : "", Ht = dn ? T(dn) : "";
      return typeof b == "function" && I.set(b, Ht), Ht;
    }
    function ce(b, $, Q) {
      return H(b, !1);
    }
    function ye(b) {
      var $ = b.prototype;
      return !!($ && $.isReactComponent);
    }
    function ie(b, $, Q) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return H(b, ye(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ce(b.render);
          case d:
            return ie(b.type, $, Q);
          case p: {
            var re = b, ge = re._payload, me = re._init;
            try {
              return ie(me(ge), $, Q);
            } catch {
            }
          }
        }
      return "";
    }
    var Te = Object.prototype.hasOwnProperty, Re = {}, Ne = C.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var $ = b._owner, Q = ie(b.type, b._source, $ ? $.type : null);
        Ne.setExtraStackFrame(Q);
      } else
        Ne.setExtraStackFrame(null);
    }
    function Ke(b, $, Q, re, ge) {
      {
        var me = Function.call.bind(Te);
        for (var le in b)
          if (me(b, le)) {
            var se = void 0;
            try {
              if (typeof b[le] != "function") {
                var Be = Error((re || "React class") + ": " + Q + " type `" + le + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[le] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Be.name = "Invariant Violation", Be;
              }
              se = b[le]($, le, re, Q, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ke) {
              se = ke;
            }
            se && !(se instanceof Error) && (Ie(ge), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", re || "React class", Q, le, typeof se), Ie(null)), se instanceof Error && !(se.message in Re) && (Re[se.message] = !0, Ie(ge), w("Failed %s type: %s", Q, se.message), Ie(null));
          }
      }
    }
    var Ze = Array.isArray;
    function Se(b) {
      return Ze(b);
    }
    function qe(b) {
      {
        var $ = typeof Symbol == "function" && Symbol.toStringTag, Q = $ && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return Q;
      }
    }
    function rt(b) {
      try {
        return Pe(b), !1;
      } catch {
        return !0;
      }
    }
    function Pe(b) {
      return "" + b;
    }
    function Me(b) {
      if (rt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qe(b)), Pe(b);
    }
    var Ge = C.ReactCurrentOwner, He = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, $e, ot;
    function Fe(b) {
      if (Te.call(b, "ref")) {
        var $ = Object.getOwnPropertyDescriptor(b, "ref").get;
        if ($ && $.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function Kt(b) {
      if (Te.call(b, "key")) {
        var $ = Object.getOwnPropertyDescriptor(b, "key").get;
        if ($ && $.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function lt(b, $) {
      typeof b.ref == "string" && Ge.current;
    }
    function ht(b, $) {
      {
        var Q = function() {
          $e || ($e = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", $));
        };
        Q.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: Q,
          configurable: !0
        });
      }
    }
    function Dt(b, $) {
      {
        var Q = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", $));
        };
        Q.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: Q,
          configurable: !0
        });
      }
    }
    var ln = function(b, $, Q, re, ge, me, le) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: $,
        ref: Q,
        props: le,
        // Record the component responsible for creating this element.
        _owner: me
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: re
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ge
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function Pt(b, $, Q, re, ge) {
      {
        var me, le = {}, se = null, Be = null;
        Q !== void 0 && (Me(Q), se = "" + Q), Kt($) && (Me($.key), se = "" + $.key), Fe($) && (Be = $.ref, lt($));
        for (me in $)
          Te.call($, me) && !He.hasOwnProperty(me) && (le[me] = $[me]);
        if (b && b.defaultProps) {
          var ke = b.defaultProps;
          for (me in ke)
            le[me] === void 0 && (le[me] = ke[me]);
        }
        if (se || Be) {
          var Le = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && ht(le, Le), Be && Dt(le, Le);
        }
        return ln(b, se, Be, ge, re, Ge.current, le);
      }
    }
    var St = C.ReactCurrentOwner, ut = C.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var $ = b._owner, Q = ie(b.type, b._source, $ ? $.type : null);
        ut.setExtraStackFrame(Q);
      } else
        ut.setExtraStackFrame(null);
    }
    var un;
    un = !1;
    function cn(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Nt() {
      {
        if (St.current) {
          var b = V(St.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function Gn(b) {
      return "";
    }
    var zt = {};
    function Yn(b) {
      {
        var $ = Nt();
        if (!$) {
          var Q = typeof b == "string" ? b : b.displayName || b.name;
          Q && ($ = `

Check the top-level render call using <` + Q + ">.");
        }
        return $;
      }
    }
    function $t(b, $) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var Q = Yn($);
        if (zt[Q])
          return;
        zt[Q] = !0;
        var re = "";
        b && b._owner && b._owner !== St.current && (re = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Q, re), Xe(null);
      }
    }
    function Sn(b, $) {
      {
        if (typeof b != "object")
          return;
        if (Se(b))
          for (var Q = 0; Q < b.length; Q++) {
            var re = b[Q];
            cn(re) && $t(re, $);
          }
        else if (cn(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ge = h(b);
          if (typeof ge == "function" && ge !== b.entries)
            for (var me = ge.call(b), le; !(le = me.next()).done; )
              cn(le.value) && $t(le.value, $);
        }
      }
    }
    function pr(b) {
      {
        var $ = b.type;
        if ($ == null || typeof $ == "string")
          return;
        var Q;
        if (typeof $ == "function")
          Q = $.propTypes;
        else if (typeof $ == "object" && ($.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        $.$$typeof === d))
          Q = $.propTypes;
        else
          return;
        if (Q) {
          var re = V($);
          Ke(Q, b.props, "prop", re, b);
        } else if ($.PropTypes !== void 0 && !un) {
          un = !0;
          var ge = V($);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ge || "Unknown");
        }
        typeof $.getDefaultProps == "function" && !$.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ut(b) {
      {
        for (var $ = Object.keys(b.props), Q = 0; Q < $.length; Q++) {
          var re = $[Q];
          if (re !== "children" && re !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", re), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var oe = {};
    function to(b, $, Q, re, ge, me) {
      {
        var le = R(b);
        if (!le) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Be = Gn();
          Be ? se += Be : se += Nt();
          var ke;
          b === null ? ke = "null" : Se(b) ? ke = "array" : b !== void 0 && b.$$typeof === t ? (ke = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : ke = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ke, se);
        }
        var Le = Pt(b, $, Q, ge, me);
        if (Le == null)
          return Le;
        if (le) {
          var We = $.children;
          if (We !== void 0)
            if (re)
              if (Se(We)) {
                for (var dn = 0; dn < We.length; dn++)
                  Sn(We[dn], b);
                Object.freeze && Object.freeze(We);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Sn(We, b);
        }
        if (Te.call($, "key")) {
          var Ht = V(b), ze = Object.keys($).filter(function(Fi) {
            return Fi !== "key";
          }), fr = ze.length > 0 ? "{key: someKey, " + ze.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!oe[Ht + fr]) {
            var Ii = ze.length > 0 ? "{" + ze.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, fr, Ht, Ii, Ht), oe[Ht + fr] = !0;
          }
        }
        return b === r ? Ut(Le) : pr(Le), Le;
      }
    }
    function Ti(b, $, Q) {
      return to(b, $, Q, !0);
    }
    function ji(b, $, Q) {
      return to(b, $, Q, !1);
    }
    var Ai = ji, Bi = Ti;
    wu.Fragment = r, wu.jsx = Ai, wu.jsxs = Bi;
  }()), wu;
}
process.env.NODE_ENV === "production" ? qg.exports = w$() : qg.exports = C$();
var nr = qg.exports;
Ve({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Ew(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function ur(e) {
  var t, n;
  return Ew(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(Ew(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var VS = Symbol.for("immer-nothing"), xw = Symbol.for("immer-draftable"), Wr = Symbol.for("immer-state"), E$ = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function _r(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = E$[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var $s = Object.getPrototypeOf;
function ys(e) {
  return !!e && !!e[Wr];
}
function bs(e) {
  var t;
  return e ? ZS(e) || Array.isArray(e) || !!e[xw] || !!((t = e.constructor) != null && t[xw]) || Ep(e) || xp(e) : !1;
}
var x$ = Object.prototype.constructor.toString();
function ZS(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = $s(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === x$;
}
function Yc(e, t) {
  Cp(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Cp(e) {
  const t = e[Wr];
  return t ? t.type_ : Array.isArray(e) ? 1 : Ep(e) ? 2 : xp(e) ? 3 : 0;
}
function Gg(e, t) {
  return Cp(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function qS(e, t, n) {
  const r = Cp(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function O$(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Ep(e) {
  return e instanceof Map;
}
function xp(e) {
  return e instanceof Set;
}
function Yi(e) {
  return e.copy_ || e.base_;
}
function Yg(e, t) {
  if (Ep(e))
    return new Map(e);
  if (xp(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = ZS(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Wr];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create($s(e), r);
  } else {
    const r = $s(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function zv(e, t = !1) {
  return Op(e) || ys(e) || !bs(e) || (Cp(e) > 1 && (e.set = e.add = e.clear = e.delete = k$), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => zv(r, !0))), e;
}
function k$() {
  _r(2);
}
function Op(e) {
  return Object.isFrozen(e);
}
var _$ = {};
function ws(e) {
  const t = _$[e];
  return t || _r(0, e), t;
}
var ul;
function GS() {
  return ul;
}
function L$(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Ow(e, t) {
  t && (ws("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Kg(e) {
  Xg(e), e.drafts_.forEach(D$), e.drafts_ = null;
}
function Xg(e) {
  e === ul && (ul = e.parent_);
}
function kw(e) {
  return ul = L$(ul, e);
}
function D$(e) {
  const t = e[Wr];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function _w(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Wr].modified_ && (Kg(t), _r(4)), bs(e) && (e = Kc(t, e), t.parent_ || Xc(t, e)), t.patches_ && ws("Patches").generateReplacementPatches_(
    n[Wr].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Kc(t, n, []), Kg(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== VS ? e : void 0;
}
function Kc(e, t, n) {
  if (Op(t))
    return t;
  const r = t[Wr];
  if (!r)
    return Yc(
      t,
      (o, i) => Lw(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Xc(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Yc(
      i,
      (a, l) => Lw(e, r, o, a, l, n, s)
    ), Xc(e, o, !1), n && e.patches_ && ws("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Lw(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && _r(5), ys(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Gg(t.assigned_, r) ? i.concat(r) : void 0, l = Kc(e, o, a);
    if (qS(n, r, l), ys(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (bs(o) && !Op(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Kc(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Xc(e, o);
  }
}
function Xc(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && zv(t, n);
}
function P$(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : GS(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = $v;
  n && (o = [r], i = cl);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var $v = {
  get(e, t) {
    if (t === Wr)
      return e;
    const n = Yi(e);
    if (!Gg(n, t))
      return S$(e, n, t);
    const r = n[t];
    return e.finalized_ || !bs(r) ? r : r === Ff(e.base_, t) ? (Rf(e), e.copy_[t] = Qg(r, e)) : r;
  },
  has(e, t) {
    return t in Yi(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Yi(e));
  },
  set(e, t, n) {
    const r = YS(Yi(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Ff(Yi(e), t), i = o == null ? void 0 : o[Wr];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (O$(n, o) && (n !== void 0 || Gg(e.base_, t)))
        return !0;
      Rf(e), Jg(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Ff(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Rf(e), Jg(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Yi(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    _r(11);
  },
  getPrototypeOf(e) {
    return $s(e.base_);
  },
  setPrototypeOf() {
    _r(12);
  }
}, cl = {};
Yc($v, (e, t) => {
  cl[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
cl.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && _r(13), cl.set.call(this, e, t, void 0);
};
cl.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && _r(14), $v.set.call(this, e[0], t, n, e[0]);
};
function Ff(e, t) {
  const n = e[Wr];
  return (n ? Yi(n) : e)[t];
}
function S$(e, t, n) {
  var r;
  const o = YS(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function YS(e, t) {
  if (!(t in e))
    return;
  let n = $s(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = $s(n);
  }
}
function Jg(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Jg(e.parent_));
}
function Rf(e) {
  e.copy_ || (e.copy_ = Yg(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var M$ = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && _r(6), r !== void 0 && typeof r != "function" && _r(7);
      let o;
      if (bs(t)) {
        const i = kw(this), s = Qg(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? Kg(i) : Xg(i);
        }
        return Ow(i, r), _w(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === VS && (o = void 0), this.autoFreeze_ && zv(o, !0), r) {
          const i = [], s = [];
          ws("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        _r(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    bs(e) || _r(8), ys(e) && (e = T$(e));
    const t = kw(this), n = Qg(e, void 0);
    return n[Wr].isManual_ = !0, Xg(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Wr];
    (!n || !n.isManual_) && _r(9);
    const { scope_: r } = n;
    return Ow(r, t), _w(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = ws("Patches").applyPatches_;
    return ys(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Qg(e, t) {
  const n = Ep(e) ? ws("MapSet").proxyMap_(e, t) : xp(e) ? ws("MapSet").proxySet_(e, t) : P$(e, t);
  return (t ? t.scope_ : GS()).drafts_.push(n), n;
}
function T$(e) {
  return ys(e) || _r(10, e), KS(e);
}
function KS(e) {
  if (!bs(e) || Op(e))
    return e;
  const t = e[Wr];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Yg(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Yg(e, !0);
  return Yc(n, (r, o) => {
    qS(n, r, KS(o));
  }), t && (t.finalized_ = !1), n;
}
var Vr = new M$(), Uv = Vr.produce;
Vr.produceWithPatches.bind(
  Vr
);
Vr.setAutoFreeze.bind(Vr);
Vr.setUseStrictShallowCopy.bind(Vr);
Vr.applyPatches.bind(Vr);
var Dw = Vr.createDraft.bind(Vr), Pw = Vr.finishDraft.bind(Vr), we = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = we.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return we.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return we.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return we.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return we.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && we.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return we.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && we.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && we.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && we.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && we.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && we.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!we.isAncestor(t, e) && !we.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (we.equals(i, r) || we.endsBefore(i, r) || we.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (we.equals(s, r) || we.isAncestor(s, r))
          return null;
        we.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        we.equals(a, r) || we.endsBefore(a, r) ? r[a.length - 1] -= 1 : we.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (we.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else we.endsBefore(u, r) ? r[u.length - 1] += 1 : we.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: d,
          newPath: p
        } = t;
        if (we.equals(d, p))
          return r;
        if (we.isAncestor(d, r) || we.equals(d, r)) {
          var g = p.slice();
          return we.endsBefore(d, p) && d.length < p.length && (g[d.length - 1] -= 1), g.concat(r.slice(d.length));
        } else we.isSibling(d, p) && (we.isAncestor(p, r) || we.equals(p, r)) ? we.endsBefore(d, r) ? r[d.length - 1] -= 1 : r[d.length - 1] += 1 : we.endsBefore(p, r) || we.equals(p, r) || we.isAncestor(p, r) ? (we.endsBefore(d, r) && (r[d.length - 1] -= 1), r[p.length - 1] += 1) : we.endsBefore(d, r) && (we.equals(p, r) && (r[p.length - 1] += 1), r[d.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function dl(e) {
  "@babel/helpers - typeof";
  return dl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, dl(e);
}
function j$(e, t) {
  if (dl(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (dl(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function A$(e) {
  var t = j$(e, "string");
  return dl(t) === "symbol" ? t : String(t);
}
function qs(e, t, n) {
  return t = A$(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Sw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ua(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Sw(Object(n), !0).forEach(function(r) {
      qs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Sw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var B$ = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = et.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of pt.points(t))
          t[l] = mn.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: d
      } = n;
      if (d.length === 0) break;
      var p = et.leaf(e, u), g = p.text.slice(0, c), f = p.text.slice(c);
      if (p.text = g + d + f, t)
        for (var [m, h] of pt.points(t))
          t[h] = mn.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: C
      } = n, w = et.get(e, C), P = we.previous(C), E = et.get(e, P), v = et.parent(e, C), x = C[C.length - 1];
      if ($n.isText(w) && $n.isText(E))
        E.text += w.text;
      else if (!$n.isText(w) && !$n.isText(E))
        E.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(C, "] to nodes of different interfaces: ").concat(Ar.stringify(w), " ").concat(Ar.stringify(E)));
      if (v.children.splice(x, 1), t)
        for (var [L, z] of pt.points(t))
          t[z] = mn.transform(L, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: R
      } = n;
      if (we.isAncestor(k, R))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(R, "] because the destination is inside itself."));
      var A = et.get(e, k), U = et.parent(e, k), V = k[k.length - 1];
      U.children.splice(V, 1);
      var N = we.transform(k, n), Z = et.get(e, we.parent(N)), K = N[N.length - 1];
      if (Z.children.splice(K, 0, A), t)
        for (var [X, te] of pt.points(t))
          t[te] = mn.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, D = ee[ee.length - 1], j = et.parent(e, ee);
      if (j.children.splice(D, 1), t)
        for (var [G, S] of pt.points(t)) {
          var Y = mn.transform(G, n);
          if (t != null && Y != null)
            t[S] = Y;
          else {
            var O = void 0, M = void 0;
            for (var [W, T] of et.texts(e))
              if (we.compare(T, ee) === -1)
                O = [W, T];
              else {
                M = [W, T];
                break;
              }
            var q = !1;
            O && M && (we.equals(M[1], ee) ? q = !we.hasPrevious(M[1]) : q = we.common(O[1], ee).length < we.common(M[1], ee).length), O && !q ? (G.path = O[1], G.offset = O[0].text.length) : M ? (G.path = M[1], G.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: I,
        offset: J,
        text: H
      } = n;
      if (H.length === 0) break;
      var ce = et.leaf(e, I), ye = ce.text.slice(0, J), ie = ce.text.slice(J + H.length);
      if (ce.text = ye + ie, t)
        for (var [Te, Re] of pt.points(t))
          t[Re] = mn.transform(Te, n);
      break;
    }
    case "set_node": {
      var {
        path: Ne,
        properties: Ie,
        newProperties: Ke
      } = n;
      if (Ne.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ze = et.get(e, Ne);
      for (var Se in Ke) {
        if (Se === "children" || Se === "text")
          throw new Error('Cannot set the "'.concat(Se, '" property of nodes!'));
        var qe = Ke[Se];
        qe == null ? delete Ze[Se] : Ze[Se] = qe;
      }
      for (var rt in Ie)
        Ke.hasOwnProperty(rt) || delete Ze[rt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Pe
      } = n;
      if (Pe == null)
        t = Pe;
      else {
        if (t == null) {
          if (!pt.isRange(Pe))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Ar.stringify(Pe), " when there is no current selection."));
          t = ua({}, Pe);
        }
        for (var Me in Pe) {
          var Ge = Pe[Me];
          if (Ge == null) {
            if (Me === "anchor" || Me === "focus")
              throw new Error('Cannot remove the "'.concat(Me, '" selection property'));
            delete t[Me];
          } else
            t[Me] = Ge;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: He,
        position: $e,
        properties: ot
      } = n;
      if (He.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(He, "] because the root node cannot be split."));
      var Fe = et.get(e, He), Kt = et.parent(e, He), lt = He[He.length - 1], ht;
      if ($n.isText(Fe)) {
        var Dt = Fe.text.slice(0, $e), ln = Fe.text.slice($e);
        Fe.text = Dt, ht = ua(ua({}, ot), {}, {
          text: ln
        });
      } else {
        var Pt = Fe.children.slice(0, $e), St = Fe.children.slice($e);
        Fe.children = Pt, ht = ua(ua({}, ot), {}, {
          children: St
        });
      }
      if (Kt.children.splice(lt + 1, 0, ht), t)
        for (var [ut, Xe] of pt.points(t))
          t[Xe] = mn.transform(ut, n);
      break;
    }
  }
  return t;
}, I$ = {
  transform(e, t) {
    e.children = Dw(e.children);
    var n = e.selection && Dw(e.selection);
    try {
      n = B$(e, n, t);
    } finally {
      e.children = Pw(e.children), n ? e.selection = ys(n) ? Pw(n) : n : e.selection = null;
    }
  }
}, F$ = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, R$ = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, XS = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (ur(r) && ur(o)) {
      if (!XS(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function N$(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function pl(e, t) {
  if (e == null) return {};
  var n = N$(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var z$ = ["anchor", "focus"];
function Mw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Mw(Object(n), !0).forEach(function(r) {
      qs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Mw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return pt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = pt.edges(e);
    return t;
  },
  equals(e, t) {
    return mn.equals(e.anchor, t.anchor) && mn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (pt.isRange(t)) {
      if (pt.includes(e, t.anchor) || pt.includes(e, t.focus))
        return !0;
      var [n, r] = pt.edges(e), [o, i] = pt.edges(t);
      return mn.isBefore(n, o) && mn.isAfter(r, i);
    }
    var [s, a] = pt.edges(e), l = !1, u = !1;
    return mn.isPoint(t) ? (l = mn.compare(t, s) >= 0, u = mn.compare(t, a) <= 0) : (l = we.compare(t, s.path) >= 0, u = we.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = pl(e, z$), [r, o] = pt.edges(e), [i, s] = pt.edges(t), a = mn.isBefore(r, i) ? i : r, l = mn.isBefore(o, s) ? o : s;
    return mn.isBefore(l, a) ? null : $$({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return mn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return mn.equals(t, n);
  },
  isExpanded(e) {
    return !pt.isCollapsed(e);
  },
  isForward(e) {
    return !pt.isBackward(e);
  },
  isRange(e) {
    return ur(e) && mn.isPoint(e.anchor) && mn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = pt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Uv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = pt.isCollapsed(r);
        pt.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? pt.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = mn.transform(r.anchor, t, {
        affinity: i
      }), u = mn.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, Tw = (e) => ur(e) && et.isNodeList(e.children) && !tn.isEditor(e), Mo = {
  isAncestor(e) {
    return ur(e) && et.isNodeList(e.children);
  },
  isElement: Tw,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Mo.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return Tw(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, U$ = ["children"], H$ = ["text"], jw = /* @__PURE__ */ new WeakMap(), et = {
  ancestor(e, t) {
    var n = et.get(e, t);
    if ($n.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Ar.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of we.ancestors(t, n)) {
        var o = et.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if ($n.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Ar.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Ar.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = et.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = et.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = we.common(t, n), o = et.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = et.get(e, t);
    if (tn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Ar.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of et.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of et.nodes(e, t))
        Mo.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Mo.isAncestor(e)) {
      var t = pl(e, U$);
      return t;
    } else {
      var t = pl(e, H$);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = et.get(e, n); r && !($n.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if ($n.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Ar.stringify(e)));
    var n = Uv({
      children: e.children
    }, (r) => {
      var [o, i] = pt.edges(t), s = et.nodes(r, {
        reverse: !0,
        pass: (p) => {
          var [, g] = p;
          return !pt.includes(t, g);
        }
      });
      for (var [, a] of s) {
        if (!pt.includes(t, a)) {
          var l = et.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (we.equals(a, i.path)) {
          var c = et.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (we.equals(a, o.path)) {
          var d = et.leaf(r, a);
          d.text = d.text.slice(o.offset);
        }
      }
      tn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if ($n.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Ar.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if ($n.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return $n.isText(e) || Mo.isElement(e) || tn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = jw.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => et.isNode(r));
    return jw.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = et.get(e, n); r && !($n.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = et.get(e, t);
    if (!$n.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Ar.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of we.levels(t, n)) {
        var o = et.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Mo.isElement(e) && Mo.isElementProps(t) && Mo.matches(e, t) || $n.isText(e) && $n.isTextProps(t) && $n.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? we.isBefore(a, i) : we.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !$n.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          we.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = et.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = we.next(a);
          if (et.has(e, c)) {
            a = c, l = et.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var d = we.previous(a);
          a = d, l = et.get(e, a);
          continue;
        }
        a = we.parent(a), l = et.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = we.parent(t), r = et.get(e, n);
    if ($n.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return $n.isText(e) ? e.text : e.children.map(et.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of et.nodes(e, t))
        $n.isText(n) && (yield [n, r]);
    }();
  }
};
function Aw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Aw(Object(n), !0).forEach(function(r) {
      qs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Aw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Pa = {
  isNodeOperation(e) {
    return Pa.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!ur(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return we.isPath(e.path) && et.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && we.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && we.isPath(e.path) && ur(e.properties);
      case "move_node":
        return we.isPath(e.path) && we.isPath(e.newPath);
      case "remove_node":
        return we.isPath(e.path) && et.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && we.isPath(e.path);
      case "set_node":
        return we.isPath(e.path) && ur(e.properties) && ur(e.newProperties);
      case "set_selection":
        return e.properties === null && pt.isRange(e.newProperties) || e.newProperties === null && pt.isRange(e.properties) || ur(e.properties) && ur(e.newProperties);
      case "split_node":
        return we.isPath(e.path) && typeof e.position == "number" && ur(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Pa.isOperation(t));
  },
  isSelectionOperation(e) {
    return Pa.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Pa.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return wn(wn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return wn(wn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return wn(wn({}, e), {}, {
          type: "split_node",
          path: we.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (we.equals(t, n))
          return e;
        if (we.isSibling(n, t))
          return wn(wn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = we.transform(n, e), o = we.transform(we.next(n), e);
        return wn(wn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return wn(wn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return wn(wn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return wn(wn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? wn(wn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? wn(wn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : wn(wn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return wn(wn({}, e), {}, {
          type: "merge_node",
          path: we.next(e.path)
        });
    }
  }
}, Bw = /* @__PURE__ */ new WeakMap(), W$ = (e) => {
  var t = Bw.get(e);
  if (t !== void 0)
    return t;
  if (!ur(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || ur(e.marks)) && (e.selection === null || pt.isRange(e.selection)) && et.isNodeList(e.children) && Pa.isOperationList(e.operations);
  return Bw.set(e, n), n;
}, tn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return W$(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function Iw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Iw(Object(n), !0).forEach(function(r) {
      qs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Iw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mn = {
  compare(e, t) {
    var n = we.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return mn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return mn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && we.equals(e.path, t.path);
  },
  isPoint(e) {
    return ur(e) && typeof e.offset == "number" && we.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Uv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = we.transform(i, t, n);
          break;
        }
        case "insert_text": {
          we.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          we.equals(t.path, i) && (r.offset += t.position), r.path = we.transform(i, t, n);
          break;
        }
        case "remove_text": {
          we.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (we.equals(t.path, i) || we.isAncestor(t.path, i))
            return null;
          r.path = we.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (we.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = we.transform(i, t, Fw(Fw({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = we.transform(i, t, n);
          break;
        }
      }
    });
  }
}, Rw = void 0, Ar = {
  setScrubber(e) {
    Rw = e;
  },
  stringify(e) {
    return JSON.stringify(e, Rw);
  }
}, V$ = ["text"], Z$ = ["anchor", "focus"];
function Nw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Oo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Nw(Object(n), !0).forEach(function(r) {
      qs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Nw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $n = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = pl(i, V$);
      return s;
    }
    return XS(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return ur(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => $n.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Oo({}, e)];
    for (var r of t) {
      var o = pl(r, Z$), [i, s] = pt.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var d of n) {
        var {
          length: p
        } = d.text, g = l;
        if (l += p, u <= g && l <= c) {
          Object.assign(d, o), a.push(d);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          a.push(d);
          continue;
        }
        var f = d, m = void 0, h = void 0;
        if (c < l) {
          var C = c - g;
          h = Oo(Oo({}, f), {}, {
            text: f.text.slice(C)
          }), f = Oo(Oo({}, f), {}, {
            text: f.text.slice(0, C)
          });
        }
        if (u > g) {
          var w = u - g;
          m = Oo(Oo({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Oo(Oo({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && a.push(m), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, q$ = (e) => e.selection ? e.selection : e.children.length > 0 ? tn.end(e, []) : [0], fn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(fn || (fn = {}));
fn.L, fn.L | fn.V | fn.LV | fn.LVT, fn.LV | fn.V, fn.V | fn.T, fn.LVT | fn.T, fn.T, fn.Any, fn.Extend | fn.ZWJ, fn.Any, fn.SpacingMark, fn.Prepend, fn.Any, fn.ZWJ, fn.ExtPict, fn.RI, fn.RI;
var G$ = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    tn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = q$(e)
      } = n;
      if (we.isPath(o) && (o = tn.range(e, o)), pt.isRange(o))
        if (pt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = pt.end(o);
          if (!r && tn.void(e, {
            at: i
          }))
            return;
          var s = pt.start(o), a = tn.pointRef(e, s), l = tn.pointRef(e, i);
          Jc.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Jc.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && tn.void(e, {
        at: o
      }) || tn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: d,
          offset: p
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: d,
          offset: p,
          text: t
        });
      }
    });
  }
};
function zw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zw(Object(n), !0).forEach(function(r) {
      qs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jc = Cu(Cu(Cu(Cu({}, I$), F$), R$), G$), JS = {}, Hv = {}, Wv = {}, _s = {}, Vv = {}, Zv = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Zv);
var yt = {}, xi = sn && sn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Ra = sn && sn.__assign || function() {
  return Ra = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ra.apply(this, arguments);
};
Object.defineProperty(yt, "__esModule", { value: !0 });
yt.cloneNode = yt.hasChildren = yt.isDocument = yt.isDirective = yt.isComment = yt.isText = yt.isCDATA = yt.isTag = yt.Element = yt.Document = yt.CDATA = yt.NodeWithChildren = yt.ProcessingInstruction = yt.Comment = yt.Text = yt.DataNode = yt.Node = void 0;
var Sr = Zv, qv = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), Gv(this, t);
    }, e;
  }()
);
yt.Node = qv;
var kp = (
  /** @class */
  function(e) {
    xi(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(qv)
);
yt.DataNode = kp;
var QS = (
  /** @class */
  function(e) {
    xi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Sr.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(kp)
);
yt.Text = QS;
var eM = (
  /** @class */
  function(e) {
    xi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Sr.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(kp)
);
yt.Comment = eM;
var tM = (
  /** @class */
  function(e) {
    xi(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Sr.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(kp)
);
yt.ProcessingInstruction = tM;
var _p = (
  /** @class */
  function(e) {
    xi(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(qv)
);
yt.NodeWithChildren = _p;
var nM = (
  /** @class */
  function(e) {
    xi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Sr.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(_p)
);
yt.CDATA = nM;
var rM = (
  /** @class */
  function(e) {
    xi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Sr.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(_p)
);
yt.Document = rM;
var oM = (
  /** @class */
  function(e) {
    xi(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Sr.ElementType.Script : n === "style" ? Sr.ElementType.Style : Sr.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(_p)
);
yt.Element = oM;
function iM(e) {
  return (0, Sr.isTag)(e);
}
yt.isTag = iM;
function sM(e) {
  return e.type === Sr.ElementType.CDATA;
}
yt.isCDATA = sM;
function aM(e) {
  return e.type === Sr.ElementType.Text;
}
yt.isText = aM;
function lM(e) {
  return e.type === Sr.ElementType.Comment;
}
yt.isComment = lM;
function uM(e) {
  return e.type === Sr.ElementType.Directive;
}
yt.isDirective = uM;
function cM(e) {
  return e.type === Sr.ElementType.Root;
}
yt.isDocument = cM;
function Y$(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
yt.hasChildren = Y$;
function Gv(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (aM(e))
    n = new QS(e.data);
  else if (lM(e))
    n = new eM(e.data);
  else if (iM(e)) {
    var r = t ? Nf(e.children) : [], o = new oM(e.name, Ra({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Ra({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Ra({}, e["x-attribsPrefix"])), n = o;
  } else if (sM(e)) {
    var r = t ? Nf(e.children) : [], i = new nM(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (cM(e)) {
    var r = t ? Nf(e.children) : [], s = new rM(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (uM(e)) {
    var a = new tM(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
yt.cloneNode = Gv;
function Nf(e) {
  for (var t = e.map(function(r) {
    return Gv(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = sn && sn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var d = Object.getOwnPropertyDescriptor(l, u);
    (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, d);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = sn && sn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Zv, o = yt;
  n(yt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, d = new o.Element(l, u, void 0, c);
        this.addNode(d), this.tagStack.push(d);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(Vv);
var dM = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(dM);
Object.defineProperty(_s, "__esModule", { value: !0 });
_s.formatAttributes = pM;
_s.escapeSpecialCharacters = J$;
_s.revertEscapedCharacters = fM;
_s.formatDOM = hM;
var Eu = Vv, fl = dM;
function K$(e) {
  return fl.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function pM(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function X$(e) {
  e = e.toLowerCase();
  var t = K$(e);
  return t || e;
}
function J$(e) {
  return e.replace(fl.CARRIAGE_RETURN_REGEX, fl.CARRIAGE_RETURN_PLACEHOLDER);
}
function fM(e) {
  return e.replace(fl.CARRIAGE_RETURN_PLACEHOLDER_REGEX, fl.CARRIAGE_RETURN);
}
function hM(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = X$(a.nodeName);
        o = new Eu.Element(l, pM(a.attributes)), o.children = hM(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Eu.Text(fM(a.nodeValue));
        break;
      case 8:
        o = new Eu.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Eu.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(Wv, "__esModule", { value: !0 });
Wv.default = r3;
var Q$ = _s, $w = "html", Uw = "head", xu = "body", e3 = /<([a-zA-Z]+[0-9]?)/, Hw = /<head[^]*>/i, Ww = /<body[^]*>/i, Qc = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, em = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, Vw = typeof window == "object" && window.DOMParser;
if (typeof Vw == "function") {
  var t3 = new Vw(), n3 = "text/html";
  em = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), t3.parseFromString(e, n3);
  }, Qc = em;
}
if (typeof document == "object" && document.implementation) {
  var Ou = document.implementation.createHTMLDocument();
  Qc = function(e, t) {
    if (t) {
      var n = Ou.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Ou;
    }
    return Ou.documentElement.innerHTML = e, Ou;
  };
}
var ku = typeof document == "object" && document.createElement("template"), tm;
ku && ku.content && (tm = function(e) {
  return ku.innerHTML = e, ku.content.childNodes;
});
function r3(e) {
  var t, n;
  e = (0, Q$.escapeSpecialCharacters)(e);
  var r = e.match(e3), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case $w: {
      var i = em(e);
      if (!Hw.test(e)) {
        var s = i.querySelector(Uw);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!Ww.test(e)) {
        var s = i.querySelector(xu);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll($w);
    }
    case Uw:
    case xu: {
      var a = Qc(e).querySelectorAll(o);
      return Ww.test(e) && Hw.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (tm)
        return tm(e);
      var s = Qc(e, xu).querySelector(xu);
      return s.childNodes;
    }
  }
}
var o3 = sn && sn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Hv, "__esModule", { value: !0 });
Hv.default = l3;
var i3 = o3(Wv), s3 = _s, a3 = /<(![a-zA-Z\s]+)>/;
function l3(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(a3), n = t ? t[1] : void 0;
  return (0, s3.formatDOM)((0, i3.default)(e), null, n);
}
var Lp = {}, io = {}, Dp = {}, u3 = 0;
Dp.SAME = u3;
var c3 = 1;
Dp.CAMELCASE = c3;
Dp.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const gM = 0, Oi = 1, Pp = 2, Sp = 3, Yv = 4, mM = 5, vM = 6;
function d3(e) {
  return sr.hasOwnProperty(e) ? sr[e] : null;
}
function wr(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === Pp || t === Sp || t === Yv, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const sr = {}, p3 = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
p3.forEach((e) => {
  sr[e] = new wr(
    e,
    gM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  sr[e] = new wr(
    e,
    Oi,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  sr[e] = new wr(
    e,
    Pp,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  sr[e] = new wr(
    e,
    Pp,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  sr[e] = new wr(
    e,
    Sp,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  sr[e] = new wr(
    e,
    Sp,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  sr[e] = new wr(
    e,
    Yv,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  sr[e] = new wr(
    e,
    vM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  sr[e] = new wr(
    e,
    mM,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Kv = /[\-\:]([a-z])/g, Xv = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Kv, Xv);
  sr[t] = new wr(
    t,
    Oi,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Kv, Xv);
  sr[t] = new wr(
    t,
    Oi,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Kv, Xv);
  sr[t] = new wr(
    t,
    Oi,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  sr[e] = new wr(
    e,
    Oi,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const f3 = "xlinkHref";
sr[f3] = new wr(
  "xlinkHref",
  Oi,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  sr[e] = new wr(
    e,
    Oi,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: h3,
  SAME: g3,
  possibleStandardNames: Zw
} = Dp, m3 = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", v3 = m3 + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", y3 = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + v3 + "]*$")
), b3 = Object.keys(
  Zw
).reduce((e, t) => {
  const n = Zw[t];
  return n === g3 ? e[t] = t : n === h3 ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
io.BOOLEAN = Sp;
io.BOOLEANISH_STRING = Pp;
io.NUMERIC = mM;
io.OVERLOADED_BOOLEAN = Yv;
io.POSITIVE_NUMERIC = vM;
io.RESERVED = gM;
io.STRING = Oi;
io.getPropertyInfo = d3;
io.isCustomAttribute = y3;
io.possibleStandardNames = b3;
var Jv = {}, Qv = {}, qw = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, w3 = /\n/g, C3 = /^\s*/, E3 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, x3 = /^:\s*/, O3 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, k3 = /^[;\s]*/, _3 = /^\s+|\s+$/g, L3 = `
`, Gw = "/", Yw = "*", es = "", D3 = "comment", P3 = "declaration", S3 = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(w3);
    m && (n += m.length);
    var h = f.lastIndexOf(L3);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new s(f), u(), m;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var h = m[0];
      return o(h), e = e.slice(h.length), m;
    }
  }
  function u() {
    l(C3);
  }
  function c(f) {
    var m;
    for (f = f || []; m = d(); )
      m !== !1 && f.push(m);
    return f;
  }
  function d() {
    var f = i();
    if (!(Gw != e.charAt(0) || Yw != e.charAt(1))) {
      for (var m = 2; es != e.charAt(m) && (Yw != e.charAt(m) || Gw != e.charAt(m + 1)); )
        ++m;
      if (m += 2, es === e.charAt(m - 1))
        return a("End of comment missing");
      var h = e.slice(2, m - 2);
      return r += 2, o(h), e = e.slice(m), r += 2, f({
        type: D3,
        comment: h
      });
    }
  }
  function p() {
    var f = i(), m = l(E3);
    if (m) {
      if (d(), !l(x3)) return a("property missing ':'");
      var h = l(O3), C = f({
        type: P3,
        property: Kw(m[0].replace(qw, es)),
        value: h ? Kw(h[0].replace(qw, es)) : es
      });
      return l(k3), C;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = p(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function Kw(e) {
  return e ? e.replace(_3, es) : es;
}
var M3 = sn && sn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Qv, "__esModule", { value: !0 });
Qv.default = j3;
var T3 = M3(S3);
function j3(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, T3.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var Mp = {};
Object.defineProperty(Mp, "__esModule", { value: !0 });
Mp.camelCase = void 0;
var A3 = /^--[a-zA-Z0-9_-]+$/, B3 = /-([a-z])/g, I3 = /^[^-]+$/, F3 = /^-(webkit|moz|ms|o|khtml)-/, R3 = /^-(ms)-/, N3 = function(e) {
  return !e || I3.test(e) || A3.test(e);
}, z3 = function(e, t) {
  return t.toUpperCase();
}, Xw = function(e, t) {
  return "".concat(t, "-");
}, $3 = function(e, t) {
  return t === void 0 && (t = {}), N3(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(R3, Xw) : e = e.replace(F3, Xw), e.replace(B3, z3));
};
Mp.camelCase = $3;
var U3 = sn && sn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, H3 = U3(Qv), W3 = Mp;
function nm(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, H3.default)(e, function(r, o) {
    r && o && (n[(0, W3.camelCase)(r, t)] = o);
  }), n;
}
nm.default = nm;
var V3 = nm;
(function(e) {
  var t = sn && sn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Oe, r = t(V3), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, d) {
    return c.includes("-") ? !o.has(c) : !!(d && typeof d.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, d) {
    if (typeof c == "string") {
      if (!c.trim()) {
        d.style = {};
        return;
      }
      try {
        d.style = (0, r.default)(c, s);
      } catch {
        d.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Jv);
Object.defineProperty(Lp, "__esModule", { value: !0 });
Lp.default = Y3;
var Sa = io, Jw = Jv, Z3 = ["checked", "value"], q3 = ["input", "select", "textarea"], G3 = {
  reset: !0,
  submit: !0
};
function Y3(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && G3[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Sa.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = Qw(s);
    if (a) {
      var l = (0, Sa.getPropertyInfo)(a);
      switch (Z3.includes(a) && q3.includes(t) && !r && (a = Qw("default" + s)), n[a] = i, l && l.type) {
        case Sa.BOOLEAN:
          n[a] = !0;
          break;
        case Sa.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    Jw.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, Jw.setStyleProp)(e.style, n), n;
}
function Qw(e) {
  return Sa.possibleStandardNames[e];
}
var ey = {}, K3 = sn && sn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ey, "__esModule", { value: !0 });
ey.default = yM;
var zf = Oe, X3 = K3(Lp), Na = Jv, J3 = {
  cloneElement: zf.cloneElement,
  createElement: zf.createElement,
  isValidElement: zf.isValidElement
};
function yM(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Na.returnFirstArg, i = t.library || J3, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var d = e[c];
    if (r) {
      var p = t.replace(d, c);
      if (l(p)) {
        u > 1 && (p = s(p, {
          key: p.key || c
        })), n.push(o(p, d, c));
        continue;
      }
    }
    if (d.type === "text") {
      var g = !d.data.trim().length;
      if (g && d.parent && !(0, Na.canTextBeChildOfNode)(d.parent) || t.trim && g)
        continue;
      n.push(o(d.data, d, c));
      continue;
    }
    var f = d, m = {};
    Q3(f) ? ((0, Na.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, X3.default)(f.attribs, f.name));
    var h = void 0;
    switch (d.type) {
      case "script":
      case "style":
        d.children[0] && (m.dangerouslySetInnerHTML = {
          __html: d.children[0].data
        });
        break;
      case "tag":
        d.name === "textarea" && d.children[0] ? m.defaultValue = d.children[0].data : d.children && d.children.length && (h = yM(d.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(a(d.name, m, h), d, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Q3(e) {
  return Na.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Na.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = sn && sn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(Hv);
  e.htmlToDOM = n.default;
  var r = t(Lp);
  e.attributesToProps = r.default;
  var o = t(ey);
  e.domToReact = o.default;
  var i = Vv;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(JS);
const eU = /* @__PURE__ */ b$(JS);
eU.default;
var an = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function tU(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var rm = { exports: {} }, ca = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var eC;
function nU() {
  if (eC) return ca;
  eC = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, d = {}, p = null, g = null;
    u !== void 0 && (p = "" + u), l.key !== void 0 && (p = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (d[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) d[c] === void 0 && (d[c] = l[c]);
    return { $$typeof: t, type: a, key: p, ref: g, props: d, _owner: o.current };
  }
  return ca.Fragment = n, ca.jsx = s, ca.jsxs = s, ca;
}
var _u = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tC;
function rU() {
  return tC || (tC = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var $ = f && b[f] || b[m];
      return typeof $ == "function" ? $ : null;
    }
    var C = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var $ = arguments.length, Q = new Array($ > 1 ? $ - 1 : 0), re = 1; re < $; re++)
          Q[re - 1] = arguments[re];
        P("error", b, Q);
      }
    }
    function P(b, $, Q) {
      {
        var re = C.ReactDebugCurrentFrame, ge = re.getStackAddendum();
        ge !== "" && ($ += "%s", Q = Q.concat([ge]));
        var me = Q.map(function(le) {
          return String(le);
        });
        me.unshift("Warning: " + $), Function.prototype.apply.call(console[b], console, me);
      }
    }
    var E = !1, v = !1, x = !1, L = !1, z = !1, k;
    k = Symbol.for("react.module.reference");
    function R(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || z || b === o || b === u || b === c || L || b === g || E || v || x || typeof b == "object" && b !== null && (b.$$typeof === p || b.$$typeof === d || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === k || b.getModuleId !== void 0));
    }
    function A(b, $, Q) {
      var re = b.displayName;
      if (re)
        return re;
      var ge = $.displayName || $.name || "";
      return ge !== "" ? Q + "(" + ge + ")" : Q;
    }
    function U(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var $ = b;
            return U($) + ".Consumer";
          case s:
            var Q = b;
            return U(Q._context) + ".Provider";
          case l:
            return A(b, b.render, "ForwardRef");
          case d:
            var re = b.displayName || null;
            return re !== null ? re : V(b.type) || "Memo";
          case p: {
            var ge = b, me = ge._payload, le = ge._init;
            try {
              return V(le(me));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var N = Object.assign, Z = 0, K, X, te, ee, D, j, G;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function Y() {
      {
        if (Z === 0) {
          K = console.log, X = console.info, te = console.warn, ee = console.error, D = console.group, j = console.groupCollapsed, G = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: N({}, b, {
              value: K
            }),
            info: N({}, b, {
              value: X
            }),
            warn: N({}, b, {
              value: te
            }),
            error: N({}, b, {
              value: ee
            }),
            group: N({}, b, {
              value: D
            }),
            groupCollapsed: N({}, b, {
              value: j
            }),
            groupEnd: N({}, b, {
              value: G
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = C.ReactCurrentDispatcher, W;
    function T(b, $, Q) {
      {
        if (W === void 0)
          try {
            throw Error();
          } catch (ge) {
            var re = ge.stack.trim().match(/\n( *(at )?)/);
            W = re && re[1] || "";
          }
        return `
` + W + b;
      }
    }
    var q = !1, I;
    {
      var J = typeof WeakMap == "function" ? WeakMap : Map;
      I = new J();
    }
    function H(b, $) {
      if (!b || q)
        return "";
      {
        var Q = I.get(b);
        if (Q !== void 0)
          return Q;
      }
      var re;
      q = !0;
      var ge = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var me;
      me = M.current, M.current = null, Y();
      try {
        if ($) {
          var le = function() {
            throw Error();
          };
          if (Object.defineProperty(le.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(le, []);
            } catch (ze) {
              re = ze;
            }
            Reflect.construct(b, [], le);
          } else {
            try {
              le.call();
            } catch (ze) {
              re = ze;
            }
            b.call(le.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ze) {
            re = ze;
          }
          b();
        }
      } catch (ze) {
        if (ze && re && typeof ze.stack == "string") {
          for (var se = ze.stack.split(`
`), Be = re.stack.split(`
`), ke = se.length - 1, Le = Be.length - 1; ke >= 1 && Le >= 0 && se[ke] !== Be[Le]; )
            Le--;
          for (; ke >= 1 && Le >= 0; ke--, Le--)
            if (se[ke] !== Be[Le]) {
              if (ke !== 1 || Le !== 1)
                do
                  if (ke--, Le--, Le < 0 || se[ke] !== Be[Le]) {
                    var We = `
` + se[ke].replace(" at new ", " at ");
                    return b.displayName && We.includes("<anonymous>") && (We = We.replace("<anonymous>", b.displayName)), typeof b == "function" && I.set(b, We), We;
                  }
                while (ke >= 1 && Le >= 0);
              break;
            }
        }
      } finally {
        q = !1, M.current = me, O(), Error.prepareStackTrace = ge;
      }
      var dn = b ? b.displayName || b.name : "", Ht = dn ? T(dn) : "";
      return typeof b == "function" && I.set(b, Ht), Ht;
    }
    function ce(b, $, Q) {
      return H(b, !1);
    }
    function ye(b) {
      var $ = b.prototype;
      return !!($ && $.isReactComponent);
    }
    function ie(b, $, Q) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return H(b, ye(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ce(b.render);
          case d:
            return ie(b.type, $, Q);
          case p: {
            var re = b, ge = re._payload, me = re._init;
            try {
              return ie(me(ge), $, Q);
            } catch {
            }
          }
        }
      return "";
    }
    var Te = Object.prototype.hasOwnProperty, Re = {}, Ne = C.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var $ = b._owner, Q = ie(b.type, b._source, $ ? $.type : null);
        Ne.setExtraStackFrame(Q);
      } else
        Ne.setExtraStackFrame(null);
    }
    function Ke(b, $, Q, re, ge) {
      {
        var me = Function.call.bind(Te);
        for (var le in b)
          if (me(b, le)) {
            var se = void 0;
            try {
              if (typeof b[le] != "function") {
                var Be = Error((re || "React class") + ": " + Q + " type `" + le + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[le] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Be.name = "Invariant Violation", Be;
              }
              se = b[le]($, le, re, Q, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ke) {
              se = ke;
            }
            se && !(se instanceof Error) && (Ie(ge), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", re || "React class", Q, le, typeof se), Ie(null)), se instanceof Error && !(se.message in Re) && (Re[se.message] = !0, Ie(ge), w("Failed %s type: %s", Q, se.message), Ie(null));
          }
      }
    }
    var Ze = Array.isArray;
    function Se(b) {
      return Ze(b);
    }
    function qe(b) {
      {
        var $ = typeof Symbol == "function" && Symbol.toStringTag, Q = $ && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return Q;
      }
    }
    function rt(b) {
      try {
        return Pe(b), !1;
      } catch {
        return !0;
      }
    }
    function Pe(b) {
      return "" + b;
    }
    function Me(b) {
      if (rt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qe(b)), Pe(b);
    }
    var Ge = C.ReactCurrentOwner, He = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, $e, ot;
    function Fe(b) {
      if (Te.call(b, "ref")) {
        var $ = Object.getOwnPropertyDescriptor(b, "ref").get;
        if ($ && $.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function Kt(b) {
      if (Te.call(b, "key")) {
        var $ = Object.getOwnPropertyDescriptor(b, "key").get;
        if ($ && $.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function lt(b, $) {
      typeof b.ref == "string" && Ge.current;
    }
    function ht(b, $) {
      {
        var Q = function() {
          $e || ($e = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", $));
        };
        Q.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: Q,
          configurable: !0
        });
      }
    }
    function Dt(b, $) {
      {
        var Q = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", $));
        };
        Q.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: Q,
          configurable: !0
        });
      }
    }
    var ln = function(b, $, Q, re, ge, me, le) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: $,
        ref: Q,
        props: le,
        // Record the component responsible for creating this element.
        _owner: me
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: re
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ge
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function Pt(b, $, Q, re, ge) {
      {
        var me, le = {}, se = null, Be = null;
        Q !== void 0 && (Me(Q), se = "" + Q), Kt($) && (Me($.key), se = "" + $.key), Fe($) && (Be = $.ref, lt($));
        for (me in $)
          Te.call($, me) && !He.hasOwnProperty(me) && (le[me] = $[me]);
        if (b && b.defaultProps) {
          var ke = b.defaultProps;
          for (me in ke)
            le[me] === void 0 && (le[me] = ke[me]);
        }
        if (se || Be) {
          var Le = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && ht(le, Le), Be && Dt(le, Le);
        }
        return ln(b, se, Be, ge, re, Ge.current, le);
      }
    }
    var St = C.ReactCurrentOwner, ut = C.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var $ = b._owner, Q = ie(b.type, b._source, $ ? $.type : null);
        ut.setExtraStackFrame(Q);
      } else
        ut.setExtraStackFrame(null);
    }
    var un;
    un = !1;
    function cn(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Nt() {
      {
        if (St.current) {
          var b = V(St.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function Gn(b) {
      return "";
    }
    var zt = {};
    function Yn(b) {
      {
        var $ = Nt();
        if (!$) {
          var Q = typeof b == "string" ? b : b.displayName || b.name;
          Q && ($ = `

Check the top-level render call using <` + Q + ">.");
        }
        return $;
      }
    }
    function $t(b, $) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var Q = Yn($);
        if (zt[Q])
          return;
        zt[Q] = !0;
        var re = "";
        b && b._owner && b._owner !== St.current && (re = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Q, re), Xe(null);
      }
    }
    function Sn(b, $) {
      {
        if (typeof b != "object")
          return;
        if (Se(b))
          for (var Q = 0; Q < b.length; Q++) {
            var re = b[Q];
            cn(re) && $t(re, $);
          }
        else if (cn(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ge = h(b);
          if (typeof ge == "function" && ge !== b.entries)
            for (var me = ge.call(b), le; !(le = me.next()).done; )
              cn(le.value) && $t(le.value, $);
        }
      }
    }
    function pr(b) {
      {
        var $ = b.type;
        if ($ == null || typeof $ == "string")
          return;
        var Q;
        if (typeof $ == "function")
          Q = $.propTypes;
        else if (typeof $ == "object" && ($.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        $.$$typeof === d))
          Q = $.propTypes;
        else
          return;
        if (Q) {
          var re = V($);
          Ke(Q, b.props, "prop", re, b);
        } else if ($.PropTypes !== void 0 && !un) {
          un = !0;
          var ge = V($);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ge || "Unknown");
        }
        typeof $.getDefaultProps == "function" && !$.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ut(b) {
      {
        for (var $ = Object.keys(b.props), Q = 0; Q < $.length; Q++) {
          var re = $[Q];
          if (re !== "children" && re !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", re), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var oe = {};
    function to(b, $, Q, re, ge, me) {
      {
        var le = R(b);
        if (!le) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Be = Gn();
          Be ? se += Be : se += Nt();
          var ke;
          b === null ? ke = "null" : Se(b) ? ke = "array" : b !== void 0 && b.$$typeof === t ? (ke = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : ke = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ke, se);
        }
        var Le = Pt(b, $, Q, ge, me);
        if (Le == null)
          return Le;
        if (le) {
          var We = $.children;
          if (We !== void 0)
            if (re)
              if (Se(We)) {
                for (var dn = 0; dn < We.length; dn++)
                  Sn(We[dn], b);
                Object.freeze && Object.freeze(We);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Sn(We, b);
        }
        if (Te.call($, "key")) {
          var Ht = V(b), ze = Object.keys($).filter(function(Fi) {
            return Fi !== "key";
          }), fr = ze.length > 0 ? "{key: someKey, " + ze.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!oe[Ht + fr]) {
            var Ii = ze.length > 0 ? "{" + ze.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, fr, Ht, Ii, Ht), oe[Ht + fr] = !0;
          }
        }
        return b === r ? Ut(Le) : pr(Le), Le;
      }
    }
    function Ti(b, $, Q) {
      return to(b, $, Q, !0);
    }
    function ji(b, $, Q) {
      return to(b, $, Q, !1);
    }
    var Ai = ji, Bi = Ti;
    _u.Fragment = r, _u.jsx = Ai, _u.jsxs = Bi;
  }()), _u;
}
process.env.NODE_ENV === "production" ? rm.exports = nU() : rm.exports = rU();
var rr = rm.exports;
Ve({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function nC(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function cr(e) {
  var t, n;
  return nC(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(nC(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var bM = Symbol.for("immer-nothing"), rC = Symbol.for("immer-draftable"), Zr = Symbol.for("immer-state"), oU = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Lr(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = oU[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Us = Object.getPrototypeOf;
function Cs(e) {
  return !!e && !!e[Zr];
}
function Es(e) {
  var t;
  return e ? wM(e) || Array.isArray(e) || !!e[rC] || !!((t = e.constructor) != null && t[rC]) || jp(e) || Ap(e) : !1;
}
var iU = Object.prototype.constructor.toString();
function wM(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Us(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === iU;
}
function ed(e, t) {
  Tp(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Tp(e) {
  const t = e[Zr];
  return t ? t.type_ : Array.isArray(e) ? 1 : jp(e) ? 2 : Ap(e) ? 3 : 0;
}
function om(e, t) {
  return Tp(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function CM(e, t, n) {
  const r = Tp(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function sU(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function jp(e) {
  return e instanceof Map;
}
function Ap(e) {
  return e instanceof Set;
}
function Ki(e) {
  return e.copy_ || e.base_;
}
function im(e, t) {
  if (jp(e))
    return new Map(e);
  if (Ap(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = wM(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Zr];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(Us(e), r);
  } else {
    const r = Us(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function ty(e, t = !1) {
  return Bp(e) || Cs(e) || !Es(e) || (Tp(e) > 1 && (e.set = e.add = e.clear = e.delete = aU), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => ty(r, !0))), e;
}
function aU() {
  Lr(2);
}
function Bp(e) {
  return Object.isFrozen(e);
}
var lU = {};
function xs(e) {
  const t = lU[e];
  return t || Lr(0, e), t;
}
var hl;
function EM() {
  return hl;
}
function uU(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function oC(e, t) {
  t && (xs("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function sm(e) {
  am(e), e.drafts_.forEach(cU), e.drafts_ = null;
}
function am(e) {
  e === hl && (hl = e.parent_);
}
function iC(e) {
  return hl = uU(hl, e);
}
function cU(e) {
  const t = e[Zr];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function sC(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Zr].modified_ && (sm(t), Lr(4)), Es(e) && (e = td(t, e), t.parent_ || nd(t, e)), t.patches_ && xs("Patches").generateReplacementPatches_(
    n[Zr].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = td(t, n, []), sm(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== bM ? e : void 0;
}
function td(e, t, n) {
  if (Bp(t))
    return t;
  const r = t[Zr];
  if (!r)
    return ed(
      t,
      (o, i) => aC(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return nd(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), ed(
      i,
      (a, l) => aC(e, r, o, a, l, n, s)
    ), nd(e, o, !1), n && e.patches_ && xs("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function aC(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && Lr(5), Cs(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !om(t.assigned_, r) ? i.concat(r) : void 0, l = td(e, o, a);
    if (CM(n, r, l), Cs(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (Es(o) && !Bp(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    td(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && nd(e, o);
  }
}
function nd(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && ty(t, n);
}
function dU(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : EM(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = ny;
  n && (o = [r], i = gl);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var ny = {
  get(e, t) {
    if (t === Zr)
      return e;
    const n = Ki(e);
    if (!om(n, t))
      return pU(e, n, t);
    const r = n[t];
    return e.finalized_ || !Es(r) ? r : r === $f(e.base_, t) ? (Uf(e), e.copy_[t] = um(r, e)) : r;
  },
  has(e, t) {
    return t in Ki(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ki(e));
  },
  set(e, t, n) {
    const r = xM(Ki(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = $f(Ki(e), t), i = o == null ? void 0 : o[Zr];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (sU(n, o) && (n !== void 0 || om(e.base_, t)))
        return !0;
      Uf(e), lm(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return $f(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Uf(e), lm(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ki(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Lr(11);
  },
  getPrototypeOf(e) {
    return Us(e.base_);
  },
  setPrototypeOf() {
    Lr(12);
  }
}, gl = {};
ed(ny, (e, t) => {
  gl[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
gl.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Lr(13), gl.set.call(this, e, t, void 0);
};
gl.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Lr(14), ny.set.call(this, e[0], t, n, e[0]);
};
function $f(e, t) {
  const n = e[Zr];
  return (n ? Ki(n) : e)[t];
}
function pU(e, t, n) {
  var r;
  const o = xM(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function xM(e, t) {
  if (!(t in e))
    return;
  let n = Us(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Us(n);
  }
}
function lm(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && lm(e.parent_));
}
function Uf(e) {
  e.copy_ || (e.copy_ = im(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var fU = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Lr(6), r !== void 0 && typeof r != "function" && Lr(7);
      let o;
      if (Es(t)) {
        const i = iC(this), s = um(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? sm(i) : am(i);
        }
        return oC(i, r), sC(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === bM && (o = void 0), this.autoFreeze_ && ty(o, !0), r) {
          const i = [], s = [];
          xs("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        Lr(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Es(e) || Lr(8), Cs(e) && (e = hU(e));
    const t = iC(this), n = um(e, void 0);
    return n[Zr].isManual_ = !0, am(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Zr];
    (!n || !n.isManual_) && Lr(9);
    const { scope_: r } = n;
    return oC(r, t), sC(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = xs("Patches").applyPatches_;
    return Cs(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function um(e, t) {
  const n = jp(e) ? xs("MapSet").proxyMap_(e, t) : Ap(e) ? xs("MapSet").proxySet_(e, t) : dU(e, t);
  return (t ? t.scope_ : EM()).drafts_.push(n), n;
}
function hU(e) {
  return Cs(e) || Lr(10, e), OM(e);
}
function OM(e) {
  if (!Es(e) || Bp(e))
    return e;
  const t = e[Zr];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = im(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = im(e, !0);
  return ed(n, (r, o) => {
    CM(n, r, OM(o));
  }), t && (t.finalized_ = !1), n;
}
var qr = new fU(), ry = qr.produce;
qr.produceWithPatches.bind(
  qr
);
qr.setAutoFreeze.bind(qr);
qr.setUseStrictShallowCopy.bind(qr);
qr.applyPatches.bind(qr);
var lC = qr.createDraft.bind(qr), uC = qr.finishDraft.bind(qr), Ce = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ce.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Ce.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ce.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Ce.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ce.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ce.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ce.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ce.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ce.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ce.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ce.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ce.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ce.isAncestor(t, e) && !Ce.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ce.equals(i, r) || Ce.endsBefore(i, r) || Ce.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (Ce.equals(s, r) || Ce.isAncestor(s, r))
          return null;
        Ce.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        Ce.equals(a, r) || Ce.endsBefore(a, r) ? r[a.length - 1] -= 1 : Ce.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ce.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ce.endsBefore(u, r) ? r[u.length - 1] += 1 : Ce.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: d,
          newPath: p
        } = t;
        if (Ce.equals(d, p))
          return r;
        if (Ce.isAncestor(d, r) || Ce.equals(d, r)) {
          var g = p.slice();
          return Ce.endsBefore(d, p) && d.length < p.length && (g[d.length - 1] -= 1), g.concat(r.slice(d.length));
        } else Ce.isSibling(d, p) && (Ce.isAncestor(p, r) || Ce.equals(p, r)) ? Ce.endsBefore(d, r) ? r[d.length - 1] -= 1 : r[d.length - 1] += 1 : Ce.endsBefore(p, r) || Ce.equals(p, r) || Ce.isAncestor(p, r) ? (Ce.endsBefore(d, r) && (r[d.length - 1] -= 1), r[p.length - 1] += 1) : Ce.endsBefore(d, r) && (Ce.equals(p, r) && (r[p.length - 1] += 1), r[d.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function ml(e) {
  "@babel/helpers - typeof";
  return ml = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ml(e);
}
function gU(e, t) {
  if (ml(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (ml(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function mU(e) {
  var t = gU(e, "string");
  return ml(t) === "symbol" ? t : String(t);
}
function Gs(e, t, n) {
  return t = mU(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function cC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function da(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cC(Object(n), !0).forEach(function(r) {
      Gs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vU = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = tt.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of ft.points(t))
          t[l] = vn.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: d
      } = n;
      if (d.length === 0) break;
      var p = tt.leaf(e, u), g = p.text.slice(0, c), f = p.text.slice(c);
      if (p.text = g + d + f, t)
        for (var [m, h] of ft.points(t))
          t[h] = vn.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: C
      } = n, w = tt.get(e, C), P = Ce.previous(C), E = tt.get(e, P), v = tt.parent(e, C), x = C[C.length - 1];
      if (Un.isText(w) && Un.isText(E))
        E.text += w.text;
      else if (!Un.isText(w) && !Un.isText(E))
        E.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(C, "] to nodes of different interfaces: ").concat(Br.stringify(w), " ").concat(Br.stringify(E)));
      if (v.children.splice(x, 1), t)
        for (var [L, z] of ft.points(t))
          t[z] = vn.transform(L, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: R
      } = n;
      if (Ce.isAncestor(k, R))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(R, "] because the destination is inside itself."));
      var A = tt.get(e, k), U = tt.parent(e, k), V = k[k.length - 1];
      U.children.splice(V, 1);
      var N = Ce.transform(k, n), Z = tt.get(e, Ce.parent(N)), K = N[N.length - 1];
      if (Z.children.splice(K, 0, A), t)
        for (var [X, te] of ft.points(t))
          t[te] = vn.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, D = ee[ee.length - 1], j = tt.parent(e, ee);
      if (j.children.splice(D, 1), t)
        for (var [G, S] of ft.points(t)) {
          var Y = vn.transform(G, n);
          if (t != null && Y != null)
            t[S] = Y;
          else {
            var O = void 0, M = void 0;
            for (var [W, T] of tt.texts(e))
              if (Ce.compare(T, ee) === -1)
                O = [W, T];
              else {
                M = [W, T];
                break;
              }
            var q = !1;
            O && M && (Ce.equals(M[1], ee) ? q = !Ce.hasPrevious(M[1]) : q = Ce.common(O[1], ee).length < Ce.common(M[1], ee).length), O && !q ? (G.path = O[1], G.offset = O[0].text.length) : M ? (G.path = M[1], G.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: I,
        offset: J,
        text: H
      } = n;
      if (H.length === 0) break;
      var ce = tt.leaf(e, I), ye = ce.text.slice(0, J), ie = ce.text.slice(J + H.length);
      if (ce.text = ye + ie, t)
        for (var [Te, Re] of ft.points(t))
          t[Re] = vn.transform(Te, n);
      break;
    }
    case "set_node": {
      var {
        path: Ne,
        properties: Ie,
        newProperties: Ke
      } = n;
      if (Ne.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ze = tt.get(e, Ne);
      for (var Se in Ke) {
        if (Se === "children" || Se === "text")
          throw new Error('Cannot set the "'.concat(Se, '" property of nodes!'));
        var qe = Ke[Se];
        qe == null ? delete Ze[Se] : Ze[Se] = qe;
      }
      for (var rt in Ie)
        Ke.hasOwnProperty(rt) || delete Ze[rt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Pe
      } = n;
      if (Pe == null)
        t = Pe;
      else {
        if (t == null) {
          if (!ft.isRange(Pe))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Br.stringify(Pe), " when there is no current selection."));
          t = da({}, Pe);
        }
        for (var Me in Pe) {
          var Ge = Pe[Me];
          if (Ge == null) {
            if (Me === "anchor" || Me === "focus")
              throw new Error('Cannot remove the "'.concat(Me, '" selection property'));
            delete t[Me];
          } else
            t[Me] = Ge;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: He,
        position: $e,
        properties: ot
      } = n;
      if (He.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(He, "] because the root node cannot be split."));
      var Fe = tt.get(e, He), Kt = tt.parent(e, He), lt = He[He.length - 1], ht;
      if (Un.isText(Fe)) {
        var Dt = Fe.text.slice(0, $e), ln = Fe.text.slice($e);
        Fe.text = Dt, ht = da(da({}, ot), {}, {
          text: ln
        });
      } else {
        var Pt = Fe.children.slice(0, $e), St = Fe.children.slice($e);
        Fe.children = Pt, ht = da(da({}, ot), {}, {
          children: St
        });
      }
      if (Kt.children.splice(lt + 1, 0, ht), t)
        for (var [ut, Xe] of ft.points(t))
          t[Xe] = vn.transform(ut, n);
      break;
    }
  }
  return t;
}, yU = {
  transform(e, t) {
    e.children = lC(e.children);
    var n = e.selection && lC(e.selection);
    try {
      n = vU(e, n, t);
    } finally {
      e.children = uC(e.children), n ? e.selection = Cs(n) ? uC(n) : n : e.selection = null;
    }
  }
}, bU = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, wU = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, kM = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (cr(r) && cr(o)) {
      if (!kM(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function CU(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function vl(e, t) {
  if (e == null) return {};
  var n = CU(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var EU = ["anchor", "focus"];
function dC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dC(Object(n), !0).forEach(function(r) {
      Gs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ft = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return ft.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = ft.edges(e);
    return t;
  },
  equals(e, t) {
    return vn.equals(e.anchor, t.anchor) && vn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (ft.isRange(t)) {
      if (ft.includes(e, t.anchor) || ft.includes(e, t.focus))
        return !0;
      var [n, r] = ft.edges(e), [o, i] = ft.edges(t);
      return vn.isBefore(n, o) && vn.isAfter(r, i);
    }
    var [s, a] = ft.edges(e), l = !1, u = !1;
    return vn.isPoint(t) ? (l = vn.compare(t, s) >= 0, u = vn.compare(t, a) <= 0) : (l = Ce.compare(t, s.path) >= 0, u = Ce.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = vl(e, EU), [r, o] = ft.edges(e), [i, s] = ft.edges(t), a = vn.isBefore(r, i) ? i : r, l = vn.isBefore(o, s) ? o : s;
    return vn.isBefore(l, a) ? null : xU({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return vn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return vn.equals(t, n);
  },
  isExpanded(e) {
    return !ft.isCollapsed(e);
  },
  isForward(e) {
    return !ft.isBackward(e);
  },
  isRange(e) {
    return cr(e) && vn.isPoint(e.anchor) && vn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = ft.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ry(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = ft.isCollapsed(r);
        ft.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? ft.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = vn.transform(r.anchor, t, {
        affinity: i
      }), u = vn.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, pC = (e) => cr(e) && tt.isNodeList(e.children) && !nn.isEditor(e), To = {
  isAncestor(e) {
    return cr(e) && tt.isNodeList(e.children);
  },
  isElement: pC,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => To.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return pC(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, OU = ["children"], kU = ["text"], fC = /* @__PURE__ */ new WeakMap(), tt = {
  ancestor(e, t) {
    var n = tt.get(e, t);
    if (Un.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Br.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ce.ancestors(t, n)) {
        var o = tt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Un.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Br.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Br.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = tt.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = tt.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ce.common(t, n), o = tt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = tt.get(e, t);
    if (nn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Br.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of tt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of tt.nodes(e, t))
        To.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (To.isAncestor(e)) {
      var t = vl(e, OU);
      return t;
    } else {
      var t = vl(e, kU);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = tt.get(e, n); r && !(Un.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Un.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Br.stringify(e)));
    var n = ry({
      children: e.children
    }, (r) => {
      var [o, i] = ft.edges(t), s = tt.nodes(r, {
        reverse: !0,
        pass: (p) => {
          var [, g] = p;
          return !ft.includes(t, g);
        }
      });
      for (var [, a] of s) {
        if (!ft.includes(t, a)) {
          var l = tt.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (Ce.equals(a, i.path)) {
          var c = tt.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ce.equals(a, o.path)) {
          var d = tt.leaf(r, a);
          d.text = d.text.slice(o.offset);
        }
      }
      nn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Un.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Br.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Un.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Un.isText(e) || To.isElement(e) || nn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = fC.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => tt.isNode(r));
    return fC.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = tt.get(e, n); r && !(Un.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = tt.get(e, t);
    if (!Un.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Br.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ce.levels(t, n)) {
        var o = tt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return To.isElement(e) && To.isElementProps(t) && To.matches(e, t) || Un.isText(e) && Un.isTextProps(t) && Un.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? Ce.isBefore(a, i) : Ce.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !Un.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ce.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = tt.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = Ce.next(a);
          if (tt.has(e, c)) {
            a = c, l = tt.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var d = Ce.previous(a);
          a = d, l = tt.get(e, a);
          continue;
        }
        a = Ce.parent(a), l = tt.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ce.parent(t), r = tt.get(e, n);
    if (Un.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Un.isText(e) ? e.text : e.children.map(tt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of tt.nodes(e, t))
        Un.isText(n) && (yield [n, r]);
    }();
  }
};
function hC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hC(Object(n), !0).forEach(function(r) {
      Gs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ma = {
  isNodeOperation(e) {
    return Ma.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!cr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ce.isPath(e.path) && tt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ce.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ce.isPath(e.path) && cr(e.properties);
      case "move_node":
        return Ce.isPath(e.path) && Ce.isPath(e.newPath);
      case "remove_node":
        return Ce.isPath(e.path) && tt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ce.isPath(e.path);
      case "set_node":
        return Ce.isPath(e.path) && cr(e.properties) && cr(e.newProperties);
      case "set_selection":
        return e.properties === null && ft.isRange(e.newProperties) || e.newProperties === null && ft.isRange(e.properties) || cr(e.properties) && cr(e.newProperties);
      case "split_node":
        return Ce.isPath(e.path) && typeof e.position == "number" && cr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Ma.isOperation(t));
  },
  isSelectionOperation(e) {
    return Ma.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Ma.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Cn(Cn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Cn(Cn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Cn(Cn({}, e), {}, {
          type: "split_node",
          path: Ce.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ce.equals(t, n))
          return e;
        if (Ce.isSibling(n, t))
          return Cn(Cn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ce.transform(n, e), o = Ce.transform(Ce.next(n), e);
        return Cn(Cn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Cn(Cn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Cn(Cn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return Cn(Cn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? Cn(Cn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Cn(Cn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : Cn(Cn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return Cn(Cn({}, e), {}, {
          type: "merge_node",
          path: Ce.next(e.path)
        });
    }
  }
}, gC = /* @__PURE__ */ new WeakMap(), _U = (e) => {
  var t = gC.get(e);
  if (t !== void 0)
    return t;
  if (!cr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || cr(e.marks)) && (e.selection === null || ft.isRange(e.selection)) && tt.isNodeList(e.children) && Ma.isOperationList(e.operations);
  return gC.set(e, n), n;
}, nn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return _U(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function mC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mC(Object(n), !0).forEach(function(r) {
      Gs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vn = {
  compare(e, t) {
    var n = Ce.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return vn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return vn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ce.equals(e.path, t.path);
  },
  isPoint(e) {
    return cr(e) && typeof e.offset == "number" && Ce.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ry(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ce.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ce.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ce.equals(t.path, i) && (r.offset += t.position), r.path = Ce.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ce.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ce.equals(t.path, i) || Ce.isAncestor(t.path, i))
            return null;
          r.path = Ce.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ce.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = Ce.transform(i, t, vC(vC({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ce.transform(i, t, n);
          break;
        }
      }
    });
  }
}, yC = void 0, Br = {
  setScrubber(e) {
    yC = e;
  },
  stringify(e) {
    return JSON.stringify(e, yC);
  }
}, LU = ["text"], DU = ["anchor", "focus"];
function bC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ko(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bC(Object(n), !0).forEach(function(r) {
      Gs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Un = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = vl(i, LU);
      return s;
    }
    return kM(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return cr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Un.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [ko({}, e)];
    for (var r of t) {
      var o = vl(r, DU), [i, s] = ft.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var d of n) {
        var {
          length: p
        } = d.text, g = l;
        if (l += p, u <= g && l <= c) {
          Object.assign(d, o), a.push(d);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          a.push(d);
          continue;
        }
        var f = d, m = void 0, h = void 0;
        if (c < l) {
          var C = c - g;
          h = ko(ko({}, f), {}, {
            text: f.text.slice(C)
          }), f = ko(ko({}, f), {}, {
            text: f.text.slice(0, C)
          });
        }
        if (u > g) {
          var w = u - g;
          m = ko(ko({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = ko(ko({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && a.push(m), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, PU = (e) => e.selection ? e.selection : e.children.length > 0 ? nn.end(e, []) : [0], hn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(hn || (hn = {}));
hn.L, hn.L | hn.V | hn.LV | hn.LVT, hn.LV | hn.V, hn.V | hn.T, hn.LVT | hn.T, hn.T, hn.Any, hn.Extend | hn.ZWJ, hn.Any, hn.SpacingMark, hn.Prepend, hn.Any, hn.ZWJ, hn.ExtPict, hn.RI, hn.RI;
var SU = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    nn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = PU(e)
      } = n;
      if (Ce.isPath(o) && (o = nn.range(e, o)), ft.isRange(o))
        if (ft.isCollapsed(o))
          o = o.anchor;
        else {
          var i = ft.end(o);
          if (!r && nn.void(e, {
            at: i
          }))
            return;
          var s = ft.start(o), a = nn.pointRef(e, s), l = nn.pointRef(e, i);
          rd.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, rd.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && nn.void(e, {
        at: o
      }) || nn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: d,
          offset: p
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: d,
          offset: p,
          text: t
        });
      }
    });
  }
};
function wC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wC(Object(n), !0).forEach(function(r) {
      Gs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rd = Lu(Lu(Lu(Lu({}, yU), bU), wU), SU), _M = {}, oy = {}, iy = {}, Ls = {}, sy = {}, ay = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(ay);
var bt = {}, ki = an && an.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), za = an && an.__assign || function() {
  return za = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, za.apply(this, arguments);
};
Object.defineProperty(bt, "__esModule", { value: !0 });
bt.cloneNode = bt.hasChildren = bt.isDocument = bt.isDirective = bt.isComment = bt.isText = bt.isCDATA = bt.isTag = bt.Element = bt.Document = bt.CDATA = bt.NodeWithChildren = bt.ProcessingInstruction = bt.Comment = bt.Text = bt.DataNode = bt.Node = void 0;
var Mr = ay, ly = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), uy(this, t);
    }, e;
  }()
);
bt.Node = ly;
var Ip = (
  /** @class */
  function(e) {
    ki(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ly)
);
bt.DataNode = Ip;
var LM = (
  /** @class */
  function(e) {
    ki(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Mr.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ip)
);
bt.Text = LM;
var DM = (
  /** @class */
  function(e) {
    ki(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Mr.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ip)
);
bt.Comment = DM;
var PM = (
  /** @class */
  function(e) {
    ki(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Mr.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ip)
);
bt.ProcessingInstruction = PM;
var Fp = (
  /** @class */
  function(e) {
    ki(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ly)
);
bt.NodeWithChildren = Fp;
var SM = (
  /** @class */
  function(e) {
    ki(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Mr.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Fp)
);
bt.CDATA = SM;
var MM = (
  /** @class */
  function(e) {
    ki(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Mr.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Fp)
);
bt.Document = MM;
var TM = (
  /** @class */
  function(e) {
    ki(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Mr.ElementType.Script : n === "style" ? Mr.ElementType.Style : Mr.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Fp)
);
bt.Element = TM;
function jM(e) {
  return (0, Mr.isTag)(e);
}
bt.isTag = jM;
function AM(e) {
  return e.type === Mr.ElementType.CDATA;
}
bt.isCDATA = AM;
function BM(e) {
  return e.type === Mr.ElementType.Text;
}
bt.isText = BM;
function IM(e) {
  return e.type === Mr.ElementType.Comment;
}
bt.isComment = IM;
function FM(e) {
  return e.type === Mr.ElementType.Directive;
}
bt.isDirective = FM;
function RM(e) {
  return e.type === Mr.ElementType.Root;
}
bt.isDocument = RM;
function MU(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
bt.hasChildren = MU;
function uy(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (BM(e))
    n = new LM(e.data);
  else if (IM(e))
    n = new DM(e.data);
  else if (jM(e)) {
    var r = t ? Hf(e.children) : [], o = new TM(e.name, za({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = za({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = za({}, e["x-attribsPrefix"])), n = o;
  } else if (AM(e)) {
    var r = t ? Hf(e.children) : [], i = new SM(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (RM(e)) {
    var r = t ? Hf(e.children) : [], s = new MM(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (FM(e)) {
    var a = new PM(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
bt.cloneNode = uy;
function Hf(e) {
  for (var t = e.map(function(r) {
    return uy(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = an && an.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var d = Object.getOwnPropertyDescriptor(l, u);
    (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, d);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = an && an.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = ay, o = bt;
  n(bt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, d = new o.Element(l, u, void 0, c);
        this.addNode(d), this.tagStack.push(d);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(sy);
var NM = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(NM);
Object.defineProperty(Ls, "__esModule", { value: !0 });
Ls.formatAttributes = zM;
Ls.escapeSpecialCharacters = AU;
Ls.revertEscapedCharacters = $M;
Ls.formatDOM = UM;
var Du = sy, yl = NM;
function TU(e) {
  return yl.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function zM(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function jU(e) {
  e = e.toLowerCase();
  var t = TU(e);
  return t || e;
}
function AU(e) {
  return e.replace(yl.CARRIAGE_RETURN_REGEX, yl.CARRIAGE_RETURN_PLACEHOLDER);
}
function $M(e) {
  return e.replace(yl.CARRIAGE_RETURN_PLACEHOLDER_REGEX, yl.CARRIAGE_RETURN);
}
function UM(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = jU(a.nodeName);
        o = new Du.Element(l, zM(a.attributes)), o.children = UM(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Du.Text($M(a.nodeValue));
        break;
      case 8:
        o = new Du.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Du.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(iy, "__esModule", { value: !0 });
iy.default = NU;
var BU = Ls, CC = "html", EC = "head", Pu = "body", IU = /<([a-zA-Z]+[0-9]?)/, xC = /<head[^]*>/i, OC = /<body[^]*>/i, od = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, cm = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, kC = typeof window == "object" && window.DOMParser;
if (typeof kC == "function") {
  var FU = new kC(), RU = "text/html";
  cm = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), FU.parseFromString(e, RU);
  }, od = cm;
}
if (typeof document == "object" && document.implementation) {
  var Su = document.implementation.createHTMLDocument();
  od = function(e, t) {
    if (t) {
      var n = Su.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Su;
    }
    return Su.documentElement.innerHTML = e, Su;
  };
}
var Mu = typeof document == "object" && document.createElement("template"), dm;
Mu && Mu.content && (dm = function(e) {
  return Mu.innerHTML = e, Mu.content.childNodes;
});
function NU(e) {
  var t, n;
  e = (0, BU.escapeSpecialCharacters)(e);
  var r = e.match(IU), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case CC: {
      var i = cm(e);
      if (!xC.test(e)) {
        var s = i.querySelector(EC);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!OC.test(e)) {
        var s = i.querySelector(Pu);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(CC);
    }
    case EC:
    case Pu: {
      var a = od(e).querySelectorAll(o);
      return OC.test(e) && xC.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (dm)
        return dm(e);
      var s = od(e, Pu).querySelector(Pu);
      return s.childNodes;
    }
  }
}
var zU = an && an.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(oy, "__esModule", { value: !0 });
oy.default = WU;
var $U = zU(iy), UU = Ls, HU = /<(![a-zA-Z\s]+)>/;
function WU(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(HU), n = t ? t[1] : void 0;
  return (0, UU.formatDOM)((0, $U.default)(e), null, n);
}
var Rp = {}, so = {}, Np = {}, VU = 0;
Np.SAME = VU;
var ZU = 1;
Np.CAMELCASE = ZU;
Np.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const HM = 0, _i = 1, zp = 2, $p = 3, cy = 4, WM = 5, VM = 6;
function qU(e) {
  return ar.hasOwnProperty(e) ? ar[e] : null;
}
function Cr(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === zp || t === $p || t === cy, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const ar = {}, GU = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
GU.forEach((e) => {
  ar[e] = new Cr(
    e,
    HM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ar[e] = new Cr(
    e,
    _i,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ar[e] = new Cr(
    e,
    zp,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ar[e] = new Cr(
    e,
    zp,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ar[e] = new Cr(
    e,
    $p,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ar[e] = new Cr(
    e,
    $p,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ar[e] = new Cr(
    e,
    cy,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ar[e] = new Cr(
    e,
    VM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ar[e] = new Cr(
    e,
    WM,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const dy = /[\-\:]([a-z])/g, py = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dy, py);
  ar[t] = new Cr(
    t,
    _i,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dy, py);
  ar[t] = new Cr(
    t,
    _i,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dy, py);
  ar[t] = new Cr(
    t,
    _i,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ar[e] = new Cr(
    e,
    _i,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const YU = "xlinkHref";
ar[YU] = new Cr(
  "xlinkHref",
  _i,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ar[e] = new Cr(
    e,
    _i,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: KU,
  SAME: XU,
  possibleStandardNames: _C
} = Np, JU = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", QU = JU + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", e9 = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + QU + "]*$")
), t9 = Object.keys(
  _C
).reduce((e, t) => {
  const n = _C[t];
  return n === XU ? e[t] = t : n === KU ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
so.BOOLEAN = $p;
so.BOOLEANISH_STRING = zp;
so.NUMERIC = WM;
so.OVERLOADED_BOOLEAN = cy;
so.POSITIVE_NUMERIC = VM;
so.RESERVED = HM;
so.STRING = _i;
so.getPropertyInfo = qU;
so.isCustomAttribute = e9;
so.possibleStandardNames = t9;
var fy = {}, hy = {}, LC = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, n9 = /\n/g, r9 = /^\s*/, o9 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, i9 = /^:\s*/, s9 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, a9 = /^[;\s]*/, l9 = /^\s+|\s+$/g, u9 = `
`, DC = "/", PC = "*", ts = "", c9 = "comment", d9 = "declaration", p9 = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(n9);
    m && (n += m.length);
    var h = f.lastIndexOf(u9);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new s(f), u(), m;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var h = m[0];
      return o(h), e = e.slice(h.length), m;
    }
  }
  function u() {
    l(r9);
  }
  function c(f) {
    var m;
    for (f = f || []; m = d(); )
      m !== !1 && f.push(m);
    return f;
  }
  function d() {
    var f = i();
    if (!(DC != e.charAt(0) || PC != e.charAt(1))) {
      for (var m = 2; ts != e.charAt(m) && (PC != e.charAt(m) || DC != e.charAt(m + 1)); )
        ++m;
      if (m += 2, ts === e.charAt(m - 1))
        return a("End of comment missing");
      var h = e.slice(2, m - 2);
      return r += 2, o(h), e = e.slice(m), r += 2, f({
        type: c9,
        comment: h
      });
    }
  }
  function p() {
    var f = i(), m = l(o9);
    if (m) {
      if (d(), !l(i9)) return a("property missing ':'");
      var h = l(s9), C = f({
        type: d9,
        property: SC(m[0].replace(LC, ts)),
        value: h ? SC(h[0].replace(LC, ts)) : ts
      });
      return l(a9), C;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = p(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function SC(e) {
  return e ? e.replace(l9, ts) : ts;
}
var f9 = an && an.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(hy, "__esModule", { value: !0 });
hy.default = g9;
var h9 = f9(p9);
function g9(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, h9.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var Up = {};
Object.defineProperty(Up, "__esModule", { value: !0 });
Up.camelCase = void 0;
var m9 = /^--[a-zA-Z0-9_-]+$/, v9 = /-([a-z])/g, y9 = /^[^-]+$/, b9 = /^-(webkit|moz|ms|o|khtml)-/, w9 = /^-(ms)-/, C9 = function(e) {
  return !e || y9.test(e) || m9.test(e);
}, E9 = function(e, t) {
  return t.toUpperCase();
}, MC = function(e, t) {
  return "".concat(t, "-");
}, x9 = function(e, t) {
  return t === void 0 && (t = {}), C9(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(w9, MC) : e = e.replace(b9, MC), e.replace(v9, E9));
};
Up.camelCase = x9;
var O9 = an && an.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, k9 = O9(hy), _9 = Up;
function pm(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, k9.default)(e, function(r, o) {
    r && o && (n[(0, _9.camelCase)(r, t)] = o);
  }), n;
}
pm.default = pm;
var L9 = pm;
(function(e) {
  var t = an && an.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Oe, r = t(L9), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, d) {
    return c.includes("-") ? !o.has(c) : !!(d && typeof d.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, d) {
    if (typeof c == "string") {
      if (!c.trim()) {
        d.style = {};
        return;
      }
      try {
        d.style = (0, r.default)(c, s);
      } catch {
        d.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(fy);
Object.defineProperty(Rp, "__esModule", { value: !0 });
Rp.default = M9;
var Ta = so, TC = fy, D9 = ["checked", "value"], P9 = ["input", "select", "textarea"], S9 = {
  reset: !0,
  submit: !0
};
function M9(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && S9[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Ta.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = jC(s);
    if (a) {
      var l = (0, Ta.getPropertyInfo)(a);
      switch (D9.includes(a) && P9.includes(t) && !r && (a = jC("default" + s)), n[a] = i, l && l.type) {
        case Ta.BOOLEAN:
          n[a] = !0;
          break;
        case Ta.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    TC.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, TC.setStyleProp)(e.style, n), n;
}
function jC(e) {
  return Ta.possibleStandardNames[e];
}
var gy = {}, T9 = an && an.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(gy, "__esModule", { value: !0 });
gy.default = ZM;
var Wf = Oe, j9 = T9(Rp), $a = fy, A9 = {
  cloneElement: Wf.cloneElement,
  createElement: Wf.createElement,
  isValidElement: Wf.isValidElement
};
function ZM(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || $a.returnFirstArg, i = t.library || A9, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var d = e[c];
    if (r) {
      var p = t.replace(d, c);
      if (l(p)) {
        u > 1 && (p = s(p, {
          key: p.key || c
        })), n.push(o(p, d, c));
        continue;
      }
    }
    if (d.type === "text") {
      var g = !d.data.trim().length;
      if (g && d.parent && !(0, $a.canTextBeChildOfNode)(d.parent) || t.trim && g)
        continue;
      n.push(o(d.data, d, c));
      continue;
    }
    var f = d, m = {};
    B9(f) ? ((0, $a.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, j9.default)(f.attribs, f.name));
    var h = void 0;
    switch (d.type) {
      case "script":
      case "style":
        d.children[0] && (m.dangerouslySetInnerHTML = {
          __html: d.children[0].data
        });
        break;
      case "tag":
        d.name === "textarea" && d.children[0] ? m.defaultValue = d.children[0].data : d.children && d.children.length && (h = ZM(d.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(a(d.name, m, h), d, c));
  }
  return n.length === 1 ? n[0] : n;
}
function B9(e) {
  return $a.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, $a.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = an && an.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(oy);
  e.htmlToDOM = n.default;
  var r = t(Rp);
  e.attributesToProps = r.default;
  var o = t(gy);
  e.domToReact = o.default;
  var i = sy;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(_M);
const I9 = /* @__PURE__ */ tU(_M);
I9.default;
Ve({});
function F9(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const R9 = {
  CNPJ: "99.999.999/9999-99"
};
F9(R9.CNPJ).length;
Tr((e, t) => /* @__PURE__ */ rr.jsx("input", { ref: t, ...e }));
function qM(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const GM = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function N9(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function z9(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const $9 = qM(GM.NINE).length, U9 = Tr((e, t) => /* @__PURE__ */ rr.jsx("input", { ref: t, ...e }));
Tr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: s, currentCountry: a, disabled: l } = e, [u, c] = _(!1);
    y(() => {
      u ? i(a.mask) : c(!0);
    }, [a]);
    const d = `phoneInputMask ${o}`;
    function p(g) {
      let f = qM(g.target.value);
      const m = z9(f);
      f.length > $9 || (f = N9(f, GM[m]), g.target.value = f, i(f));
    }
    return a.code === "+55" ? /* @__PURE__ */ rr.jsx(
      "input",
      {
        value: s,
        onChange: p,
        className: d,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ rr.jsx(
      Ml,
      {
        value: s,
        onChange: (g) => i(g.target.value),
        className: d,
        component: U9,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: a.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
Ve({});
var No = {};
Object.defineProperty(No, "__esModule", {
  value: !0
});
var H9 = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Vf = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, YM = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: H9 ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, my = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Tu = 1; Tu < 20; Tu++)
  my["f" + Tu] = 111 + Tu;
function Hp(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return KM(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return XM(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function W9(e, t) {
  return Hp(e, t);
}
function V9(e, t) {
  return Hp(e, { byKey: !0 }, t);
}
function KM(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in Vf)
    r[Vf[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), d; !(a = (d = c.next()).done); a = !0) {
      var p = d.value, g = p.endsWith("?") && p.length > 1;
      g && (p = p.slice(0, -1));
      var f = vy(p), m = Vf[f];
      if (p.length > 1 && !m && !YM[p] && !my[f])
        throw new TypeError('Unknown modifier: "' + p + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = JM(p)), m && (r[m] = g ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function XM(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function JM(e) {
  e = vy(e);
  var t = my[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function vy(e) {
  return e = e.toLowerCase(), e = YM[e] || e, e;
}
No.default = Hp;
var Zf = No.isHotkey = Hp;
No.isCodeHotkey = W9;
No.isKeyHotkey = V9;
No.parseHotkey = KM;
No.compareHotkey = XM;
No.toKeyCode = JM;
No.toKeyName = vy;
var Z9 = typeof an == "object" && an && an.Object === Object && an, q9 = Z9, G9 = q9, Y9 = typeof self == "object" && self && self.Object === Object && self, K9 = G9 || Y9 || Function("return this")(), X9 = K9, J9 = X9, Q9 = J9.Symbol, QM = Q9, AC = QM;
AC && AC.toStringTag;
var BC = QM;
BC && BC.toStringTag;
var IC;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(IC || (IC = {}));
var yy = function(e) {
  return Object.freeze(e);
}, eH = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, yy(this);
  }
  return e;
}(), tH = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, yy(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), FC = typeof window < "u" ? window : {};
/msie|trident/i.test(FC.navigator && FC.navigator.userAgent);
var qf = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new eH((n ? t : e) || 0, (n ? e : t) || 0);
};
yy({
  devicePixelContentBoxSize: qf(),
  borderBoxSize: qf(),
  contentBoxSize: qf(),
  contentRect: new tH(0, 0, 0, 0)
});
function bl(e) {
  "@babel/helpers - typeof";
  return bl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, bl(e);
}
function nH(e, t) {
  if (bl(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (bl(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function rH(e) {
  var t = nH(e, "string");
  return bl(t) === "symbol" ? t : String(t);
}
function Ua(e, t, n) {
  return t = rH(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var oH = /* @__PURE__ */ Ve(null), Gf, Yf;
parseInt(Oe.version.split(".")[0], 10);
var RC = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Kf = typeof navigator < "u" && /Android/.test(navigator.userAgent), ju = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), iH = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Gf = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Gf !== void 0 && Gf[1] && parseInt((Yf = navigator.userAgent.match(/Version\/(\d+)/)) === null || Yf === void 0 ? void 0 : Yf[1], 10) < 17;
var sH = /* @__PURE__ */ new WeakMap(), aH = /* @__PURE__ */ new WeakMap(), lH = /* @__PURE__ */ new WeakMap(), uH = /* @__PURE__ */ new WeakMap(), cH = /* @__PURE__ */ new WeakMap(), NC = /* @__PURE__ */ new WeakMap(), dH = /* @__PURE__ */ new WeakMap(), zC = /* @__PURE__ */ new WeakMap(), Au = /* @__PURE__ */ new WeakMap(), pH = /* @__PURE__ */ new WeakMap(), fH = /* @__PURE__ */ new WeakMap(), hH = /* @__PURE__ */ new WeakMap(), eT = globalThis.Node, gH = globalThis.Text, tT = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, mH = (e) => id(e) && e.nodeType === 8, ho = (e) => id(e) && e.nodeType === 1, id = (e) => {
  var t = tT(e);
  return !!t && e instanceof t.Node;
}, $C = (e) => {
  var t = e && e.anchorNode && tT(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, vH = (e) => {
  var [t, n] = e;
  if (ho(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = nT(t, o, r ? "backward" : "forward"), r = o < n; ho(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = bH(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, yH = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, nT = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (mH(o) || ho(o) && o.childNodes.length === 0 || ho(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, bH = (e, t, n) => {
  var [r] = nT(e, t, n);
  return r;
}, UC = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), rT = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ho(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Et.getWindow(e);
  if (o.contains(r))
    return Et.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : rT(e, i, n);
}, HC = (e, t) => !!(e.compareDocumentPosition(t) & eT.DOCUMENT_POSITION_PRECEDING), wH = (e, t) => !!(e.compareDocumentPosition(t) & eT.DOCUMENT_POSITION_FOLLOWING), CH = 0;
class EH {
  constructor() {
    Ua(this, "id", void 0), this.id = "".concat(CH++);
  }
}
var Et = {
  androidPendingDiffs: (e) => hH.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = fH.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Et.toDOMNode(e, e), n = Et.findDocumentOrShadowRoot(e);
    Au.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Et.findDocumentOrShadowRoot(e), r = UC(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && rd.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Et.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Et.toSlateNode(e, t.target), s = Et.findPath(e, i);
    if (To.isElement(i) && nn.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = nn.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? nn.before(e, u) : nn.after(e, u);
      if (c) {
        var d = nn.range(e, c);
        return d;
      }
    }
    var p, {
      document: g
    } = Et.getWindow(e);
    if (g.caretRangeFromPoint)
      p = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (p = g.createRange(), p.setStart(f.offsetNode, f.offset), p.setEnd(f.offsetNode, f.offset));
    }
    if (!p)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = Et.toSlateRange(e, p, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = NC.get(t);
    return n || (n = new EH(), NC.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = aH.get(r);
      if (o == null) {
        if (nn.isEditor(r))
          return n;
        break;
      }
      var i = sH.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Br.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Au.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Et.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Et.toDOMNode(e, e), r = Et.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = UC(r), i = Et.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || rd.select(e, nn.start(e, [])), Au.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = lH.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Et.toDOMNode(e, e), i;
    try {
      i = ho(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => id(t) && Et.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return nn.hasPath(e, n.path) && nn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Et.hasEditableTarget(e, t) || Et.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => id(t) && Et.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!pH.get(e),
  isFocused: (e) => !!Au.get(e),
  isReadOnly: (e) => !!zC.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (zC.get(e)) return !1;
    var n = Et.hasTarget(e, t) && Et.toSlateNode(e, t);
    return To.isElement(n) && nn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = dH.get(e), r = nn.isEditor(t) ? uH.get(e) : n == null ? void 0 : n.get(Et.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Br.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = nn.node(e, t.path), r = Et.toDOMNode(e, n), o;
    nn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: d
        } = c.textContent, p = u.getAttribute("data-slate-length"), g = p == null ? d : parseInt(p, 10), f = a + g, m = s[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var h, C = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            C instanceof gH ? C : m,
            (h = m.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(d, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Br.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = ft.isBackward(t), i = Et.toDOMPoint(e, n), s = ft.isCollapsed(t) ? i : Et.toDOMPoint(e, r), a = Et.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [d, p] = o ? i : s, g = ho(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = ho(d) ? d : d.parentElement, h = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(d, h ? 1 : p), l;
  },
  toSlateNode: (e, t) => {
    var n = ho(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? cH.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : vH(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var d, p, g = Et.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), C = h && g.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), P = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var E = Et.getWindow(e), v = E.document.createRange();
          v.setStart(u, 0), v.setEnd(s, a);
          var x = v.cloneContents(), L = [...Array.prototype.slice.call(x.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(x.querySelectorAll("[contenteditable=false]"))];
          L.forEach((S) => {
            if (Kf && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = x.textContent.length, P = u;
        }
      } else if (m) {
        for (var z = m.querySelectorAll("[data-slate-leaf]"), k = 0; k < z.length; k++) {
          var R = z[k];
          if (Et.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), P = w, c = P.textContent.length, P.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (C) {
        var A = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], U = C.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, N = [...A(U), ...A(U == null ? void 0 : U.nextElementSibling)];
          w = (V = N.find((S) => wH(C, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...A(U == null ? void 0 : U.previousElementSibling), ...A(U)];
          w = (Z = K.findLast((S) => HC(C, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), P = w, i === "forward" ? c = 0 : (c = P.textContent.length, P.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      P && c === P.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Kf && P.getAttribute("data-slate-zero-width") === "z" && (d = P.textContent) !== null && d !== void 0 && d.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      ju && (p = P.textContent) !== null && p !== void 0 && p.endsWith(`

`)) && c--;
    }
    if (Kf && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && Et.hasDOMNode(e, X, {
        editable: !0
      })) {
        var te = Et.toSlateNode(e, X), {
          path: ee,
          offset: D
        } = nn.start(e, Et.findPath(e, te));
        return X.querySelector("[data-slate-leaf]") || (D = a), {
          path: ee,
          offset: D
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var j = Et.toSlateNode(e, u), G = Et.findPath(e, j);
    return {
      path: G,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = $C(t) ? t.anchorNode : t.startContainer, a, l, u, c, d;
    if (s)
      if ($C(t)) {
        if (ju && t.rangeCount > 1) {
          u = t.focusNode;
          var p = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && p.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let x = function(L) {
              return L.childElementCount > 0 ? x(L.children[0]) : L;
            };
            var f = p.startContainer, m = g.startContainer, h = x(f.children[p.startOffset]), C = x(m.children[g.startOffset]);
            c = 0, C.childNodes.length > 0 ? a = C.childNodes[0] : a = C, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, C instanceof HTMLElement ? l = C.innerHTML.length : l = 0;
          } else
            p.startContainer === u ? (a = g.endContainer, l = g.endOffset, c = p.startOffset) : (a = p.startContainer, l = p.endOffset, c = g.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        iH && yH(a) || ju ? d = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : d = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, d = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    ju && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Et.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var P = HC(a, u) || a === u && c < l, E = d ? w : Et.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: P ? "forward" : "backward"
    });
    if (!E)
      return null;
    var v = {
      anchor: w,
      focus: E
    };
    return ft.isExpanded(v) && ft.isForward(v) && ho(u) && nn.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = nn.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, xH = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, OH = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, kH = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, En = (e) => {
  var t = xH[e], n = OH[e], r = kH[e], o = t && Zf(t), i = n && Zf(n), s = r && Zf(r);
  return (a) => !!(o && o(a) || RC && i && i(a) || !RC && s && s(a));
};
En("bold"), En("compose"), En("moveBackward"), En("moveForward"), En("deleteBackward"), En("deleteForward"), En("deleteLineBackward"), En("deleteLineForward"), En("deleteWordBackward"), En("deleteWordForward"), En("extendBackward"), En("extendForward"), En("extendLineBackward"), En("extendLineForward"), En("italic"), En("moveLineBackward"), En("moveLineForward"), En("moveWordBackward"), En("moveWordForward"), En("redo"), En("insertSoftBreak"), En("splitBlock"), En("transposeCharacter"), En("undo");
var _H = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => rT(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, LH = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class DH extends Kd {
  constructor() {
    super(...arguments), Ua(this, "context", null), Ua(this, "manager", null), Ua(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, LH);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = _H(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Ua(DH, "contextType", oH);
Ve({});
Ve({});
Ve({});
var Hn = {}, by = {}, jl = {}, Al = {}, oT = "Expected a function", WC = NaN, PH = "[object Symbol]", SH = /^\s+|\s+$/g, MH = /^[-+]0x[0-9a-f]+$/i, TH = /^0b[01]+$/i, jH = /^0o[0-7]+$/i, AH = parseInt, BH = typeof an == "object" && an && an.Object === Object && an, IH = typeof self == "object" && self && self.Object === Object && self, FH = BH || IH || Function("return this")(), RH = Object.prototype, NH = RH.toString, zH = Math.max, $H = Math.min, Xf = function() {
  return FH.Date.now();
};
function UH(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, d = !1, p = !0;
  if (typeof e != "function")
    throw new TypeError(oT);
  t = VC(t) || 0, sd(n) && (c = !!n.leading, d = "maxWait" in n, i = d ? zH(VC(n.maxWait) || 0, t) : i, p = "trailing" in n ? !!n.trailing : p);
  function g(x) {
    var L = r, z = o;
    return r = o = void 0, u = x, s = e.apply(z, L), s;
  }
  function f(x) {
    return u = x, a = setTimeout(C, t), c ? g(x) : s;
  }
  function m(x) {
    var L = x - l, z = x - u, k = t - L;
    return d ? $H(k, i - z) : k;
  }
  function h(x) {
    var L = x - l, z = x - u;
    return l === void 0 || L >= t || L < 0 || d && z >= i;
  }
  function C() {
    var x = Xf();
    if (h(x))
      return w(x);
    a = setTimeout(C, m(x));
  }
  function w(x) {
    return a = void 0, p && r ? g(x) : (r = o = void 0, s);
  }
  function P() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function E() {
    return a === void 0 ? s : w(Xf());
  }
  function v() {
    var x = Xf(), L = h(x);
    if (r = arguments, o = this, l = x, L) {
      if (a === void 0)
        return f(l);
      if (d)
        return a = setTimeout(C, t), g(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return v.cancel = P, v.flush = E, v;
}
function HH(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(oT);
  return sd(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), UH(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function sd(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function WH(e) {
  return !!e && typeof e == "object";
}
function VH(e) {
  return typeof e == "symbol" || WH(e) && NH.call(e) == PH;
}
function VC(e) {
  if (typeof e == "number")
    return e;
  if (VH(e))
    return WC;
  if (sd(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = sd(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(SH, "");
  var n = TH.test(e);
  return n || jH.test(e) ? AH(e.slice(2), n ? 2 : 8) : MH.test(e) ? WC : +e;
}
var ZH = HH, Bl = {};
Object.defineProperty(Bl, "__esModule", {
  value: !0
});
Bl.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Dc.has(t) || Dc.set(t, /* @__PURE__ */ new Set());
  var o = Dc.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Bl.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Dc.get(t).delete(n.name || t);
};
var Dc = /* @__PURE__ */ new Map();
Object.defineProperty(Al, "__esModule", {
  value: !0
});
var qH = ZH, GH = YH(qH), ZC = Bl;
function YH(e) {
  return e && e.__esModule ? e : { default: e };
}
var KH = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, GH.default)(e, t);
}, Tn = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = KH(function(r) {
        Tn.scrollHandler(e);
      }, t);
      return Tn.scrollSpyContainers.push(e), (0, ZC.addPassiveEventListener)(e, "scroll", n), function() {
        (0, ZC.removePassiveEventListener)(e, "scroll", n), Tn.scrollSpyContainers.splice(Tn.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return Tn.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Tn.scrollSpyContainers[Tn.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Tn.currentPositionX(e), Tn.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Tn.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Tn.scrollSpyContainers[Tn.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    Tn.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Tn.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Tn.spySetState && Tn.spySetState.length && Tn.spySetState.indexOf(e) > -1 && Tn.spySetState.splice(Tn.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Tn.scrollHandler);
  },
  update: function() {
    return Tn.scrollSpyContainers.forEach(function(e) {
      return Tn.scrollHandler(e);
    });
  }
};
Al.default = Tn;
var Ys = {}, Il = {};
Object.defineProperty(Il, "__esModule", {
  value: !0
});
var XH = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, JH = function() {
  return window.location.hash.replace(/^#/, "");
}, QH = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, eW = function(e) {
  return getComputedStyle(e).position !== "static";
}, Jf = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, tW = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (eW(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Jf(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return Jf(t, a).offsetTop - Jf(e, a).offsetTop;
};
Il.default = {
  updateHash: XH,
  getHash: JH,
  filterElementInContainer: QH,
  scrollOffset: tW
};
var Wp = {}, wy = {};
Object.defineProperty(wy, "__esModule", {
  value: !0
});
wy.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Cy = {};
Object.defineProperty(Cy, "__esModule", {
  value: !0
});
var nW = Bl, rW = ["mousedown", "wheel", "touchmove", "keydown"];
Cy.default = {
  subscribe: function(e) {
    return typeof document < "u" && rW.forEach(function(t) {
      return (0, nW.addPassiveEventListener)(document, t, e);
    });
  }
};
var Fl = {};
Object.defineProperty(Fl, "__esModule", {
  value: !0
});
var fm = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      fm.registered[e] = t;
    },
    remove: function(e) {
      fm.registered[e] = null;
    }
  }
};
Fl.default = fm;
Object.defineProperty(Wp, "__esModule", {
  value: !0
});
var oW = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, iW = Il;
Vp(iW);
var sW = wy, qC = Vp(sW), aW = Cy, lW = Vp(aW), uW = Fl, uo = Vp(uW);
function Vp(e) {
  return e && e.__esModule ? e : { default: e };
}
var iT = function(e) {
  return qC.default[e.smooth] || qC.default.defaultEasing;
}, cW = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, dW = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, hm = function() {
  return dW() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), sT = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, aT = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, lT = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, pW = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, fW = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, hW = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    uo.default.registered.end && uo.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    hm.call(window, i);
    return;
  }
  uo.default.registered.end && uo.default.registered.end(o.to, o.target, o.currentPosition);
}, Ey = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Rl = function(e, t, n, r) {
  t.data = t.data || sT(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (lW.default.subscribe(o), Ey(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? aT(t) : lT(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    uo.default.registered.end && uo.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = cW(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = iT(t), s = hW.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      uo.default.registered.begin && uo.default.registered.begin(t.data.to, t.data.target), hm.call(window, s);
    }, t.delay);
    return;
  }
  uo.default.registered.begin && uo.default.registered.begin(t.data.to, t.data.target), hm.call(window, s);
}, Zp = function(e) {
  return e = oW({}, e), e.data = e.data || sT(), e.absolute = !0, e;
}, gW = function(e) {
  Rl(0, Zp(e));
}, mW = function(e, t) {
  Rl(e, Zp(t));
}, vW = function(e) {
  e = Zp(e), Ey(e), Rl(e.horizontal ? pW(e) : fW(e), e);
}, yW = function(e, t) {
  t = Zp(t), Ey(t);
  var n = t.horizontal ? aT(t) : lT(t);
  Rl(e + n, t);
};
Wp.default = {
  animateTopScroll: Rl,
  getAnimationType: iT,
  scrollToTop: gW,
  scrollToBottom: vW,
  scrollTo: mW,
  scrollMore: yW
};
Object.defineProperty(Ys, "__esModule", {
  value: !0
});
var bW = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, wW = Il, CW = xy(wW), EW = Wp, xW = xy(EW), OW = Fl, Bu = xy(OW);
function xy(e) {
  return e && e.__esModule ? e : { default: e };
}
var Iu = {}, GC = void 0;
Ys.default = {
  unmount: function() {
    Iu = {};
  },
  register: function(e, t) {
    Iu[e] = t;
  },
  unregister: function(e) {
    delete Iu[e];
  },
  get: function(e) {
    return Iu[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return GC = e;
  },
  getActiveLink: function() {
    return GC;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = bW({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = CW.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      Bu.default.registered.begin && Bu.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, Bu.default.registered.end && Bu.default.registered.end(e, n);
      return;
    }
    xW.default.animateTopScroll(a, t, e, n);
  }
};
var gm = { exports: {} }, Qf = { exports: {} }, Wt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var YC;
function kW() {
  if (YC) return Wt;
  YC = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function P(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case d:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case a:
                case c:
                case f:
                case g:
                case s:
                  return v;
                default:
                  return x;
              }
          }
        case n:
          return x;
      }
    }
  }
  function E(v) {
    return P(v) === u;
  }
  return Wt.AsyncMode = l, Wt.ConcurrentMode = u, Wt.ContextConsumer = a, Wt.ContextProvider = s, Wt.Element = t, Wt.ForwardRef = c, Wt.Fragment = r, Wt.Lazy = f, Wt.Memo = g, Wt.Portal = n, Wt.Profiler = i, Wt.StrictMode = o, Wt.Suspense = d, Wt.isAsyncMode = function(v) {
    return E(v) || P(v) === l;
  }, Wt.isConcurrentMode = E, Wt.isContextConsumer = function(v) {
    return P(v) === a;
  }, Wt.isContextProvider = function(v) {
    return P(v) === s;
  }, Wt.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Wt.isForwardRef = function(v) {
    return P(v) === c;
  }, Wt.isFragment = function(v) {
    return P(v) === r;
  }, Wt.isLazy = function(v) {
    return P(v) === f;
  }, Wt.isMemo = function(v) {
    return P(v) === g;
  }, Wt.isPortal = function(v) {
    return P(v) === n;
  }, Wt.isProfiler = function(v) {
    return P(v) === i;
  }, Wt.isStrictMode = function(v) {
    return P(v) === o;
  }, Wt.isSuspense = function(v) {
    return P(v) === d;
  }, Wt.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === d || v === p || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === s || v.$$typeof === a || v.$$typeof === c || v.$$typeof === h || v.$$typeof === C || v.$$typeof === w || v.$$typeof === m);
  }, Wt.typeOf = P, Wt;
}
var Xt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var KC;
function _W() {
  return KC || (KC = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function P(H) {
      return typeof H == "string" || typeof H == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      H === r || H === u || H === i || H === o || H === d || H === p || typeof H == "object" && H !== null && (H.$$typeof === f || H.$$typeof === g || H.$$typeof === s || H.$$typeof === a || H.$$typeof === c || H.$$typeof === h || H.$$typeof === C || H.$$typeof === w || H.$$typeof === m);
    }
    function E(H) {
      if (typeof H == "object" && H !== null) {
        var ce = H.$$typeof;
        switch (ce) {
          case t:
            var ye = H.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case d:
                return ye;
              default:
                var ie = ye && ye.$$typeof;
                switch (ie) {
                  case a:
                  case c:
                  case f:
                  case g:
                  case s:
                    return ie;
                  default:
                    return ce;
                }
            }
          case n:
            return ce;
        }
      }
    }
    var v = l, x = u, L = a, z = s, k = t, R = c, A = r, U = f, V = g, N = n, Z = i, K = o, X = d, te = !1;
    function ee(H) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), D(H) || E(H) === l;
    }
    function D(H) {
      return E(H) === u;
    }
    function j(H) {
      return E(H) === a;
    }
    function G(H) {
      return E(H) === s;
    }
    function S(H) {
      return typeof H == "object" && H !== null && H.$$typeof === t;
    }
    function Y(H) {
      return E(H) === c;
    }
    function O(H) {
      return E(H) === r;
    }
    function M(H) {
      return E(H) === f;
    }
    function W(H) {
      return E(H) === g;
    }
    function T(H) {
      return E(H) === n;
    }
    function q(H) {
      return E(H) === i;
    }
    function I(H) {
      return E(H) === o;
    }
    function J(H) {
      return E(H) === d;
    }
    Xt.AsyncMode = v, Xt.ConcurrentMode = x, Xt.ContextConsumer = L, Xt.ContextProvider = z, Xt.Element = k, Xt.ForwardRef = R, Xt.Fragment = A, Xt.Lazy = U, Xt.Memo = V, Xt.Portal = N, Xt.Profiler = Z, Xt.StrictMode = K, Xt.Suspense = X, Xt.isAsyncMode = ee, Xt.isConcurrentMode = D, Xt.isContextConsumer = j, Xt.isContextProvider = G, Xt.isElement = S, Xt.isForwardRef = Y, Xt.isFragment = O, Xt.isLazy = M, Xt.isMemo = W, Xt.isPortal = T, Xt.isProfiler = q, Xt.isStrictMode = I, Xt.isSuspense = J, Xt.isValidElementType = P, Xt.typeOf = E;
  }()), Xt;
}
var XC;
function uT() {
  return XC || (XC = 1, process.env.NODE_ENV === "production" ? Qf.exports = kW() : Qf.exports = _W()), Qf.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var eh, JC;
function LW() {
  if (JC) return eh;
  JC = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return eh = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var d in a)
        t.call(a, d) && (l[d] = a[d]);
      if (e) {
        u = e(a);
        for (var p = 0; p < u.length; p++)
          n.call(a, u[p]) && (l[u[p]] = a[u[p]]);
      }
    }
    return l;
  }, eh;
}
var th, QC;
function Oy() {
  if (QC) return th;
  QC = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return th = e, th;
}
var eE, tE;
function cT() {
  return tE || (tE = 1, eE = Function.call.bind(Object.prototype.hasOwnProperty)), eE;
}
var nh, nE;
function DW() {
  if (nE) return nh;
  nE = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Oy(), n = {}, r = cT();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var d;
          try {
            if (typeof i[c] != "function") {
              var p = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            d = i[c](s, c, l, a, null, t);
          } catch (f) {
            d = f;
          }
          if (d && !(d instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in n)) {
            n[d.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + a + " type: " + d.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, nh = o, nh;
}
var rh, rE;
function PW() {
  if (rE) return rh;
  rE = 1;
  var e = uT(), t = LW(), n = Oy(), r = cT(), o = DW(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return rh = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function d(D) {
      var j = D && (u && D[u] || D[c]);
      if (typeof j == "function")
        return j;
    }
    var p = "<<anonymous>>", g = {
      array: C("array"),
      bigint: C("bigint"),
      bool: C("boolean"),
      func: C("function"),
      number: C("number"),
      object: C("object"),
      string: C("string"),
      symbol: C("symbol"),
      any: w(),
      arrayOf: P,
      element: E(),
      elementType: v(),
      instanceOf: x,
      node: R(),
      objectOf: z,
      oneOf: L,
      oneOfType: k,
      shape: U,
      exact: V
    };
    function f(D, j) {
      return D === j ? D !== 0 || 1 / D === 1 / j : D !== D && j !== j;
    }
    function m(D, j) {
      this.message = D, this.data = j && typeof j == "object" ? j : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function h(D) {
      if (process.env.NODE_ENV !== "production")
        var j = {}, G = 0;
      function S(O, M, W, T, q, I, J) {
        if (T = T || p, I = I || W, J !== n) {
          if (l) {
            var H = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw H.name = "Invariant Violation", H;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ce = T + ":" + W;
            !j[ce] && // Avoid spamming the console because they are often not actionable except for lib authors
            G < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + I + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), j[ce] = !0, G++);
          }
        }
        return M[W] == null ? O ? M[W] === null ? new m("The " + q + " `" + I + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + I + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : D(M, W, T, q, I);
      }
      var Y = S.bind(null, !1);
      return Y.isRequired = S.bind(null, !0), Y;
    }
    function C(D) {
      function j(G, S, Y, O, M, W) {
        var T = G[S], q = K(T);
        if (q !== D) {
          var I = X(T);
          return new m(
            "Invalid " + O + " `" + M + "` of type " + ("`" + I + "` supplied to `" + Y + "`, expected ") + ("`" + D + "`."),
            { expectedType: D }
          );
        }
        return null;
      }
      return h(j);
    }
    function w() {
      return h(s);
    }
    function P(D) {
      function j(G, S, Y, O, M) {
        if (typeof D != "function")
          return new m("Property `" + M + "` of component `" + Y + "` has invalid PropType notation inside arrayOf.");
        var W = G[S];
        if (!Array.isArray(W)) {
          var T = K(W);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + T + "` supplied to `" + Y + "`, expected an array."));
        }
        for (var q = 0; q < W.length; q++) {
          var I = D(W, q, Y, O, M + "[" + q + "]", n);
          if (I instanceof Error)
            return I;
        }
        return null;
      }
      return h(j);
    }
    function E() {
      function D(j, G, S, Y, O) {
        var M = j[G];
        if (!a(M)) {
          var W = K(M);
          return new m("Invalid " + Y + " `" + O + "` of type " + ("`" + W + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(D);
    }
    function v() {
      function D(j, G, S, Y, O) {
        var M = j[G];
        if (!e.isValidElementType(M)) {
          var W = K(M);
          return new m("Invalid " + Y + " `" + O + "` of type " + ("`" + W + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(D);
    }
    function x(D) {
      function j(G, S, Y, O, M) {
        if (!(G[S] instanceof D)) {
          var W = D.name || p, T = ee(G[S]);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + T + "` supplied to `" + Y + "`, expected ") + ("instance of `" + W + "`."));
        }
        return null;
      }
      return h(j);
    }
    function L(D) {
      if (!Array.isArray(D))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function j(G, S, Y, O, M) {
        for (var W = G[S], T = 0; T < D.length; T++)
          if (f(W, D[T]))
            return null;
        var q = JSON.stringify(D, function(I, J) {
          var H = X(J);
          return H === "symbol" ? String(J) : J;
        });
        return new m("Invalid " + O + " `" + M + "` of value `" + String(W) + "` " + ("supplied to `" + Y + "`, expected one of " + q + "."));
      }
      return h(j);
    }
    function z(D) {
      function j(G, S, Y, O, M) {
        if (typeof D != "function")
          return new m("Property `" + M + "` of component `" + Y + "` has invalid PropType notation inside objectOf.");
        var W = G[S], T = K(W);
        if (T !== "object")
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + T + "` supplied to `" + Y + "`, expected an object."));
        for (var q in W)
          if (r(W, q)) {
            var I = D(W, q, Y, O, M + "." + q, n);
            if (I instanceof Error)
              return I;
          }
        return null;
      }
      return h(j);
    }
    function k(D) {
      if (!Array.isArray(D))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var j = 0; j < D.length; j++) {
        var G = D[j];
        if (typeof G != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(G) + " at index " + j + "."
          ), s;
      }
      function S(Y, O, M, W, T) {
        for (var q = [], I = 0; I < D.length; I++) {
          var J = D[I], H = J(Y, O, M, W, T, n);
          if (H == null)
            return null;
          H.data && r(H.data, "expectedType") && q.push(H.data.expectedType);
        }
        var ce = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + W + " `" + T + "` supplied to " + ("`" + M + "`" + ce + "."));
      }
      return h(S);
    }
    function R() {
      function D(j, G, S, Y, O) {
        return N(j[G]) ? null : new m("Invalid " + Y + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return h(D);
    }
    function A(D, j, G, S, Y) {
      return new m(
        (D || "React class") + ": " + j + " type `" + G + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Y + "`."
      );
    }
    function U(D) {
      function j(G, S, Y, O, M) {
        var W = G[S], T = K(W);
        if (T !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + T + "` " + ("supplied to `" + Y + "`, expected `object`."));
        for (var q in D) {
          var I = D[q];
          if (typeof I != "function")
            return A(Y, O, M, q, X(I));
          var J = I(W, q, Y, O, M + "." + q, n);
          if (J)
            return J;
        }
        return null;
      }
      return h(j);
    }
    function V(D) {
      function j(G, S, Y, O, M) {
        var W = G[S], T = K(W);
        if (T !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + T + "` " + ("supplied to `" + Y + "`, expected `object`."));
        var q = t({}, G[S], D);
        for (var I in q) {
          var J = D[I];
          if (r(D, I) && typeof J != "function")
            return A(Y, O, M, I, X(J));
          if (!J)
            return new m(
              "Invalid " + O + " `" + M + "` key `" + I + "` supplied to `" + Y + "`.\nBad object: " + JSON.stringify(G[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(D), null, "  ")
            );
          var H = J(W, I, Y, O, M + "." + I, n);
          if (H)
            return H;
        }
        return null;
      }
      return h(j);
    }
    function N(D) {
      switch (typeof D) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !D;
        case "object":
          if (Array.isArray(D))
            return D.every(N);
          if (D === null || a(D))
            return !0;
          var j = d(D);
          if (j) {
            var G = j.call(D), S;
            if (j !== D.entries) {
              for (; !(S = G.next()).done; )
                if (!N(S.value))
                  return !1;
            } else
              for (; !(S = G.next()).done; ) {
                var Y = S.value;
                if (Y && !N(Y[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(D, j) {
      return D === "symbol" ? !0 : j ? j["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && j instanceof Symbol : !1;
    }
    function K(D) {
      var j = typeof D;
      return Array.isArray(D) ? "array" : D instanceof RegExp ? "object" : Z(j, D) ? "symbol" : j;
    }
    function X(D) {
      if (typeof D > "u" || D === null)
        return "" + D;
      var j = K(D);
      if (j === "object") {
        if (D instanceof Date)
          return "date";
        if (D instanceof RegExp)
          return "regexp";
      }
      return j;
    }
    function te(D) {
      var j = X(D);
      switch (j) {
        case "array":
        case "object":
          return "an " + j;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + j;
        default:
          return j;
      }
    }
    function ee(D) {
      return !D.constructor || !D.constructor.name ? p : D.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, rh;
}
var oh, oE;
function SW() {
  if (oE) return oh;
  oE = 1;
  var e = Oy();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, oh = function() {
    function r(s, a, l, u, c, d) {
      if (d !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, oh;
}
if (process.env.NODE_ENV !== "production") {
  var MW = uT(), TW = !0;
  gm.exports = PW()(MW.isElement, TW);
} else
  gm.exports = SW()();
var qp = gm.exports, Gp = {};
Object.defineProperty(Gp, "__esModule", {
  value: !0
});
var jW = Il, ih = AW(jW);
function AW(e) {
  return e && e.__esModule ? e : { default: e };
}
var BW = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return ih.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && ih.default.getHash() !== e && ih.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Gp.default = BW;
Object.defineProperty(jl, "__esModule", {
  value: !0
});
var Fu = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, IW = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), FW = Oe, iE = Nl(FW), RW = Al, Ru = Nl(RW), NW = Ys, zW = Nl(NW), $W = qp, xn = Nl($W), UW = Gp, Ho = Nl(UW);
function Nl(e) {
  return e && e.__esModule ? e : { default: e };
}
function HW(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function WW(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function VW(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var sE = {
  to: xn.default.string.isRequired,
  containerId: xn.default.string,
  container: xn.default.object,
  activeClass: xn.default.string,
  activeStyle: xn.default.object,
  spy: xn.default.bool,
  horizontal: xn.default.bool,
  smooth: xn.default.oneOfType([xn.default.bool, xn.default.string]),
  offset: xn.default.number,
  delay: xn.default.number,
  isDynamic: xn.default.bool,
  onClick: xn.default.func,
  duration: xn.default.oneOfType([xn.default.number, xn.default.func]),
  absolute: xn.default.bool,
  onSetActive: xn.default.func,
  onSetInactive: xn.default.func,
  ignoreCancelEvents: xn.default.bool,
  hashSpy: xn.default.bool,
  saveHashHistory: xn.default.bool,
  spyThrottle: xn.default.number
};
jl.default = function(e, t) {
  var n = t || zW.default, r = function(i) {
    VW(s, i);
    function s(a) {
      HW(this, s);
      var l = WW(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return IW(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          if (!Ru.default.isMounted(a)) {
            var l = Ru.default.mount(a, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (Ho.default.isMounted() || Ho.default.mount(n), Ho.default.mapContainer(this.props.to, a)), Ru.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Ru.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(a) {
          return a();
        });
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Fu({}, this.props.style, this.props.activeStyle) : l = Fu({}, this.props.style);
        var u = Fu({}, this.props);
        for (var c in sE)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, iE.default.createElement(e, u);
      }
    }]), s;
  }(iE.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, Fu({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(Ho.default.isMounted() && !Ho.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, d = null, p = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, h = 0;
          if (l.getBoundingClientRect) {
            var C = l.getBoundingClientRect();
            h = C.left;
          }
          if (!d || i.props.isDynamic) {
            if (d = n.get(c), !d)
              return;
            var w = d.getBoundingClientRect();
            f = w.left - h + s, m = f + w.width;
          }
          var P = s - i.props.offset;
          p = P >= Math.floor(f) && P < Math.floor(m), g = P < Math.floor(f) || P >= Math.floor(m);
        } else {
          var E = 0, v = 0, x = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            x = L.top;
          }
          if (!d || i.props.isDynamic) {
            if (d = n.get(c), !d)
              return;
            var z = d.getBoundingClientRect();
            E = z.top - x + a, v = E + z.height;
          }
          var k = a - i.props.offset;
          p = k >= Math.floor(E) && k < Math.floor(v), g = k < Math.floor(E) || k >= Math.floor(v);
        }
        var R = n.getActiveLink();
        if (g) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && Ho.default.getHash() === c) {
            var A = i.props.saveHashHistory, U = A === void 0 ? !1 : A;
            Ho.default.changeHash("", U);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, d));
        }
        if (p && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, N = V === void 0 ? !1 : V;
          i.props.hashSpy && Ho.default.changeHash(c, N), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, d));
        }
      }
    };
  };
  return r.propTypes = sE, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(by, "__esModule", {
  value: !0
});
var ZW = Oe, aE = dT(ZW), qW = jl, GW = dT(qW);
function dT(e) {
  return e && e.__esModule ? e : { default: e };
}
function YW(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lE(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function KW(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var XW = function(e) {
  KW(t, e);
  function t() {
    var n, r, o, i;
    YW(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = lE(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return aE.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), lE(o, i);
  }
  return t;
}(aE.default.Component);
by.default = (0, GW.default)(XW);
var ky = {};
Object.defineProperty(ky, "__esModule", {
  value: !0
});
var JW = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), QW = Oe, uE = pT(QW), e8 = jl, t8 = pT(e8);
function pT(e) {
  return e && e.__esModule ? e : { default: e };
}
function n8(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function r8(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function o8(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var i8 = function(e) {
  o8(t, e);
  function t() {
    return n8(this, t), r8(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return JW(t, [{
    key: "render",
    value: function() {
      return uE.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(uE.default.Component);
ky.default = (0, t8.default)(i8);
var _y = {}, Yp = {};
Object.defineProperty(Yp, "__esModule", {
  value: !0
});
var s8 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, a8 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), l8 = Oe, cE = Kp(l8), u8 = Tl;
Kp(u8);
var c8 = Ys, dE = Kp(c8), d8 = qp, pE = Kp(d8);
function Kp(e) {
  return e && e.__esModule ? e : { default: e };
}
function p8(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function f8(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function h8(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Yp.default = function(e) {
  var t = function(n) {
    h8(r, n);
    function r(o) {
      p8(this, r);
      var i = f8(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return a8(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        dE.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        dE.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return cE.default.createElement(e, s8({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(cE.default.Component);
  return t.propTypes = {
    name: pE.default.string,
    id: pE.default.string
  }, t;
};
Object.defineProperty(_y, "__esModule", {
  value: !0
});
var fE = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, g8 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), m8 = Oe, hE = Ly(m8), v8 = Yp, y8 = Ly(v8), b8 = qp, gE = Ly(b8);
function Ly(e) {
  return e && e.__esModule ? e : { default: e };
}
function w8(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function C8(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function E8(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var fT = function(e) {
  E8(t, e);
  function t() {
    return w8(this, t), C8(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return g8(t, [{
    key: "render",
    value: function() {
      var n = this, r = fE({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, hE.default.createElement(
        "div",
        fE({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(hE.default.Component);
fT.propTypes = {
  name: gE.default.string,
  id: gE.default.string
};
_y.default = (0, y8.default)(fT);
var sh = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, mE = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function vE(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function yE(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function bE(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Nu = Oe, Ri = Al, ah = Ys, In = qp, Wo = Gp, wE = {
  to: In.string.isRequired,
  containerId: In.string,
  container: In.object,
  activeClass: In.string,
  spy: In.bool,
  smooth: In.oneOfType([In.bool, In.string]),
  offset: In.number,
  delay: In.number,
  isDynamic: In.bool,
  onClick: In.func,
  duration: In.oneOfType([In.number, In.func]),
  absolute: In.bool,
  onSetActive: In.func,
  onSetInactive: In.func,
  ignoreCancelEvents: In.bool,
  hashSpy: In.bool,
  spyThrottle: In.number
}, x8 = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || ah, r = function(i) {
      bE(s, i);
      function s(a) {
        vE(this, s);
        var l = yE(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return mE(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            Ri.isMounted(a) || Ri.mount(a, this.props.spyThrottle), this.props.hashSpy && (Wo.isMounted() || Wo.mount(n), Wo.mapContainer(this.props.to, a)), this.props.spy && Ri.addStateHandler(this.stateHandler), Ri.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Ri.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = sh({}, this.props);
          for (var u in wE)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, Nu.createElement(e, l);
        }
      }]), s;
    }(Nu.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, sh({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(Wo.isMounted() && !Wo.isInitialized())) {
          var l = i.props.to, u = null, c = 0, d = 0, p = 0;
          if (a.getBoundingClientRect) {
            var g = a.getBoundingClientRect();
            p = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - p + s, d = c + f.height;
          }
          var m = s - i.props.offset, h = m >= Math.floor(c) && m < Math.floor(d), C = m < Math.floor(c) || m >= Math.floor(d), w = n.getActiveLink();
          if (C)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Wo.getHash() === l && Wo.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Ri.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Wo.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Ri.updateStates();
        }
      };
    };
    return r.propTypes = wE, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      bE(r, n);
      function r(o) {
        vE(this, r);
        var i = yE(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return mE(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          ah.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          ah.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Nu.createElement(e, sh({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Nu.Component);
    return t.propTypes = {
      name: In.string,
      id: In.string
    }, t;
  }
}, O8 = x8;
Object.defineProperty(Hn, "__esModule", {
  value: !0
});
Hn.Helpers = Hn.ScrollElement = Hn.ScrollLink = Hn.animateScroll = Hn.scrollSpy = Hn.Events = Hn.scroller = Hn.Element = Hn.Button = Hn.Link = void 0;
var k8 = by, hT = yo(k8), _8 = ky, gT = yo(_8), L8 = _y, mT = yo(L8), D8 = Ys, vT = yo(D8), P8 = Fl, yT = yo(P8), S8 = Al, bT = yo(S8), M8 = Wp, wT = yo(M8), T8 = jl, CT = yo(T8), j8 = Yp, ET = yo(j8), A8 = O8, xT = yo(A8);
function yo(e) {
  return e && e.__esModule ? e : { default: e };
}
Hn.Link = hT.default;
Hn.Button = gT.default;
Hn.Element = mT.default;
Hn.scroller = vT.default;
Hn.Events = yT.default;
Hn.scrollSpy = bT.default;
Hn.animateScroll = wT.default;
Hn.ScrollLink = CT.default;
Hn.ScrollElement = ET.default;
Hn.Helpers = xT.default;
Hn.default = { Link: hT.default, Button: gT.default, Element: mT.default, scroller: vT.default, Events: yT.default, scrollSpy: bT.default, animateScroll: wT.default, ScrollLink: CT.default, ScrollElement: ET.default, Helpers: xT.default };
Ve({});
Ve({});
Ve({});
function wl(e) {
  "@babel/helpers - typeof";
  return wl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, wl(e);
}
function B8(e, t) {
  if (wl(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (wl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function I8(e) {
  var t = B8(e, "string");
  return wl(t) == "symbol" ? t : t + "";
}
function pe(e, t, n) {
  return (t = I8(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function OT(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var lh, CE;
function F8() {
  if (CE) return lh;
  CE = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, s, a, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [o, i, s, a, l, u], p = 0;
        c = new Error(r.replace(/%s/g, function() {
          return d[p++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return lh = t, lh;
}
var R8 = F8(), Kn = /* @__PURE__ */ OT(R8), it = Ve(null);
function N8() {
  Kn(!!_e, "useGoogleMap is React hook and requires React version 16.8+");
  var e = _e(it);
  return Kn(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function z8(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function $8(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function U8(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return $8(e, i), o;
}
function H8(e, t, n) {
  var r = z8(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function W8(e) {
  google.maps.event.removeListener(e);
}
function Mt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(W8);
}
function kt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = H8(o, i, n);
  return U8(t, r, o, i), s;
}
function V8(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: d,
    onMouseMove: p,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: h,
    onRightClick: C,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: P,
    onUnmount: E
  } = e, [v, x] = _(null), L = Ye(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null), [T, q] = _(null), [I, J] = _(null);
  return y(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), y(() => {
    v !== null && typeof s < "u" && v.setCenter(s);
  }, [v, s]), y(() => {
    v && l && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), y(() => {
    v && c && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), y(() => {
    v && d && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(v, "dragstart", d)));
  }, [d]), y(() => {
    v && m && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", m)));
  }, [m]), y(() => {
    v && p && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(v, "mousemove", p)));
  }, [p]), y(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), y(() => {
    v && f && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), y(() => {
    v && h && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(v, "mouseup", h)));
  }, [h]), y(() => {
    v && C && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(v, "rightclick", C)));
  }, [C]), y(() => {
    v && a && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", a)));
  }, [a]), y(() => {
    v && u && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(v, "drag", u)));
  }, [u]), y(() => {
    v && w && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(v, "center_changed", w)));
  }, [a]), y(() => {
    var H = L.current === null ? null : new google.maps.Map(L.current, n);
    return x(H), H !== null && P && P(H), () => {
      H !== null && E && E(H);
    };
  }, []), rr.jsx("div", {
    id: r,
    ref: L,
    style: o,
    className: i,
    children: rr.jsx(it.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
De(V8);
function EE(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function kT(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        EE(i, r, o, s, a, "next", l);
      }
      function a(l) {
        EE(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function _T(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Kn(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var ns = typeof document < "u";
function LT(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return ns ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(p) {
          c && c(p), i(p);
        };
        return;
      } else
        s.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(p) {
      d.setAttribute("data-state", "error"), i(p);
    }, a.initMap = function() {
      d.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function xE(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function DT() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return xE(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return xE(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var pa = !1;
function PT() {
  return rr.jsx("div", {
    children: "Loading..."
  });
}
var mm = {
  id: "script-loader",
  version: "weekly"
};
class Z8 extends Ee {
  constructor() {
    super(...arguments), pe(this, "check", null), pe(this, "state", {
      loaded: !1
    }), pe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), pe(this, "isCleaningUp", /* @__PURE__ */ kT(function* () {
      function t(n) {
        if (!pa)
          n();
        else if (ns)
          var r = window.setInterval(function() {
            pa || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), pe(this, "cleanup", () => {
      pa = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), pe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && DT(), Kn(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: _T(this.props)
      };
      LT(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), pe(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (ns) {
      if (window.google && window.google.maps && !pa) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), ns && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (ns) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, pa = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return rr.jsxs(rr.Fragment, {
      children: [rr.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || rr.jsx(PT, {})]
    });
  }
}
pe(Z8, "defaultProps", mm);
function q8(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function Dy(e, t) {
  if (e == null) return {};
  var n, r, o = q8(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var OE;
function G8(e) {
  var {
    id: t = mm.id,
    version: n = mm.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: d,
    authReferrerPolicy: p
  } = e, g = Ye(!1), [f, m] = _(!1), [h, C] = _(void 0);
  y(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), y(function() {
    ns && u && DT();
  }, [u]), y(function() {
    f && Kn(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = _T({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: d,
    authReferrerPolicy: p
  });
  y(function() {
    if (!ns)
      return;
    function E() {
      g.current && (m(!0), OE = w);
    }
    if (window.google && window.google.maps && OE === w) {
      E();
      return;
    }
    LT({
      id: t,
      url: w,
      nonce: r
    }).then(E).catch(function(v) {
      g.current && C(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var P = Ye(void 0);
  return y(function() {
    P.current && l !== P.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), P.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var Y8 = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], K8 = rr.jsx(PT, {});
function X8(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = Dy(e, Y8), {
    isLoaded: a,
    loadError: l
  } = G8(s);
  return y(function() {
    a && typeof n == "function" && n();
  }, [a, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || K8;
}
De(X8);
var kE;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(kE || (kE = {}));
function _E(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ad(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _E(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _E(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var LE = {}, DE = {
  options(e, t) {
    e.setOptions(t);
  }
};
function J8(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = _e(it), [i, s] = _(null);
  return y(() => {
    i !== null && i.setMap(o);
  }, [o]), y(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), y(() => {
    var a = new google.maps.TrafficLayer(ad(ad({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
De(J8);
class Q8 extends Ee {
  constructor() {
    super(...arguments), pe(this, "state", {
      trafficLayer: null
    }), pe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), pe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(ad(ad({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: DE,
      eventMap: LE,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: DE,
      eventMap: LE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Mt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
pe(Q8, "contextType", it);
function eV(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = _e(it), [o, i] = _(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
De(eV);
class tV extends Ee {
  constructor() {
    super(...arguments), pe(this, "state", {
      bicyclingLayer: null
    }), pe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
pe(tV, "contextType", it);
function nV(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = _e(it), [o, i] = _(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
De(nV);
class rV extends Ee {
  constructor() {
    super(...arguments), pe(this, "state", {
      transitLayer: null
    }), pe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
pe(rV, "contextType", it);
function PE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ld(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PE(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var SE = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, ME = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function oV(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, d = _e(it), [p, g] = _(null), [f, m] = _(null), [h, C] = _(null), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null);
  return y(() => {
    p !== null && p.setMap(d);
  }, [d]), y(() => {
    t && p !== null && p.setOptions(t);
  }, [p, t]), y(() => {
    p !== null && p.setDrawingMode(n ?? null);
  }, [p, n]), y(() => {
    p && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(p, "circlecomplete", r)));
  }, [p, r]), y(() => {
    p && o && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(p, "markercomplete", o)));
  }, [p, o]), y(() => {
    p && i && (w !== null && google.maps.event.removeListener(w), P(google.maps.event.addListener(p, "overlaycomplete", i)));
  }, [p, i]), y(() => {
    p && s && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(p, "polygoncomplete", s)));
  }, [p, s]), y(() => {
    p && a && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(p, "polylinecomplete", a)));
  }, [p, a]), y(() => {
    p && l && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(p, "rectanglecomplete", l)));
  }, [p, l]), y(() => {
    Kn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(ld(ld({}, t), {}, {
      map: d
    }));
    return n && R.setDrawingMode(n), r && m(google.maps.event.addListener(R, "circlecomplete", r)), o && C(google.maps.event.addListener(R, "markercomplete", o)), i && P(google.maps.event.addListener(R, "overlaycomplete", i)), s && v(google.maps.event.addListener(R, "polygoncomplete", s)), a && L(google.maps.event.addListener(R, "polylinecomplete", a)), l && k(google.maps.event.addListener(R, "rectanglecomplete", l)), g(R), u && u(R), () => {
      p !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), E && google.maps.event.removeListener(E), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), c && c(p), p.setMap(null));
    };
  }, []), null;
}
De(oV);
class iV extends Ee {
  constructor(t) {
    super(t), pe(this, "registeredEvents", []), pe(this, "state", {
      drawingManager: null
    }), pe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Kn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(ld(ld({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: ME,
      eventMap: SE,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: ME,
      eventMap: SE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Mt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
pe(iV, "contextType", it);
function TE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function js(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TE(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jE = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, AE = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, ud = {};
function sV(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: d,
    label: p,
    opacity: g,
    shape: f,
    title: m,
    zIndex: h,
    onClick: C,
    onDblClick: w,
    onDrag: P,
    onDragEnd: E,
    onDragStart: v,
    onMouseOut: x,
    onMouseOver: L,
    onMouseUp: z,
    onMouseDown: k,
    onRightClick: R,
    onClickableChanged: A,
    onCursorChanged: U,
    onAnimationChanged: V,
    onDraggableChanged: N,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: D,
    onZindexChanged: j,
    onLoad: G,
    onUnmount: S
  } = e, Y = _e(it), [O, M] = _(null), [W, T] = _(null), [q, I] = _(null), [J, H] = _(null), [ce, ye] = _(null), [ie, Te] = _(null), [Re, Ne] = _(null), [Ie, Ke] = _(null), [Ze, Se] = _(null), [qe, rt] = _(null), [Pe, Me] = _(null), [Ge, He] = _(null), [$e, ot] = _(null), [Fe, Kt] = _(null), [lt, ht] = _(null), [Dt, ln] = _(null), [Pt, St] = _(null), [ut, Xe] = _(null), [un, cn] = _(null), [Nt, Gn] = _(null), [zt, Yn] = _(null), [$t, Sn] = _(null);
  y(() => {
    O !== null && O.setMap(Y);
  }, [Y]), y(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), y(() => {
    typeof s < "u" && O !== null && O.setDraggable(s);
  }, [O, s]), y(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), y(() => {
    typeof a < "u" && O !== null && O.setVisible(a);
  }, [O, a]), y(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), y(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), y(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), y(() => {
    O && d !== void 0 && O.setIcon(d);
  }, [O, d]), y(() => {
    O && p !== void 0 && O.setLabel(p);
  }, [O, p]), y(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), y(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), y(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), y(() => {
    O && h !== void 0 && O.setZIndex(h);
  }, [O, h]), y(() => {
    O && w && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), y(() => {
    O && E && (q !== null && google.maps.event.removeListener(q), I(google.maps.event.addListener(O, "dragend", E)));
  }, [E]), y(() => {
    O && v && (J !== null && google.maps.event.removeListener(J), H(google.maps.event.addListener(O, "dragstart", v)));
  }, [v]), y(() => {
    O && k && (ce !== null && google.maps.event.removeListener(ce), ye(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), y(() => {
    O && x && (ie !== null && google.maps.event.removeListener(ie), Te(google.maps.event.addListener(O, "mouseout", x)));
  }, [x]), y(() => {
    O && L && (Re !== null && google.maps.event.removeListener(Re), Ne(google.maps.event.addListener(O, "mouseover", L)));
  }, [L]), y(() => {
    O && z && (Ie !== null && google.maps.event.removeListener(Ie), Ke(google.maps.event.addListener(O, "mouseup", z)));
  }, [z]), y(() => {
    O && R && (Ze !== null && google.maps.event.removeListener(Ze), Se(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), y(() => {
    O && C && (qe !== null && google.maps.event.removeListener(qe), rt(google.maps.event.addListener(O, "click", C)));
  }, [C]), y(() => {
    O && P && (Pe !== null && google.maps.event.removeListener(Pe), Me(google.maps.event.addListener(O, "drag", P)));
  }, [P]), y(() => {
    O && A && (Ge !== null && google.maps.event.removeListener(Ge), He(google.maps.event.addListener(O, "clickable_changed", A)));
  }, [A]), y(() => {
    O && U && ($e !== null && google.maps.event.removeListener($e), ot(google.maps.event.addListener(O, "cursor_changed", U)));
  }, [U]), y(() => {
    O && V && (Fe !== null && google.maps.event.removeListener(Fe), Kt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), y(() => {
    O && N && (lt !== null && google.maps.event.removeListener(lt), ht(google.maps.event.addListener(O, "draggable_changed", N)));
  }, [N]), y(() => {
    O && Z && (Dt !== null && google.maps.event.removeListener(Dt), ln(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), y(() => {
    O && K && (Pt !== null && google.maps.event.removeListener(Pt), St(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), y(() => {
    O && X && (ut !== null && google.maps.event.removeListener(ut), Xe(google.maps.event.addListener(O, "position_changed", X)));
  }, [X]), y(() => {
    O && te && (un !== null && google.maps.event.removeListener(un), cn(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), y(() => {
    O && ee && (Nt !== null && google.maps.event.removeListener(Nt), Gn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), y(() => {
    O && D && (zt !== null && google.maps.event.removeListener(zt), Yn(google.maps.event.addListener(O, "visible_changed", D)));
  }, [D]), y(() => {
    O && j && ($t !== null && google.maps.event.removeListener($t), Sn(google.maps.event.addListener(O, "zindex_changed", j)));
  }, [j]), y(() => {
    var Ut = js(js(js({}, n || ud), r ? ud : {
      map: Y
    }), {}, {
      position: t
    }), oe = new google.maps.Marker(Ut);
    return r ? r.addMarker(oe, !!o) : oe.setMap(Y), t && oe.setPosition(t), typeof a < "u" && oe.setVisible(a), typeof s < "u" && oe.setDraggable(s), typeof u < "u" && oe.setClickable(u), typeof c == "string" && oe.setCursor(c), d && oe.setIcon(d), typeof p < "u" && oe.setLabel(p), typeof g < "u" && oe.setOpacity(g), f && oe.setShape(f), typeof m == "string" && oe.setTitle(m), typeof h == "number" && oe.setZIndex(h), w && T(google.maps.event.addListener(oe, "dblclick", w)), E && I(google.maps.event.addListener(oe, "dragend", E)), v && H(google.maps.event.addListener(oe, "dragstart", v)), k && ye(google.maps.event.addListener(oe, "mousedown", k)), x && Te(google.maps.event.addListener(oe, "mouseout", x)), L && Ne(google.maps.event.addListener(oe, "mouseover", L)), z && Ke(google.maps.event.addListener(oe, "mouseup", z)), R && Se(google.maps.event.addListener(oe, "rightclick", R)), C && rt(google.maps.event.addListener(oe, "click", C)), P && Me(google.maps.event.addListener(oe, "drag", P)), A && He(google.maps.event.addListener(oe, "clickable_changed", A)), U && ot(google.maps.event.addListener(oe, "cursor_changed", U)), V && Kt(google.maps.event.addListener(oe, "animation_changed", V)), N && ht(google.maps.event.addListener(oe, "draggable_changed", N)), Z && ln(google.maps.event.addListener(oe, "flat_changed", Z)), K && St(google.maps.event.addListener(oe, "icon_changed", K)), X && Xe(google.maps.event.addListener(oe, "position_changed", X)), te && cn(google.maps.event.addListener(oe, "shape_changed", te)), ee && Gn(google.maps.event.addListener(oe, "title_changed", ee)), D && Yn(google.maps.event.addListener(oe, "visible_changed", D)), j && Sn(google.maps.event.addListener(oe, "zindex_changed", j)), M(oe), G && G(oe), () => {
      W !== null && google.maps.event.removeListener(W), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ce !== null && google.maps.event.removeListener(ce), ie !== null && google.maps.event.removeListener(ie), Re !== null && google.maps.event.removeListener(Re), Ie !== null && google.maps.event.removeListener(Ie), Ze !== null && google.maps.event.removeListener(Ze), qe !== null && google.maps.event.removeListener(qe), Ge !== null && google.maps.event.removeListener(Ge), $e !== null && google.maps.event.removeListener($e), Fe !== null && google.maps.event.removeListener(Fe), lt !== null && google.maps.event.removeListener(lt), Dt !== null && google.maps.event.removeListener(Dt), Pt !== null && google.maps.event.removeListener(Pt), ut !== null && google.maps.event.removeListener(ut), Nt !== null && google.maps.event.removeListener(Nt), zt !== null && google.maps.event.removeListener(zt), $t !== null && google.maps.event.removeListener($t), S && S(oe), r ? r.removeMarker(oe, !!o) : oe && oe.setMap(null);
    };
  }, []);
  var pr = qn(() => i ? Ct.map(i, (Ut) => {
    if (!mi(Ut))
      return Ut;
    var oe = Ut;
    return vi(oe, {
      anchor: O
    });
  }) : null, [i, O]);
  return rr.jsx(rr.Fragment, {
    children: pr
  }) || null;
}
De(sV);
class aV extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return kT(function* () {
      var n = js(js(js({}, t.props.options || ud), t.props.clusterer ? ud : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = kt({
        updaterMap: AE,
        eventMap: jE,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: AE,
      eventMap: jE,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Mt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? Ct.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
pe(aV, "contextType", it);
var lV = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), d = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(d !== null ? "".concat(d.y, "px") : "0", "; left: ").concat(d !== null ? "".concat(d.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var p = document.createElement("img");
        p.alt = a, p.src = this.url, p.width = this.width, p.height = this.height, p.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (p.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(p), this.div.appendChild(g), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), uV = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new lV(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function cV(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var dV = 2e3, pV = 500, fV = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", hV = "png", gV = [53, 56, 66, 78, 90], mV = "cluster", ST = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || fV, this.imageExtension = r.imageExtension || hV, this.imageSizes = r.imageSizes || gV, this.calculator = r.calculator || cV, this.batchSize = r.batchSize || dV, this.batchSizeIE = r.batchSizeIE || pV, this.clusterClass = r.clusterClass || mV, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new uV(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var d = 0, p = this.clusters; d < p.length; d++) {
            var g = p[d];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function BE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vV(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BE(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Gr = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, At = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, yV = {};
function bV(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: d,
    imageSizes: p,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: h,
    zoomOnClick: C,
    onClick: w,
    onClusteringBegin: P,
    onClusteringEnd: E,
    onMouseOver: v,
    onMouseOut: x,
    onLoad: L,
    onUnmount: z
  } = e, [k, R] = _(null), A = _e(it), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null);
  return y(() => {
    k && x && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(k, Gr.onMouseOut, x)));
  }, [x]), y(() => {
    k && v && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(k, Gr.onMouseOver, v)));
  }, [v]), y(() => {
    k && w && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(k, Gr.onClick, w)));
  }, [w]), y(() => {
    k && P && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(k, Gr.onClusteringBegin, P)));
  }, [P]), y(() => {
    k && E && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(k, Gr.onClusteringEnd, E)));
  }, [E]), y(() => {
    typeof r < "u" && k !== null && At.averageCenter(k, r);
  }, [k, r]), y(() => {
    typeof o < "u" && k !== null && At.batchSizeIE(k, o);
  }, [k, o]), y(() => {
    typeof i < "u" && k !== null && At.calculator(k, i);
  }, [k, i]), y(() => {
    typeof s < "u" && k !== null && At.clusterClass(k, s);
  }, [k, s]), y(() => {
    typeof a < "u" && k !== null && At.enableRetinaIcons(k, a);
  }, [k, a]), y(() => {
    typeof l < "u" && k !== null && At.gridSize(k, l);
  }, [k, l]), y(() => {
    typeof u < "u" && k !== null && At.ignoreHidden(k, u);
  }, [k, u]), y(() => {
    typeof c < "u" && k !== null && At.imageExtension(k, c);
  }, [k, c]), y(() => {
    typeof d < "u" && k !== null && At.imagePath(k, d);
  }, [k, d]), y(() => {
    typeof p < "u" && k !== null && At.imageSizes(k, p);
  }, [k, p]), y(() => {
    typeof g < "u" && k !== null && At.maxZoom(k, g);
  }, [k, g]), y(() => {
    typeof f < "u" && k !== null && At.minimumClusterSize(k, f);
  }, [k, f]), y(() => {
    typeof m < "u" && k !== null && At.styles(k, m);
  }, [k, m]), y(() => {
    typeof h < "u" && k !== null && At.title(k, h);
  }, [k, h]), y(() => {
    typeof C < "u" && k !== null && At.zoomOnClick(k, C);
  }, [k, C]), y(() => {
    if (A) {
      var G = vV({}, n || yV), S = new ST(A, [], G);
      return r && At.averageCenter(S, r), o && At.batchSizeIE(S, o), i && At.calculator(S, i), s && At.clusterClass(S, s), a && At.enableRetinaIcons(S, a), l && At.gridSize(S, l), u && At.ignoreHidden(S, u), c && At.imageExtension(S, c), d && At.imagePath(S, d), p && At.imageSizes(S, p), g && At.maxZoom(S, g), f && At.minimumClusterSize(S, f), m && At.styles(S, m), h && At.title(S, h), C && At.zoomOnClick(S, C), x && ee(google.maps.event.addListener(S, Gr.onMouseOut, x)), v && j(google.maps.event.addListener(S, Gr.onMouseOver, v)), w && V(google.maps.event.addListener(S, Gr.onClick, w)), P && Z(google.maps.event.addListener(S, Gr.onClusteringBegin, P)), E && X(google.maps.event.addListener(S, Gr.onClusteringEnd, E)), R(S), L && L(S), () => {
        te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), z && z(S);
      };
    }
  }, []), k !== null && t(k) || null;
}
De(bV);
class wV extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []), pe(this, "state", {
      markerClusterer: null
    }), pe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new ST(this.context, [], this.props.options);
      this.registeredEvents = kt({
        updaterMap: At,
        eventMap: Gr,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: At,
      eventMap: Gr,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Mt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
pe(wV, "contextType", it);
function IE(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var MT = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || IE(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, IE));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, d = this.div.offsetWidth, p = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), h = m.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + g ? r = h.x + u - g : h.x + d + u + g > a && (r = h.x + d + u + g - a), this.alignBottom ? h.y < -c + f + p ? o = h.y + c - f - p : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + p + c + f > l && (o = h.y + p + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), CV = ["position"], EV = ["position"];
function FE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FE(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var RE = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, NE = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, xV = {};
function OV(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: p
  } = e, g = _e(it), [f, m] = _(null), [h, C] = _(null), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), R = Ye(null);
  return y(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    if (o && f !== null) {
      var A = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(A);
    }
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), P(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    if (g) {
      var A = r || xV, {
        position: U
      } = A, V = Dy(A, CV), N;
      U && !(U instanceof google.maps.LatLng) && (N = new google.maps.LatLng(U.lat, U.lng));
      var Z = new MT(cd(cd({}, V), N ? {
        position: N
      } : {}));
      R.current = document.createElement("div"), m(Z), s && C(google.maps.event.addListener(Z, "closeclick", s)), a && P(google.maps.event.addListener(Z, "domready", a)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && L(google.maps.event.addListener(Z, "position_changed", u)), c && k(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(R.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : Kn(!1, "You must provide either an anchor or a position prop for <InfoBox>."), d && d(Z);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), p && p(f), f.close());
    };
  }, []), R.current ? dr(Ct.only(t), R.current) : null;
}
De(OV);
class kV extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []), pe(this, "containerElement", null), pe(this, "state", {
      infoBox: null
    }), pe(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Kn(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), pe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = Dy(t, EV), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new MT(cd(cd({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = kt({
      updaterMap: NE,
      eventMap: RE,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: NE,
      eventMap: RE,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Mt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? dr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
pe(kV, "contextType", it);
var zE, $E;
function _V() {
  return $E || ($E = 1, zE = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), zE;
}
var LV = _V(), UE = /* @__PURE__ */ OT(LV), HE = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], uh = 1, fa = 8;
class Py {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== uh)
      throw new Error("Got v".concat(o, " data when expected v").concat(uh, "."));
    var i = HE[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new Py(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = HE.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, fa, t), this.coords = new this.ArrayType(this.data, fa + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(fa + s + a + l), this.ids = new this.IndexArrayType(this.data, fa, t), this.coords = new this.ArrayType(this.data, fa + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (uh << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return vm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, d = l.pop() || 0, p = l.pop() || 0;
      if (d - p <= a) {
        for (var g = p; g <= d; g++) {
          var f = s[2 * g], m = s[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var h = p + d >> 1, C = s[2 * h], w = s[2 * h + 1];
      C >= t && C <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= C : n <= w) && (l.push(p), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= C : o >= w) && (l.push(h + 1), l.push(d), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, d = a.pop() || 0, p = a.pop() || 0;
      if (d - p <= s) {
        for (var g = p; g <= d; g++)
          WE(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = p + d >> 1, m = i[2 * f], h = i[2 * f + 1];
      WE(m, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= h) && (a.push(p), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= m : n + r >= h) && (a.push(f + 1), a.push(d), a.push(1 - c));
    }
    return l;
  }
}
function vm(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    TT(e, t, s, r, o, i), vm(e, t, n, r, s - 1, 1 - i), vm(e, t, n, s + 1, o, 1 - i);
  }
}
function TT(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), d = Math.max(r, Math.floor(n - a * u / s + c)), p = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      TT(e, t, n, d, p, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (ha(e, t, r, n), t[2 * o + i] > g && ha(e, t, r, o); f < m; ) {
      for (ha(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? ha(e, t, r, m) : (m++, ha(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function ha(e, t, n, r) {
  ch(e, n, r), ch(t, 2 * n, 2 * r), ch(t, 2 * n + 1, 2 * r + 1);
}
function ch(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function WE(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var DV = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, VE = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Ni = 2, ni = 3, dh = 4, Jo = 5, jT = 6;
class PV {
  constructor(t) {
    this.options = Object.assign(Object.create(DV), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, d = VE(zu(u)), p = VE($u(c));
        s.push(
          d,
          p,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(zu(r), $u(s), zu(i), $u(o)), d = u.data, p = [];
    for (var g of c) {
      var f = this.stride * g;
      p.push(d[f + Jo] > 1 ? ZE(d, f, this.clusterProps) : this.points[d[f + ni]]);
    }
    return p;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), d = [];
    for (var p of c) {
      var g = p * this.stride;
      s[g + dh] === t && d.push(s[g + Jo] > 1 ? ZE(s, g, this.clusterProps) : this.points[s[g + ni]]);
    }
    if (d.length === 0) throw new Error(o);
    return d;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, d = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, d), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, d), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, d), d.features.length ? d : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Py(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + Jo] > 1, c = void 0, d = void 0, p = void 0;
      if (u)
        c = AT(n, l, this.clusterProps), d = n[l], p = n[l + 1];
      else {
        var g = this.points[n[l + ni]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        d = zu(f), p = $u(m);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (d * i - r)), Math.round(this.options.extent * (p * i - o))]],
        tags: c
      }, C = void 0;
      u || this.options.generateId ? C = n[l + ni] : C = this.points[n[l + ni]].id, C !== void 0 && (h.id = C), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, d = 0; d < l.length; d += c)
      if (!(l[d + Ni] <= n)) {
        l[d + Ni] = n;
        var p = l[d], g = l[d + 1], f = t.within(l[d], l[d + 1], a), m = l[d + Jo], h = m;
        for (var C of f) {
          var w = C * c;
          l[w + Ni] > n && (h += l[w + Jo]);
        }
        if (h > m && h >= s) {
          var P = p * m, E = g * m, v = void 0, x = -1, L = ((d / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var k = z * c;
            if (!(l[k + Ni] <= n)) {
              l[k + Ni] = n;
              var R = l[k + Jo];
              P += l[k] * R, E += l[k + 1] * R, l[k + dh] = L, i && (v || (v = this._map(l, d, !0), x = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, k)));
            }
          }
          l[d + dh] = L, u.push(P / h, E / h, 1 / 0, L, -1, h), i && u.push(x);
        } else {
          for (var A = 0; A < c; A++) u.push(l[d + A]);
          if (h > 1)
            for (var U of f) {
              var V = U * c;
              if (!(l[V + Ni] <= n)) {
                l[V + Ni] = n;
                for (var N = 0; N < c; N++) u.push(l[V + N]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Jo] > 1) {
      var o = this.clusterProps[t[n + jT]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + ni]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function ZE(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ni],
    properties: AT(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [SV(e[t]), MV(e[t + 1])]
    }
  };
}
function AT(e, t, n) {
  var r = e[t + Jo], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + jT], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + ni],
    point_count: r,
    point_count_abbreviated: o
  });
}
function zu(e) {
  return e / 360 + 0.5;
}
function $u(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function SV(e) {
  return (e - 0.5) * 360;
}
function MV(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function TV(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ir {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class ym {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ir.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ir.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ir.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
let jV = class {
  constructor(e) {
    var {
      maxZoom: t = 16
    } = e;
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(e) {
    var {
      markers: t
    } = e;
    return AV(t);
  }
};
var AV = (e) => {
  var t = e.map((n) => new ym({
    position: Ir.getPosition(n),
    markers: [n]
  }));
  return t;
};
class BV extends jV {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = TV(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new PV(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!UE(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = Ir.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !UE(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new ym({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new ym({
      markers: [i],
      position: Ir.getPosition(i)
    });
  }
}
class IV {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class FV {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ir.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), d = c.parseFromString(a, "image/svg+xml").documentElement;
      d.setAttribute("transform", "translate(0 25)");
      var p = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: d
      };
      return new google.maps.marker.AdvancedMarkerElement(p);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function RV(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Sy {
  constructor() {
    RV(Sy, google.maps.OverlayView);
  }
}
var Ha;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Ha || (Ha = {}));
var NV = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class zV extends Sy {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new BV(o),
      renderer: s = new FV(),
      onClusterClick: a = NV
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ir.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Ha.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || Ir.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => Ir.setMap(l, null)));
      }
      google.maps.event.trigger(this, Ha.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ir.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new IV(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ir.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Ha.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ir.setMap(r.marker, n);
    });
  }
}
function qE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function GE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qE(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function $V(e) {
  var t = N8(), [n, r] = _(null);
  return y(() => {
    if (t && n === null) {
      var o = new zV(GE(GE({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function UV(e) {
  var {
    children: t,
    options: n
  } = e, r = $V(n);
  return r !== null ? t(r) : null;
}
De(UV);
var YE = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, KE = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function HV(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: p
  } = e, g = _e(it), [f, m] = _(null), [h, C] = _(null), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), R = Ye(null);
  return y(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), P(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    var A = new google.maps.InfoWindow(r);
    return m(A), R.current = document.createElement("div"), s && C(google.maps.event.addListener(A, "closeclick", s)), a && P(google.maps.event.addListener(A, "domready", a)), l && v(google.maps.event.addListener(A, "content_changed", l)), u && L(google.maps.event.addListener(A, "position_changed", u)), c && k(google.maps.event.addListener(A, "zindex_changed", c)), A.setContent(R.current), o && A.setPosition(o), i && A.setZIndex(i), n ? A.open(g, n) : A.getPosition() ? A.open(g) : Kn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), d && d(A), () => {
      h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), p && p(A), A.close();
    };
  }, []), R.current ? dr(Ct.only(t), R.current) : null;
}
De(HV);
class WV extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []), pe(this, "containerElement", null), pe(this, "state", {
      infoWindow: null
    }), pe(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Kn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), pe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = kt({
      updaterMap: KE,
      eventMap: YE,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: KE,
      eventMap: YE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Mt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? dr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
pe(WV, "contextType", it);
function XE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XE(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var JE = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, QE = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, VV = {};
function ZV(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: p,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onLoad: C,
    onUnmount: w
  } = e, P = _e(it), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null);
  return y(() => {
    E !== null && E.setMap(P);
  }, [P]), y(() => {
    typeof t < "u" && E !== null && E.setOptions(t);
  }, [E, t]), y(() => {
    typeof n < "u" && E !== null && E.setDraggable(n);
  }, [E, n]), y(() => {
    typeof r < "u" && E !== null && E.setEditable(r);
  }, [E, r]), y(() => {
    typeof o < "u" && E !== null && E.setVisible(o);
  }, [E, o]), y(() => {
    typeof i < "u" && E !== null && E.setPath(i);
  }, [E, i]), y(() => {
    E && s && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(E, "dblclick", s)));
  }, [s]), y(() => {
    E && a && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(E, "dragend", a)));
  }, [a]), y(() => {
    E && l && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(E, "dragstart", l)));
  }, [l]), y(() => {
    E && u && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(E, "mousedown", u)));
  }, [u]), y(() => {
    E && c && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(() => {
    E && d && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(E, "mouseout", d)));
  }, [d]), y(() => {
    E && p && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(E, "mouseover", p)));
  }, [p]), y(() => {
    E && g && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(E, "mouseup", g)));
  }, [g]), y(() => {
    E && f && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(E, "rightclick", f)));
  }, [f]), y(() => {
    E && m && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(E, "click", m)));
  }, [m]), y(() => {
    E && h && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(E, "drag", h)));
  }, [h]), y(() => {
    var T = new google.maps.Polyline(dd(dd({}, t || VV), {}, {
      map: P
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), s && L(google.maps.event.addListener(T, "dblclick", s)), a && k(google.maps.event.addListener(T, "dragend", a)), l && A(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), d && X(google.maps.event.addListener(T, "mouseout", d)), p && ee(google.maps.event.addListener(T, "mouseover", p)), g && j(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && O(google.maps.event.addListener(T, "click", m)), h && W(google.maps.event.addListener(T, "drag", h)), v(T), C && C(T), () => {
      x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), G !== null && google.maps.event.removeListener(G), Y !== null && google.maps.event.removeListener(Y), w && w(T), T.setMap(null);
    };
  }, []), null;
}
De(ZV);
class qV extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []), pe(this, "state", {
      polyline: null
    }), pe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(dd(dd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: QE,
      eventMap: JE,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: QE,
      eventMap: JE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Mt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
pe(qV, "contextType", it);
function ex(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ex(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ex(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nx = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, rx = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function GV(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: p,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: C,
    onLoad: w,
    onUnmount: P,
    onEdit: E
  } = e, v = _e(it), [x, L] = _(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null), [T, q] = _(null);
  return y(() => {
    x !== null && x.setMap(v);
  }, [v]), y(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), y(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), y(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), y(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), y(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), y(() => {
    typeof s < "u" && x !== null && x.setPaths(s);
  }, [x, s]), y(() => {
    x && typeof a == "function" && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), y(() => {
    x && (google.maps.event.addListener(x.getPath(), "insert_at", () => {
      E == null || E(x);
    }), google.maps.event.addListener(x.getPath(), "set_at", () => {
      E == null || E(x);
    }), google.maps.event.addListener(x.getPath(), "remove_at", () => {
      E == null || E(x);
    }));
  }, [x, E]), y(() => {
    x && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(x, "dragend", l)));
  }, [l]), y(() => {
    x && typeof u == "function" && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(x, "dragstart", u)));
  }, [u]), y(() => {
    x && typeof c == "function" && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(x, "mousedown", c)));
  }, [c]), y(() => {
    x && typeof d == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(x, "mousemove", d)));
  }, [d]), y(() => {
    x && typeof p == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), y(() => {
    x && typeof g == "function" && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(x, "mouseover", g)));
  }, [g]), y(() => {
    x && typeof f == "function" && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(x, "mouseup", f)));
  }, [f]), y(() => {
    x && typeof m == "function" && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(x, "rightclick", m)));
  }, [m]), y(() => {
    x && typeof h == "function" && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(x, "click", h)));
  }, [h]), y(() => {
    x && typeof C == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(x, "drag", C)));
  }, [C]), y(() => {
    var I = new google.maps.Polygon(tx(tx({}, t), {}, {
      map: v
    }));
    return i && I.setPath(i), s && I.setPaths(s), typeof o < "u" && I.setVisible(o), typeof r < "u" && I.setEditable(r), typeof n < "u" && I.setDraggable(n), a && k(google.maps.event.addListener(I, "dblclick", a)), l && A(google.maps.event.addListener(I, "dragend", l)), u && V(google.maps.event.addListener(I, "dragstart", u)), c && Z(google.maps.event.addListener(I, "mousedown", c)), d && X(google.maps.event.addListener(I, "mousemove", d)), p && ee(google.maps.event.addListener(I, "mouseout", p)), g && j(google.maps.event.addListener(I, "mouseover", g)), f && S(google.maps.event.addListener(I, "mouseup", f)), m && O(google.maps.event.addListener(I, "rightclick", m)), h && W(google.maps.event.addListener(I, "click", h)), C && q(google.maps.event.addListener(I, "drag", C)), L(I), w && w(I), () => {
      z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), G !== null && google.maps.event.removeListener(G), Y !== null && google.maps.event.removeListener(Y), M !== null && google.maps.event.removeListener(M), P && P(I), I.setMap(null);
    };
  }, []), null;
}
De(GV);
class YV extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = kt({
      updaterMap: rx,
      eventMap: nx,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: rx,
      eventMap: nx,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Mt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
pe(YV, "contextType", it);
function ox(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ox(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ox(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ix = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, sx = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function KV(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: p,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onBoundsChanged: C,
    onLoad: w,
    onUnmount: P
  } = e, E = _e(it), [v, x] = _(null), [L, z] = _(null), [k, R] = _(null), [A, U] = _(null), [V, N] = _(null), [Z, K] = _(null), [X, te] = _(null), [ee, D] = _(null), [j, G] = _(null), [S, Y] = _(null), [O, M] = _(null), [W, T] = _(null), [q, I] = _(null);
  return y(() => {
    v !== null && v.setMap(E);
  }, [E]), y(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), y(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), y(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), y(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), y(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), y(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), z(google.maps.event.addListener(v, "dblclick", s)));
  }, [s]), y(() => {
    v && a && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(v, "dragend", a)));
  }, [a]), y(() => {
    v && l && (A !== null && google.maps.event.removeListener(A), U(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), y(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), N(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), y(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), y(() => {
    v && d && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(v, "mouseout", d)));
  }, [d]), y(() => {
    v && p && (ee !== null && google.maps.event.removeListener(ee), D(google.maps.event.addListener(v, "mouseover", p)));
  }, [p]), y(() => {
    v && g && (j !== null && google.maps.event.removeListener(j), G(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), y(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), Y(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), y(() => {
    v && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(v, "click", m)));
  }, [m]), y(() => {
    v && h && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(v, "drag", h)));
  }, [h]), y(() => {
    v && C && (q !== null && google.maps.event.removeListener(q), I(google.maps.event.addListener(v, "bounds_changed", C)));
  }, [C]), y(() => {
    var J = new google.maps.Rectangle(pd(pd({}, t), {}, {
      map: E
    }));
    return typeof i < "u" && J.setVisible(i), typeof o < "u" && J.setEditable(o), typeof r < "u" && J.setDraggable(r), typeof n < "u" && J.setBounds(n), s && z(google.maps.event.addListener(J, "dblclick", s)), a && R(google.maps.event.addListener(J, "dragend", a)), l && U(google.maps.event.addListener(J, "dragstart", l)), u && N(google.maps.event.addListener(J, "mousedown", u)), c && K(google.maps.event.addListener(J, "mousemove", c)), d && te(google.maps.event.addListener(J, "mouseout", d)), p && D(google.maps.event.addListener(J, "mouseover", p)), g && G(google.maps.event.addListener(J, "mouseup", g)), f && Y(google.maps.event.addListener(J, "rightclick", f)), m && M(google.maps.event.addListener(J, "click", m)), h && T(google.maps.event.addListener(J, "drag", h)), C && I(google.maps.event.addListener(J, "bounds_changed", C)), x(J), w && w(J), () => {
      L !== null && google.maps.event.removeListener(L), k !== null && google.maps.event.removeListener(k), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), q !== null && google.maps.event.removeListener(q), P && P(J), J.setMap(null);
    };
  }, []), null;
}
De(KV);
class XV extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []), pe(this, "state", {
      rectangle: null
    }), pe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(pd(pd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: sx,
      eventMap: ix,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: sx,
      eventMap: ix,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Mt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
pe(XV, "contextType", it);
function ax(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ax(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ax(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lx = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, ux = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, JV = {};
function QV(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: p,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: C,
    onCenterChanged: w,
    onRadiusChanged: P,
    onLoad: E,
    onUnmount: v
  } = e, x = _e(it), [L, z] = _(null), [k, R] = _(null), [A, U] = _(null), [V, N] = _(null), [Z, K] = _(null), [X, te] = _(null), [ee, D] = _(null), [j, G] = _(null), [S, Y] = _(null), [O, M] = _(null), [W, T] = _(null), [q, I] = _(null), [J, H] = _(null), [ce, ye] = _(null);
  return y(() => {
    L !== null && L.setMap(x);
  }, [x]), y(() => {
    typeof t < "u" && L !== null && L.setOptions(t);
  }, [L, t]), y(() => {
    typeof o < "u" && L !== null && L.setDraggable(o);
  }, [L, o]), y(() => {
    typeof i < "u" && L !== null && L.setEditable(i);
  }, [L, i]), y(() => {
    typeof s < "u" && L !== null && L.setVisible(s);
  }, [L, s]), y(() => {
    typeof r == "number" && L !== null && L.setRadius(r);
  }, [L, r]), y(() => {
    typeof n < "u" && L !== null && L.setCenter(n);
  }, [L, n]), y(() => {
    L && a && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(L, "dblclick", a)));
  }, [a]), y(() => {
    L && l && (A !== null && google.maps.event.removeListener(A), U(google.maps.event.addListener(L, "dragend", l)));
  }, [l]), y(() => {
    L && u && (V !== null && google.maps.event.removeListener(V), N(google.maps.event.addListener(L, "dragstart", u)));
  }, [u]), y(() => {
    L && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(L, "mousedown", c)));
  }, [c]), y(() => {
    L && d && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(L, "mousemove", d)));
  }, [d]), y(() => {
    L && p && (ee !== null && google.maps.event.removeListener(ee), D(google.maps.event.addListener(L, "mouseout", p)));
  }, [p]), y(() => {
    L && g && (j !== null && google.maps.event.removeListener(j), G(google.maps.event.addListener(L, "mouseover", g)));
  }, [g]), y(() => {
    L && f && (S !== null && google.maps.event.removeListener(S), Y(google.maps.event.addListener(L, "mouseup", f)));
  }, [f]), y(() => {
    L && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(L, "rightclick", m)));
  }, [m]), y(() => {
    L && h && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(L, "click", h)));
  }, [h]), y(() => {
    L && C && (q !== null && google.maps.event.removeListener(q), I(google.maps.event.addListener(L, "drag", C)));
  }, [C]), y(() => {
    L && w && (J !== null && google.maps.event.removeListener(J), H(google.maps.event.addListener(L, "center_changed", w)));
  }, [h]), y(() => {
    L && P && (ce !== null && google.maps.event.removeListener(ce), ye(google.maps.event.addListener(L, "radius_changed", P)));
  }, [P]), y(() => {
    var ie = new google.maps.Circle(fd(fd({}, t || JV), {}, {
      map: x
    }));
    return typeof r == "number" && ie.setRadius(r), typeof n < "u" && ie.setCenter(n), typeof r == "number" && ie.setRadius(r), typeof s < "u" && ie.setVisible(s), typeof i < "u" && ie.setEditable(i), typeof o < "u" && ie.setDraggable(o), a && R(google.maps.event.addListener(ie, "dblclick", a)), l && U(google.maps.event.addListener(ie, "dragend", l)), u && N(google.maps.event.addListener(ie, "dragstart", u)), c && K(google.maps.event.addListener(ie, "mousedown", c)), d && te(google.maps.event.addListener(ie, "mousemove", d)), p && D(google.maps.event.addListener(ie, "mouseout", p)), g && G(google.maps.event.addListener(ie, "mouseover", g)), f && Y(google.maps.event.addListener(ie, "mouseup", f)), m && M(google.maps.event.addListener(ie, "rightclick", m)), h && T(google.maps.event.addListener(ie, "click", h)), C && I(google.maps.event.addListener(ie, "drag", C)), w && H(google.maps.event.addListener(ie, "center_changed", w)), P && ye(google.maps.event.addListener(ie, "radius_changed", P)), z(ie), E && E(ie), () => {
      k !== null && google.maps.event.removeListener(k), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), J !== null && google.maps.event.removeListener(J), ce !== null && google.maps.event.removeListener(ce), v && v(ie), ie.setMap(null);
    };
  }, []), null;
}
De(QV);
class e6 extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []), pe(this, "state", {
      circle: null
    }), pe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(fd(fd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: ux,
      eventMap: lx,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: ux,
      eventMap: lx,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Mt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
pe(e6, "contextType", it);
function cx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cx(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dx = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, px = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function t6(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: d,
    onRemoveProperty: p,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: h
  } = e, C = _e(it), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null), [T, q] = _(null);
  return y(() => {
    w !== null && w.setMap(C);
  }, [C]), y(() => {
    w && r && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), y(() => {
    w && o && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), y(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), y(() => {
    w && s && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), y(() => {
    w && a && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), y(() => {
    w && l && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), y(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), y(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), y(() => {
    w && c && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), y(() => {
    w && d && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(w, "removefeature", d)));
  }, [d]), y(() => {
    w && p && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(w, "removeproperty", p)));
  }, [p]), y(() => {
    w && g && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), y(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), y(() => {
    if (C !== null) {
      var I = new google.maps.Data(hd(hd({}, t), {}, {
        map: C
      }));
      r && v(google.maps.event.addListener(I, "dblclick", r)), o && L(google.maps.event.addListener(I, "mousedown", o)), i && k(google.maps.event.addListener(I, "mousemove", i)), s && A(google.maps.event.addListener(I, "mouseout", s)), a && V(google.maps.event.addListener(I, "mouseover", a)), l && Z(google.maps.event.addListener(I, "mouseup", l)), u && X(google.maps.event.addListener(I, "rightclick", u)), n && ee(google.maps.event.addListener(I, "click", n)), c && j(google.maps.event.addListener(I, "addfeature", c)), d && S(google.maps.event.addListener(I, "removefeature", d)), p && O(google.maps.event.addListener(I, "removeproperty", p)), g && W(google.maps.event.addListener(I, "setgeometry", g)), f && q(google.maps.event.addListener(I, "setproperty", f)), P(I), m && m(I);
    }
    return () => {
      w && (E !== null && google.maps.event.removeListener(E), x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), G !== null && google.maps.event.removeListener(G), Y !== null && google.maps.event.removeListener(Y), M !== null && google.maps.event.removeListener(M), T !== null && google.maps.event.removeListener(T), h && h(w), w.setMap(null));
    };
  }, []), null;
}
De(t6);
class n6 extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []), pe(this, "state", {
      data: null
    }), pe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(hd(hd({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = kt({
        updaterMap: px,
        eventMap: dx,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: px,
      eventMap: dx,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Mt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
pe(n6, "contextType", it);
function fx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fx(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gx = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, mx = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class r6 extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []), pe(this, "state", {
      kmlLayer: null
    }), pe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(hx(hx({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: mx,
      eventMap: gx,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: mx,
      eventMap: gx,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Mt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
pe(r6, "contextType", it);
function BT(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function o6(e, t) {
  return new t(e.lat, e.lng);
}
function i6(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function s6(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function a6(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function l6(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function u6(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function IT(e, t, n, r) {
  return n !== void 0 ? l6(e, t, a6(n, google.maps.LatLngBounds, i6)) : u6(e, t, s6(r, google.maps.LatLng, o6));
}
function c6(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function vx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function d6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vx(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function p6(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = d6({}, this.container ? BT(this.container, o) : {
        x: 0,
        y: 0
      }), u = IT(a, l, this.bounds, this.position);
      for (var [c, d] of Object.entries(u))
        this.container.style[c] = d;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function yx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function f6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yx(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function bx(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function wx(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function h6(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = _e(it), c = qn(() => {
    var p = document.createElement("div");
    return p.style.position = "absolute", p;
  }, []), d = qn(() => p6(c, r, t, n, a), [c, r, t, n]);
  return y(() => (i == null || i(d), d == null || d.setMap(u), () => {
    s == null || s(d), d == null || d.setMap(null);
  }), [u, d]), y(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
De(h6);
class Ks extends Ee {
  constructor(t) {
    super(t), pe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), pe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Kn(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), pe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), pe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = f6({
        x: 0,
        y: 0
      }, this.containerRef.current ? BT(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = IT(r, o, this.props.bounds, this.props.position);
      if (!c6(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), pe(this, "draw", () => {
      this.onPositionElement();
    }), pe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = eo();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = bx(t.position), r = bx(this.props.position), o = wx(t.bounds), i = wx(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(rr.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: Ct.only(this.props.children)
    }), t) : null;
  }
}
pe(Ks, "FLOAT_PANE", "floatPane");
pe(Ks, "MAP_PANE", "mapPane");
pe(Ks, "MARKER_LAYER", "markerLayer");
pe(Ks, "OVERLAY_LAYER", "overlayLayer");
pe(Ks, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
pe(Ks, "contextType", it);
function g6() {
}
function Cx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ex(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Cx(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Cx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xx = {
  onDblClick: "dblclick",
  onClick: "click"
}, Ox = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function m6(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = _e(it), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = qn(() => new google.maps.GroundOverlay(t, s, r), []);
  return y(() => {
    a !== null && a.setMap(i);
  }, [i]), y(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), y(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), y(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
De(m6);
class FT extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []), pe(this, "state", {
      groundOverlay: null
    }), pe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Kn(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Ex(Ex({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: Ox,
      eventMap: xx,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: Ox,
      eventMap: xx,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
pe(FT, "defaultProps", {
  onLoad: g6
});
pe(FT, "contextType", it);
function kx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kx(Object(n), !0).forEach(function(r) {
      pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _x = {}, Lx = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function v6(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = _e(it), [s, a] = _(null);
  return y(() => {
    google.maps.visualization || Kn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(() => {
    Kn(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), y(() => {
    s !== null && s.setMap(i);
  }, [i]), y(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), y(() => {
    var l = new google.maps.visualization.HeatmapLayer(gd(gd({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
De(v6);
class y6 extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []), pe(this, "state", {
      heatmapLayer: null
    }), pe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Kn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Kn(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(gd(gd({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = kt({
      updaterMap: Lx,
      eventMap: _x,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: Lx,
      eventMap: _x,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Mt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
pe(y6, "contextType", it);
var Dx = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, Px = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class b6 extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []), pe(this, "state", {
      streetViewPanorama: null
    }), pe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = kt({
      updaterMap: Px,
      eventMap: Dx,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: Px,
      eventMap: Dx,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Mt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
pe(b6, "contextType", it);
class w6 extends Ee {
  constructor() {
    super(...arguments), pe(this, "state", {
      streetViewService: null
    }), pe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
pe(w6, "contextType", it);
var Sx = {
  onDirectionsChanged: "directions_changed"
}, Mx = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class C6 extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []), pe(this, "state", {
      directionsRenderer: null
    }), pe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = kt({
      updaterMap: Mx,
      eventMap: Sx,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: Mx,
      eventMap: Sx,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Mt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
pe(C6, "contextType", it);
var Tx = {
  onPlacesChanged: "places_changed"
}, jx = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class E6 extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []), pe(this, "containerElement", eo()), pe(this, "state", {
      searchBox: null
    }), pe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Kn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = kt({
          updaterMap: jx,
          eventMap: Tx,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: jx,
      eventMap: Tx,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Mt(this.registeredEvents));
  }
  render() {
    return rr.jsx("div", {
      ref: this.containerElement,
      children: Ct.only(this.props.children)
    });
  }
}
pe(E6, "contextType", it);
var Ax = {
  onPlaceChanged: "place_changed"
}, Bx = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class RT extends Ee {
  constructor() {
    super(...arguments), pe(this, "registeredEvents", []), pe(this, "containerElement", eo()), pe(this, "state", {
      autocomplete: null
    }), pe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Kn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = kt({
        updaterMap: Bx,
        eventMap: Ax,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Mt(this.registeredEvents), this.registeredEvents = kt({
      updaterMap: Bx,
      eventMap: Ax,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Mt(this.registeredEvents);
  }
  render() {
    return rr.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: Ct.only(this.props.children)
    });
  }
}
pe(RT, "defaultProps", {
  className: ""
});
pe(RT, "contextType", it);
let x6 = { data: "" }, O6 = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || x6, k6 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, _6 = /\/\*[^]*?\*\/|  +/g, Ix = /\n+/g, li = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? li(s, i) : i + "{" + li(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += li(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += li.p ? li.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, _o = {}, NT = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + NT(e[n]);
    return t;
  }
  return e;
}, L6 = (e, t, n, r, o) => {
  let i = NT(e), s = _o[i] || (_o[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!_o[s]) {
    let l = i !== e ? e : ((u) => {
      let c, d, p = [{}];
      for (; c = k6.exec(u.replace(_6, "")); ) c[4] ? p.shift() : c[3] ? (d = c[3].replace(Ix, " ").trim(), p.unshift(p[0][d] = p[0][d] || {})) : p[0][c[1]] = c[2].replace(Ix, " ").trim();
      return p[0];
    })(e);
    _o[s] = li(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && _o.g ? _o.g : null;
  return n && (_o.g = _o[s]), ((l, u, c, d) => {
    d ? u.data = u.data.replace(d, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(_o[s], t, r, a), s;
}, D6 = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : li(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function Xp(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return L6(n.unshift ? n.raw ? D6(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, O6(t.target), t.g, t.o, t.k);
}
let zT, bm, wm;
Xp.bind({ g: 1 });
let Bo = Xp.bind({ k: 1 });
function P6(e, t, n, r) {
  li.p = t, zT = e, bm = n, wm = r;
}
function Li(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: bm && bm() }, a), n.o = / *go\d+/.test(l), a.className = Xp.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), wm && u[0] && wm(a), zT(u, a);
    }
    return o;
  };
}
var S6 = (e) => typeof e == "function", M6 = (e, t) => S6(e) ? e(t) : e, T6 = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), j6 = Bo`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, A6 = Bo`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, B6 = Bo`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, I6 = Li("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${j6} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${A6} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${B6} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, F6 = Bo`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, R6 = Li("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${F6} 1s linear infinite;
`, N6 = Bo`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, z6 = Bo`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, $6 = Li("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${N6} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${z6} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, U6 = Li("div")`
  position: absolute;
`, H6 = Li("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, W6 = Bo`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, V6 = Li("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${W6} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, Z6 = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ue.createElement(V6, null, t) : t : n === "blank" ? null : Ue.createElement(H6, null, Ue.createElement(R6, { ...r }), n !== "loading" && Ue.createElement(U6, null, n === "error" ? Ue.createElement(I6, { ...r }) : Ue.createElement($6, { ...r })));
}, q6 = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, G6 = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, Y6 = "0%{opacity:0;} 100%{opacity:1;}", K6 = "0%{opacity:1;} 100%{opacity:0;}", X6 = Li("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, J6 = Li("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Q6 = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = T6() ? [Y6, K6] : [q6(n), G6(n)];
  return { animation: t ? `${Bo(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Bo(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ue.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? Q6(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ue.createElement(Z6, { toast: e }), s = Ue.createElement(J6, { ...e.ariaProps }, M6(e.message, e));
  return Ue.createElement(X6, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ue.createElement(Ue.Fragment, null, i, s));
});
P6(Ue.createElement);
Xp`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ve({});
function e5(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const t5 = {
  CNPJ: "99.999.999/9999-99"
};
e5(t5.CNPJ).length;
Tr((e, t) => /* @__PURE__ */ nr.jsx("input", { ref: t, ...e }));
function $T(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const UT = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function n5(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function r5(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const o5 = $T(UT.NINE).length, i5 = Tr((e, t) => /* @__PURE__ */ nr.jsx("input", { ref: t, ...e }));
Tr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: s, currentCountry: a, disabled: l } = e, [u, c] = _(!1);
    y(() => {
      u ? i(a.mask) : c(!0);
    }, [a]);
    const d = `phoneInputMask ${o}`;
    function p(g) {
      let f = $T(g.target.value);
      const m = r5(f);
      f.length > o5 || (f = n5(f, UT[m]), g.target.value = f, i(f));
    }
    return a.code === "+55" ? /* @__PURE__ */ nr.jsx(
      "input",
      {
        value: s,
        onChange: p,
        className: d,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ nr.jsx(
      Ml,
      {
        value: s,
        onChange: (g) => i(g.target.value),
        className: d,
        component: i5,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: a.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
Ve({});
var zo = {};
Object.defineProperty(zo, "__esModule", {
  value: !0
});
var s5 = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), ph = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, HT = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: s5 ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, My = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Uu = 1; Uu < 20; Uu++)
  My["f" + Uu] = 111 + Uu;
function Jp(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return WT(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return VT(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function a5(e, t) {
  return Jp(e, t);
}
function l5(e, t) {
  return Jp(e, { byKey: !0 }, t);
}
function WT(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in ph)
    r[ph[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), d; !(a = (d = c.next()).done); a = !0) {
      var p = d.value, g = p.endsWith("?") && p.length > 1;
      g && (p = p.slice(0, -1));
      var f = Ty(p), m = ph[f];
      if (p.length > 1 && !m && !HT[p] && !My[f])
        throw new TypeError('Unknown modifier: "' + p + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = ZT(p)), m && (r[m] = g ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function VT(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function ZT(e) {
  e = Ty(e);
  var t = My[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function Ty(e) {
  return e = e.toLowerCase(), e = HT[e] || e, e;
}
zo.default = Jp;
var fh = zo.isHotkey = Jp;
zo.isCodeHotkey = a5;
zo.isKeyHotkey = l5;
zo.parseHotkey = WT;
zo.compareHotkey = VT;
zo.toKeyCode = ZT;
zo.toKeyName = Ty;
var u5 = typeof sn == "object" && sn && sn.Object === Object && sn, c5 = u5, d5 = c5, p5 = typeof self == "object" && self && self.Object === Object && self, f5 = d5 || p5 || Function("return this")(), h5 = f5, g5 = h5, m5 = g5.Symbol, qT = m5, Fx = qT;
Fx && Fx.toStringTag;
var Rx = qT;
Rx && Rx.toStringTag;
var Nx;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Nx || (Nx = {}));
var jy = function(e) {
  return Object.freeze(e);
}, v5 = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, jy(this);
  }
  return e;
}(), y5 = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, jy(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), zx = typeof window < "u" ? window : {};
/msie|trident/i.test(zx.navigator && zx.navigator.userAgent);
var hh = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new v5((n ? t : e) || 0, (n ? e : t) || 0);
};
jy({
  devicePixelContentBoxSize: hh(),
  borderBoxSize: hh(),
  contentBoxSize: hh(),
  contentRect: new y5(0, 0, 0, 0)
});
function Cl(e) {
  "@babel/helpers - typeof";
  return Cl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Cl(e);
}
function b5(e, t) {
  if (Cl(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Cl(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function w5(e) {
  var t = b5(e, "string");
  return Cl(t) === "symbol" ? t : String(t);
}
function Wa(e, t, n) {
  return t = w5(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var C5 = /* @__PURE__ */ Ve(null), gh, mh;
parseInt(Oe.version.split(".")[0], 10);
var $x = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), vh = typeof navigator < "u" && /Android/.test(navigator.userAgent), Hu = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), E5 = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (gh = navigator.userAgent.match(/Version\/(\d+)/)) !== null && gh !== void 0 && gh[1] && parseInt((mh = navigator.userAgent.match(/Version\/(\d+)/)) === null || mh === void 0 ? void 0 : mh[1], 10) < 17;
var x5 = /* @__PURE__ */ new WeakMap(), O5 = /* @__PURE__ */ new WeakMap(), k5 = /* @__PURE__ */ new WeakMap(), _5 = /* @__PURE__ */ new WeakMap(), L5 = /* @__PURE__ */ new WeakMap(), Ux = /* @__PURE__ */ new WeakMap(), D5 = /* @__PURE__ */ new WeakMap(), Hx = /* @__PURE__ */ new WeakMap(), Wu = /* @__PURE__ */ new WeakMap(), P5 = /* @__PURE__ */ new WeakMap(), S5 = /* @__PURE__ */ new WeakMap(), M5 = /* @__PURE__ */ new WeakMap(), GT = globalThis.Node, T5 = globalThis.Text, YT = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, j5 = (e) => md(e) && e.nodeType === 8, go = (e) => md(e) && e.nodeType === 1, md = (e) => {
  var t = YT(e);
  return !!t && e instanceof t.Node;
}, Wx = (e) => {
  var t = e && e.anchorNode && YT(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, A5 = (e) => {
  var [t, n] = e;
  if (go(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = KT(t, o, r ? "backward" : "forward"), r = o < n; go(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = I5(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, B5 = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, KT = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (j5(o) || go(o) && o.childNodes.length === 0 || go(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, I5 = (e, t, n) => {
  var [r] = KT(e, t, n);
  return r;
}, Vx = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), XT = (e, t, n) => {
  var {
    target: r
  } = t;
  if (go(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = xt.getWindow(e);
  if (o.contains(r))
    return xt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : XT(e, i, n);
}, Zx = (e, t) => !!(e.compareDocumentPosition(t) & GT.DOCUMENT_POSITION_PRECEDING), F5 = (e, t) => !!(e.compareDocumentPosition(t) & GT.DOCUMENT_POSITION_FOLLOWING), R5 = 0;
class N5 {
  constructor() {
    Wa(this, "id", void 0), this.id = "".concat(R5++);
  }
}
var xt = {
  androidPendingDiffs: (e) => M5.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = S5.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = xt.toDOMNode(e, e), n = xt.findDocumentOrShadowRoot(e);
    Wu.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = xt.findDocumentOrShadowRoot(e), r = Vx(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Jc.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = xt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = xt.toSlateNode(e, t.target), s = xt.findPath(e, i);
    if (Mo.isElement(i) && tn.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = tn.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? tn.before(e, u) : tn.after(e, u);
      if (c) {
        var d = tn.range(e, c);
        return d;
      }
    }
    var p, {
      document: g
    } = xt.getWindow(e);
    if (g.caretRangeFromPoint)
      p = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (p = g.createRange(), p.setStart(f.offsetNode, f.offset), p.setEnd(f.offsetNode, f.offset));
    }
    if (!p)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = xt.toSlateRange(e, p, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = Ux.get(t);
    return n || (n = new N5(), Ux.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = O5.get(r);
      if (o == null) {
        if (tn.isEditor(r))
          return n;
        break;
      }
      var i = x5.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Ar.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Wu.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          xt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = xt.toDOMNode(e, e), r = xt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = Vx(r), i = xt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Jc.select(e, tn.start(e, [])), Wu.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = k5.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = xt.toDOMNode(e, e), i;
    try {
      i = go(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => md(t) && xt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return tn.hasPath(e, n.path) && tn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => xt.hasEditableTarget(e, t) || xt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => md(t) && xt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!P5.get(e),
  isFocused: (e) => !!Wu.get(e),
  isReadOnly: (e) => !!Hx.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (Hx.get(e)) return !1;
    var n = xt.hasTarget(e, t) && xt.toSlateNode(e, t);
    return Mo.isElement(n) && tn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = D5.get(e), r = tn.isEditor(t) ? _5.get(e) : n == null ? void 0 : n.get(xt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Ar.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = tn.node(e, t.path), r = xt.toDOMNode(e, n), o;
    tn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: d
        } = c.textContent, p = u.getAttribute("data-slate-length"), g = p == null ? d : parseInt(p, 10), f = a + g, m = s[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var h, C = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            C instanceof T5 ? C : m,
            (h = m.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(d, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Ar.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = pt.isBackward(t), i = xt.toDOMPoint(e, n), s = pt.isCollapsed(t) ? i : xt.toDOMPoint(e, r), a = xt.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [d, p] = o ? i : s, g = go(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = go(d) ? d : d.parentElement, h = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(d, h ? 1 : p), l;
  },
  toSlateNode: (e, t) => {
    var n = go(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? L5.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : A5(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var d, p, g = xt.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), C = h && g.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), P = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var E = xt.getWindow(e), v = E.document.createRange();
          v.setStart(u, 0), v.setEnd(s, a);
          var x = v.cloneContents(), L = [...Array.prototype.slice.call(x.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(x.querySelectorAll("[contenteditable=false]"))];
          L.forEach((S) => {
            if (vh && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = x.textContent.length, P = u;
        }
      } else if (m) {
        for (var z = m.querySelectorAll("[data-slate-leaf]"), k = 0; k < z.length; k++) {
          var R = z[k];
          if (xt.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), P = w, c = P.textContent.length, P.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (C) {
        var A = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], U = C.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, N = [...A(U), ...A(U == null ? void 0 : U.nextElementSibling)];
          w = (V = N.find((S) => F5(C, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...A(U == null ? void 0 : U.previousElementSibling), ...A(U)];
          w = (Z = K.findLast((S) => Zx(C, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), P = w, i === "forward" ? c = 0 : (c = P.textContent.length, P.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      P && c === P.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      vh && P.getAttribute("data-slate-zero-width") === "z" && (d = P.textContent) !== null && d !== void 0 && d.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Hu && (p = P.textContent) !== null && p !== void 0 && p.endsWith(`

`)) && c--;
    }
    if (vh && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && xt.hasDOMNode(e, X, {
        editable: !0
      })) {
        var te = xt.toSlateNode(e, X), {
          path: ee,
          offset: D
        } = tn.start(e, xt.findPath(e, te));
        return X.querySelector("[data-slate-leaf]") || (D = a), {
          path: ee,
          offset: D
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var j = xt.toSlateNode(e, u), G = xt.findPath(e, j);
    return {
      path: G,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = Wx(t) ? t.anchorNode : t.startContainer, a, l, u, c, d;
    if (s)
      if (Wx(t)) {
        if (Hu && t.rangeCount > 1) {
          u = t.focusNode;
          var p = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && p.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let x = function(L) {
              return L.childElementCount > 0 ? x(L.children[0]) : L;
            };
            var f = p.startContainer, m = g.startContainer, h = x(f.children[p.startOffset]), C = x(m.children[g.startOffset]);
            c = 0, C.childNodes.length > 0 ? a = C.childNodes[0] : a = C, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, C instanceof HTMLElement ? l = C.innerHTML.length : l = 0;
          } else
            p.startContainer === u ? (a = g.endContainer, l = g.endOffset, c = p.startOffset) : (a = p.startContainer, l = p.endOffset, c = g.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        E5 && B5(a) || Hu ? d = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : d = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, d = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Hu && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = xt.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var P = Zx(a, u) || a === u && c < l, E = d ? w : xt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: P ? "forward" : "backward"
    });
    if (!E)
      return null;
    var v = {
      anchor: w,
      focus: E
    };
    return pt.isExpanded(v) && pt.isForward(v) && go(u) && tn.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = tn.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, z5 = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, $5 = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, U5 = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, On = (e) => {
  var t = z5[e], n = $5[e], r = U5[e], o = t && fh(t), i = n && fh(n), s = r && fh(r);
  return (a) => !!(o && o(a) || $x && i && i(a) || !$x && s && s(a));
};
On("bold"), On("compose"), On("moveBackward"), On("moveForward"), On("deleteBackward"), On("deleteForward"), On("deleteLineBackward"), On("deleteLineForward"), On("deleteWordBackward"), On("deleteWordForward"), On("extendBackward"), On("extendForward"), On("extendLineBackward"), On("extendLineForward"), On("italic"), On("moveLineBackward"), On("moveLineForward"), On("moveWordBackward"), On("moveWordForward"), On("redo"), On("insertSoftBreak"), On("splitBlock"), On("transposeCharacter"), On("undo");
var H5 = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => XT(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, W5 = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class V5 extends Kd {
  constructor() {
    super(...arguments), Wa(this, "context", null), Wa(this, "manager", null), Wa(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, W5);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = H5(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Wa(V5, "contextType", C5);
Ve({});
Ve({});
Ve({});
var Wn = {}, Ay = {}, zl = {}, $l = {}, JT = "Expected a function", qx = NaN, Z5 = "[object Symbol]", q5 = /^\s+|\s+$/g, G5 = /^[-+]0x[0-9a-f]+$/i, Y5 = /^0b[01]+$/i, K5 = /^0o[0-7]+$/i, X5 = parseInt, J5 = typeof sn == "object" && sn && sn.Object === Object && sn, Q5 = typeof self == "object" && self && self.Object === Object && self, e4 = J5 || Q5 || Function("return this")(), t4 = Object.prototype, n4 = t4.toString, r4 = Math.max, o4 = Math.min, yh = function() {
  return e4.Date.now();
};
function i4(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, d = !1, p = !0;
  if (typeof e != "function")
    throw new TypeError(JT);
  t = Gx(t) || 0, vd(n) && (c = !!n.leading, d = "maxWait" in n, i = d ? r4(Gx(n.maxWait) || 0, t) : i, p = "trailing" in n ? !!n.trailing : p);
  function g(x) {
    var L = r, z = o;
    return r = o = void 0, u = x, s = e.apply(z, L), s;
  }
  function f(x) {
    return u = x, a = setTimeout(C, t), c ? g(x) : s;
  }
  function m(x) {
    var L = x - l, z = x - u, k = t - L;
    return d ? o4(k, i - z) : k;
  }
  function h(x) {
    var L = x - l, z = x - u;
    return l === void 0 || L >= t || L < 0 || d && z >= i;
  }
  function C() {
    var x = yh();
    if (h(x))
      return w(x);
    a = setTimeout(C, m(x));
  }
  function w(x) {
    return a = void 0, p && r ? g(x) : (r = o = void 0, s);
  }
  function P() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function E() {
    return a === void 0 ? s : w(yh());
  }
  function v() {
    var x = yh(), L = h(x);
    if (r = arguments, o = this, l = x, L) {
      if (a === void 0)
        return f(l);
      if (d)
        return a = setTimeout(C, t), g(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return v.cancel = P, v.flush = E, v;
}
function s4(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(JT);
  return vd(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), i4(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function vd(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function a4(e) {
  return !!e && typeof e == "object";
}
function l4(e) {
  return typeof e == "symbol" || a4(e) && n4.call(e) == Z5;
}
function Gx(e) {
  if (typeof e == "number")
    return e;
  if (l4(e))
    return qx;
  if (vd(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = vd(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(q5, "");
  var n = Y5.test(e);
  return n || K5.test(e) ? X5(e.slice(2), n ? 2 : 8) : G5.test(e) ? qx : +e;
}
var u4 = s4, Ul = {};
Object.defineProperty(Ul, "__esModule", {
  value: !0
});
Ul.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Pc.has(t) || Pc.set(t, /* @__PURE__ */ new Set());
  var o = Pc.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Ul.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Pc.get(t).delete(n.name || t);
};
var Pc = /* @__PURE__ */ new Map();
Object.defineProperty($l, "__esModule", {
  value: !0
});
var c4 = u4, d4 = p4(c4), Yx = Ul;
function p4(e) {
  return e && e.__esModule ? e : { default: e };
}
var f4 = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, d4.default)(e, t);
}, jn = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = f4(function(r) {
        jn.scrollHandler(e);
      }, t);
      return jn.scrollSpyContainers.push(e), (0, Yx.addPassiveEventListener)(e, "scroll", n), function() {
        (0, Yx.removePassiveEventListener)(e, "scroll", n), jn.scrollSpyContainers.splice(jn.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return jn.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = jn.scrollSpyContainers[jn.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(jn.currentPositionX(e), jn.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    jn.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = jn.scrollSpyContainers[jn.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    jn.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    jn.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), jn.spySetState && jn.spySetState.length && jn.spySetState.indexOf(e) > -1 && jn.spySetState.splice(jn.spySetState.indexOf(e), 1), document.removeEventListener("scroll", jn.scrollHandler);
  },
  update: function() {
    return jn.scrollSpyContainers.forEach(function(e) {
      return jn.scrollHandler(e);
    });
  }
};
$l.default = jn;
var Xs = {}, Hl = {};
Object.defineProperty(Hl, "__esModule", {
  value: !0
});
var h4 = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, g4 = function() {
  return window.location.hash.replace(/^#/, "");
}, m4 = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, v4 = function(e) {
  return getComputedStyle(e).position !== "static";
}, bh = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, y4 = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (v4(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = bh(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return bh(t, a).offsetTop - bh(e, a).offsetTop;
};
Hl.default = {
  updateHash: h4,
  getHash: g4,
  filterElementInContainer: m4,
  scrollOffset: y4
};
var Qp = {}, By = {};
Object.defineProperty(By, "__esModule", {
  value: !0
});
By.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Iy = {};
Object.defineProperty(Iy, "__esModule", {
  value: !0
});
var b4 = Ul, w4 = ["mousedown", "wheel", "touchmove", "keydown"];
Iy.default = {
  subscribe: function(e) {
    return typeof document < "u" && w4.forEach(function(t) {
      return (0, b4.addPassiveEventListener)(document, t, e);
    });
  }
};
var Wl = {};
Object.defineProperty(Wl, "__esModule", {
  value: !0
});
var Cm = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Cm.registered[e] = t;
    },
    remove: function(e) {
      Cm.registered[e] = null;
    }
  }
};
Wl.default = Cm;
Object.defineProperty(Qp, "__esModule", {
  value: !0
});
var C4 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, E4 = Hl;
ef(E4);
var x4 = By, Kx = ef(x4), O4 = Iy, k4 = ef(O4), _4 = Wl, co = ef(_4);
function ef(e) {
  return e && e.__esModule ? e : { default: e };
}
var QT = function(e) {
  return Kx.default[e.smooth] || Kx.default.defaultEasing;
}, L4 = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, D4 = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Em = function() {
  return D4() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), ej = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, tj = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, nj = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, P4 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, S4 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, M4 = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    co.default.registered.end && co.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Em.call(window, i);
    return;
  }
  co.default.registered.end && co.default.registered.end(o.to, o.target, o.currentPosition);
}, Fy = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Vl = function(e, t, n, r) {
  t.data = t.data || ej(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (k4.default.subscribe(o), Fy(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? tj(t) : nj(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    co.default.registered.end && co.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = L4(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = QT(t), s = M4.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      co.default.registered.begin && co.default.registered.begin(t.data.to, t.data.target), Em.call(window, s);
    }, t.delay);
    return;
  }
  co.default.registered.begin && co.default.registered.begin(t.data.to, t.data.target), Em.call(window, s);
}, tf = function(e) {
  return e = C4({}, e), e.data = e.data || ej(), e.absolute = !0, e;
}, T4 = function(e) {
  Vl(0, tf(e));
}, j4 = function(e, t) {
  Vl(e, tf(t));
}, A4 = function(e) {
  e = tf(e), Fy(e), Vl(e.horizontal ? P4(e) : S4(e), e);
}, B4 = function(e, t) {
  t = tf(t), Fy(t);
  var n = t.horizontal ? tj(t) : nj(t);
  Vl(e + n, t);
};
Qp.default = {
  animateTopScroll: Vl,
  getAnimationType: QT,
  scrollToTop: T4,
  scrollToBottom: A4,
  scrollTo: j4,
  scrollMore: B4
};
Object.defineProperty(Xs, "__esModule", {
  value: !0
});
var I4 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, F4 = Hl, R4 = Ry(F4), N4 = Qp, z4 = Ry(N4), $4 = Wl, Vu = Ry($4);
function Ry(e) {
  return e && e.__esModule ? e : { default: e };
}
var Zu = {}, Xx = void 0;
Xs.default = {
  unmount: function() {
    Zu = {};
  },
  register: function(e, t) {
    Zu[e] = t;
  },
  unregister: function(e) {
    delete Zu[e];
  },
  get: function(e) {
    return Zu[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return Xx = e;
  },
  getActiveLink: function() {
    return Xx;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = I4({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = R4.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      Vu.default.registered.begin && Vu.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, Vu.default.registered.end && Vu.default.registered.end(e, n);
      return;
    }
    z4.default.animateTopScroll(a, t, e, n);
  }
};
var xm = { exports: {} }, wh = { exports: {} }, Vt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Jx;
function U4() {
  if (Jx) return Vt;
  Jx = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function P(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case d:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case a:
                case c:
                case f:
                case g:
                case s:
                  return v;
                default:
                  return x;
              }
          }
        case n:
          return x;
      }
    }
  }
  function E(v) {
    return P(v) === u;
  }
  return Vt.AsyncMode = l, Vt.ConcurrentMode = u, Vt.ContextConsumer = a, Vt.ContextProvider = s, Vt.Element = t, Vt.ForwardRef = c, Vt.Fragment = r, Vt.Lazy = f, Vt.Memo = g, Vt.Portal = n, Vt.Profiler = i, Vt.StrictMode = o, Vt.Suspense = d, Vt.isAsyncMode = function(v) {
    return E(v) || P(v) === l;
  }, Vt.isConcurrentMode = E, Vt.isContextConsumer = function(v) {
    return P(v) === a;
  }, Vt.isContextProvider = function(v) {
    return P(v) === s;
  }, Vt.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Vt.isForwardRef = function(v) {
    return P(v) === c;
  }, Vt.isFragment = function(v) {
    return P(v) === r;
  }, Vt.isLazy = function(v) {
    return P(v) === f;
  }, Vt.isMemo = function(v) {
    return P(v) === g;
  }, Vt.isPortal = function(v) {
    return P(v) === n;
  }, Vt.isProfiler = function(v) {
    return P(v) === i;
  }, Vt.isStrictMode = function(v) {
    return P(v) === o;
  }, Vt.isSuspense = function(v) {
    return P(v) === d;
  }, Vt.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === d || v === p || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === s || v.$$typeof === a || v.$$typeof === c || v.$$typeof === h || v.$$typeof === C || v.$$typeof === w || v.$$typeof === m);
  }, Vt.typeOf = P, Vt;
}
var Jt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Qx;
function H4() {
  return Qx || (Qx = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function P(H) {
      return typeof H == "string" || typeof H == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      H === r || H === u || H === i || H === o || H === d || H === p || typeof H == "object" && H !== null && (H.$$typeof === f || H.$$typeof === g || H.$$typeof === s || H.$$typeof === a || H.$$typeof === c || H.$$typeof === h || H.$$typeof === C || H.$$typeof === w || H.$$typeof === m);
    }
    function E(H) {
      if (typeof H == "object" && H !== null) {
        var ce = H.$$typeof;
        switch (ce) {
          case t:
            var ye = H.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case d:
                return ye;
              default:
                var ie = ye && ye.$$typeof;
                switch (ie) {
                  case a:
                  case c:
                  case f:
                  case g:
                  case s:
                    return ie;
                  default:
                    return ce;
                }
            }
          case n:
            return ce;
        }
      }
    }
    var v = l, x = u, L = a, z = s, k = t, R = c, A = r, U = f, V = g, N = n, Z = i, K = o, X = d, te = !1;
    function ee(H) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), D(H) || E(H) === l;
    }
    function D(H) {
      return E(H) === u;
    }
    function j(H) {
      return E(H) === a;
    }
    function G(H) {
      return E(H) === s;
    }
    function S(H) {
      return typeof H == "object" && H !== null && H.$$typeof === t;
    }
    function Y(H) {
      return E(H) === c;
    }
    function O(H) {
      return E(H) === r;
    }
    function M(H) {
      return E(H) === f;
    }
    function W(H) {
      return E(H) === g;
    }
    function T(H) {
      return E(H) === n;
    }
    function q(H) {
      return E(H) === i;
    }
    function I(H) {
      return E(H) === o;
    }
    function J(H) {
      return E(H) === d;
    }
    Jt.AsyncMode = v, Jt.ConcurrentMode = x, Jt.ContextConsumer = L, Jt.ContextProvider = z, Jt.Element = k, Jt.ForwardRef = R, Jt.Fragment = A, Jt.Lazy = U, Jt.Memo = V, Jt.Portal = N, Jt.Profiler = Z, Jt.StrictMode = K, Jt.Suspense = X, Jt.isAsyncMode = ee, Jt.isConcurrentMode = D, Jt.isContextConsumer = j, Jt.isContextProvider = G, Jt.isElement = S, Jt.isForwardRef = Y, Jt.isFragment = O, Jt.isLazy = M, Jt.isMemo = W, Jt.isPortal = T, Jt.isProfiler = q, Jt.isStrictMode = I, Jt.isSuspense = J, Jt.isValidElementType = P, Jt.typeOf = E;
  }()), Jt;
}
var e1;
function rj() {
  return e1 || (e1 = 1, process.env.NODE_ENV === "production" ? wh.exports = U4() : wh.exports = H4()), wh.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Ch, t1;
function W4() {
  if (t1) return Ch;
  t1 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Ch = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var d in a)
        t.call(a, d) && (l[d] = a[d]);
      if (e) {
        u = e(a);
        for (var p = 0; p < u.length; p++)
          n.call(a, u[p]) && (l[u[p]] = a[u[p]]);
      }
    }
    return l;
  }, Ch;
}
var Eh, n1;
function Ny() {
  if (n1) return Eh;
  n1 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Eh = e, Eh;
}
var r1, o1;
function oj() {
  return o1 || (o1 = 1, r1 = Function.call.bind(Object.prototype.hasOwnProperty)), r1;
}
var xh, i1;
function V4() {
  if (i1) return xh;
  i1 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Ny(), n = {}, r = oj();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var d;
          try {
            if (typeof i[c] != "function") {
              var p = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            d = i[c](s, c, l, a, null, t);
          } catch (f) {
            d = f;
          }
          if (d && !(d instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in n)) {
            n[d.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + a + " type: " + d.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, xh = o, xh;
}
var Oh, s1;
function Z4() {
  if (s1) return Oh;
  s1 = 1;
  var e = rj(), t = W4(), n = Ny(), r = oj(), o = V4(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return Oh = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function d(D) {
      var j = D && (u && D[u] || D[c]);
      if (typeof j == "function")
        return j;
    }
    var p = "<<anonymous>>", g = {
      array: C("array"),
      bigint: C("bigint"),
      bool: C("boolean"),
      func: C("function"),
      number: C("number"),
      object: C("object"),
      string: C("string"),
      symbol: C("symbol"),
      any: w(),
      arrayOf: P,
      element: E(),
      elementType: v(),
      instanceOf: x,
      node: R(),
      objectOf: z,
      oneOf: L,
      oneOfType: k,
      shape: U,
      exact: V
    };
    function f(D, j) {
      return D === j ? D !== 0 || 1 / D === 1 / j : D !== D && j !== j;
    }
    function m(D, j) {
      this.message = D, this.data = j && typeof j == "object" ? j : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function h(D) {
      if (process.env.NODE_ENV !== "production")
        var j = {}, G = 0;
      function S(O, M, W, T, q, I, J) {
        if (T = T || p, I = I || W, J !== n) {
          if (l) {
            var H = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw H.name = "Invariant Violation", H;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ce = T + ":" + W;
            !j[ce] && // Avoid spamming the console because they are often not actionable except for lib authors
            G < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + I + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), j[ce] = !0, G++);
          }
        }
        return M[W] == null ? O ? M[W] === null ? new m("The " + q + " `" + I + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + I + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : D(M, W, T, q, I);
      }
      var Y = S.bind(null, !1);
      return Y.isRequired = S.bind(null, !0), Y;
    }
    function C(D) {
      function j(G, S, Y, O, M, W) {
        var T = G[S], q = K(T);
        if (q !== D) {
          var I = X(T);
          return new m(
            "Invalid " + O + " `" + M + "` of type " + ("`" + I + "` supplied to `" + Y + "`, expected ") + ("`" + D + "`."),
            { expectedType: D }
          );
        }
        return null;
      }
      return h(j);
    }
    function w() {
      return h(s);
    }
    function P(D) {
      function j(G, S, Y, O, M) {
        if (typeof D != "function")
          return new m("Property `" + M + "` of component `" + Y + "` has invalid PropType notation inside arrayOf.");
        var W = G[S];
        if (!Array.isArray(W)) {
          var T = K(W);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + T + "` supplied to `" + Y + "`, expected an array."));
        }
        for (var q = 0; q < W.length; q++) {
          var I = D(W, q, Y, O, M + "[" + q + "]", n);
          if (I instanceof Error)
            return I;
        }
        return null;
      }
      return h(j);
    }
    function E() {
      function D(j, G, S, Y, O) {
        var M = j[G];
        if (!a(M)) {
          var W = K(M);
          return new m("Invalid " + Y + " `" + O + "` of type " + ("`" + W + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(D);
    }
    function v() {
      function D(j, G, S, Y, O) {
        var M = j[G];
        if (!e.isValidElementType(M)) {
          var W = K(M);
          return new m("Invalid " + Y + " `" + O + "` of type " + ("`" + W + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(D);
    }
    function x(D) {
      function j(G, S, Y, O, M) {
        if (!(G[S] instanceof D)) {
          var W = D.name || p, T = ee(G[S]);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + T + "` supplied to `" + Y + "`, expected ") + ("instance of `" + W + "`."));
        }
        return null;
      }
      return h(j);
    }
    function L(D) {
      if (!Array.isArray(D))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function j(G, S, Y, O, M) {
        for (var W = G[S], T = 0; T < D.length; T++)
          if (f(W, D[T]))
            return null;
        var q = JSON.stringify(D, function(I, J) {
          var H = X(J);
          return H === "symbol" ? String(J) : J;
        });
        return new m("Invalid " + O + " `" + M + "` of value `" + String(W) + "` " + ("supplied to `" + Y + "`, expected one of " + q + "."));
      }
      return h(j);
    }
    function z(D) {
      function j(G, S, Y, O, M) {
        if (typeof D != "function")
          return new m("Property `" + M + "` of component `" + Y + "` has invalid PropType notation inside objectOf.");
        var W = G[S], T = K(W);
        if (T !== "object")
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + T + "` supplied to `" + Y + "`, expected an object."));
        for (var q in W)
          if (r(W, q)) {
            var I = D(W, q, Y, O, M + "." + q, n);
            if (I instanceof Error)
              return I;
          }
        return null;
      }
      return h(j);
    }
    function k(D) {
      if (!Array.isArray(D))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var j = 0; j < D.length; j++) {
        var G = D[j];
        if (typeof G != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(G) + " at index " + j + "."
          ), s;
      }
      function S(Y, O, M, W, T) {
        for (var q = [], I = 0; I < D.length; I++) {
          var J = D[I], H = J(Y, O, M, W, T, n);
          if (H == null)
            return null;
          H.data && r(H.data, "expectedType") && q.push(H.data.expectedType);
        }
        var ce = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + W + " `" + T + "` supplied to " + ("`" + M + "`" + ce + "."));
      }
      return h(S);
    }
    function R() {
      function D(j, G, S, Y, O) {
        return N(j[G]) ? null : new m("Invalid " + Y + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return h(D);
    }
    function A(D, j, G, S, Y) {
      return new m(
        (D || "React class") + ": " + j + " type `" + G + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Y + "`."
      );
    }
    function U(D) {
      function j(G, S, Y, O, M) {
        var W = G[S], T = K(W);
        if (T !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + T + "` " + ("supplied to `" + Y + "`, expected `object`."));
        for (var q in D) {
          var I = D[q];
          if (typeof I != "function")
            return A(Y, O, M, q, X(I));
          var J = I(W, q, Y, O, M + "." + q, n);
          if (J)
            return J;
        }
        return null;
      }
      return h(j);
    }
    function V(D) {
      function j(G, S, Y, O, M) {
        var W = G[S], T = K(W);
        if (T !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + T + "` " + ("supplied to `" + Y + "`, expected `object`."));
        var q = t({}, G[S], D);
        for (var I in q) {
          var J = D[I];
          if (r(D, I) && typeof J != "function")
            return A(Y, O, M, I, X(J));
          if (!J)
            return new m(
              "Invalid " + O + " `" + M + "` key `" + I + "` supplied to `" + Y + "`.\nBad object: " + JSON.stringify(G[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(D), null, "  ")
            );
          var H = J(W, I, Y, O, M + "." + I, n);
          if (H)
            return H;
        }
        return null;
      }
      return h(j);
    }
    function N(D) {
      switch (typeof D) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !D;
        case "object":
          if (Array.isArray(D))
            return D.every(N);
          if (D === null || a(D))
            return !0;
          var j = d(D);
          if (j) {
            var G = j.call(D), S;
            if (j !== D.entries) {
              for (; !(S = G.next()).done; )
                if (!N(S.value))
                  return !1;
            } else
              for (; !(S = G.next()).done; ) {
                var Y = S.value;
                if (Y && !N(Y[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(D, j) {
      return D === "symbol" ? !0 : j ? j["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && j instanceof Symbol : !1;
    }
    function K(D) {
      var j = typeof D;
      return Array.isArray(D) ? "array" : D instanceof RegExp ? "object" : Z(j, D) ? "symbol" : j;
    }
    function X(D) {
      if (typeof D > "u" || D === null)
        return "" + D;
      var j = K(D);
      if (j === "object") {
        if (D instanceof Date)
          return "date";
        if (D instanceof RegExp)
          return "regexp";
      }
      return j;
    }
    function te(D) {
      var j = X(D);
      switch (j) {
        case "array":
        case "object":
          return "an " + j;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + j;
        default:
          return j;
      }
    }
    function ee(D) {
      return !D.constructor || !D.constructor.name ? p : D.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, Oh;
}
var kh, a1;
function q4() {
  if (a1) return kh;
  a1 = 1;
  var e = Ny();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, kh = function() {
    function r(s, a, l, u, c, d) {
      if (d !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, kh;
}
if (process.env.NODE_ENV !== "production") {
  var G4 = rj(), Y4 = !0;
  xm.exports = Z4()(G4.isElement, Y4);
} else
  xm.exports = q4()();
var nf = xm.exports, rf = {};
Object.defineProperty(rf, "__esModule", {
  value: !0
});
var K4 = Hl, _h = X4(K4);
function X4(e) {
  return e && e.__esModule ? e : { default: e };
}
var J4 = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return _h.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && _h.default.getHash() !== e && _h.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
rf.default = J4;
Object.defineProperty(zl, "__esModule", {
  value: !0
});
var qu = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Q4 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), e7 = Oe, l1 = Zl(e7), t7 = $l, Gu = Zl(t7), n7 = Xs, r7 = Zl(n7), o7 = nf, kn = Zl(o7), i7 = rf, Vo = Zl(i7);
function Zl(e) {
  return e && e.__esModule ? e : { default: e };
}
function s7(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function a7(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function l7(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var u1 = {
  to: kn.default.string.isRequired,
  containerId: kn.default.string,
  container: kn.default.object,
  activeClass: kn.default.string,
  activeStyle: kn.default.object,
  spy: kn.default.bool,
  horizontal: kn.default.bool,
  smooth: kn.default.oneOfType([kn.default.bool, kn.default.string]),
  offset: kn.default.number,
  delay: kn.default.number,
  isDynamic: kn.default.bool,
  onClick: kn.default.func,
  duration: kn.default.oneOfType([kn.default.number, kn.default.func]),
  absolute: kn.default.bool,
  onSetActive: kn.default.func,
  onSetInactive: kn.default.func,
  ignoreCancelEvents: kn.default.bool,
  hashSpy: kn.default.bool,
  saveHashHistory: kn.default.bool,
  spyThrottle: kn.default.number
};
zl.default = function(e, t) {
  var n = t || r7.default, r = function(i) {
    l7(s, i);
    function s(a) {
      s7(this, s);
      var l = a7(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return Q4(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          if (!Gu.default.isMounted(a)) {
            var l = Gu.default.mount(a, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (Vo.default.isMounted() || Vo.default.mount(n), Vo.default.mapContainer(this.props.to, a)), Gu.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Gu.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(a) {
          return a();
        });
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = qu({}, this.props.style, this.props.activeStyle) : l = qu({}, this.props.style);
        var u = qu({}, this.props);
        for (var c in u1)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, l1.default.createElement(e, u);
      }
    }]), s;
  }(l1.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, qu({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(Vo.default.isMounted() && !Vo.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, d = null, p = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, h = 0;
          if (l.getBoundingClientRect) {
            var C = l.getBoundingClientRect();
            h = C.left;
          }
          if (!d || i.props.isDynamic) {
            if (d = n.get(c), !d)
              return;
            var w = d.getBoundingClientRect();
            f = w.left - h + s, m = f + w.width;
          }
          var P = s - i.props.offset;
          p = P >= Math.floor(f) && P < Math.floor(m), g = P < Math.floor(f) || P >= Math.floor(m);
        } else {
          var E = 0, v = 0, x = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            x = L.top;
          }
          if (!d || i.props.isDynamic) {
            if (d = n.get(c), !d)
              return;
            var z = d.getBoundingClientRect();
            E = z.top - x + a, v = E + z.height;
          }
          var k = a - i.props.offset;
          p = k >= Math.floor(E) && k < Math.floor(v), g = k < Math.floor(E) || k >= Math.floor(v);
        }
        var R = n.getActiveLink();
        if (g) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && Vo.default.getHash() === c) {
            var A = i.props.saveHashHistory, U = A === void 0 ? !1 : A;
            Vo.default.changeHash("", U);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, d));
        }
        if (p && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, N = V === void 0 ? !1 : V;
          i.props.hashSpy && Vo.default.changeHash(c, N), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, d));
        }
      }
    };
  };
  return r.propTypes = u1, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Ay, "__esModule", {
  value: !0
});
var u7 = Oe, c1 = ij(u7), c7 = zl, d7 = ij(c7);
function ij(e) {
  return e && e.__esModule ? e : { default: e };
}
function p7(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function d1(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function f7(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var h7 = function(e) {
  f7(t, e);
  function t() {
    var n, r, o, i;
    p7(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = d1(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return c1.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), d1(o, i);
  }
  return t;
}(c1.default.Component);
Ay.default = (0, d7.default)(h7);
var zy = {};
Object.defineProperty(zy, "__esModule", {
  value: !0
});
var g7 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), m7 = Oe, p1 = sj(m7), v7 = zl, y7 = sj(v7);
function sj(e) {
  return e && e.__esModule ? e : { default: e };
}
function b7(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function w7(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function C7(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var E7 = function(e) {
  C7(t, e);
  function t() {
    return b7(this, t), w7(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return g7(t, [{
    key: "render",
    value: function() {
      return p1.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(p1.default.Component);
zy.default = (0, y7.default)(E7);
var $y = {}, of = {};
Object.defineProperty(of, "__esModule", {
  value: !0
});
var x7 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, O7 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), k7 = Oe, f1 = sf(k7), _7 = Tl;
sf(_7);
var L7 = Xs, h1 = sf(L7), D7 = nf, g1 = sf(D7);
function sf(e) {
  return e && e.__esModule ? e : { default: e };
}
function P7(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function S7(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function M7(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
of.default = function(e) {
  var t = function(n) {
    M7(r, n);
    function r(o) {
      P7(this, r);
      var i = S7(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return O7(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        h1.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        h1.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return f1.default.createElement(e, x7({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(f1.default.Component);
  return t.propTypes = {
    name: g1.default.string,
    id: g1.default.string
  }, t;
};
Object.defineProperty($y, "__esModule", {
  value: !0
});
var m1 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, T7 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), j7 = Oe, v1 = Uy(j7), A7 = of, B7 = Uy(A7), I7 = nf, y1 = Uy(I7);
function Uy(e) {
  return e && e.__esModule ? e : { default: e };
}
function F7(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function R7(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function N7(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var aj = function(e) {
  N7(t, e);
  function t() {
    return F7(this, t), R7(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return T7(t, [{
    key: "render",
    value: function() {
      var n = this, r = m1({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, v1.default.createElement(
        "div",
        m1({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(v1.default.Component);
aj.propTypes = {
  name: y1.default.string,
  id: y1.default.string
};
$y.default = (0, B7.default)(aj);
var Lh = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, b1 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function w1(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function C1(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function E1(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Yu = Oe, zi = $l, Dh = Xs, Fn = nf, Zo = rf, x1 = {
  to: Fn.string.isRequired,
  containerId: Fn.string,
  container: Fn.object,
  activeClass: Fn.string,
  spy: Fn.bool,
  smooth: Fn.oneOfType([Fn.bool, Fn.string]),
  offset: Fn.number,
  delay: Fn.number,
  isDynamic: Fn.bool,
  onClick: Fn.func,
  duration: Fn.oneOfType([Fn.number, Fn.func]),
  absolute: Fn.bool,
  onSetActive: Fn.func,
  onSetInactive: Fn.func,
  ignoreCancelEvents: Fn.bool,
  hashSpy: Fn.bool,
  spyThrottle: Fn.number
}, z7 = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Dh, r = function(i) {
      E1(s, i);
      function s(a) {
        w1(this, s);
        var l = C1(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return b1(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            zi.isMounted(a) || zi.mount(a, this.props.spyThrottle), this.props.hashSpy && (Zo.isMounted() || Zo.mount(n), Zo.mapContainer(this.props.to, a)), this.props.spy && zi.addStateHandler(this.stateHandler), zi.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          zi.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = Lh({}, this.props);
          for (var u in x1)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, Yu.createElement(e, l);
        }
      }]), s;
    }(Yu.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, Lh({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(Zo.isMounted() && !Zo.isInitialized())) {
          var l = i.props.to, u = null, c = 0, d = 0, p = 0;
          if (a.getBoundingClientRect) {
            var g = a.getBoundingClientRect();
            p = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - p + s, d = c + f.height;
          }
          var m = s - i.props.offset, h = m >= Math.floor(c) && m < Math.floor(d), C = m < Math.floor(c) || m >= Math.floor(d), w = n.getActiveLink();
          if (C)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Zo.getHash() === l && Zo.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), zi.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Zo.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), zi.updateStates();
        }
      };
    };
    return r.propTypes = x1, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      E1(r, n);
      function r(o) {
        w1(this, r);
        var i = C1(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return b1(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Dh.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Dh.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Yu.createElement(e, Lh({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Yu.Component);
    return t.propTypes = {
      name: Fn.string,
      id: Fn.string
    }, t;
  }
}, $7 = z7;
Object.defineProperty(Wn, "__esModule", {
  value: !0
});
Wn.Helpers = Wn.ScrollElement = Wn.ScrollLink = Wn.animateScroll = Wn.scrollSpy = Wn.Events = Wn.scroller = Wn.Element = Wn.Button = Wn.Link = void 0;
var U7 = Ay, lj = bo(U7), H7 = zy, uj = bo(H7), W7 = $y, cj = bo(W7), V7 = Xs, dj = bo(V7), Z7 = Wl, pj = bo(Z7), q7 = $l, fj = bo(q7), G7 = Qp, hj = bo(G7), Y7 = zl, gj = bo(Y7), K7 = of, mj = bo(K7), X7 = $7, vj = bo(X7);
function bo(e) {
  return e && e.__esModule ? e : { default: e };
}
Wn.Link = lj.default;
Wn.Button = uj.default;
Wn.Element = cj.default;
Wn.scroller = dj.default;
Wn.Events = pj.default;
Wn.scrollSpy = fj.default;
Wn.animateScroll = hj.default;
Wn.ScrollLink = gj.default;
Wn.ScrollElement = mj.default;
Wn.Helpers = vj.default;
Wn.default = { Link: lj.default, Button: uj.default, Element: cj.default, scroller: dj.default, Events: pj.default, scrollSpy: fj.default, animateScroll: hj.default, ScrollLink: gj.default, ScrollElement: mj.default, Helpers: vj.default };
Ve({});
Ve({});
Ve({});
function El(e) {
  "@babel/helpers - typeof";
  return El = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, El(e);
}
function J7(e, t) {
  if (El(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (El(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Q7(e) {
  var t = J7(e, "string");
  return El(t) == "symbol" ? t : t + "";
}
function fe(e, t, n) {
  return (t = Q7(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function yj(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ph, O1;
function eZ() {
  if (O1) return Ph;
  O1 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, s, a, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [o, i, s, a, l, u], p = 0;
        c = new Error(r.replace(/%s/g, function() {
          return d[p++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Ph = t, Ph;
}
var tZ = eZ(), Xn = /* @__PURE__ */ yj(tZ), st = Ve(null);
function nZ() {
  Xn(!!_e, "useGoogleMap is React hook and requires React version 16.8+");
  var e = _e(st);
  return Xn(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function rZ(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function oZ(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function iZ(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return oZ(e, i), o;
}
function sZ(e, t, n) {
  var r = rZ(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function aZ(e) {
  google.maps.event.removeListener(e);
}
function Tt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(aZ);
}
function _t(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = sZ(o, i, n);
  return iZ(t, r, o, i), s;
}
function lZ(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: d,
    onMouseMove: p,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: h,
    onRightClick: C,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: P,
    onUnmount: E
  } = e, [v, x] = _(null), L = Ye(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null), [T, q] = _(null), [I, J] = _(null);
  return y(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), y(() => {
    v !== null && typeof s < "u" && v.setCenter(s);
  }, [v, s]), y(() => {
    v && l && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), y(() => {
    v && c && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), y(() => {
    v && d && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(v, "dragstart", d)));
  }, [d]), y(() => {
    v && m && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", m)));
  }, [m]), y(() => {
    v && p && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(v, "mousemove", p)));
  }, [p]), y(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), y(() => {
    v && f && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), y(() => {
    v && h && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(v, "mouseup", h)));
  }, [h]), y(() => {
    v && C && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(v, "rightclick", C)));
  }, [C]), y(() => {
    v && a && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", a)));
  }, [a]), y(() => {
    v && u && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(v, "drag", u)));
  }, [u]), y(() => {
    v && w && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(v, "center_changed", w)));
  }, [a]), y(() => {
    var H = L.current === null ? null : new google.maps.Map(L.current, n);
    return x(H), H !== null && P && P(H), () => {
      H !== null && E && E(H);
    };
  }, []), nr.jsx("div", {
    id: r,
    ref: L,
    style: o,
    className: i,
    children: nr.jsx(st.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
De(lZ);
function k1(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function bj(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        k1(i, r, o, s, a, "next", l);
      }
      function a(l) {
        k1(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function wj(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Xn(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var rs = typeof document < "u";
function Cj(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return rs ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(p) {
          c && c(p), i(p);
        };
        return;
      } else
        s.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(p) {
      d.setAttribute("data-state", "error"), i(p);
    }, a.initMap = function() {
      d.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function _1(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Ej() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return _1(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return _1(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var ga = !1;
function xj() {
  return nr.jsx("div", {
    children: "Loading..."
  });
}
var Om = {
  id: "script-loader",
  version: "weekly"
};
class uZ extends Ee {
  constructor() {
    super(...arguments), fe(this, "check", null), fe(this, "state", {
      loaded: !1
    }), fe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), fe(this, "isCleaningUp", /* @__PURE__ */ bj(function* () {
      function t(n) {
        if (!ga)
          n();
        else if (rs)
          var r = window.setInterval(function() {
            ga || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), fe(this, "cleanup", () => {
      ga = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), fe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Ej(), Xn(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: wj(this.props)
      };
      Cj(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), fe(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (rs) {
      if (window.google && window.google.maps && !ga) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), rs && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (rs) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, ga = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return nr.jsxs(nr.Fragment, {
      children: [nr.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || nr.jsx(xj, {})]
    });
  }
}
fe(uZ, "defaultProps", Om);
function cZ(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function Hy(e, t) {
  if (e == null) return {};
  var n, r, o = cZ(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var L1;
function dZ(e) {
  var {
    id: t = Om.id,
    version: n = Om.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: d,
    authReferrerPolicy: p
  } = e, g = Ye(!1), [f, m] = _(!1), [h, C] = _(void 0);
  y(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), y(function() {
    rs && u && Ej();
  }, [u]), y(function() {
    f && Xn(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = wj({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: d,
    authReferrerPolicy: p
  });
  y(function() {
    if (!rs)
      return;
    function E() {
      g.current && (m(!0), L1 = w);
    }
    if (window.google && window.google.maps && L1 === w) {
      E();
      return;
    }
    Cj({
      id: t,
      url: w,
      nonce: r
    }).then(E).catch(function(v) {
      g.current && C(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var P = Ye(void 0);
  return y(function() {
    P.current && l !== P.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), P.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var pZ = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], fZ = nr.jsx(xj, {});
function hZ(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = Hy(e, pZ), {
    isLoaded: a,
    loadError: l
  } = dZ(s);
  return y(function() {
    a && typeof n == "function" && n();
  }, [a, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || fZ;
}
De(hZ);
var D1;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(D1 || (D1 = {}));
function P1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? P1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : P1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var S1 = {}, M1 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function gZ(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = _e(st), [i, s] = _(null);
  return y(() => {
    i !== null && i.setMap(o);
  }, [o]), y(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), y(() => {
    var a = new google.maps.TrafficLayer(yd(yd({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
De(gZ);
class mZ extends Ee {
  constructor() {
    super(...arguments), fe(this, "state", {
      trafficLayer: null
    }), fe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), fe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(yd(yd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _t({
      updaterMap: M1,
      eventMap: S1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: M1,
      eventMap: S1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Tt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
fe(mZ, "contextType", st);
function vZ(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = _e(st), [o, i] = _(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
De(vZ);
class yZ extends Ee {
  constructor() {
    super(...arguments), fe(this, "state", {
      bicyclingLayer: null
    }), fe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
fe(yZ, "contextType", st);
function bZ(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = _e(st), [o, i] = _(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
De(bZ);
class wZ extends Ee {
  constructor() {
    super(...arguments), fe(this, "state", {
      transitLayer: null
    }), fe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
fe(wZ, "contextType", st);
function T1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? T1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : T1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var j1 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, A1 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function CZ(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, d = _e(st), [p, g] = _(null), [f, m] = _(null), [h, C] = _(null), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null);
  return y(() => {
    p !== null && p.setMap(d);
  }, [d]), y(() => {
    t && p !== null && p.setOptions(t);
  }, [p, t]), y(() => {
    p !== null && p.setDrawingMode(n ?? null);
  }, [p, n]), y(() => {
    p && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(p, "circlecomplete", r)));
  }, [p, r]), y(() => {
    p && o && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(p, "markercomplete", o)));
  }, [p, o]), y(() => {
    p && i && (w !== null && google.maps.event.removeListener(w), P(google.maps.event.addListener(p, "overlaycomplete", i)));
  }, [p, i]), y(() => {
    p && s && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(p, "polygoncomplete", s)));
  }, [p, s]), y(() => {
    p && a && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(p, "polylinecomplete", a)));
  }, [p, a]), y(() => {
    p && l && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(p, "rectanglecomplete", l)));
  }, [p, l]), y(() => {
    Xn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(bd(bd({}, t), {}, {
      map: d
    }));
    return n && R.setDrawingMode(n), r && m(google.maps.event.addListener(R, "circlecomplete", r)), o && C(google.maps.event.addListener(R, "markercomplete", o)), i && P(google.maps.event.addListener(R, "overlaycomplete", i)), s && v(google.maps.event.addListener(R, "polygoncomplete", s)), a && L(google.maps.event.addListener(R, "polylinecomplete", a)), l && k(google.maps.event.addListener(R, "rectanglecomplete", l)), g(R), u && u(R), () => {
      p !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), E && google.maps.event.removeListener(E), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), c && c(p), p.setMap(null));
    };
  }, []), null;
}
De(CZ);
class EZ extends Ee {
  constructor(t) {
    super(t), fe(this, "registeredEvents", []), fe(this, "state", {
      drawingManager: null
    }), fe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Xn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(bd(bd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _t({
      updaterMap: A1,
      eventMap: j1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: A1,
      eventMap: j1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Tt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
fe(EZ, "contextType", st);
function B1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function As(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? B1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : B1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var I1 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, F1 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, wd = {};
function xZ(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: d,
    label: p,
    opacity: g,
    shape: f,
    title: m,
    zIndex: h,
    onClick: C,
    onDblClick: w,
    onDrag: P,
    onDragEnd: E,
    onDragStart: v,
    onMouseOut: x,
    onMouseOver: L,
    onMouseUp: z,
    onMouseDown: k,
    onRightClick: R,
    onClickableChanged: A,
    onCursorChanged: U,
    onAnimationChanged: V,
    onDraggableChanged: N,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: D,
    onZindexChanged: j,
    onLoad: G,
    onUnmount: S
  } = e, Y = _e(st), [O, M] = _(null), [W, T] = _(null), [q, I] = _(null), [J, H] = _(null), [ce, ye] = _(null), [ie, Te] = _(null), [Re, Ne] = _(null), [Ie, Ke] = _(null), [Ze, Se] = _(null), [qe, rt] = _(null), [Pe, Me] = _(null), [Ge, He] = _(null), [$e, ot] = _(null), [Fe, Kt] = _(null), [lt, ht] = _(null), [Dt, ln] = _(null), [Pt, St] = _(null), [ut, Xe] = _(null), [un, cn] = _(null), [Nt, Gn] = _(null), [zt, Yn] = _(null), [$t, Sn] = _(null);
  y(() => {
    O !== null && O.setMap(Y);
  }, [Y]), y(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), y(() => {
    typeof s < "u" && O !== null && O.setDraggable(s);
  }, [O, s]), y(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), y(() => {
    typeof a < "u" && O !== null && O.setVisible(a);
  }, [O, a]), y(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), y(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), y(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), y(() => {
    O && d !== void 0 && O.setIcon(d);
  }, [O, d]), y(() => {
    O && p !== void 0 && O.setLabel(p);
  }, [O, p]), y(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), y(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), y(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), y(() => {
    O && h !== void 0 && O.setZIndex(h);
  }, [O, h]), y(() => {
    O && w && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), y(() => {
    O && E && (q !== null && google.maps.event.removeListener(q), I(google.maps.event.addListener(O, "dragend", E)));
  }, [E]), y(() => {
    O && v && (J !== null && google.maps.event.removeListener(J), H(google.maps.event.addListener(O, "dragstart", v)));
  }, [v]), y(() => {
    O && k && (ce !== null && google.maps.event.removeListener(ce), ye(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), y(() => {
    O && x && (ie !== null && google.maps.event.removeListener(ie), Te(google.maps.event.addListener(O, "mouseout", x)));
  }, [x]), y(() => {
    O && L && (Re !== null && google.maps.event.removeListener(Re), Ne(google.maps.event.addListener(O, "mouseover", L)));
  }, [L]), y(() => {
    O && z && (Ie !== null && google.maps.event.removeListener(Ie), Ke(google.maps.event.addListener(O, "mouseup", z)));
  }, [z]), y(() => {
    O && R && (Ze !== null && google.maps.event.removeListener(Ze), Se(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), y(() => {
    O && C && (qe !== null && google.maps.event.removeListener(qe), rt(google.maps.event.addListener(O, "click", C)));
  }, [C]), y(() => {
    O && P && (Pe !== null && google.maps.event.removeListener(Pe), Me(google.maps.event.addListener(O, "drag", P)));
  }, [P]), y(() => {
    O && A && (Ge !== null && google.maps.event.removeListener(Ge), He(google.maps.event.addListener(O, "clickable_changed", A)));
  }, [A]), y(() => {
    O && U && ($e !== null && google.maps.event.removeListener($e), ot(google.maps.event.addListener(O, "cursor_changed", U)));
  }, [U]), y(() => {
    O && V && (Fe !== null && google.maps.event.removeListener(Fe), Kt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), y(() => {
    O && N && (lt !== null && google.maps.event.removeListener(lt), ht(google.maps.event.addListener(O, "draggable_changed", N)));
  }, [N]), y(() => {
    O && Z && (Dt !== null && google.maps.event.removeListener(Dt), ln(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), y(() => {
    O && K && (Pt !== null && google.maps.event.removeListener(Pt), St(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), y(() => {
    O && X && (ut !== null && google.maps.event.removeListener(ut), Xe(google.maps.event.addListener(O, "position_changed", X)));
  }, [X]), y(() => {
    O && te && (un !== null && google.maps.event.removeListener(un), cn(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), y(() => {
    O && ee && (Nt !== null && google.maps.event.removeListener(Nt), Gn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), y(() => {
    O && D && (zt !== null && google.maps.event.removeListener(zt), Yn(google.maps.event.addListener(O, "visible_changed", D)));
  }, [D]), y(() => {
    O && j && ($t !== null && google.maps.event.removeListener($t), Sn(google.maps.event.addListener(O, "zindex_changed", j)));
  }, [j]), y(() => {
    var Ut = As(As(As({}, n || wd), r ? wd : {
      map: Y
    }), {}, {
      position: t
    }), oe = new google.maps.Marker(Ut);
    return r ? r.addMarker(oe, !!o) : oe.setMap(Y), t && oe.setPosition(t), typeof a < "u" && oe.setVisible(a), typeof s < "u" && oe.setDraggable(s), typeof u < "u" && oe.setClickable(u), typeof c == "string" && oe.setCursor(c), d && oe.setIcon(d), typeof p < "u" && oe.setLabel(p), typeof g < "u" && oe.setOpacity(g), f && oe.setShape(f), typeof m == "string" && oe.setTitle(m), typeof h == "number" && oe.setZIndex(h), w && T(google.maps.event.addListener(oe, "dblclick", w)), E && I(google.maps.event.addListener(oe, "dragend", E)), v && H(google.maps.event.addListener(oe, "dragstart", v)), k && ye(google.maps.event.addListener(oe, "mousedown", k)), x && Te(google.maps.event.addListener(oe, "mouseout", x)), L && Ne(google.maps.event.addListener(oe, "mouseover", L)), z && Ke(google.maps.event.addListener(oe, "mouseup", z)), R && Se(google.maps.event.addListener(oe, "rightclick", R)), C && rt(google.maps.event.addListener(oe, "click", C)), P && Me(google.maps.event.addListener(oe, "drag", P)), A && He(google.maps.event.addListener(oe, "clickable_changed", A)), U && ot(google.maps.event.addListener(oe, "cursor_changed", U)), V && Kt(google.maps.event.addListener(oe, "animation_changed", V)), N && ht(google.maps.event.addListener(oe, "draggable_changed", N)), Z && ln(google.maps.event.addListener(oe, "flat_changed", Z)), K && St(google.maps.event.addListener(oe, "icon_changed", K)), X && Xe(google.maps.event.addListener(oe, "position_changed", X)), te && cn(google.maps.event.addListener(oe, "shape_changed", te)), ee && Gn(google.maps.event.addListener(oe, "title_changed", ee)), D && Yn(google.maps.event.addListener(oe, "visible_changed", D)), j && Sn(google.maps.event.addListener(oe, "zindex_changed", j)), M(oe), G && G(oe), () => {
      W !== null && google.maps.event.removeListener(W), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ce !== null && google.maps.event.removeListener(ce), ie !== null && google.maps.event.removeListener(ie), Re !== null && google.maps.event.removeListener(Re), Ie !== null && google.maps.event.removeListener(Ie), Ze !== null && google.maps.event.removeListener(Ze), qe !== null && google.maps.event.removeListener(qe), Ge !== null && google.maps.event.removeListener(Ge), $e !== null && google.maps.event.removeListener($e), Fe !== null && google.maps.event.removeListener(Fe), lt !== null && google.maps.event.removeListener(lt), Dt !== null && google.maps.event.removeListener(Dt), Pt !== null && google.maps.event.removeListener(Pt), ut !== null && google.maps.event.removeListener(ut), Nt !== null && google.maps.event.removeListener(Nt), zt !== null && google.maps.event.removeListener(zt), $t !== null && google.maps.event.removeListener($t), S && S(oe), r ? r.removeMarker(oe, !!o) : oe && oe.setMap(null);
    };
  }, []);
  var pr = qn(() => i ? Ct.map(i, (Ut) => {
    if (!mi(Ut))
      return Ut;
    var oe = Ut;
    return vi(oe, {
      anchor: O
    });
  }) : null, [i, O]);
  return nr.jsx(nr.Fragment, {
    children: pr
  }) || null;
}
De(xZ);
class OZ extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return bj(function* () {
      var n = As(As(As({}, t.props.options || wd), t.props.clusterer ? wd : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = _t({
        updaterMap: F1,
        eventMap: I1,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: F1,
      eventMap: I1,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Tt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? Ct.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
fe(OZ, "contextType", st);
var kZ = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), d = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(d !== null ? "".concat(d.y, "px") : "0", "; left: ").concat(d !== null ? "".concat(d.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var p = document.createElement("img");
        p.alt = a, p.src = this.url, p.width = this.width, p.height = this.height, p.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (p.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(p), this.div.appendChild(g), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), _Z = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new kZ(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function LZ(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var DZ = 2e3, PZ = 500, SZ = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", MZ = "png", TZ = [53, 56, 66, 78, 90], jZ = "cluster", Oj = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || SZ, this.imageExtension = r.imageExtension || MZ, this.imageSizes = r.imageSizes || TZ, this.calculator = r.calculator || LZ, this.batchSize = r.batchSize || DZ, this.batchSizeIE = r.batchSizeIE || PZ, this.clusterClass = r.clusterClass || jZ, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new _Z(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var d = 0, p = this.clusters; d < p.length; d++) {
            var g = p[d];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function R1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function AZ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? R1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : R1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yr = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Bt = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, BZ = {};
function IZ(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: d,
    imageSizes: p,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: h,
    zoomOnClick: C,
    onClick: w,
    onClusteringBegin: P,
    onClusteringEnd: E,
    onMouseOver: v,
    onMouseOut: x,
    onLoad: L,
    onUnmount: z
  } = e, [k, R] = _(null), A = _e(st), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null);
  return y(() => {
    k && x && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(k, Yr.onMouseOut, x)));
  }, [x]), y(() => {
    k && v && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(k, Yr.onMouseOver, v)));
  }, [v]), y(() => {
    k && w && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(k, Yr.onClick, w)));
  }, [w]), y(() => {
    k && P && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(k, Yr.onClusteringBegin, P)));
  }, [P]), y(() => {
    k && E && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(k, Yr.onClusteringEnd, E)));
  }, [E]), y(() => {
    typeof r < "u" && k !== null && Bt.averageCenter(k, r);
  }, [k, r]), y(() => {
    typeof o < "u" && k !== null && Bt.batchSizeIE(k, o);
  }, [k, o]), y(() => {
    typeof i < "u" && k !== null && Bt.calculator(k, i);
  }, [k, i]), y(() => {
    typeof s < "u" && k !== null && Bt.clusterClass(k, s);
  }, [k, s]), y(() => {
    typeof a < "u" && k !== null && Bt.enableRetinaIcons(k, a);
  }, [k, a]), y(() => {
    typeof l < "u" && k !== null && Bt.gridSize(k, l);
  }, [k, l]), y(() => {
    typeof u < "u" && k !== null && Bt.ignoreHidden(k, u);
  }, [k, u]), y(() => {
    typeof c < "u" && k !== null && Bt.imageExtension(k, c);
  }, [k, c]), y(() => {
    typeof d < "u" && k !== null && Bt.imagePath(k, d);
  }, [k, d]), y(() => {
    typeof p < "u" && k !== null && Bt.imageSizes(k, p);
  }, [k, p]), y(() => {
    typeof g < "u" && k !== null && Bt.maxZoom(k, g);
  }, [k, g]), y(() => {
    typeof f < "u" && k !== null && Bt.minimumClusterSize(k, f);
  }, [k, f]), y(() => {
    typeof m < "u" && k !== null && Bt.styles(k, m);
  }, [k, m]), y(() => {
    typeof h < "u" && k !== null && Bt.title(k, h);
  }, [k, h]), y(() => {
    typeof C < "u" && k !== null && Bt.zoomOnClick(k, C);
  }, [k, C]), y(() => {
    if (A) {
      var G = AZ({}, n || BZ), S = new Oj(A, [], G);
      return r && Bt.averageCenter(S, r), o && Bt.batchSizeIE(S, o), i && Bt.calculator(S, i), s && Bt.clusterClass(S, s), a && Bt.enableRetinaIcons(S, a), l && Bt.gridSize(S, l), u && Bt.ignoreHidden(S, u), c && Bt.imageExtension(S, c), d && Bt.imagePath(S, d), p && Bt.imageSizes(S, p), g && Bt.maxZoom(S, g), f && Bt.minimumClusterSize(S, f), m && Bt.styles(S, m), h && Bt.title(S, h), C && Bt.zoomOnClick(S, C), x && ee(google.maps.event.addListener(S, Yr.onMouseOut, x)), v && j(google.maps.event.addListener(S, Yr.onMouseOver, v)), w && V(google.maps.event.addListener(S, Yr.onClick, w)), P && Z(google.maps.event.addListener(S, Yr.onClusteringBegin, P)), E && X(google.maps.event.addListener(S, Yr.onClusteringEnd, E)), R(S), L && L(S), () => {
        te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), z && z(S);
      };
    }
  }, []), k !== null && t(k) || null;
}
De(IZ);
class FZ extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      markerClusterer: null
    }), fe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Oj(this.context, [], this.props.options);
      this.registeredEvents = _t({
        updaterMap: Bt,
        eventMap: Yr,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: Bt,
      eventMap: Yr,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Tt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
fe(FZ, "contextType", st);
function N1(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var kj = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || N1(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, N1));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, d = this.div.offsetWidth, p = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), h = m.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + g ? r = h.x + u - g : h.x + d + u + g > a && (r = h.x + d + u + g - a), this.alignBottom ? h.y < -c + f + p ? o = h.y + c - f - p : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + p + c + f > l && (o = h.y + p + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), RZ = ["position"], NZ = ["position"];
function z1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? z1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : z1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $1 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, U1 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, zZ = {};
function $Z(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: p
  } = e, g = _e(st), [f, m] = _(null), [h, C] = _(null), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), R = Ye(null);
  return y(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    if (o && f !== null) {
      var A = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(A);
    }
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), P(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    if (g) {
      var A = r || zZ, {
        position: U
      } = A, V = Hy(A, RZ), N;
      U && !(U instanceof google.maps.LatLng) && (N = new google.maps.LatLng(U.lat, U.lng));
      var Z = new kj(Cd(Cd({}, V), N ? {
        position: N
      } : {}));
      R.current = document.createElement("div"), m(Z), s && C(google.maps.event.addListener(Z, "closeclick", s)), a && P(google.maps.event.addListener(Z, "domready", a)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && L(google.maps.event.addListener(Z, "position_changed", u)), c && k(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(R.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : Xn(!1, "You must provide either an anchor or a position prop for <InfoBox>."), d && d(Z);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), p && p(f), f.close());
    };
  }, []), R.current ? dr(Ct.only(t), R.current) : null;
}
De($Z);
class UZ extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "containerElement", null), fe(this, "state", {
      infoBox: null
    }), fe(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Xn(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), fe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = Hy(t, NZ), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new kj(Cd(Cd({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = _t({
      updaterMap: U1,
      eventMap: $1,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: U1,
      eventMap: $1,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Tt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? dr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
fe(UZ, "contextType", st);
var H1, W1;
function HZ() {
  return W1 || (W1 = 1, H1 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), H1;
}
var WZ = HZ(), V1 = /* @__PURE__ */ yj(WZ), Z1 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Sh = 1, ma = 8;
class Wy {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Sh)
      throw new Error("Got v".concat(o, " data when expected v").concat(Sh, "."));
    var i = Z1[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new Wy(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = Z1.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, ma, t), this.coords = new this.ArrayType(this.data, ma + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(ma + s + a + l), this.ids = new this.IndexArrayType(this.data, ma, t), this.coords = new this.ArrayType(this.data, ma + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Sh << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return km(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, d = l.pop() || 0, p = l.pop() || 0;
      if (d - p <= a) {
        for (var g = p; g <= d; g++) {
          var f = s[2 * g], m = s[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var h = p + d >> 1, C = s[2 * h], w = s[2 * h + 1];
      C >= t && C <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= C : n <= w) && (l.push(p), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= C : o >= w) && (l.push(h + 1), l.push(d), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, d = a.pop() || 0, p = a.pop() || 0;
      if (d - p <= s) {
        for (var g = p; g <= d; g++)
          q1(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = p + d >> 1, m = i[2 * f], h = i[2 * f + 1];
      q1(m, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= h) && (a.push(p), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= m : n + r >= h) && (a.push(f + 1), a.push(d), a.push(1 - c));
    }
    return l;
  }
}
function km(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    _j(e, t, s, r, o, i), km(e, t, n, r, s - 1, 1 - i), km(e, t, n, s + 1, o, 1 - i);
  }
}
function _j(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), d = Math.max(r, Math.floor(n - a * u / s + c)), p = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      _j(e, t, n, d, p, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (va(e, t, r, n), t[2 * o + i] > g && va(e, t, r, o); f < m; ) {
      for (va(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? va(e, t, r, m) : (m++, va(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function va(e, t, n, r) {
  Mh(e, n, r), Mh(t, 2 * n, 2 * r), Mh(t, 2 * n + 1, 2 * r + 1);
}
function Mh(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function q1(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var VZ = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, G1 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), $i = 2, ri = 3, Th = 4, Qo = 5, Lj = 6;
class ZZ {
  constructor(t) {
    this.options = Object.assign(Object.create(VZ), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, d = G1(Ku(u)), p = G1(Xu(c));
        s.push(
          d,
          p,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Ku(r), Xu(s), Ku(i), Xu(o)), d = u.data, p = [];
    for (var g of c) {
      var f = this.stride * g;
      p.push(d[f + Qo] > 1 ? Y1(d, f, this.clusterProps) : this.points[d[f + ri]]);
    }
    return p;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), d = [];
    for (var p of c) {
      var g = p * this.stride;
      s[g + Th] === t && d.push(s[g + Qo] > 1 ? Y1(s, g, this.clusterProps) : this.points[s[g + ri]]);
    }
    if (d.length === 0) throw new Error(o);
    return d;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, d = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, d), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, d), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, d), d.features.length ? d : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Wy(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + Qo] > 1, c = void 0, d = void 0, p = void 0;
      if (u)
        c = Dj(n, l, this.clusterProps), d = n[l], p = n[l + 1];
      else {
        var g = this.points[n[l + ri]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        d = Ku(f), p = Xu(m);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (d * i - r)), Math.round(this.options.extent * (p * i - o))]],
        tags: c
      }, C = void 0;
      u || this.options.generateId ? C = n[l + ri] : C = this.points[n[l + ri]].id, C !== void 0 && (h.id = C), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, d = 0; d < l.length; d += c)
      if (!(l[d + $i] <= n)) {
        l[d + $i] = n;
        var p = l[d], g = l[d + 1], f = t.within(l[d], l[d + 1], a), m = l[d + Qo], h = m;
        for (var C of f) {
          var w = C * c;
          l[w + $i] > n && (h += l[w + Qo]);
        }
        if (h > m && h >= s) {
          var P = p * m, E = g * m, v = void 0, x = -1, L = ((d / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var k = z * c;
            if (!(l[k + $i] <= n)) {
              l[k + $i] = n;
              var R = l[k + Qo];
              P += l[k] * R, E += l[k + 1] * R, l[k + Th] = L, i && (v || (v = this._map(l, d, !0), x = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, k)));
            }
          }
          l[d + Th] = L, u.push(P / h, E / h, 1 / 0, L, -1, h), i && u.push(x);
        } else {
          for (var A = 0; A < c; A++) u.push(l[d + A]);
          if (h > 1)
            for (var U of f) {
              var V = U * c;
              if (!(l[V + $i] <= n)) {
                l[V + $i] = n;
                for (var N = 0; N < c; N++) u.push(l[V + N]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Qo] > 1) {
      var o = this.clusterProps[t[n + Lj]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + ri]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function Y1(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ri],
    properties: Dj(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [qZ(e[t]), GZ(e[t + 1])]
    }
  };
}
function Dj(e, t, n) {
  var r = e[t + Qo], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Lj], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + ri],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Ku(e) {
  return e / 360 + 0.5;
}
function Xu(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function qZ(e) {
  return (e - 0.5) * 360;
}
function GZ(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function YZ(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Fr {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class _m {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Fr.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Fr.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Fr.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class KZ {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return XZ(n);
  }
}
var XZ = (e) => {
  var t = e.map((n) => new _m({
    position: Fr.getPosition(n),
    markers: [n]
  }));
  return t;
};
class JZ extends KZ {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = YZ(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new ZZ(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!V1(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = Fr.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !V1(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new _m({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new _m({
      markers: [i],
      position: Fr.getPosition(i)
    });
  }
}
class QZ {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class eq {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Fr.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), d = c.parseFromString(a, "image/svg+xml").documentElement;
      d.setAttribute("transform", "translate(0 25)");
      var p = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: d
      };
      return new google.maps.marker.AdvancedMarkerElement(p);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function tq(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Vy {
  constructor() {
    tq(Vy, google.maps.OverlayView);
  }
}
var Va;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Va || (Va = {}));
var nq = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class rq extends Vy {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new JZ(o),
      renderer: s = new eq(),
      onClusterClick: a = nq
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Fr.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Va.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || Fr.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => Fr.setMap(l, null)));
      }
      google.maps.event.trigger(this, Va.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Fr.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new QZ(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Fr.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Va.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Fr.setMap(r.marker, n);
    });
  }
}
function K1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function X1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? K1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : K1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function oq(e) {
  var t = nZ(), [n, r] = _(null);
  return y(() => {
    if (t && n === null) {
      var o = new rq(X1(X1({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function iq(e) {
  var {
    children: t,
    options: n
  } = e, r = oq(n);
  return r !== null ? t(r) : null;
}
De(iq);
var J1 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Q1 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function sq(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: p
  } = e, g = _e(st), [f, m] = _(null), [h, C] = _(null), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), R = Ye(null);
  return y(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), P(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    var A = new google.maps.InfoWindow(r);
    return m(A), R.current = document.createElement("div"), s && C(google.maps.event.addListener(A, "closeclick", s)), a && P(google.maps.event.addListener(A, "domready", a)), l && v(google.maps.event.addListener(A, "content_changed", l)), u && L(google.maps.event.addListener(A, "position_changed", u)), c && k(google.maps.event.addListener(A, "zindex_changed", c)), A.setContent(R.current), o && A.setPosition(o), i && A.setZIndex(i), n ? A.open(g, n) : A.getPosition() ? A.open(g) : Xn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), d && d(A), () => {
      h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), p && p(A), A.close();
    };
  }, []), R.current ? dr(Ct.only(t), R.current) : null;
}
De(sq);
class aq extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "containerElement", null), fe(this, "state", {
      infoWindow: null
    }), fe(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Xn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), fe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = _t({
      updaterMap: Q1,
      eventMap: J1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: Q1,
      eventMap: J1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Tt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? dr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
fe(aq, "contextType", st);
function eO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ed(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tO = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, nO = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, lq = {};
function uq(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: p,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onLoad: C,
    onUnmount: w
  } = e, P = _e(st), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null);
  return y(() => {
    E !== null && E.setMap(P);
  }, [P]), y(() => {
    typeof t < "u" && E !== null && E.setOptions(t);
  }, [E, t]), y(() => {
    typeof n < "u" && E !== null && E.setDraggable(n);
  }, [E, n]), y(() => {
    typeof r < "u" && E !== null && E.setEditable(r);
  }, [E, r]), y(() => {
    typeof o < "u" && E !== null && E.setVisible(o);
  }, [E, o]), y(() => {
    typeof i < "u" && E !== null && E.setPath(i);
  }, [E, i]), y(() => {
    E && s && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(E, "dblclick", s)));
  }, [s]), y(() => {
    E && a && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(E, "dragend", a)));
  }, [a]), y(() => {
    E && l && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(E, "dragstart", l)));
  }, [l]), y(() => {
    E && u && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(E, "mousedown", u)));
  }, [u]), y(() => {
    E && c && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(() => {
    E && d && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(E, "mouseout", d)));
  }, [d]), y(() => {
    E && p && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(E, "mouseover", p)));
  }, [p]), y(() => {
    E && g && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(E, "mouseup", g)));
  }, [g]), y(() => {
    E && f && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(E, "rightclick", f)));
  }, [f]), y(() => {
    E && m && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(E, "click", m)));
  }, [m]), y(() => {
    E && h && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(E, "drag", h)));
  }, [h]), y(() => {
    var T = new google.maps.Polyline(Ed(Ed({}, t || lq), {}, {
      map: P
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), s && L(google.maps.event.addListener(T, "dblclick", s)), a && k(google.maps.event.addListener(T, "dragend", a)), l && A(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), d && X(google.maps.event.addListener(T, "mouseout", d)), p && ee(google.maps.event.addListener(T, "mouseover", p)), g && j(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && O(google.maps.event.addListener(T, "click", m)), h && W(google.maps.event.addListener(T, "drag", h)), v(T), C && C(T), () => {
      x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), G !== null && google.maps.event.removeListener(G), Y !== null && google.maps.event.removeListener(Y), w && w(T), T.setMap(null);
    };
  }, []), null;
}
De(uq);
class cq extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      polyline: null
    }), fe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Ed(Ed({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _t({
      updaterMap: nO,
      eventMap: tO,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: nO,
      eventMap: tO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Tt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
fe(cq, "contextType", st);
function rO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var iO = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, sO = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function dq(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: p,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: C,
    onLoad: w,
    onUnmount: P,
    onEdit: E
  } = e, v = _e(st), [x, L] = _(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null), [T, q] = _(null);
  return y(() => {
    x !== null && x.setMap(v);
  }, [v]), y(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), y(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), y(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), y(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), y(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), y(() => {
    typeof s < "u" && x !== null && x.setPaths(s);
  }, [x, s]), y(() => {
    x && typeof a == "function" && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), y(() => {
    x && (google.maps.event.addListener(x.getPath(), "insert_at", () => {
      E == null || E(x);
    }), google.maps.event.addListener(x.getPath(), "set_at", () => {
      E == null || E(x);
    }), google.maps.event.addListener(x.getPath(), "remove_at", () => {
      E == null || E(x);
    }));
  }, [x, E]), y(() => {
    x && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(x, "dragend", l)));
  }, [l]), y(() => {
    x && typeof u == "function" && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(x, "dragstart", u)));
  }, [u]), y(() => {
    x && typeof c == "function" && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(x, "mousedown", c)));
  }, [c]), y(() => {
    x && typeof d == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(x, "mousemove", d)));
  }, [d]), y(() => {
    x && typeof p == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), y(() => {
    x && typeof g == "function" && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(x, "mouseover", g)));
  }, [g]), y(() => {
    x && typeof f == "function" && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(x, "mouseup", f)));
  }, [f]), y(() => {
    x && typeof m == "function" && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(x, "rightclick", m)));
  }, [m]), y(() => {
    x && typeof h == "function" && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(x, "click", h)));
  }, [h]), y(() => {
    x && typeof C == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(x, "drag", C)));
  }, [C]), y(() => {
    var I = new google.maps.Polygon(oO(oO({}, t), {}, {
      map: v
    }));
    return i && I.setPath(i), s && I.setPaths(s), typeof o < "u" && I.setVisible(o), typeof r < "u" && I.setEditable(r), typeof n < "u" && I.setDraggable(n), a && k(google.maps.event.addListener(I, "dblclick", a)), l && A(google.maps.event.addListener(I, "dragend", l)), u && V(google.maps.event.addListener(I, "dragstart", u)), c && Z(google.maps.event.addListener(I, "mousedown", c)), d && X(google.maps.event.addListener(I, "mousemove", d)), p && ee(google.maps.event.addListener(I, "mouseout", p)), g && j(google.maps.event.addListener(I, "mouseover", g)), f && S(google.maps.event.addListener(I, "mouseup", f)), m && O(google.maps.event.addListener(I, "rightclick", m)), h && W(google.maps.event.addListener(I, "click", h)), C && q(google.maps.event.addListener(I, "drag", C)), L(I), w && w(I), () => {
      z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), G !== null && google.maps.event.removeListener(G), Y !== null && google.maps.event.removeListener(Y), M !== null && google.maps.event.removeListener(M), P && P(I), I.setMap(null);
    };
  }, []), null;
}
De(dq);
class pq extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = _t({
      updaterMap: sO,
      eventMap: iO,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: sO,
      eventMap: iO,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Tt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
fe(pq, "contextType", st);
function aO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lO = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, uO = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function fq(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: p,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onBoundsChanged: C,
    onLoad: w,
    onUnmount: P
  } = e, E = _e(st), [v, x] = _(null), [L, z] = _(null), [k, R] = _(null), [A, U] = _(null), [V, N] = _(null), [Z, K] = _(null), [X, te] = _(null), [ee, D] = _(null), [j, G] = _(null), [S, Y] = _(null), [O, M] = _(null), [W, T] = _(null), [q, I] = _(null);
  return y(() => {
    v !== null && v.setMap(E);
  }, [E]), y(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), y(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), y(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), y(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), y(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), y(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), z(google.maps.event.addListener(v, "dblclick", s)));
  }, [s]), y(() => {
    v && a && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(v, "dragend", a)));
  }, [a]), y(() => {
    v && l && (A !== null && google.maps.event.removeListener(A), U(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), y(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), N(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), y(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), y(() => {
    v && d && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(v, "mouseout", d)));
  }, [d]), y(() => {
    v && p && (ee !== null && google.maps.event.removeListener(ee), D(google.maps.event.addListener(v, "mouseover", p)));
  }, [p]), y(() => {
    v && g && (j !== null && google.maps.event.removeListener(j), G(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), y(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), Y(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), y(() => {
    v && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(v, "click", m)));
  }, [m]), y(() => {
    v && h && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(v, "drag", h)));
  }, [h]), y(() => {
    v && C && (q !== null && google.maps.event.removeListener(q), I(google.maps.event.addListener(v, "bounds_changed", C)));
  }, [C]), y(() => {
    var J = new google.maps.Rectangle(xd(xd({}, t), {}, {
      map: E
    }));
    return typeof i < "u" && J.setVisible(i), typeof o < "u" && J.setEditable(o), typeof r < "u" && J.setDraggable(r), typeof n < "u" && J.setBounds(n), s && z(google.maps.event.addListener(J, "dblclick", s)), a && R(google.maps.event.addListener(J, "dragend", a)), l && U(google.maps.event.addListener(J, "dragstart", l)), u && N(google.maps.event.addListener(J, "mousedown", u)), c && K(google.maps.event.addListener(J, "mousemove", c)), d && te(google.maps.event.addListener(J, "mouseout", d)), p && D(google.maps.event.addListener(J, "mouseover", p)), g && G(google.maps.event.addListener(J, "mouseup", g)), f && Y(google.maps.event.addListener(J, "rightclick", f)), m && M(google.maps.event.addListener(J, "click", m)), h && T(google.maps.event.addListener(J, "drag", h)), C && I(google.maps.event.addListener(J, "bounds_changed", C)), x(J), w && w(J), () => {
      L !== null && google.maps.event.removeListener(L), k !== null && google.maps.event.removeListener(k), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), q !== null && google.maps.event.removeListener(q), P && P(J), J.setMap(null);
    };
  }, []), null;
}
De(fq);
class hq extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      rectangle: null
    }), fe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(xd(xd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _t({
      updaterMap: uO,
      eventMap: lO,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: uO,
      eventMap: lO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Tt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
fe(hq, "contextType", st);
function cO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Od(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dO = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, pO = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, gq = {};
function mq(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: p,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: C,
    onCenterChanged: w,
    onRadiusChanged: P,
    onLoad: E,
    onUnmount: v
  } = e, x = _e(st), [L, z] = _(null), [k, R] = _(null), [A, U] = _(null), [V, N] = _(null), [Z, K] = _(null), [X, te] = _(null), [ee, D] = _(null), [j, G] = _(null), [S, Y] = _(null), [O, M] = _(null), [W, T] = _(null), [q, I] = _(null), [J, H] = _(null), [ce, ye] = _(null);
  return y(() => {
    L !== null && L.setMap(x);
  }, [x]), y(() => {
    typeof t < "u" && L !== null && L.setOptions(t);
  }, [L, t]), y(() => {
    typeof o < "u" && L !== null && L.setDraggable(o);
  }, [L, o]), y(() => {
    typeof i < "u" && L !== null && L.setEditable(i);
  }, [L, i]), y(() => {
    typeof s < "u" && L !== null && L.setVisible(s);
  }, [L, s]), y(() => {
    typeof r == "number" && L !== null && L.setRadius(r);
  }, [L, r]), y(() => {
    typeof n < "u" && L !== null && L.setCenter(n);
  }, [L, n]), y(() => {
    L && a && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(L, "dblclick", a)));
  }, [a]), y(() => {
    L && l && (A !== null && google.maps.event.removeListener(A), U(google.maps.event.addListener(L, "dragend", l)));
  }, [l]), y(() => {
    L && u && (V !== null && google.maps.event.removeListener(V), N(google.maps.event.addListener(L, "dragstart", u)));
  }, [u]), y(() => {
    L && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(L, "mousedown", c)));
  }, [c]), y(() => {
    L && d && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(L, "mousemove", d)));
  }, [d]), y(() => {
    L && p && (ee !== null && google.maps.event.removeListener(ee), D(google.maps.event.addListener(L, "mouseout", p)));
  }, [p]), y(() => {
    L && g && (j !== null && google.maps.event.removeListener(j), G(google.maps.event.addListener(L, "mouseover", g)));
  }, [g]), y(() => {
    L && f && (S !== null && google.maps.event.removeListener(S), Y(google.maps.event.addListener(L, "mouseup", f)));
  }, [f]), y(() => {
    L && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(L, "rightclick", m)));
  }, [m]), y(() => {
    L && h && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(L, "click", h)));
  }, [h]), y(() => {
    L && C && (q !== null && google.maps.event.removeListener(q), I(google.maps.event.addListener(L, "drag", C)));
  }, [C]), y(() => {
    L && w && (J !== null && google.maps.event.removeListener(J), H(google.maps.event.addListener(L, "center_changed", w)));
  }, [h]), y(() => {
    L && P && (ce !== null && google.maps.event.removeListener(ce), ye(google.maps.event.addListener(L, "radius_changed", P)));
  }, [P]), y(() => {
    var ie = new google.maps.Circle(Od(Od({}, t || gq), {}, {
      map: x
    }));
    return typeof r == "number" && ie.setRadius(r), typeof n < "u" && ie.setCenter(n), typeof r == "number" && ie.setRadius(r), typeof s < "u" && ie.setVisible(s), typeof i < "u" && ie.setEditable(i), typeof o < "u" && ie.setDraggable(o), a && R(google.maps.event.addListener(ie, "dblclick", a)), l && U(google.maps.event.addListener(ie, "dragend", l)), u && N(google.maps.event.addListener(ie, "dragstart", u)), c && K(google.maps.event.addListener(ie, "mousedown", c)), d && te(google.maps.event.addListener(ie, "mousemove", d)), p && D(google.maps.event.addListener(ie, "mouseout", p)), g && G(google.maps.event.addListener(ie, "mouseover", g)), f && Y(google.maps.event.addListener(ie, "mouseup", f)), m && M(google.maps.event.addListener(ie, "rightclick", m)), h && T(google.maps.event.addListener(ie, "click", h)), C && I(google.maps.event.addListener(ie, "drag", C)), w && H(google.maps.event.addListener(ie, "center_changed", w)), P && ye(google.maps.event.addListener(ie, "radius_changed", P)), z(ie), E && E(ie), () => {
      k !== null && google.maps.event.removeListener(k), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), J !== null && google.maps.event.removeListener(J), ce !== null && google.maps.event.removeListener(ce), v && v(ie), ie.setMap(null);
    };
  }, []), null;
}
De(mq);
class vq extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      circle: null
    }), fe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Od(Od({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _t({
      updaterMap: pO,
      eventMap: dO,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: pO,
      eventMap: dO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Tt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
fe(vq, "contextType", st);
function fO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hO = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, gO = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function yq(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: d,
    onRemoveProperty: p,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: h
  } = e, C = _e(st), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null), [T, q] = _(null);
  return y(() => {
    w !== null && w.setMap(C);
  }, [C]), y(() => {
    w && r && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), y(() => {
    w && o && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), y(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), y(() => {
    w && s && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), y(() => {
    w && a && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), y(() => {
    w && l && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), y(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), y(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), y(() => {
    w && c && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), y(() => {
    w && d && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(w, "removefeature", d)));
  }, [d]), y(() => {
    w && p && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(w, "removeproperty", p)));
  }, [p]), y(() => {
    w && g && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), y(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), y(() => {
    if (C !== null) {
      var I = new google.maps.Data(kd(kd({}, t), {}, {
        map: C
      }));
      r && v(google.maps.event.addListener(I, "dblclick", r)), o && L(google.maps.event.addListener(I, "mousedown", o)), i && k(google.maps.event.addListener(I, "mousemove", i)), s && A(google.maps.event.addListener(I, "mouseout", s)), a && V(google.maps.event.addListener(I, "mouseover", a)), l && Z(google.maps.event.addListener(I, "mouseup", l)), u && X(google.maps.event.addListener(I, "rightclick", u)), n && ee(google.maps.event.addListener(I, "click", n)), c && j(google.maps.event.addListener(I, "addfeature", c)), d && S(google.maps.event.addListener(I, "removefeature", d)), p && O(google.maps.event.addListener(I, "removeproperty", p)), g && W(google.maps.event.addListener(I, "setgeometry", g)), f && q(google.maps.event.addListener(I, "setproperty", f)), P(I), m && m(I);
    }
    return () => {
      w && (E !== null && google.maps.event.removeListener(E), x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), G !== null && google.maps.event.removeListener(G), Y !== null && google.maps.event.removeListener(Y), M !== null && google.maps.event.removeListener(M), T !== null && google.maps.event.removeListener(T), h && h(w), w.setMap(null));
    };
  }, []), null;
}
De(yq);
class bq extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      data: null
    }), fe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(kd(kd({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = _t({
        updaterMap: gO,
        eventMap: hO,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: gO,
      eventMap: hO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Tt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
fe(bq, "contextType", st);
function mO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yO = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, bO = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class wq extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      kmlLayer: null
    }), fe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(vO(vO({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _t({
      updaterMap: bO,
      eventMap: yO,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: bO,
      eventMap: yO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Tt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
fe(wq, "contextType", st);
function Pj(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Cq(e, t) {
  return new t(e.lat, e.lng);
}
function Eq(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function xq(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Oq(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function kq(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function _q(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Sj(e, t, n, r) {
  return n !== void 0 ? kq(e, t, Oq(n, google.maps.LatLngBounds, Eq)) : _q(e, t, xq(r, google.maps.LatLng, Cq));
}
function Lq(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function wO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dq(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Pq(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = Dq({}, this.container ? Pj(this.container, o) : {
        x: 0,
        y: 0
      }), u = Sj(a, l, this.bounds, this.position);
      for (var [c, d] of Object.entries(u))
        this.container.style[c] = d;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function CO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sq(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function EO(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function xO(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Mq(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = _e(st), c = qn(() => {
    var p = document.createElement("div");
    return p.style.position = "absolute", p;
  }, []), d = qn(() => Pq(c, r, t, n, a), [c, r, t, n]);
  return y(() => (i == null || i(d), d == null || d.setMap(u), () => {
    s == null || s(d), d == null || d.setMap(null);
  }), [u, d]), y(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
De(Mq);
class Js extends Ee {
  constructor(t) {
    super(t), fe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), fe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Xn(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), fe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), fe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Sq({
        x: 0,
        y: 0
      }, this.containerRef.current ? Pj(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Sj(r, o, this.props.bounds, this.props.position);
      if (!Lq(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), fe(this, "draw", () => {
      this.onPositionElement();
    }), fe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = eo();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = EO(t.position), r = EO(this.props.position), o = xO(t.bounds), i = xO(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(nr.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: Ct.only(this.props.children)
    }), t) : null;
  }
}
fe(Js, "FLOAT_PANE", "floatPane");
fe(Js, "MAP_PANE", "mapPane");
fe(Js, "MARKER_LAYER", "markerLayer");
fe(Js, "OVERLAY_LAYER", "overlayLayer");
fe(Js, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
fe(Js, "contextType", st);
function Tq() {
}
function OO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _O = {
  onDblClick: "dblclick",
  onClick: "click"
}, LO = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function jq(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = _e(st), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = qn(() => new google.maps.GroundOverlay(t, s, r), []);
  return y(() => {
    a !== null && a.setMap(i);
  }, [i]), y(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), y(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), y(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
De(jq);
class Mj extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      groundOverlay: null
    }), fe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Xn(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, kO(kO({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _t({
      updaterMap: LO,
      eventMap: _O,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: LO,
      eventMap: _O,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
fe(Mj, "defaultProps", {
  onLoad: Tq
});
fe(Mj, "contextType", st);
function DO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _d(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PO = {}, SO = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Aq(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = _e(st), [s, a] = _(null);
  return y(() => {
    google.maps.visualization || Xn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(() => {
    Xn(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), y(() => {
    s !== null && s.setMap(i);
  }, [i]), y(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), y(() => {
    var l = new google.maps.visualization.HeatmapLayer(_d(_d({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
De(Aq);
class Bq extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      heatmapLayer: null
    }), fe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Xn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Xn(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(_d(_d({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = _t({
      updaterMap: SO,
      eventMap: PO,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: SO,
      eventMap: PO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Tt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
fe(Bq, "contextType", st);
var MO = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, TO = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Iq extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      streetViewPanorama: null
    }), fe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = _t({
      updaterMap: TO,
      eventMap: MO,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: TO,
      eventMap: MO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Tt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
fe(Iq, "contextType", st);
class Fq extends Ee {
  constructor() {
    super(...arguments), fe(this, "state", {
      streetViewService: null
    }), fe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
fe(Fq, "contextType", st);
var jO = {
  onDirectionsChanged: "directions_changed"
}, AO = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Rq extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      directionsRenderer: null
    }), fe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = _t({
      updaterMap: AO,
      eventMap: jO,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: AO,
      eventMap: jO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Tt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
fe(Rq, "contextType", st);
var BO = {
  onPlacesChanged: "places_changed"
}, IO = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Nq extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "containerElement", eo()), fe(this, "state", {
      searchBox: null
    }), fe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Xn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = _t({
          updaterMap: IO,
          eventMap: BO,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: IO,
      eventMap: BO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Tt(this.registeredEvents));
  }
  render() {
    return nr.jsx("div", {
      ref: this.containerElement,
      children: Ct.only(this.props.children)
    });
  }
}
fe(Nq, "contextType", st);
var FO = {
  onPlaceChanged: "place_changed"
}, RO = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class Tj extends Ee {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "containerElement", eo()), fe(this, "state", {
      autocomplete: null
    }), fe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Xn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = _t({
        updaterMap: RO,
        eventMap: FO,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Tt(this.registeredEvents), this.registeredEvents = _t({
      updaterMap: RO,
      eventMap: FO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Tt(this.registeredEvents);
  }
  render() {
    return nr.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: Ct.only(this.props.children)
    });
  }
}
fe(Tj, "defaultProps", {
  className: ""
});
fe(Tj, "contextType", st);
let zq = { data: "" }, $q = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || zq, Uq = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Hq = /\/\*[^]*?\*\/|  +/g, NO = /\n+/g, ui = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? ui(s, i) : i + "{" + ui(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += ui(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ui.p ? ui.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Lo = {}, jj = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + jj(e[n]);
    return t;
  }
  return e;
}, Wq = (e, t, n, r, o) => {
  let i = jj(e), s = Lo[i] || (Lo[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Lo[s]) {
    let l = i !== e ? e : ((u) => {
      let c, d, p = [{}];
      for (; c = Uq.exec(u.replace(Hq, "")); ) c[4] ? p.shift() : c[3] ? (d = c[3].replace(NO, " ").trim(), p.unshift(p[0][d] = p[0][d] || {})) : p[0][c[1]] = c[2].replace(NO, " ").trim();
      return p[0];
    })(e);
    Lo[s] = ui(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Lo.g ? Lo.g : null;
  return n && (Lo.g = Lo[s]), ((l, u, c, d) => {
    d ? u.data = u.data.replace(d, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Lo[s], t, r, a), s;
}, Vq = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : ui(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function af(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Wq(n.unshift ? n.raw ? Vq(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, $q(t.target), t.g, t.o, t.k);
}
let Aj, Lm, Dm;
af.bind({ g: 1 });
let Io = af.bind({ k: 1 });
function Zq(e, t, n, r) {
  ui.p = t, Aj = e, Lm = n, Dm = r;
}
function Di(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: Lm && Lm() }, a), n.o = / *go\d+/.test(l), a.className = af.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), Dm && u[0] && Dm(a), Aj(u, a);
    }
    return o;
  };
}
var qq = (e) => typeof e == "function", Gq = (e, t) => qq(e) ? e(t) : e, Yq = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Kq = Io`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Xq = Io`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Jq = Io`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Qq = Di("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Kq} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Xq} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Jq} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, eG = Io`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, tG = Di("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${eG} 1s linear infinite;
`, nG = Io`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, rG = Io`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, oG = Di("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${nG} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${rG} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, iG = Di("div")`
  position: absolute;
`, sG = Di("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, aG = Io`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, lG = Di("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${aG} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, uG = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ue.createElement(lG, null, t) : t : n === "blank" ? null : Ue.createElement(sG, null, Ue.createElement(tG, { ...r }), n !== "loading" && Ue.createElement(iG, null, n === "error" ? Ue.createElement(Qq, { ...r }) : Ue.createElement(oG, { ...r })));
}, cG = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, dG = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, pG = "0%{opacity:0;} 100%{opacity:1;}", fG = "0%{opacity:1;} 100%{opacity:0;}", hG = Di("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, gG = Di("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, mG = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Yq() ? [pG, fG] : [cG(n), dG(n)];
  return { animation: t ? `${Io(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Io(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ue.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? mG(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ue.createElement(uG, { toast: e }), s = Ue.createElement(gG, { ...e.ariaProps }, Gq(e.message, e));
  return Ue.createElement(hG, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ue.createElement(Ue.Fragment, null, i, s));
});
Zq(Ue.createElement);
af`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function Zy(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: s,
    rightIcon: a,
    disabled: l,
    className: u = "",
    children: c,
    ...d
  } = e, p = { xs: 12, sm: 16, md: 20, lg: 24 }[i], g = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ Rt.jsxs("button", { className: g, disabled: l || t, ...d, children: [
    /* @__PURE__ */ Rt.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ Rt.jsx(vo, { size: p, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ Rt.jsxs("div", { className: "arkynButtonContent", children: [
      z0(p, s),
      c,
      z0(p, a)
    ] })
  ] });
}
function vG() {
  const e = ov(), t = jP(), n = iv(), [r, o] = _(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function s() {
    r && o(null);
  }
  y(() => {
    var u, c;
    let d = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, d) || Object.entries(d).length !== 0 && o(d);
  }, [n, e]), y(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && s();
  }, [n, t]);
  const a = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(a || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
Ve({});
function yG(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: s,
    className: a = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${a}`;
  return /* @__PURE__ */ Rt.jsxs(
    "button",
    {
      disabled: s || t,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ Rt.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ Rt.jsx(vo, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ Rt.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ Rt.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function bG(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...s
  } = e, a = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ Rt.jsxs("div", { className: a.trim(), ...s, children: [
    r,
    /* @__PURE__ */ Rt.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function wG(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const CG = {
  CNPJ: "99.999.999/9999-99"
};
wG(CG.CNPJ).length;
Tr((e, t) => /* @__PURE__ */ Rt.jsx("input", { ref: t, ...e }));
function Bj(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Ij = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function EG(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function xG(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const OG = Bj(Ij.NINE).length, kG = Tr((e, t) => /* @__PURE__ */ Rt.jsx("input", { ref: t, ...e }));
Tr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: s, currentCountry: a, disabled: l } = e, [u, c] = _(!1);
    y(() => {
      u ? i(a.mask) : c(!0);
    }, [a]);
    const d = `phoneInputMask ${o}`;
    function p(g) {
      let f = Bj(g.target.value);
      const m = xG(f);
      f.length > OG || (f = EG(f, Ij[m]), g.target.value = f, i(f));
    }
    return a.code === "+55" ? /* @__PURE__ */ Rt.jsx(
      "input",
      {
        value: s,
        onChange: p,
        className: d,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Rt.jsx(
      Ml,
      {
        value: s,
        onChange: (g) => i(g.target.value),
        className: d,
        component: kG,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: a.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
Ve({});
var $o = {};
Object.defineProperty($o, "__esModule", {
  value: !0
});
var _G = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), jh = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Fj = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: _G ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, qy = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Ju = 1; Ju < 20; Ju++)
  qy["f" + Ju] = 111 + Ju;
function lf(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return Rj(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return Nj(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function LG(e, t) {
  return lf(e, t);
}
function DG(e, t) {
  return lf(e, { byKey: !0 }, t);
}
function Rj(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in jh)
    r[jh[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), d; !(a = (d = c.next()).done); a = !0) {
      var p = d.value, g = p.endsWith("?") && p.length > 1;
      g && (p = p.slice(0, -1));
      var f = Gy(p), m = jh[f];
      if (p.length > 1 && !m && !Fj[p] && !qy[f])
        throw new TypeError('Unknown modifier: "' + p + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = zj(p)), m && (r[m] = g ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Nj(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function zj(e) {
  e = Gy(e);
  var t = qy[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function Gy(e) {
  return e = e.toLowerCase(), e = Fj[e] || e, e;
}
$o.default = lf;
var Ah = $o.isHotkey = lf;
$o.isCodeHotkey = LG;
$o.isKeyHotkey = DG;
$o.parseHotkey = Rj;
$o.compareHotkey = Nj;
$o.toKeyCode = zj;
$o.toKeyName = Gy;
var PG = typeof on == "object" && on && on.Object === Object && on, SG = PG, MG = SG, TG = typeof self == "object" && self && self.Object === Object && self, jG = MG || TG || Function("return this")(), AG = jG, BG = AG, IG = BG.Symbol, $j = IG, zO = $j;
zO && zO.toStringTag;
var $O = $j;
$O && $O.toStringTag;
var UO;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(UO || (UO = {}));
var Yy = function(e) {
  return Object.freeze(e);
}, FG = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Yy(this);
  }
  return e;
}(), RG = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Yy(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), HO = typeof window < "u" ? window : {};
/msie|trident/i.test(HO.navigator && HO.navigator.userAgent);
var Bh = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new FG((n ? t : e) || 0, (n ? e : t) || 0);
};
Yy({
  devicePixelContentBoxSize: Bh(),
  borderBoxSize: Bh(),
  contentBoxSize: Bh(),
  contentRect: new RG(0, 0, 0, 0)
});
function xl(e) {
  "@babel/helpers - typeof";
  return xl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, xl(e);
}
function NG(e, t) {
  if (xl(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (xl(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function zG(e) {
  var t = NG(e, "string");
  return xl(t) === "symbol" ? t : String(t);
}
function Za(e, t, n) {
  return t = zG(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var $G = /* @__PURE__ */ Ve(null), Ih, Fh;
parseInt(Oe.version.split(".")[0], 10);
var WO = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Rh = typeof navigator < "u" && /Android/.test(navigator.userAgent), Qu = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), UG = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Ih = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Ih !== void 0 && Ih[1] && parseInt((Fh = navigator.userAgent.match(/Version\/(\d+)/)) === null || Fh === void 0 ? void 0 : Fh[1], 10) < 17;
var HG = /* @__PURE__ */ new WeakMap(), WG = /* @__PURE__ */ new WeakMap(), VG = /* @__PURE__ */ new WeakMap(), ZG = /* @__PURE__ */ new WeakMap(), qG = /* @__PURE__ */ new WeakMap(), VO = /* @__PURE__ */ new WeakMap(), GG = /* @__PURE__ */ new WeakMap(), ZO = /* @__PURE__ */ new WeakMap(), ec = /* @__PURE__ */ new WeakMap(), YG = /* @__PURE__ */ new WeakMap(), KG = /* @__PURE__ */ new WeakMap(), XG = /* @__PURE__ */ new WeakMap(), Uj = globalThis.Node, JG = globalThis.Text, Hj = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, QG = (e) => Ld(e) && e.nodeType === 8, mo = (e) => Ld(e) && e.nodeType === 1, Ld = (e) => {
  var t = Hj(e);
  return !!t && e instanceof t.Node;
}, qO = (e) => {
  var t = e && e.anchorNode && Hj(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, eY = (e) => {
  var [t, n] = e;
  if (mo(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Wj(t, o, r ? "backward" : "forward"), r = o < n; mo(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = nY(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, tY = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Wj = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (QG(o) || mo(o) && o.childNodes.length === 0 || mo(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, nY = (e, t, n) => {
  var [r] = Wj(e, t, n);
  return r;
}, GO = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Vj = (e, t, n) => {
  var {
    target: r
  } = t;
  if (mo(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Ot.getWindow(e);
  if (o.contains(r))
    return Ot.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Vj(e, i, n);
}, YO = (e, t) => !!(e.compareDocumentPosition(t) & Uj.DOCUMENT_POSITION_PRECEDING), rY = (e, t) => !!(e.compareDocumentPosition(t) & Uj.DOCUMENT_POSITION_FOLLOWING), oY = 0;
class iY {
  constructor() {
    Za(this, "id", void 0), this.id = "".concat(oY++);
  }
}
var Ot = {
  androidPendingDiffs: (e) => XG.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = KG.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Ot.toDOMNode(e, e), n = Ot.findDocumentOrShadowRoot(e);
    ec.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Ot.findDocumentOrShadowRoot(e), r = GO(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && qc.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Ot.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Ot.toSlateNode(e, t.target), s = Ot.findPath(e, i);
    if (So.isElement(i) && en.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = en.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? en.before(e, u) : en.after(e, u);
      if (c) {
        var d = en.range(e, c);
        return d;
      }
    }
    var p, {
      document: g
    } = Ot.getWindow(e);
    if (g.caretRangeFromPoint)
      p = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (p = g.createRange(), p.setStart(f.offsetNode, f.offset), p.setEnd(f.offsetNode, f.offset));
    }
    if (!p)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = Ot.toSlateRange(e, p, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = VO.get(t);
    return n || (n = new iY(), VO.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = WG.get(r);
      if (o == null) {
        if (en.isEditor(r))
          return n;
        break;
      }
      var i = HG.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(jr.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!ec.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Ot.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Ot.toDOMNode(e, e), r = Ot.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = GO(r), i = Ot.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || qc.select(e, en.start(e, [])), ec.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = VG.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Ot.toDOMNode(e, e), i;
    try {
      i = mo(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Ld(t) && Ot.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return en.hasPath(e, n.path) && en.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Ot.hasEditableTarget(e, t) || Ot.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Ld(t) && Ot.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!YG.get(e),
  isFocused: (e) => !!ec.get(e),
  isReadOnly: (e) => !!ZO.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (ZO.get(e)) return !1;
    var n = Ot.hasTarget(e, t) && Ot.toSlateNode(e, t);
    return So.isElement(n) && en.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = GG.get(e), r = en.isEditor(t) ? ZG.get(e) : n == null ? void 0 : n.get(Ot.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(jr.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = en.node(e, t.path), r = Ot.toDOMNode(e, n), o;
    en.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: d
        } = c.textContent, p = u.getAttribute("data-slate-length"), g = p == null ? d : parseInt(p, 10), f = a + g, m = s[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var h, C = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            C instanceof JG ? C : m,
            (h = m.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(d, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(jr.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = dt.isBackward(t), i = Ot.toDOMPoint(e, n), s = dt.isCollapsed(t) ? i : Ot.toDOMPoint(e, r), a = Ot.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [d, p] = o ? i : s, g = mo(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = mo(d) ? d : d.parentElement, h = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(d, h ? 1 : p), l;
  },
  toSlateNode: (e, t) => {
    var n = mo(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? qG.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : eY(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var d, p, g = Ot.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), C = h && g.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), P = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var E = Ot.getWindow(e), v = E.document.createRange();
          v.setStart(u, 0), v.setEnd(s, a);
          var x = v.cloneContents(), L = [...Array.prototype.slice.call(x.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(x.querySelectorAll("[contenteditable=false]"))];
          L.forEach((S) => {
            if (Rh && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = x.textContent.length, P = u;
        }
      } else if (m) {
        for (var z = m.querySelectorAll("[data-slate-leaf]"), k = 0; k < z.length; k++) {
          var R = z[k];
          if (Ot.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), P = w, c = P.textContent.length, P.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (C) {
        var A = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], U = C.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, N = [...A(U), ...A(U == null ? void 0 : U.nextElementSibling)];
          w = (V = N.find((S) => rY(C, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...A(U == null ? void 0 : U.previousElementSibling), ...A(U)];
          w = (Z = K.findLast((S) => YO(C, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), P = w, i === "forward" ? c = 0 : (c = P.textContent.length, P.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      P && c === P.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Rh && P.getAttribute("data-slate-zero-width") === "z" && (d = P.textContent) !== null && d !== void 0 && d.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Qu && (p = P.textContent) !== null && p !== void 0 && p.endsWith(`

`)) && c--;
    }
    if (Rh && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && Ot.hasDOMNode(e, X, {
        editable: !0
      })) {
        var te = Ot.toSlateNode(e, X), {
          path: ee,
          offset: D
        } = en.start(e, Ot.findPath(e, te));
        return X.querySelector("[data-slate-leaf]") || (D = a), {
          path: ee,
          offset: D
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var j = Ot.toSlateNode(e, u), G = Ot.findPath(e, j);
    return {
      path: G,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = qO(t) ? t.anchorNode : t.startContainer, a, l, u, c, d;
    if (s)
      if (qO(t)) {
        if (Qu && t.rangeCount > 1) {
          u = t.focusNode;
          var p = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && p.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let x = function(L) {
              return L.childElementCount > 0 ? x(L.children[0]) : L;
            };
            var f = p.startContainer, m = g.startContainer, h = x(f.children[p.startOffset]), C = x(m.children[g.startOffset]);
            c = 0, C.childNodes.length > 0 ? a = C.childNodes[0] : a = C, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, C instanceof HTMLElement ? l = C.innerHTML.length : l = 0;
          } else
            p.startContainer === u ? (a = g.endContainer, l = g.endOffset, c = p.startOffset) : (a = p.startContainer, l = p.endOffset, c = g.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        UG && tY(a) || Qu ? d = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : d = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, d = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Qu && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Ot.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var P = YO(a, u) || a === u && c < l, E = d ? w : Ot.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: P ? "forward" : "backward"
    });
    if (!E)
      return null;
    var v = {
      anchor: w,
      focus: E
    };
    return dt.isExpanded(v) && dt.isForward(v) && mo(u) && en.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = en.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, sY = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, aY = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, lY = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, _n = (e) => {
  var t = sY[e], n = aY[e], r = lY[e], o = t && Ah(t), i = n && Ah(n), s = r && Ah(r);
  return (a) => !!(o && o(a) || WO && i && i(a) || !WO && s && s(a));
};
_n("bold"), _n("compose"), _n("moveBackward"), _n("moveForward"), _n("deleteBackward"), _n("deleteForward"), _n("deleteLineBackward"), _n("deleteLineForward"), _n("deleteWordBackward"), _n("deleteWordForward"), _n("extendBackward"), _n("extendForward"), _n("extendLineBackward"), _n("extendLineForward"), _n("italic"), _n("moveLineBackward"), _n("moveLineForward"), _n("moveWordBackward"), _n("moveWordForward"), _n("redo"), _n("insertSoftBreak"), _n("splitBlock"), _n("transposeCharacter"), _n("undo");
var uY = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => Vj(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, cY = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class dY extends Kd {
  constructor() {
    super(...arguments), Za(this, "context", null), Za(this, "manager", null), Za(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, cY);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = uY(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Za(dY, "contextType", $G);
Ve({});
Ve({});
Ve({});
var Vn = {}, Ky = {}, ql = {}, Gl = {}, Zj = "Expected a function", KO = NaN, pY = "[object Symbol]", fY = /^\s+|\s+$/g, hY = /^[-+]0x[0-9a-f]+$/i, gY = /^0b[01]+$/i, mY = /^0o[0-7]+$/i, vY = parseInt, yY = typeof on == "object" && on && on.Object === Object && on, bY = typeof self == "object" && self && self.Object === Object && self, wY = yY || bY || Function("return this")(), CY = Object.prototype, EY = CY.toString, xY = Math.max, OY = Math.min, Nh = function() {
  return wY.Date.now();
};
function kY(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, d = !1, p = !0;
  if (typeof e != "function")
    throw new TypeError(Zj);
  t = XO(t) || 0, Dd(n) && (c = !!n.leading, d = "maxWait" in n, i = d ? xY(XO(n.maxWait) || 0, t) : i, p = "trailing" in n ? !!n.trailing : p);
  function g(x) {
    var L = r, z = o;
    return r = o = void 0, u = x, s = e.apply(z, L), s;
  }
  function f(x) {
    return u = x, a = setTimeout(C, t), c ? g(x) : s;
  }
  function m(x) {
    var L = x - l, z = x - u, k = t - L;
    return d ? OY(k, i - z) : k;
  }
  function h(x) {
    var L = x - l, z = x - u;
    return l === void 0 || L >= t || L < 0 || d && z >= i;
  }
  function C() {
    var x = Nh();
    if (h(x))
      return w(x);
    a = setTimeout(C, m(x));
  }
  function w(x) {
    return a = void 0, p && r ? g(x) : (r = o = void 0, s);
  }
  function P() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function E() {
    return a === void 0 ? s : w(Nh());
  }
  function v() {
    var x = Nh(), L = h(x);
    if (r = arguments, o = this, l = x, L) {
      if (a === void 0)
        return f(l);
      if (d)
        return a = setTimeout(C, t), g(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return v.cancel = P, v.flush = E, v;
}
function _Y(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Zj);
  return Dd(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), kY(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Dd(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function LY(e) {
  return !!e && typeof e == "object";
}
function DY(e) {
  return typeof e == "symbol" || LY(e) && EY.call(e) == pY;
}
function XO(e) {
  if (typeof e == "number")
    return e;
  if (DY(e))
    return KO;
  if (Dd(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Dd(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(fY, "");
  var n = gY.test(e);
  return n || mY.test(e) ? vY(e.slice(2), n ? 2 : 8) : hY.test(e) ? KO : +e;
}
var PY = _Y, Yl = {};
Object.defineProperty(Yl, "__esModule", {
  value: !0
});
Yl.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Sc.has(t) || Sc.set(t, /* @__PURE__ */ new Set());
  var o = Sc.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Yl.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Sc.get(t).delete(n.name || t);
};
var Sc = /* @__PURE__ */ new Map();
Object.defineProperty(Gl, "__esModule", {
  value: !0
});
var SY = PY, MY = TY(SY), JO = Yl;
function TY(e) {
  return e && e.__esModule ? e : { default: e };
}
var jY = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, MY.default)(e, t);
}, An = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = jY(function(r) {
        An.scrollHandler(e);
      }, t);
      return An.scrollSpyContainers.push(e), (0, JO.addPassiveEventListener)(e, "scroll", n), function() {
        (0, JO.removePassiveEventListener)(e, "scroll", n), An.scrollSpyContainers.splice(An.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return An.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = An.scrollSpyContainers[An.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(An.currentPositionX(e), An.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    An.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = An.scrollSpyContainers[An.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    An.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    An.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), An.spySetState && An.spySetState.length && An.spySetState.indexOf(e) > -1 && An.spySetState.splice(An.spySetState.indexOf(e), 1), document.removeEventListener("scroll", An.scrollHandler);
  },
  update: function() {
    return An.scrollSpyContainers.forEach(function(e) {
      return An.scrollHandler(e);
    });
  }
};
Gl.default = An;
var Qs = {}, Kl = {};
Object.defineProperty(Kl, "__esModule", {
  value: !0
});
var AY = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, BY = function() {
  return window.location.hash.replace(/^#/, "");
}, IY = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, FY = function(e) {
  return getComputedStyle(e).position !== "static";
}, zh = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, RY = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (FY(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = zh(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return zh(t, a).offsetTop - zh(e, a).offsetTop;
};
Kl.default = {
  updateHash: AY,
  getHash: BY,
  filterElementInContainer: IY,
  scrollOffset: RY
};
var uf = {}, Xy = {};
Object.defineProperty(Xy, "__esModule", {
  value: !0
});
Xy.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Jy = {};
Object.defineProperty(Jy, "__esModule", {
  value: !0
});
var NY = Yl, zY = ["mousedown", "wheel", "touchmove", "keydown"];
Jy.default = {
  subscribe: function(e) {
    return typeof document < "u" && zY.forEach(function(t) {
      return (0, NY.addPassiveEventListener)(document, t, e);
    });
  }
};
var Xl = {};
Object.defineProperty(Xl, "__esModule", {
  value: !0
});
var Pm = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Pm.registered[e] = t;
    },
    remove: function(e) {
      Pm.registered[e] = null;
    }
  }
};
Xl.default = Pm;
Object.defineProperty(uf, "__esModule", {
  value: !0
});
var $Y = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, UY = Kl;
cf(UY);
var HY = Xy, QO = cf(HY), WY = Jy, VY = cf(WY), ZY = Xl, po = cf(ZY);
function cf(e) {
  return e && e.__esModule ? e : { default: e };
}
var qj = function(e) {
  return QO.default[e.smooth] || QO.default.defaultEasing;
}, qY = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, GY = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Sm = function() {
  return GY() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Gj = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Yj = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Kj = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, YY = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, KY = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, XY = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    po.default.registered.end && po.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Sm.call(window, i);
    return;
  }
  po.default.registered.end && po.default.registered.end(o.to, o.target, o.currentPosition);
}, Qy = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Jl = function(e, t, n, r) {
  t.data = t.data || Gj(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (VY.default.subscribe(o), Qy(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Yj(t) : Kj(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    po.default.registered.end && po.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = qY(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = qj(t), s = XY.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      po.default.registered.begin && po.default.registered.begin(t.data.to, t.data.target), Sm.call(window, s);
    }, t.delay);
    return;
  }
  po.default.registered.begin && po.default.registered.begin(t.data.to, t.data.target), Sm.call(window, s);
}, df = function(e) {
  return e = $Y({}, e), e.data = e.data || Gj(), e.absolute = !0, e;
}, JY = function(e) {
  Jl(0, df(e));
}, QY = function(e, t) {
  Jl(e, df(t));
}, eK = function(e) {
  e = df(e), Qy(e), Jl(e.horizontal ? YY(e) : KY(e), e);
}, tK = function(e, t) {
  t = df(t), Qy(t);
  var n = t.horizontal ? Yj(t) : Kj(t);
  Jl(e + n, t);
};
uf.default = {
  animateTopScroll: Jl,
  getAnimationType: qj,
  scrollToTop: JY,
  scrollToBottom: eK,
  scrollTo: QY,
  scrollMore: tK
};
Object.defineProperty(Qs, "__esModule", {
  value: !0
});
var nK = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, rK = Kl, oK = eb(rK), iK = uf, sK = eb(iK), aK = Xl, tc = eb(aK);
function eb(e) {
  return e && e.__esModule ? e : { default: e };
}
var nc = {}, ek = void 0;
Qs.default = {
  unmount: function() {
    nc = {};
  },
  register: function(e, t) {
    nc[e] = t;
  },
  unregister: function(e) {
    delete nc[e];
  },
  get: function(e) {
    return nc[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return ek = e;
  },
  getActiveLink: function() {
    return ek;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = nK({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = oK.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      tc.default.registered.begin && tc.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, tc.default.registered.end && tc.default.registered.end(e, n);
      return;
    }
    sK.default.animateTopScroll(a, t, e, n);
  }
};
var Mm = { exports: {} }, $h = { exports: {} }, Zt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tk;
function lK() {
  if (tk) return Zt;
  tk = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function P(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case d:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case a:
                case c:
                case f:
                case g:
                case s:
                  return v;
                default:
                  return x;
              }
          }
        case n:
          return x;
      }
    }
  }
  function E(v) {
    return P(v) === u;
  }
  return Zt.AsyncMode = l, Zt.ConcurrentMode = u, Zt.ContextConsumer = a, Zt.ContextProvider = s, Zt.Element = t, Zt.ForwardRef = c, Zt.Fragment = r, Zt.Lazy = f, Zt.Memo = g, Zt.Portal = n, Zt.Profiler = i, Zt.StrictMode = o, Zt.Suspense = d, Zt.isAsyncMode = function(v) {
    return E(v) || P(v) === l;
  }, Zt.isConcurrentMode = E, Zt.isContextConsumer = function(v) {
    return P(v) === a;
  }, Zt.isContextProvider = function(v) {
    return P(v) === s;
  }, Zt.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Zt.isForwardRef = function(v) {
    return P(v) === c;
  }, Zt.isFragment = function(v) {
    return P(v) === r;
  }, Zt.isLazy = function(v) {
    return P(v) === f;
  }, Zt.isMemo = function(v) {
    return P(v) === g;
  }, Zt.isPortal = function(v) {
    return P(v) === n;
  }, Zt.isProfiler = function(v) {
    return P(v) === i;
  }, Zt.isStrictMode = function(v) {
    return P(v) === o;
  }, Zt.isSuspense = function(v) {
    return P(v) === d;
  }, Zt.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === d || v === p || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === s || v.$$typeof === a || v.$$typeof === c || v.$$typeof === h || v.$$typeof === C || v.$$typeof === w || v.$$typeof === m);
  }, Zt.typeOf = P, Zt;
}
var Qt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nk;
function uK() {
  return nk || (nk = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function P(H) {
      return typeof H == "string" || typeof H == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      H === r || H === u || H === i || H === o || H === d || H === p || typeof H == "object" && H !== null && (H.$$typeof === f || H.$$typeof === g || H.$$typeof === s || H.$$typeof === a || H.$$typeof === c || H.$$typeof === h || H.$$typeof === C || H.$$typeof === w || H.$$typeof === m);
    }
    function E(H) {
      if (typeof H == "object" && H !== null) {
        var ce = H.$$typeof;
        switch (ce) {
          case t:
            var ye = H.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case d:
                return ye;
              default:
                var ie = ye && ye.$$typeof;
                switch (ie) {
                  case a:
                  case c:
                  case f:
                  case g:
                  case s:
                    return ie;
                  default:
                    return ce;
                }
            }
          case n:
            return ce;
        }
      }
    }
    var v = l, x = u, L = a, z = s, k = t, R = c, A = r, U = f, V = g, N = n, Z = i, K = o, X = d, te = !1;
    function ee(H) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), D(H) || E(H) === l;
    }
    function D(H) {
      return E(H) === u;
    }
    function j(H) {
      return E(H) === a;
    }
    function G(H) {
      return E(H) === s;
    }
    function S(H) {
      return typeof H == "object" && H !== null && H.$$typeof === t;
    }
    function Y(H) {
      return E(H) === c;
    }
    function O(H) {
      return E(H) === r;
    }
    function M(H) {
      return E(H) === f;
    }
    function W(H) {
      return E(H) === g;
    }
    function T(H) {
      return E(H) === n;
    }
    function q(H) {
      return E(H) === i;
    }
    function I(H) {
      return E(H) === o;
    }
    function J(H) {
      return E(H) === d;
    }
    Qt.AsyncMode = v, Qt.ConcurrentMode = x, Qt.ContextConsumer = L, Qt.ContextProvider = z, Qt.Element = k, Qt.ForwardRef = R, Qt.Fragment = A, Qt.Lazy = U, Qt.Memo = V, Qt.Portal = N, Qt.Profiler = Z, Qt.StrictMode = K, Qt.Suspense = X, Qt.isAsyncMode = ee, Qt.isConcurrentMode = D, Qt.isContextConsumer = j, Qt.isContextProvider = G, Qt.isElement = S, Qt.isForwardRef = Y, Qt.isFragment = O, Qt.isLazy = M, Qt.isMemo = W, Qt.isPortal = T, Qt.isProfiler = q, Qt.isStrictMode = I, Qt.isSuspense = J, Qt.isValidElementType = P, Qt.typeOf = E;
  }()), Qt;
}
var rk;
function Xj() {
  return rk || (rk = 1, process.env.NODE_ENV === "production" ? $h.exports = lK() : $h.exports = uK()), $h.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Uh, ok;
function cK() {
  if (ok) return Uh;
  ok = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Uh = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var d in a)
        t.call(a, d) && (l[d] = a[d]);
      if (e) {
        u = e(a);
        for (var p = 0; p < u.length; p++)
          n.call(a, u[p]) && (l[u[p]] = a[u[p]]);
      }
    }
    return l;
  }, Uh;
}
var Hh, ik;
function tb() {
  if (ik) return Hh;
  ik = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Hh = e, Hh;
}
var sk, ak;
function Jj() {
  return ak || (ak = 1, sk = Function.call.bind(Object.prototype.hasOwnProperty)), sk;
}
var Wh, lk;
function dK() {
  if (lk) return Wh;
  lk = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = tb(), n = {}, r = Jj();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var d;
          try {
            if (typeof i[c] != "function") {
              var p = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            d = i[c](s, c, l, a, null, t);
          } catch (f) {
            d = f;
          }
          if (d && !(d instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in n)) {
            n[d.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + a + " type: " + d.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Wh = o, Wh;
}
var Vh, uk;
function pK() {
  if (uk) return Vh;
  uk = 1;
  var e = Xj(), t = cK(), n = tb(), r = Jj(), o = dK(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return Vh = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function d(D) {
      var j = D && (u && D[u] || D[c]);
      if (typeof j == "function")
        return j;
    }
    var p = "<<anonymous>>", g = {
      array: C("array"),
      bigint: C("bigint"),
      bool: C("boolean"),
      func: C("function"),
      number: C("number"),
      object: C("object"),
      string: C("string"),
      symbol: C("symbol"),
      any: w(),
      arrayOf: P,
      element: E(),
      elementType: v(),
      instanceOf: x,
      node: R(),
      objectOf: z,
      oneOf: L,
      oneOfType: k,
      shape: U,
      exact: V
    };
    function f(D, j) {
      return D === j ? D !== 0 || 1 / D === 1 / j : D !== D && j !== j;
    }
    function m(D, j) {
      this.message = D, this.data = j && typeof j == "object" ? j : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function h(D) {
      if (process.env.NODE_ENV !== "production")
        var j = {}, G = 0;
      function S(O, M, W, T, q, I, J) {
        if (T = T || p, I = I || W, J !== n) {
          if (l) {
            var H = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw H.name = "Invariant Violation", H;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ce = T + ":" + W;
            !j[ce] && // Avoid spamming the console because they are often not actionable except for lib authors
            G < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + I + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), j[ce] = !0, G++);
          }
        }
        return M[W] == null ? O ? M[W] === null ? new m("The " + q + " `" + I + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + I + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : D(M, W, T, q, I);
      }
      var Y = S.bind(null, !1);
      return Y.isRequired = S.bind(null, !0), Y;
    }
    function C(D) {
      function j(G, S, Y, O, M, W) {
        var T = G[S], q = K(T);
        if (q !== D) {
          var I = X(T);
          return new m(
            "Invalid " + O + " `" + M + "` of type " + ("`" + I + "` supplied to `" + Y + "`, expected ") + ("`" + D + "`."),
            { expectedType: D }
          );
        }
        return null;
      }
      return h(j);
    }
    function w() {
      return h(s);
    }
    function P(D) {
      function j(G, S, Y, O, M) {
        if (typeof D != "function")
          return new m("Property `" + M + "` of component `" + Y + "` has invalid PropType notation inside arrayOf.");
        var W = G[S];
        if (!Array.isArray(W)) {
          var T = K(W);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + T + "` supplied to `" + Y + "`, expected an array."));
        }
        for (var q = 0; q < W.length; q++) {
          var I = D(W, q, Y, O, M + "[" + q + "]", n);
          if (I instanceof Error)
            return I;
        }
        return null;
      }
      return h(j);
    }
    function E() {
      function D(j, G, S, Y, O) {
        var M = j[G];
        if (!a(M)) {
          var W = K(M);
          return new m("Invalid " + Y + " `" + O + "` of type " + ("`" + W + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(D);
    }
    function v() {
      function D(j, G, S, Y, O) {
        var M = j[G];
        if (!e.isValidElementType(M)) {
          var W = K(M);
          return new m("Invalid " + Y + " `" + O + "` of type " + ("`" + W + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(D);
    }
    function x(D) {
      function j(G, S, Y, O, M) {
        if (!(G[S] instanceof D)) {
          var W = D.name || p, T = ee(G[S]);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + T + "` supplied to `" + Y + "`, expected ") + ("instance of `" + W + "`."));
        }
        return null;
      }
      return h(j);
    }
    function L(D) {
      if (!Array.isArray(D))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function j(G, S, Y, O, M) {
        for (var W = G[S], T = 0; T < D.length; T++)
          if (f(W, D[T]))
            return null;
        var q = JSON.stringify(D, function(I, J) {
          var H = X(J);
          return H === "symbol" ? String(J) : J;
        });
        return new m("Invalid " + O + " `" + M + "` of value `" + String(W) + "` " + ("supplied to `" + Y + "`, expected one of " + q + "."));
      }
      return h(j);
    }
    function z(D) {
      function j(G, S, Y, O, M) {
        if (typeof D != "function")
          return new m("Property `" + M + "` of component `" + Y + "` has invalid PropType notation inside objectOf.");
        var W = G[S], T = K(W);
        if (T !== "object")
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + T + "` supplied to `" + Y + "`, expected an object."));
        for (var q in W)
          if (r(W, q)) {
            var I = D(W, q, Y, O, M + "." + q, n);
            if (I instanceof Error)
              return I;
          }
        return null;
      }
      return h(j);
    }
    function k(D) {
      if (!Array.isArray(D))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var j = 0; j < D.length; j++) {
        var G = D[j];
        if (typeof G != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(G) + " at index " + j + "."
          ), s;
      }
      function S(Y, O, M, W, T) {
        for (var q = [], I = 0; I < D.length; I++) {
          var J = D[I], H = J(Y, O, M, W, T, n);
          if (H == null)
            return null;
          H.data && r(H.data, "expectedType") && q.push(H.data.expectedType);
        }
        var ce = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + W + " `" + T + "` supplied to " + ("`" + M + "`" + ce + "."));
      }
      return h(S);
    }
    function R() {
      function D(j, G, S, Y, O) {
        return N(j[G]) ? null : new m("Invalid " + Y + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return h(D);
    }
    function A(D, j, G, S, Y) {
      return new m(
        (D || "React class") + ": " + j + " type `" + G + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Y + "`."
      );
    }
    function U(D) {
      function j(G, S, Y, O, M) {
        var W = G[S], T = K(W);
        if (T !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + T + "` " + ("supplied to `" + Y + "`, expected `object`."));
        for (var q in D) {
          var I = D[q];
          if (typeof I != "function")
            return A(Y, O, M, q, X(I));
          var J = I(W, q, Y, O, M + "." + q, n);
          if (J)
            return J;
        }
        return null;
      }
      return h(j);
    }
    function V(D) {
      function j(G, S, Y, O, M) {
        var W = G[S], T = K(W);
        if (T !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + T + "` " + ("supplied to `" + Y + "`, expected `object`."));
        var q = t({}, G[S], D);
        for (var I in q) {
          var J = D[I];
          if (r(D, I) && typeof J != "function")
            return A(Y, O, M, I, X(J));
          if (!J)
            return new m(
              "Invalid " + O + " `" + M + "` key `" + I + "` supplied to `" + Y + "`.\nBad object: " + JSON.stringify(G[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(D), null, "  ")
            );
          var H = J(W, I, Y, O, M + "." + I, n);
          if (H)
            return H;
        }
        return null;
      }
      return h(j);
    }
    function N(D) {
      switch (typeof D) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !D;
        case "object":
          if (Array.isArray(D))
            return D.every(N);
          if (D === null || a(D))
            return !0;
          var j = d(D);
          if (j) {
            var G = j.call(D), S;
            if (j !== D.entries) {
              for (; !(S = G.next()).done; )
                if (!N(S.value))
                  return !1;
            } else
              for (; !(S = G.next()).done; ) {
                var Y = S.value;
                if (Y && !N(Y[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(D, j) {
      return D === "symbol" ? !0 : j ? j["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && j instanceof Symbol : !1;
    }
    function K(D) {
      var j = typeof D;
      return Array.isArray(D) ? "array" : D instanceof RegExp ? "object" : Z(j, D) ? "symbol" : j;
    }
    function X(D) {
      if (typeof D > "u" || D === null)
        return "" + D;
      var j = K(D);
      if (j === "object") {
        if (D instanceof Date)
          return "date";
        if (D instanceof RegExp)
          return "regexp";
      }
      return j;
    }
    function te(D) {
      var j = X(D);
      switch (j) {
        case "array":
        case "object":
          return "an " + j;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + j;
        default:
          return j;
      }
    }
    function ee(D) {
      return !D.constructor || !D.constructor.name ? p : D.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, Vh;
}
var Zh, ck;
function fK() {
  if (ck) return Zh;
  ck = 1;
  var e = tb();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Zh = function() {
    function r(s, a, l, u, c, d) {
      if (d !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Zh;
}
if (process.env.NODE_ENV !== "production") {
  var hK = Xj(), gK = !0;
  Mm.exports = pK()(hK.isElement, gK);
} else
  Mm.exports = fK()();
var pf = Mm.exports, ff = {};
Object.defineProperty(ff, "__esModule", {
  value: !0
});
var mK = Kl, qh = vK(mK);
function vK(e) {
  return e && e.__esModule ? e : { default: e };
}
var yK = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return qh.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && qh.default.getHash() !== e && qh.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
ff.default = yK;
Object.defineProperty(ql, "__esModule", {
  value: !0
});
var rc = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, bK = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), wK = Oe, dk = Ql(wK), CK = Gl, oc = Ql(CK), EK = Qs, xK = Ql(EK), OK = pf, Ln = Ql(OK), kK = ff, qo = Ql(kK);
function Ql(e) {
  return e && e.__esModule ? e : { default: e };
}
function _K(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function LK(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function DK(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var pk = {
  to: Ln.default.string.isRequired,
  containerId: Ln.default.string,
  container: Ln.default.object,
  activeClass: Ln.default.string,
  activeStyle: Ln.default.object,
  spy: Ln.default.bool,
  horizontal: Ln.default.bool,
  smooth: Ln.default.oneOfType([Ln.default.bool, Ln.default.string]),
  offset: Ln.default.number,
  delay: Ln.default.number,
  isDynamic: Ln.default.bool,
  onClick: Ln.default.func,
  duration: Ln.default.oneOfType([Ln.default.number, Ln.default.func]),
  absolute: Ln.default.bool,
  onSetActive: Ln.default.func,
  onSetInactive: Ln.default.func,
  ignoreCancelEvents: Ln.default.bool,
  hashSpy: Ln.default.bool,
  saveHashHistory: Ln.default.bool,
  spyThrottle: Ln.default.number
};
ql.default = function(e, t) {
  var n = t || xK.default, r = function(i) {
    DK(s, i);
    function s(a) {
      _K(this, s);
      var l = LK(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return bK(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          if (!oc.default.isMounted(a)) {
            var l = oc.default.mount(a, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (qo.default.isMounted() || qo.default.mount(n), qo.default.mapContainer(this.props.to, a)), oc.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        oc.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(a) {
          return a();
        });
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = rc({}, this.props.style, this.props.activeStyle) : l = rc({}, this.props.style);
        var u = rc({}, this.props);
        for (var c in pk)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, dk.default.createElement(e, u);
      }
    }]), s;
  }(dk.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, rc({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(qo.default.isMounted() && !qo.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, d = null, p = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, h = 0;
          if (l.getBoundingClientRect) {
            var C = l.getBoundingClientRect();
            h = C.left;
          }
          if (!d || i.props.isDynamic) {
            if (d = n.get(c), !d)
              return;
            var w = d.getBoundingClientRect();
            f = w.left - h + s, m = f + w.width;
          }
          var P = s - i.props.offset;
          p = P >= Math.floor(f) && P < Math.floor(m), g = P < Math.floor(f) || P >= Math.floor(m);
        } else {
          var E = 0, v = 0, x = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            x = L.top;
          }
          if (!d || i.props.isDynamic) {
            if (d = n.get(c), !d)
              return;
            var z = d.getBoundingClientRect();
            E = z.top - x + a, v = E + z.height;
          }
          var k = a - i.props.offset;
          p = k >= Math.floor(E) && k < Math.floor(v), g = k < Math.floor(E) || k >= Math.floor(v);
        }
        var R = n.getActiveLink();
        if (g) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && qo.default.getHash() === c) {
            var A = i.props.saveHashHistory, U = A === void 0 ? !1 : A;
            qo.default.changeHash("", U);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, d));
        }
        if (p && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, N = V === void 0 ? !1 : V;
          i.props.hashSpy && qo.default.changeHash(c, N), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, d));
        }
      }
    };
  };
  return r.propTypes = pk, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Ky, "__esModule", {
  value: !0
});
var PK = Oe, fk = Qj(PK), SK = ql, MK = Qj(SK);
function Qj(e) {
  return e && e.__esModule ? e : { default: e };
}
function TK(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function hk(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function jK(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var AK = function(e) {
  jK(t, e);
  function t() {
    var n, r, o, i;
    TK(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = hk(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return fk.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), hk(o, i);
  }
  return t;
}(fk.default.Component);
Ky.default = (0, MK.default)(AK);
var nb = {};
Object.defineProperty(nb, "__esModule", {
  value: !0
});
var BK = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), IK = Oe, gk = eA(IK), FK = ql, RK = eA(FK);
function eA(e) {
  return e && e.__esModule ? e : { default: e };
}
function NK(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function zK(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function $K(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var UK = function(e) {
  $K(t, e);
  function t() {
    return NK(this, t), zK(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return BK(t, [{
    key: "render",
    value: function() {
      return gk.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(gk.default.Component);
nb.default = (0, RK.default)(UK);
var rb = {}, hf = {};
Object.defineProperty(hf, "__esModule", {
  value: !0
});
var HK = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, WK = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), VK = Oe, mk = gf(VK), ZK = Tl;
gf(ZK);
var qK = Qs, vk = gf(qK), GK = pf, yk = gf(GK);
function gf(e) {
  return e && e.__esModule ? e : { default: e };
}
function YK(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function KK(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function XK(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
hf.default = function(e) {
  var t = function(n) {
    XK(r, n);
    function r(o) {
      YK(this, r);
      var i = KK(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return WK(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        vk.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        vk.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return mk.default.createElement(e, HK({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(mk.default.Component);
  return t.propTypes = {
    name: yk.default.string,
    id: yk.default.string
  }, t;
};
Object.defineProperty(rb, "__esModule", {
  value: !0
});
var bk = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, JK = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), QK = Oe, wk = ob(QK), eX = hf, tX = ob(eX), nX = pf, Ck = ob(nX);
function ob(e) {
  return e && e.__esModule ? e : { default: e };
}
function rX(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function oX(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function iX(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var tA = function(e) {
  iX(t, e);
  function t() {
    return rX(this, t), oX(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return JK(t, [{
    key: "render",
    value: function() {
      var n = this, r = bk({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, wk.default.createElement(
        "div",
        bk({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(wk.default.Component);
tA.propTypes = {
  name: Ck.default.string,
  id: Ck.default.string
};
rb.default = (0, tX.default)(tA);
var Gh = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Ek = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function xk(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ok(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function kk(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ic = Oe, Ui = Gl, Yh = Qs, Rn = pf, Go = ff, _k = {
  to: Rn.string.isRequired,
  containerId: Rn.string,
  container: Rn.object,
  activeClass: Rn.string,
  spy: Rn.bool,
  smooth: Rn.oneOfType([Rn.bool, Rn.string]),
  offset: Rn.number,
  delay: Rn.number,
  isDynamic: Rn.bool,
  onClick: Rn.func,
  duration: Rn.oneOfType([Rn.number, Rn.func]),
  absolute: Rn.bool,
  onSetActive: Rn.func,
  onSetInactive: Rn.func,
  ignoreCancelEvents: Rn.bool,
  hashSpy: Rn.bool,
  spyThrottle: Rn.number
}, sX = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Yh, r = function(i) {
      kk(s, i);
      function s(a) {
        xk(this, s);
        var l = Ok(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return Ek(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            Ui.isMounted(a) || Ui.mount(a, this.props.spyThrottle), this.props.hashSpy && (Go.isMounted() || Go.mount(n), Go.mapContainer(this.props.to, a)), this.props.spy && Ui.addStateHandler(this.stateHandler), Ui.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Ui.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = Gh({}, this.props);
          for (var u in _k)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, ic.createElement(e, l);
        }
      }]), s;
    }(ic.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, Gh({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(Go.isMounted() && !Go.isInitialized())) {
          var l = i.props.to, u = null, c = 0, d = 0, p = 0;
          if (a.getBoundingClientRect) {
            var g = a.getBoundingClientRect();
            p = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - p + s, d = c + f.height;
          }
          var m = s - i.props.offset, h = m >= Math.floor(c) && m < Math.floor(d), C = m < Math.floor(c) || m >= Math.floor(d), w = n.getActiveLink();
          if (C)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Go.getHash() === l && Go.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Ui.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Go.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Ui.updateStates();
        }
      };
    };
    return r.propTypes = _k, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      kk(r, n);
      function r(o) {
        xk(this, r);
        var i = Ok(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return Ek(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Yh.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Yh.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return ic.createElement(e, Gh({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(ic.Component);
    return t.propTypes = {
      name: Rn.string,
      id: Rn.string
    }, t;
  }
}, aX = sX;
Object.defineProperty(Vn, "__esModule", {
  value: !0
});
Vn.Helpers = Vn.ScrollElement = Vn.ScrollLink = Vn.animateScroll = Vn.scrollSpy = Vn.Events = Vn.scroller = Vn.Element = Vn.Button = Vn.Link = void 0;
var lX = Ky, nA = wo(lX), uX = nb, rA = wo(uX), cX = rb, oA = wo(cX), dX = Qs, iA = wo(dX), pX = Xl, sA = wo(pX), fX = Gl, aA = wo(fX), hX = uf, lA = wo(hX), gX = ql, uA = wo(gX), mX = hf, cA = wo(mX), vX = aX, dA = wo(vX);
function wo(e) {
  return e && e.__esModule ? e : { default: e };
}
Vn.Link = nA.default;
Vn.Button = rA.default;
Vn.Element = oA.default;
Vn.scroller = iA.default;
Vn.Events = sA.default;
Vn.scrollSpy = aA.default;
Vn.animateScroll = lA.default;
Vn.ScrollLink = uA.default;
Vn.ScrollElement = cA.default;
Vn.Helpers = dA.default;
Vn.default = { Link: nA.default, Button: rA.default, Element: oA.default, scroller: iA.default, Events: sA.default, scrollSpy: aA.default, animateScroll: lA.default, ScrollLink: uA.default, ScrollElement: cA.default, Helpers: dA.default };
Ve({});
Ve({});
Ve({});
function Ol(e) {
  "@babel/helpers - typeof";
  return Ol = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ol(e);
}
function yX(e, t) {
  if (Ol(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ol(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function bX(e) {
  var t = yX(e, "string");
  return Ol(t) == "symbol" ? t : t + "";
}
function he(e, t, n) {
  return (t = bX(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function pA(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Kh, Lk;
function wX() {
  if (Lk) return Kh;
  Lk = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, s, a, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [o, i, s, a, l, u], p = 0;
        c = new Error(r.replace(/%s/g, function() {
          return d[p++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Kh = t, Kh;
}
var CX = wX(), Jn = /* @__PURE__ */ pA(CX), at = Ve(null);
function EX() {
  Jn(!!_e, "useGoogleMap is React hook and requires React version 16.8+");
  var e = _e(at);
  return Jn(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function xX(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function OX(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function kX(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return OX(e, i), o;
}
function _X(e, t, n) {
  var r = xX(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function LX(e) {
  google.maps.event.removeListener(e);
}
function jt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(LX);
}
function Lt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = _X(o, i, n);
  return kX(t, r, o, i), s;
}
function DX(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: d,
    onMouseMove: p,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: h,
    onRightClick: C,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: P,
    onUnmount: E
  } = e, [v, x] = _(null), L = Ye(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null), [T, q] = _(null), [I, J] = _(null);
  return y(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), y(() => {
    v !== null && typeof s < "u" && v.setCenter(s);
  }, [v, s]), y(() => {
    v && l && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), y(() => {
    v && c && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), y(() => {
    v && d && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(v, "dragstart", d)));
  }, [d]), y(() => {
    v && m && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", m)));
  }, [m]), y(() => {
    v && p && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(v, "mousemove", p)));
  }, [p]), y(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), y(() => {
    v && f && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), y(() => {
    v && h && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(v, "mouseup", h)));
  }, [h]), y(() => {
    v && C && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(v, "rightclick", C)));
  }, [C]), y(() => {
    v && a && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", a)));
  }, [a]), y(() => {
    v && u && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(v, "drag", u)));
  }, [u]), y(() => {
    v && w && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(v, "center_changed", w)));
  }, [a]), y(() => {
    var H = L.current === null ? null : new google.maps.Map(L.current, n);
    return x(H), H !== null && P && P(H), () => {
      H !== null && E && E(H);
    };
  }, []), Rt.jsx("div", {
    id: r,
    ref: L,
    style: o,
    className: i,
    children: Rt.jsx(at.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
De(DX);
function Dk(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function fA(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        Dk(i, r, o, s, a, "next", l);
      }
      function a(l) {
        Dk(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function hA(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Jn(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var os = typeof document < "u";
function gA(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return os ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(p) {
          c && c(p), i(p);
        };
        return;
      } else
        s.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(p) {
      d.setAttribute("data-state", "error"), i(p);
    }, a.initMap = function() {
      d.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function Pk(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function mA() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return Pk(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return Pk(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var ya = !1;
function vA() {
  return Rt.jsx("div", {
    children: "Loading..."
  });
}
var Tm = {
  id: "script-loader",
  version: "weekly"
};
class PX extends Ee {
  constructor() {
    super(...arguments), he(this, "check", null), he(this, "state", {
      loaded: !1
    }), he(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), he(this, "isCleaningUp", /* @__PURE__ */ fA(function* () {
      function t(n) {
        if (!ya)
          n();
        else if (os)
          var r = window.setInterval(function() {
            ya || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), he(this, "cleanup", () => {
      ya = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), he(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && mA(), Jn(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: hA(this.props)
      };
      gA(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), he(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (os) {
      if (window.google && window.google.maps && !ya) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), os && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (os) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, ya = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Rt.jsxs(Rt.Fragment, {
      children: [Rt.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Rt.jsx(vA, {})]
    });
  }
}
he(PX, "defaultProps", Tm);
function SX(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function ib(e, t) {
  if (e == null) return {};
  var n, r, o = SX(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var Sk;
function MX(e) {
  var {
    id: t = Tm.id,
    version: n = Tm.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: d,
    authReferrerPolicy: p
  } = e, g = Ye(!1), [f, m] = _(!1), [h, C] = _(void 0);
  y(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), y(function() {
    os && u && mA();
  }, [u]), y(function() {
    f && Jn(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = hA({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: d,
    authReferrerPolicy: p
  });
  y(function() {
    if (!os)
      return;
    function E() {
      g.current && (m(!0), Sk = w);
    }
    if (window.google && window.google.maps && Sk === w) {
      E();
      return;
    }
    gA({
      id: t,
      url: w,
      nonce: r
    }).then(E).catch(function(v) {
      g.current && C(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var P = Ye(void 0);
  return y(function() {
    P.current && l !== P.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), P.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var TX = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], jX = Rt.jsx(vA, {});
function AX(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = ib(e, TX), {
    isLoaded: a,
    loadError: l
  } = MX(s);
  return y(function() {
    a && typeof n == "function" && n();
  }, [a, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || jX;
}
De(AX);
var Mk;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Mk || (Mk = {}));
function Tk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Tk(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jk = {}, Ak = {
  options(e, t) {
    e.setOptions(t);
  }
};
function BX(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = _e(at), [i, s] = _(null);
  return y(() => {
    i !== null && i.setMap(o);
  }, [o]), y(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), y(() => {
    var a = new google.maps.TrafficLayer(Pd(Pd({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
De(BX);
class IX extends Ee {
  constructor() {
    super(...arguments), he(this, "state", {
      trafficLayer: null
    }), he(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), he(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Pd(Pd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: Ak,
      eventMap: jk,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: Ak,
      eventMap: jk,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), jt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(IX, "contextType", at);
function FX(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = _e(at), [o, i] = _(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
De(FX);
class RX extends Ee {
  constructor() {
    super(...arguments), he(this, "state", {
      bicyclingLayer: null
    }), he(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(RX, "contextType", at);
function NX(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = _e(at), [o, i] = _(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
De(NX);
class zX extends Ee {
  constructor() {
    super(...arguments), he(this, "state", {
      transitLayer: null
    }), he(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(zX, "contextType", at);
function Bk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Bk(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Bk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ik = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, Fk = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function $X(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, d = _e(at), [p, g] = _(null), [f, m] = _(null), [h, C] = _(null), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null);
  return y(() => {
    p !== null && p.setMap(d);
  }, [d]), y(() => {
    t && p !== null && p.setOptions(t);
  }, [p, t]), y(() => {
    p !== null && p.setDrawingMode(n ?? null);
  }, [p, n]), y(() => {
    p && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(p, "circlecomplete", r)));
  }, [p, r]), y(() => {
    p && o && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(p, "markercomplete", o)));
  }, [p, o]), y(() => {
    p && i && (w !== null && google.maps.event.removeListener(w), P(google.maps.event.addListener(p, "overlaycomplete", i)));
  }, [p, i]), y(() => {
    p && s && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(p, "polygoncomplete", s)));
  }, [p, s]), y(() => {
    p && a && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(p, "polylinecomplete", a)));
  }, [p, a]), y(() => {
    p && l && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(p, "rectanglecomplete", l)));
  }, [p, l]), y(() => {
    Jn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(Sd(Sd({}, t), {}, {
      map: d
    }));
    return n && R.setDrawingMode(n), r && m(google.maps.event.addListener(R, "circlecomplete", r)), o && C(google.maps.event.addListener(R, "markercomplete", o)), i && P(google.maps.event.addListener(R, "overlaycomplete", i)), s && v(google.maps.event.addListener(R, "polygoncomplete", s)), a && L(google.maps.event.addListener(R, "polylinecomplete", a)), l && k(google.maps.event.addListener(R, "rectanglecomplete", l)), g(R), u && u(R), () => {
      p !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), E && google.maps.event.removeListener(E), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), c && c(p), p.setMap(null));
    };
  }, []), null;
}
De($X);
class UX extends Ee {
  constructor(t) {
    super(t), he(this, "registeredEvents", []), he(this, "state", {
      drawingManager: null
    }), he(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Jn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Sd(Sd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: Fk,
      eventMap: Ik,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: Fk,
      eventMap: Ik,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), jt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
he(UX, "contextType", at);
function Rk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Bs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Rk(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nk = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, zk = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Md = {};
function HX(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: d,
    label: p,
    opacity: g,
    shape: f,
    title: m,
    zIndex: h,
    onClick: C,
    onDblClick: w,
    onDrag: P,
    onDragEnd: E,
    onDragStart: v,
    onMouseOut: x,
    onMouseOver: L,
    onMouseUp: z,
    onMouseDown: k,
    onRightClick: R,
    onClickableChanged: A,
    onCursorChanged: U,
    onAnimationChanged: V,
    onDraggableChanged: N,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: D,
    onZindexChanged: j,
    onLoad: G,
    onUnmount: S
  } = e, Y = _e(at), [O, M] = _(null), [W, T] = _(null), [q, I] = _(null), [J, H] = _(null), [ce, ye] = _(null), [ie, Te] = _(null), [Re, Ne] = _(null), [Ie, Ke] = _(null), [Ze, Se] = _(null), [qe, rt] = _(null), [Pe, Me] = _(null), [Ge, He] = _(null), [$e, ot] = _(null), [Fe, Kt] = _(null), [lt, ht] = _(null), [Dt, ln] = _(null), [Pt, St] = _(null), [ut, Xe] = _(null), [un, cn] = _(null), [Nt, Gn] = _(null), [zt, Yn] = _(null), [$t, Sn] = _(null);
  y(() => {
    O !== null && O.setMap(Y);
  }, [Y]), y(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), y(() => {
    typeof s < "u" && O !== null && O.setDraggable(s);
  }, [O, s]), y(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), y(() => {
    typeof a < "u" && O !== null && O.setVisible(a);
  }, [O, a]), y(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), y(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), y(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), y(() => {
    O && d !== void 0 && O.setIcon(d);
  }, [O, d]), y(() => {
    O && p !== void 0 && O.setLabel(p);
  }, [O, p]), y(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), y(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), y(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), y(() => {
    O && h !== void 0 && O.setZIndex(h);
  }, [O, h]), y(() => {
    O && w && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), y(() => {
    O && E && (q !== null && google.maps.event.removeListener(q), I(google.maps.event.addListener(O, "dragend", E)));
  }, [E]), y(() => {
    O && v && (J !== null && google.maps.event.removeListener(J), H(google.maps.event.addListener(O, "dragstart", v)));
  }, [v]), y(() => {
    O && k && (ce !== null && google.maps.event.removeListener(ce), ye(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), y(() => {
    O && x && (ie !== null && google.maps.event.removeListener(ie), Te(google.maps.event.addListener(O, "mouseout", x)));
  }, [x]), y(() => {
    O && L && (Re !== null && google.maps.event.removeListener(Re), Ne(google.maps.event.addListener(O, "mouseover", L)));
  }, [L]), y(() => {
    O && z && (Ie !== null && google.maps.event.removeListener(Ie), Ke(google.maps.event.addListener(O, "mouseup", z)));
  }, [z]), y(() => {
    O && R && (Ze !== null && google.maps.event.removeListener(Ze), Se(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), y(() => {
    O && C && (qe !== null && google.maps.event.removeListener(qe), rt(google.maps.event.addListener(O, "click", C)));
  }, [C]), y(() => {
    O && P && (Pe !== null && google.maps.event.removeListener(Pe), Me(google.maps.event.addListener(O, "drag", P)));
  }, [P]), y(() => {
    O && A && (Ge !== null && google.maps.event.removeListener(Ge), He(google.maps.event.addListener(O, "clickable_changed", A)));
  }, [A]), y(() => {
    O && U && ($e !== null && google.maps.event.removeListener($e), ot(google.maps.event.addListener(O, "cursor_changed", U)));
  }, [U]), y(() => {
    O && V && (Fe !== null && google.maps.event.removeListener(Fe), Kt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), y(() => {
    O && N && (lt !== null && google.maps.event.removeListener(lt), ht(google.maps.event.addListener(O, "draggable_changed", N)));
  }, [N]), y(() => {
    O && Z && (Dt !== null && google.maps.event.removeListener(Dt), ln(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), y(() => {
    O && K && (Pt !== null && google.maps.event.removeListener(Pt), St(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), y(() => {
    O && X && (ut !== null && google.maps.event.removeListener(ut), Xe(google.maps.event.addListener(O, "position_changed", X)));
  }, [X]), y(() => {
    O && te && (un !== null && google.maps.event.removeListener(un), cn(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), y(() => {
    O && ee && (Nt !== null && google.maps.event.removeListener(Nt), Gn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), y(() => {
    O && D && (zt !== null && google.maps.event.removeListener(zt), Yn(google.maps.event.addListener(O, "visible_changed", D)));
  }, [D]), y(() => {
    O && j && ($t !== null && google.maps.event.removeListener($t), Sn(google.maps.event.addListener(O, "zindex_changed", j)));
  }, [j]), y(() => {
    var Ut = Bs(Bs(Bs({}, n || Md), r ? Md : {
      map: Y
    }), {}, {
      position: t
    }), oe = new google.maps.Marker(Ut);
    return r ? r.addMarker(oe, !!o) : oe.setMap(Y), t && oe.setPosition(t), typeof a < "u" && oe.setVisible(a), typeof s < "u" && oe.setDraggable(s), typeof u < "u" && oe.setClickable(u), typeof c == "string" && oe.setCursor(c), d && oe.setIcon(d), typeof p < "u" && oe.setLabel(p), typeof g < "u" && oe.setOpacity(g), f && oe.setShape(f), typeof m == "string" && oe.setTitle(m), typeof h == "number" && oe.setZIndex(h), w && T(google.maps.event.addListener(oe, "dblclick", w)), E && I(google.maps.event.addListener(oe, "dragend", E)), v && H(google.maps.event.addListener(oe, "dragstart", v)), k && ye(google.maps.event.addListener(oe, "mousedown", k)), x && Te(google.maps.event.addListener(oe, "mouseout", x)), L && Ne(google.maps.event.addListener(oe, "mouseover", L)), z && Ke(google.maps.event.addListener(oe, "mouseup", z)), R && Se(google.maps.event.addListener(oe, "rightclick", R)), C && rt(google.maps.event.addListener(oe, "click", C)), P && Me(google.maps.event.addListener(oe, "drag", P)), A && He(google.maps.event.addListener(oe, "clickable_changed", A)), U && ot(google.maps.event.addListener(oe, "cursor_changed", U)), V && Kt(google.maps.event.addListener(oe, "animation_changed", V)), N && ht(google.maps.event.addListener(oe, "draggable_changed", N)), Z && ln(google.maps.event.addListener(oe, "flat_changed", Z)), K && St(google.maps.event.addListener(oe, "icon_changed", K)), X && Xe(google.maps.event.addListener(oe, "position_changed", X)), te && cn(google.maps.event.addListener(oe, "shape_changed", te)), ee && Gn(google.maps.event.addListener(oe, "title_changed", ee)), D && Yn(google.maps.event.addListener(oe, "visible_changed", D)), j && Sn(google.maps.event.addListener(oe, "zindex_changed", j)), M(oe), G && G(oe), () => {
      W !== null && google.maps.event.removeListener(W), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ce !== null && google.maps.event.removeListener(ce), ie !== null && google.maps.event.removeListener(ie), Re !== null && google.maps.event.removeListener(Re), Ie !== null && google.maps.event.removeListener(Ie), Ze !== null && google.maps.event.removeListener(Ze), qe !== null && google.maps.event.removeListener(qe), Ge !== null && google.maps.event.removeListener(Ge), $e !== null && google.maps.event.removeListener($e), Fe !== null && google.maps.event.removeListener(Fe), lt !== null && google.maps.event.removeListener(lt), Dt !== null && google.maps.event.removeListener(Dt), Pt !== null && google.maps.event.removeListener(Pt), ut !== null && google.maps.event.removeListener(ut), Nt !== null && google.maps.event.removeListener(Nt), zt !== null && google.maps.event.removeListener(zt), $t !== null && google.maps.event.removeListener($t), S && S(oe), r ? r.removeMarker(oe, !!o) : oe && oe.setMap(null);
    };
  }, []);
  var pr = qn(() => i ? Ct.map(i, (Ut) => {
    if (!mi(Ut))
      return Ut;
    var oe = Ut;
    return vi(oe, {
      anchor: O
    });
  }) : null, [i, O]);
  return Rt.jsx(Rt.Fragment, {
    children: pr
  }) || null;
}
De(HX);
class WX extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return fA(function* () {
      var n = Bs(Bs(Bs({}, t.props.options || Md), t.props.clusterer ? Md : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Lt({
        updaterMap: zk,
        eventMap: Nk,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: zk,
      eventMap: Nk,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), jt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? Ct.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
he(WX, "contextType", at);
var VX = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), d = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(d !== null ? "".concat(d.y, "px") : "0", "; left: ").concat(d !== null ? "".concat(d.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var p = document.createElement("img");
        p.alt = a, p.src = this.url, p.width = this.width, p.height = this.height, p.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (p.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(p), this.div.appendChild(g), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), ZX = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new VX(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function qX(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var GX = 2e3, YX = 500, KX = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", XX = "png", JX = [53, 56, 66, 78, 90], QX = "cluster", yA = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || KX, this.imageExtension = r.imageExtension || XX, this.imageSizes = r.imageSizes || JX, this.calculator = r.calculator || qX, this.batchSize = r.batchSize || GX, this.batchSizeIE = r.batchSizeIE || YX, this.clusterClass = r.clusterClass || QX, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new ZX(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var d = 0, p = this.clusters; d < p.length; d++) {
            var g = p[d];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function $k(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function eJ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $k(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $k(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Kr = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, It = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, tJ = {};
function nJ(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: d,
    imageSizes: p,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: h,
    zoomOnClick: C,
    onClick: w,
    onClusteringBegin: P,
    onClusteringEnd: E,
    onMouseOver: v,
    onMouseOut: x,
    onLoad: L,
    onUnmount: z
  } = e, [k, R] = _(null), A = _e(at), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null);
  return y(() => {
    k && x && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(k, Kr.onMouseOut, x)));
  }, [x]), y(() => {
    k && v && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(k, Kr.onMouseOver, v)));
  }, [v]), y(() => {
    k && w && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(k, Kr.onClick, w)));
  }, [w]), y(() => {
    k && P && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(k, Kr.onClusteringBegin, P)));
  }, [P]), y(() => {
    k && E && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(k, Kr.onClusteringEnd, E)));
  }, [E]), y(() => {
    typeof r < "u" && k !== null && It.averageCenter(k, r);
  }, [k, r]), y(() => {
    typeof o < "u" && k !== null && It.batchSizeIE(k, o);
  }, [k, o]), y(() => {
    typeof i < "u" && k !== null && It.calculator(k, i);
  }, [k, i]), y(() => {
    typeof s < "u" && k !== null && It.clusterClass(k, s);
  }, [k, s]), y(() => {
    typeof a < "u" && k !== null && It.enableRetinaIcons(k, a);
  }, [k, a]), y(() => {
    typeof l < "u" && k !== null && It.gridSize(k, l);
  }, [k, l]), y(() => {
    typeof u < "u" && k !== null && It.ignoreHidden(k, u);
  }, [k, u]), y(() => {
    typeof c < "u" && k !== null && It.imageExtension(k, c);
  }, [k, c]), y(() => {
    typeof d < "u" && k !== null && It.imagePath(k, d);
  }, [k, d]), y(() => {
    typeof p < "u" && k !== null && It.imageSizes(k, p);
  }, [k, p]), y(() => {
    typeof g < "u" && k !== null && It.maxZoom(k, g);
  }, [k, g]), y(() => {
    typeof f < "u" && k !== null && It.minimumClusterSize(k, f);
  }, [k, f]), y(() => {
    typeof m < "u" && k !== null && It.styles(k, m);
  }, [k, m]), y(() => {
    typeof h < "u" && k !== null && It.title(k, h);
  }, [k, h]), y(() => {
    typeof C < "u" && k !== null && It.zoomOnClick(k, C);
  }, [k, C]), y(() => {
    if (A) {
      var G = eJ({}, n || tJ), S = new yA(A, [], G);
      return r && It.averageCenter(S, r), o && It.batchSizeIE(S, o), i && It.calculator(S, i), s && It.clusterClass(S, s), a && It.enableRetinaIcons(S, a), l && It.gridSize(S, l), u && It.ignoreHidden(S, u), c && It.imageExtension(S, c), d && It.imagePath(S, d), p && It.imageSizes(S, p), g && It.maxZoom(S, g), f && It.minimumClusterSize(S, f), m && It.styles(S, m), h && It.title(S, h), C && It.zoomOnClick(S, C), x && ee(google.maps.event.addListener(S, Kr.onMouseOut, x)), v && j(google.maps.event.addListener(S, Kr.onMouseOver, v)), w && V(google.maps.event.addListener(S, Kr.onClick, w)), P && Z(google.maps.event.addListener(S, Kr.onClusteringBegin, P)), E && X(google.maps.event.addListener(S, Kr.onClusteringEnd, E)), R(S), L && L(S), () => {
        te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), z && z(S);
      };
    }
  }, []), k !== null && t(k) || null;
}
De(nJ);
class rJ extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      markerClusterer: null
    }), he(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new yA(this.context, [], this.props.options);
      this.registeredEvents = Lt({
        updaterMap: It,
        eventMap: Kr,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: It,
      eventMap: Kr,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), jt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
he(rJ, "contextType", at);
function Uk(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var bA = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || Uk(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, Uk));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, d = this.div.offsetWidth, p = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), h = m.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + g ? r = h.x + u - g : h.x + d + u + g > a && (r = h.x + d + u + g - a), this.alignBottom ? h.y < -c + f + p ? o = h.y + c - f - p : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + p + c + f > l && (o = h.y + p + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), oJ = ["position"], iJ = ["position"];
function Hk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Td(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Hk(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Hk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wk = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Vk = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, sJ = {};
function aJ(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: p
  } = e, g = _e(at), [f, m] = _(null), [h, C] = _(null), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), R = Ye(null);
  return y(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    if (o && f !== null) {
      var A = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(A);
    }
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), P(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    if (g) {
      var A = r || sJ, {
        position: U
      } = A, V = ib(A, oJ), N;
      U && !(U instanceof google.maps.LatLng) && (N = new google.maps.LatLng(U.lat, U.lng));
      var Z = new bA(Td(Td({}, V), N ? {
        position: N
      } : {}));
      R.current = document.createElement("div"), m(Z), s && C(google.maps.event.addListener(Z, "closeclick", s)), a && P(google.maps.event.addListener(Z, "domready", a)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && L(google.maps.event.addListener(Z, "position_changed", u)), c && k(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(R.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : Jn(!1, "You must provide either an anchor or a position prop for <InfoBox>."), d && d(Z);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), p && p(f), f.close());
    };
  }, []), R.current ? dr(Ct.only(t), R.current) : null;
}
De(aJ);
class lJ extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", null), he(this, "state", {
      infoBox: null
    }), he(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Jn(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), he(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = ib(t, iJ), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new bA(Td(Td({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Lt({
      updaterMap: Vk,
      eventMap: Wk,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: Vk,
      eventMap: Wk,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), jt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? dr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
he(lJ, "contextType", at);
var Zk, qk;
function uJ() {
  return qk || (qk = 1, Zk = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), Zk;
}
var cJ = uJ(), Gk = /* @__PURE__ */ pA(cJ), Yk = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Xh = 1, ba = 8;
class sb {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Xh)
      throw new Error("Got v".concat(o, " data when expected v").concat(Xh, "."));
    var i = Yk[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new sb(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = Yk.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, ba, t), this.coords = new this.ArrayType(this.data, ba + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(ba + s + a + l), this.ids = new this.IndexArrayType(this.data, ba, t), this.coords = new this.ArrayType(this.data, ba + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Xh << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return jm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, d = l.pop() || 0, p = l.pop() || 0;
      if (d - p <= a) {
        for (var g = p; g <= d; g++) {
          var f = s[2 * g], m = s[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var h = p + d >> 1, C = s[2 * h], w = s[2 * h + 1];
      C >= t && C <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= C : n <= w) && (l.push(p), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= C : o >= w) && (l.push(h + 1), l.push(d), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, d = a.pop() || 0, p = a.pop() || 0;
      if (d - p <= s) {
        for (var g = p; g <= d; g++)
          Kk(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = p + d >> 1, m = i[2 * f], h = i[2 * f + 1];
      Kk(m, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= h) && (a.push(p), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= m : n + r >= h) && (a.push(f + 1), a.push(d), a.push(1 - c));
    }
    return l;
  }
}
function jm(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    wA(e, t, s, r, o, i), jm(e, t, n, r, s - 1, 1 - i), jm(e, t, n, s + 1, o, 1 - i);
  }
}
function wA(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), d = Math.max(r, Math.floor(n - a * u / s + c)), p = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      wA(e, t, n, d, p, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (wa(e, t, r, n), t[2 * o + i] > g && wa(e, t, r, o); f < m; ) {
      for (wa(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? wa(e, t, r, m) : (m++, wa(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function wa(e, t, n, r) {
  Jh(e, n, r), Jh(t, 2 * n, 2 * r), Jh(t, 2 * n + 1, 2 * r + 1);
}
function Jh(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function Kk(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var dJ = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, Xk = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Hi = 2, oi = 3, Qh = 4, ei = 5, CA = 6;
class pJ {
  constructor(t) {
    this.options = Object.assign(Object.create(dJ), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, d = Xk(sc(u)), p = Xk(ac(c));
        s.push(
          d,
          p,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(sc(r), ac(s), sc(i), ac(o)), d = u.data, p = [];
    for (var g of c) {
      var f = this.stride * g;
      p.push(d[f + ei] > 1 ? Jk(d, f, this.clusterProps) : this.points[d[f + oi]]);
    }
    return p;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), d = [];
    for (var p of c) {
      var g = p * this.stride;
      s[g + Qh] === t && d.push(s[g + ei] > 1 ? Jk(s, g, this.clusterProps) : this.points[s[g + oi]]);
    }
    if (d.length === 0) throw new Error(o);
    return d;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, d = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, d), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, d), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, d), d.features.length ? d : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new sb(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + ei] > 1, c = void 0, d = void 0, p = void 0;
      if (u)
        c = EA(n, l, this.clusterProps), d = n[l], p = n[l + 1];
      else {
        var g = this.points[n[l + oi]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        d = sc(f), p = ac(m);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (d * i - r)), Math.round(this.options.extent * (p * i - o))]],
        tags: c
      }, C = void 0;
      u || this.options.generateId ? C = n[l + oi] : C = this.points[n[l + oi]].id, C !== void 0 && (h.id = C), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, d = 0; d < l.length; d += c)
      if (!(l[d + Hi] <= n)) {
        l[d + Hi] = n;
        var p = l[d], g = l[d + 1], f = t.within(l[d], l[d + 1], a), m = l[d + ei], h = m;
        for (var C of f) {
          var w = C * c;
          l[w + Hi] > n && (h += l[w + ei]);
        }
        if (h > m && h >= s) {
          var P = p * m, E = g * m, v = void 0, x = -1, L = ((d / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var k = z * c;
            if (!(l[k + Hi] <= n)) {
              l[k + Hi] = n;
              var R = l[k + ei];
              P += l[k] * R, E += l[k + 1] * R, l[k + Qh] = L, i && (v || (v = this._map(l, d, !0), x = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, k)));
            }
          }
          l[d + Qh] = L, u.push(P / h, E / h, 1 / 0, L, -1, h), i && u.push(x);
        } else {
          for (var A = 0; A < c; A++) u.push(l[d + A]);
          if (h > 1)
            for (var U of f) {
              var V = U * c;
              if (!(l[V + Hi] <= n)) {
                l[V + Hi] = n;
                for (var N = 0; N < c; N++) u.push(l[V + N]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ei] > 1) {
      var o = this.clusterProps[t[n + CA]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + oi]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function Jk(e, t, n) {
  return {
    type: "Feature",
    id: e[t + oi],
    properties: EA(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [fJ(e[t]), hJ(e[t + 1])]
    }
  };
}
function EA(e, t, n) {
  var r = e[t + ei], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + CA], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + oi],
    point_count: r,
    point_count_abbreviated: o
  });
}
function sc(e) {
  return e / 360 + 0.5;
}
function ac(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function fJ(e) {
  return (e - 0.5) * 360;
}
function hJ(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function gJ(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Rr {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Am {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Rr.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Rr.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Rr.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class mJ {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return vJ(n);
  }
}
var vJ = (e) => {
  var t = e.map((n) => new Am({
    position: Rr.getPosition(n),
    markers: [n]
  }));
  return t;
};
class yJ extends mJ {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = gJ(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new pJ(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!Gk(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = Rr.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !Gk(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Am({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Am({
      markers: [i],
      position: Rr.getPosition(i)
    });
  }
}
class bJ {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class wJ {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Rr.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), d = c.parseFromString(a, "image/svg+xml").documentElement;
      d.setAttribute("transform", "translate(0 25)");
      var p = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: d
      };
      return new google.maps.marker.AdvancedMarkerElement(p);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function CJ(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class ab {
  constructor() {
    CJ(ab, google.maps.OverlayView);
  }
}
var qa;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(qa || (qa = {}));
var EJ = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class xJ extends ab {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new yJ(o),
      renderer: s = new wJ(),
      onClusterClick: a = EJ
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Rr.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, qa.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || Rr.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => Rr.setMap(l, null)));
      }
      google.maps.event.trigger(this, qa.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Rr.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new bJ(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Rr.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, qa.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Rr.setMap(r.marker, n);
    });
  }
}
function Qk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function e_(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qk(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Qk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function OJ(e) {
  var t = EX(), [n, r] = _(null);
  return y(() => {
    if (t && n === null) {
      var o = new xJ(e_(e_({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function kJ(e) {
  var {
    children: t,
    options: n
  } = e, r = OJ(n);
  return r !== null ? t(r) : null;
}
De(kJ);
var t_ = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, n_ = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function _J(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: p
  } = e, g = _e(at), [f, m] = _(null), [h, C] = _(null), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), R = Ye(null);
  return y(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), P(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    var A = new google.maps.InfoWindow(r);
    return m(A), R.current = document.createElement("div"), s && C(google.maps.event.addListener(A, "closeclick", s)), a && P(google.maps.event.addListener(A, "domready", a)), l && v(google.maps.event.addListener(A, "content_changed", l)), u && L(google.maps.event.addListener(A, "position_changed", u)), c && k(google.maps.event.addListener(A, "zindex_changed", c)), A.setContent(R.current), o && A.setPosition(o), i && A.setZIndex(i), n ? A.open(g, n) : A.getPosition() ? A.open(g) : Jn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), d && d(A), () => {
      h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), p && p(A), A.close();
    };
  }, []), R.current ? dr(Ct.only(t), R.current) : null;
}
De(_J);
class LJ extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", null), he(this, "state", {
      infoWindow: null
    }), he(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Jn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), he(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Lt({
      updaterMap: n_,
      eventMap: t_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: n_,
      eventMap: t_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (jt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? dr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
he(LJ, "contextType", at);
function r_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? r_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var o_ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, i_ = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, DJ = {};
function PJ(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: p,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onLoad: C,
    onUnmount: w
  } = e, P = _e(at), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null);
  return y(() => {
    E !== null && E.setMap(P);
  }, [P]), y(() => {
    typeof t < "u" && E !== null && E.setOptions(t);
  }, [E, t]), y(() => {
    typeof n < "u" && E !== null && E.setDraggable(n);
  }, [E, n]), y(() => {
    typeof r < "u" && E !== null && E.setEditable(r);
  }, [E, r]), y(() => {
    typeof o < "u" && E !== null && E.setVisible(o);
  }, [E, o]), y(() => {
    typeof i < "u" && E !== null && E.setPath(i);
  }, [E, i]), y(() => {
    E && s && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(E, "dblclick", s)));
  }, [s]), y(() => {
    E && a && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(E, "dragend", a)));
  }, [a]), y(() => {
    E && l && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(E, "dragstart", l)));
  }, [l]), y(() => {
    E && u && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(E, "mousedown", u)));
  }, [u]), y(() => {
    E && c && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(() => {
    E && d && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(E, "mouseout", d)));
  }, [d]), y(() => {
    E && p && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(E, "mouseover", p)));
  }, [p]), y(() => {
    E && g && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(E, "mouseup", g)));
  }, [g]), y(() => {
    E && f && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(E, "rightclick", f)));
  }, [f]), y(() => {
    E && m && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(E, "click", m)));
  }, [m]), y(() => {
    E && h && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(E, "drag", h)));
  }, [h]), y(() => {
    var T = new google.maps.Polyline(jd(jd({}, t || DJ), {}, {
      map: P
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), s && L(google.maps.event.addListener(T, "dblclick", s)), a && k(google.maps.event.addListener(T, "dragend", a)), l && A(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), d && X(google.maps.event.addListener(T, "mouseout", d)), p && ee(google.maps.event.addListener(T, "mouseover", p)), g && j(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && O(google.maps.event.addListener(T, "click", m)), h && W(google.maps.event.addListener(T, "drag", h)), v(T), C && C(T), () => {
      x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), G !== null && google.maps.event.removeListener(G), Y !== null && google.maps.event.removeListener(Y), w && w(T), T.setMap(null);
    };
  }, []), null;
}
De(PJ);
class SJ extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      polyline: null
    }), he(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(jd(jd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: i_,
      eventMap: o_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: i_,
      eventMap: o_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), jt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
he(SJ, "contextType", at);
function s_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function a_(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? s_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : s_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var l_ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, u_ = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function MJ(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: p,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: C,
    onLoad: w,
    onUnmount: P,
    onEdit: E
  } = e, v = _e(at), [x, L] = _(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null), [T, q] = _(null);
  return y(() => {
    x !== null && x.setMap(v);
  }, [v]), y(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), y(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), y(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), y(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), y(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), y(() => {
    typeof s < "u" && x !== null && x.setPaths(s);
  }, [x, s]), y(() => {
    x && typeof a == "function" && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), y(() => {
    x && (google.maps.event.addListener(x.getPath(), "insert_at", () => {
      E == null || E(x);
    }), google.maps.event.addListener(x.getPath(), "set_at", () => {
      E == null || E(x);
    }), google.maps.event.addListener(x.getPath(), "remove_at", () => {
      E == null || E(x);
    }));
  }, [x, E]), y(() => {
    x && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(x, "dragend", l)));
  }, [l]), y(() => {
    x && typeof u == "function" && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(x, "dragstart", u)));
  }, [u]), y(() => {
    x && typeof c == "function" && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(x, "mousedown", c)));
  }, [c]), y(() => {
    x && typeof d == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(x, "mousemove", d)));
  }, [d]), y(() => {
    x && typeof p == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), y(() => {
    x && typeof g == "function" && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(x, "mouseover", g)));
  }, [g]), y(() => {
    x && typeof f == "function" && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(x, "mouseup", f)));
  }, [f]), y(() => {
    x && typeof m == "function" && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(x, "rightclick", m)));
  }, [m]), y(() => {
    x && typeof h == "function" && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(x, "click", h)));
  }, [h]), y(() => {
    x && typeof C == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(x, "drag", C)));
  }, [C]), y(() => {
    var I = new google.maps.Polygon(a_(a_({}, t), {}, {
      map: v
    }));
    return i && I.setPath(i), s && I.setPaths(s), typeof o < "u" && I.setVisible(o), typeof r < "u" && I.setEditable(r), typeof n < "u" && I.setDraggable(n), a && k(google.maps.event.addListener(I, "dblclick", a)), l && A(google.maps.event.addListener(I, "dragend", l)), u && V(google.maps.event.addListener(I, "dragstart", u)), c && Z(google.maps.event.addListener(I, "mousedown", c)), d && X(google.maps.event.addListener(I, "mousemove", d)), p && ee(google.maps.event.addListener(I, "mouseout", p)), g && j(google.maps.event.addListener(I, "mouseover", g)), f && S(google.maps.event.addListener(I, "mouseup", f)), m && O(google.maps.event.addListener(I, "rightclick", m)), h && W(google.maps.event.addListener(I, "click", h)), C && q(google.maps.event.addListener(I, "drag", C)), L(I), w && w(I), () => {
      z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), G !== null && google.maps.event.removeListener(G), Y !== null && google.maps.event.removeListener(Y), M !== null && google.maps.event.removeListener(M), P && P(I), I.setMap(null);
    };
  }, []), null;
}
De(MJ);
class TJ extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Lt({
      updaterMap: u_,
      eventMap: l_,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: u_,
      eventMap: l_,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), jt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
he(TJ, "contextType", at);
function c_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ad(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? c_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var d_ = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, p_ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function jJ(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: p,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onBoundsChanged: C,
    onLoad: w,
    onUnmount: P
  } = e, E = _e(at), [v, x] = _(null), [L, z] = _(null), [k, R] = _(null), [A, U] = _(null), [V, N] = _(null), [Z, K] = _(null), [X, te] = _(null), [ee, D] = _(null), [j, G] = _(null), [S, Y] = _(null), [O, M] = _(null), [W, T] = _(null), [q, I] = _(null);
  return y(() => {
    v !== null && v.setMap(E);
  }, [E]), y(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), y(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), y(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), y(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), y(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), y(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), z(google.maps.event.addListener(v, "dblclick", s)));
  }, [s]), y(() => {
    v && a && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(v, "dragend", a)));
  }, [a]), y(() => {
    v && l && (A !== null && google.maps.event.removeListener(A), U(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), y(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), N(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), y(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), y(() => {
    v && d && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(v, "mouseout", d)));
  }, [d]), y(() => {
    v && p && (ee !== null && google.maps.event.removeListener(ee), D(google.maps.event.addListener(v, "mouseover", p)));
  }, [p]), y(() => {
    v && g && (j !== null && google.maps.event.removeListener(j), G(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), y(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), Y(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), y(() => {
    v && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(v, "click", m)));
  }, [m]), y(() => {
    v && h && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(v, "drag", h)));
  }, [h]), y(() => {
    v && C && (q !== null && google.maps.event.removeListener(q), I(google.maps.event.addListener(v, "bounds_changed", C)));
  }, [C]), y(() => {
    var J = new google.maps.Rectangle(Ad(Ad({}, t), {}, {
      map: E
    }));
    return typeof i < "u" && J.setVisible(i), typeof o < "u" && J.setEditable(o), typeof r < "u" && J.setDraggable(r), typeof n < "u" && J.setBounds(n), s && z(google.maps.event.addListener(J, "dblclick", s)), a && R(google.maps.event.addListener(J, "dragend", a)), l && U(google.maps.event.addListener(J, "dragstart", l)), u && N(google.maps.event.addListener(J, "mousedown", u)), c && K(google.maps.event.addListener(J, "mousemove", c)), d && te(google.maps.event.addListener(J, "mouseout", d)), p && D(google.maps.event.addListener(J, "mouseover", p)), g && G(google.maps.event.addListener(J, "mouseup", g)), f && Y(google.maps.event.addListener(J, "rightclick", f)), m && M(google.maps.event.addListener(J, "click", m)), h && T(google.maps.event.addListener(J, "drag", h)), C && I(google.maps.event.addListener(J, "bounds_changed", C)), x(J), w && w(J), () => {
      L !== null && google.maps.event.removeListener(L), k !== null && google.maps.event.removeListener(k), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), q !== null && google.maps.event.removeListener(q), P && P(J), J.setMap(null);
    };
  }, []), null;
}
De(jJ);
class AJ extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      rectangle: null
    }), he(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Ad(Ad({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: p_,
      eventMap: d_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: p_,
      eventMap: d_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), jt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
he(AJ, "contextType", at);
function f_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Bd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? f_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : f_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var h_ = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, g_ = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, BJ = {};
function IJ(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: p,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: C,
    onCenterChanged: w,
    onRadiusChanged: P,
    onLoad: E,
    onUnmount: v
  } = e, x = _e(at), [L, z] = _(null), [k, R] = _(null), [A, U] = _(null), [V, N] = _(null), [Z, K] = _(null), [X, te] = _(null), [ee, D] = _(null), [j, G] = _(null), [S, Y] = _(null), [O, M] = _(null), [W, T] = _(null), [q, I] = _(null), [J, H] = _(null), [ce, ye] = _(null);
  return y(() => {
    L !== null && L.setMap(x);
  }, [x]), y(() => {
    typeof t < "u" && L !== null && L.setOptions(t);
  }, [L, t]), y(() => {
    typeof o < "u" && L !== null && L.setDraggable(o);
  }, [L, o]), y(() => {
    typeof i < "u" && L !== null && L.setEditable(i);
  }, [L, i]), y(() => {
    typeof s < "u" && L !== null && L.setVisible(s);
  }, [L, s]), y(() => {
    typeof r == "number" && L !== null && L.setRadius(r);
  }, [L, r]), y(() => {
    typeof n < "u" && L !== null && L.setCenter(n);
  }, [L, n]), y(() => {
    L && a && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(L, "dblclick", a)));
  }, [a]), y(() => {
    L && l && (A !== null && google.maps.event.removeListener(A), U(google.maps.event.addListener(L, "dragend", l)));
  }, [l]), y(() => {
    L && u && (V !== null && google.maps.event.removeListener(V), N(google.maps.event.addListener(L, "dragstart", u)));
  }, [u]), y(() => {
    L && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(L, "mousedown", c)));
  }, [c]), y(() => {
    L && d && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(L, "mousemove", d)));
  }, [d]), y(() => {
    L && p && (ee !== null && google.maps.event.removeListener(ee), D(google.maps.event.addListener(L, "mouseout", p)));
  }, [p]), y(() => {
    L && g && (j !== null && google.maps.event.removeListener(j), G(google.maps.event.addListener(L, "mouseover", g)));
  }, [g]), y(() => {
    L && f && (S !== null && google.maps.event.removeListener(S), Y(google.maps.event.addListener(L, "mouseup", f)));
  }, [f]), y(() => {
    L && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(L, "rightclick", m)));
  }, [m]), y(() => {
    L && h && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(L, "click", h)));
  }, [h]), y(() => {
    L && C && (q !== null && google.maps.event.removeListener(q), I(google.maps.event.addListener(L, "drag", C)));
  }, [C]), y(() => {
    L && w && (J !== null && google.maps.event.removeListener(J), H(google.maps.event.addListener(L, "center_changed", w)));
  }, [h]), y(() => {
    L && P && (ce !== null && google.maps.event.removeListener(ce), ye(google.maps.event.addListener(L, "radius_changed", P)));
  }, [P]), y(() => {
    var ie = new google.maps.Circle(Bd(Bd({}, t || BJ), {}, {
      map: x
    }));
    return typeof r == "number" && ie.setRadius(r), typeof n < "u" && ie.setCenter(n), typeof r == "number" && ie.setRadius(r), typeof s < "u" && ie.setVisible(s), typeof i < "u" && ie.setEditable(i), typeof o < "u" && ie.setDraggable(o), a && R(google.maps.event.addListener(ie, "dblclick", a)), l && U(google.maps.event.addListener(ie, "dragend", l)), u && N(google.maps.event.addListener(ie, "dragstart", u)), c && K(google.maps.event.addListener(ie, "mousedown", c)), d && te(google.maps.event.addListener(ie, "mousemove", d)), p && D(google.maps.event.addListener(ie, "mouseout", p)), g && G(google.maps.event.addListener(ie, "mouseover", g)), f && Y(google.maps.event.addListener(ie, "mouseup", f)), m && M(google.maps.event.addListener(ie, "rightclick", m)), h && T(google.maps.event.addListener(ie, "click", h)), C && I(google.maps.event.addListener(ie, "drag", C)), w && H(google.maps.event.addListener(ie, "center_changed", w)), P && ye(google.maps.event.addListener(ie, "radius_changed", P)), z(ie), E && E(ie), () => {
      k !== null && google.maps.event.removeListener(k), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), J !== null && google.maps.event.removeListener(J), ce !== null && google.maps.event.removeListener(ce), v && v(ie), ie.setMap(null);
    };
  }, []), null;
}
De(IJ);
class FJ extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      circle: null
    }), he(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Bd(Bd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: g_,
      eventMap: h_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: g_,
      eventMap: h_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), jt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
he(FJ, "contextType", at);
function m_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Id(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? m_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : m_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var v_ = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, y_ = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function RJ(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: d,
    onRemoveProperty: p,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: h
  } = e, C = _e(at), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null), [T, q] = _(null);
  return y(() => {
    w !== null && w.setMap(C);
  }, [C]), y(() => {
    w && r && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), y(() => {
    w && o && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), y(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), y(() => {
    w && s && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), y(() => {
    w && a && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), y(() => {
    w && l && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), y(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), y(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), y(() => {
    w && c && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), y(() => {
    w && d && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(w, "removefeature", d)));
  }, [d]), y(() => {
    w && p && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(w, "removeproperty", p)));
  }, [p]), y(() => {
    w && g && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), y(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), y(() => {
    if (C !== null) {
      var I = new google.maps.Data(Id(Id({}, t), {}, {
        map: C
      }));
      r && v(google.maps.event.addListener(I, "dblclick", r)), o && L(google.maps.event.addListener(I, "mousedown", o)), i && k(google.maps.event.addListener(I, "mousemove", i)), s && A(google.maps.event.addListener(I, "mouseout", s)), a && V(google.maps.event.addListener(I, "mouseover", a)), l && Z(google.maps.event.addListener(I, "mouseup", l)), u && X(google.maps.event.addListener(I, "rightclick", u)), n && ee(google.maps.event.addListener(I, "click", n)), c && j(google.maps.event.addListener(I, "addfeature", c)), d && S(google.maps.event.addListener(I, "removefeature", d)), p && O(google.maps.event.addListener(I, "removeproperty", p)), g && W(google.maps.event.addListener(I, "setgeometry", g)), f && q(google.maps.event.addListener(I, "setproperty", f)), P(I), m && m(I);
    }
    return () => {
      w && (E !== null && google.maps.event.removeListener(E), x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), G !== null && google.maps.event.removeListener(G), Y !== null && google.maps.event.removeListener(Y), M !== null && google.maps.event.removeListener(M), T !== null && google.maps.event.removeListener(T), h && h(w), w.setMap(null));
    };
  }, []), null;
}
De(RJ);
class NJ extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      data: null
    }), he(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Id(Id({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Lt({
        updaterMap: y_,
        eventMap: v_,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: y_,
      eventMap: v_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), jt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
he(NJ, "contextType", at);
function b_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function w_(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? b_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : b_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var C_ = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, E_ = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class zJ extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      kmlLayer: null
    }), he(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(w_(w_({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: E_,
      eventMap: C_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: E_,
      eventMap: C_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), jt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(zJ, "contextType", at);
function xA(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function $J(e, t) {
  return new t(e.lat, e.lng);
}
function UJ(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function HJ(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function WJ(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function VJ(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function ZJ(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function OA(e, t, n, r) {
  return n !== void 0 ? VJ(e, t, WJ(n, google.maps.LatLngBounds, UJ)) : ZJ(e, t, HJ(r, google.maps.LatLng, $J));
}
function qJ(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function x_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function GJ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? x_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : x_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function YJ(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = GJ({}, this.container ? xA(this.container, o) : {
        x: 0,
        y: 0
      }), u = OA(a, l, this.bounds, this.position);
      for (var [c, d] of Object.entries(u))
        this.container.style[c] = d;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function O_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function KJ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? O_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : O_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function k_(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function __(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function XJ(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = _e(at), c = qn(() => {
    var p = document.createElement("div");
    return p.style.position = "absolute", p;
  }, []), d = qn(() => YJ(c, r, t, n, a), [c, r, t, n]);
  return y(() => (i == null || i(d), d == null || d.setMap(u), () => {
    s == null || s(d), d == null || d.setMap(null);
  }), [u, d]), y(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
De(XJ);
class ea extends Ee {
  constructor(t) {
    super(t), he(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), he(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Jn(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), he(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), he(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = KJ({
        x: 0,
        y: 0
      }, this.containerRef.current ? xA(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = OA(r, o, this.props.bounds, this.props.position);
      if (!qJ(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), he(this, "draw", () => {
      this.onPositionElement();
    }), he(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = eo();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = k_(t.position), r = k_(this.props.position), o = __(t.bounds), i = __(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(Rt.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: Ct.only(this.props.children)
    }), t) : null;
  }
}
he(ea, "FLOAT_PANE", "floatPane");
he(ea, "MAP_PANE", "mapPane");
he(ea, "MARKER_LAYER", "markerLayer");
he(ea, "OVERLAY_LAYER", "overlayLayer");
he(ea, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
he(ea, "contextType", at);
function JJ() {
}
function L_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function D_(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? L_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : L_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var P_ = {
  onDblClick: "dblclick",
  onClick: "click"
}, S_ = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function QJ(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = _e(at), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = qn(() => new google.maps.GroundOverlay(t, s, r), []);
  return y(() => {
    a !== null && a.setMap(i);
  }, [i]), y(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), y(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), y(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
De(QJ);
class kA extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      groundOverlay: null
    }), he(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Jn(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, D_(D_({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: S_,
      eventMap: P_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: S_,
      eventMap: P_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
he(kA, "defaultProps", {
  onLoad: JJ
});
he(kA, "contextType", at);
function M_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? M_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : M_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var T_ = {}, j_ = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function eQ(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = _e(at), [s, a] = _(null);
  return y(() => {
    google.maps.visualization || Jn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(() => {
    Jn(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), y(() => {
    s !== null && s.setMap(i);
  }, [i]), y(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), y(() => {
    var l = new google.maps.visualization.HeatmapLayer(Fd(Fd({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
De(eQ);
class tQ extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      heatmapLayer: null
    }), he(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Jn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Jn(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Fd(Fd({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: j_,
      eventMap: T_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: j_,
      eventMap: T_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), jt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(tQ, "contextType", at);
var A_ = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, B_ = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class nQ extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      streetViewPanorama: null
    }), he(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Lt({
      updaterMap: B_,
      eventMap: A_,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: B_,
      eventMap: A_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), jt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
he(nQ, "contextType", at);
class rQ extends Ee {
  constructor() {
    super(...arguments), he(this, "state", {
      streetViewService: null
    }), he(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
he(rQ, "contextType", at);
var I_ = {
  onDirectionsChanged: "directions_changed"
}, F_ = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class oQ extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      directionsRenderer: null
    }), he(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Lt({
      updaterMap: F_,
      eventMap: I_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: F_,
      eventMap: I_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), jt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
he(oQ, "contextType", at);
var R_ = {
  onPlacesChanged: "places_changed"
}, N_ = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class iQ extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", eo()), he(this, "state", {
      searchBox: null
    }), he(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Jn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Lt({
          updaterMap: N_,
          eventMap: R_,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: N_,
      eventMap: R_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), jt(this.registeredEvents));
  }
  render() {
    return Rt.jsx("div", {
      ref: this.containerElement,
      children: Ct.only(this.props.children)
    });
  }
}
he(iQ, "contextType", at);
var z_ = {
  onPlaceChanged: "place_changed"
}, $_ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class _A extends Ee {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", eo()), he(this, "state", {
      autocomplete: null
    }), he(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Jn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Lt({
        updaterMap: $_,
        eventMap: z_,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    jt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: $_,
      eventMap: z_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && jt(this.registeredEvents);
  }
  render() {
    return Rt.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: Ct.only(this.props.children)
    });
  }
}
he(_A, "defaultProps", {
  className: ""
});
he(_A, "contextType", at);
let sQ = { data: "" }, aQ = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || sQ, lQ = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, uQ = /\/\*[^]*?\*\/|  +/g, U_ = /\n+/g, ci = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? ci(s, i) : i + "{" + ci(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += ci(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ci.p ? ci.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Do = {}, LA = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + LA(e[n]);
    return t;
  }
  return e;
}, cQ = (e, t, n, r, o) => {
  let i = LA(e), s = Do[i] || (Do[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Do[s]) {
    let l = i !== e ? e : ((u) => {
      let c, d, p = [{}];
      for (; c = lQ.exec(u.replace(uQ, "")); ) c[4] ? p.shift() : c[3] ? (d = c[3].replace(U_, " ").trim(), p.unshift(p[0][d] = p[0][d] || {})) : p[0][c[1]] = c[2].replace(U_, " ").trim();
      return p[0];
    })(e);
    Do[s] = ci(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Do.g ? Do.g : null;
  return n && (Do.g = Do[s]), ((l, u, c, d) => {
    d ? u.data = u.data.replace(d, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Do[s], t, r, a), s;
}, dQ = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : ci(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function mf(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return cQ(n.unshift ? n.raw ? dQ(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, aQ(t.target), t.g, t.o, t.k);
}
let DA, Bm, Im;
mf.bind({ g: 1 });
let Fo = mf.bind({ k: 1 });
function pQ(e, t, n, r) {
  ci.p = t, DA = e, Bm = n, Im = r;
}
function Pi(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: Bm && Bm() }, a), n.o = / *go\d+/.test(l), a.className = mf.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), Im && u[0] && Im(a), DA(u, a);
    }
    return o;
  };
}
var fQ = (e) => typeof e == "function", hQ = (e, t) => fQ(e) ? e(t) : e, gQ = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), mQ = Fo`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, vQ = Fo`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, yQ = Fo`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, bQ = Pi("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${mQ} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${vQ} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${yQ} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, wQ = Fo`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, CQ = Pi("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${wQ} 1s linear infinite;
`, EQ = Fo`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, xQ = Fo`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, OQ = Pi("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${EQ} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${xQ} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, kQ = Pi("div")`
  position: absolute;
`, _Q = Pi("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, LQ = Fo`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, DQ = Pi("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${LQ} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, PQ = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ue.createElement(DQ, null, t) : t : n === "blank" ? null : Ue.createElement(_Q, null, Ue.createElement(CQ, { ...r }), n !== "loading" && Ue.createElement(kQ, null, n === "error" ? Ue.createElement(bQ, { ...r }) : Ue.createElement(OQ, { ...r })));
}, SQ = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, MQ = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, TQ = "0%{opacity:0;} 100%{opacity:1;}", jQ = "0%{opacity:1;} 100%{opacity:0;}", AQ = Pi("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, BQ = Pi("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, IQ = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = gQ() ? [TQ, jQ] : [SQ(n), MQ(n)];
  return { animation: t ? `${Fo(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Fo(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ue.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? IQ(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ue.createElement(PQ, { toast: e }), s = Ue.createElement(BQ, { ...e.ariaProps }, hQ(e.message, e));
  return Ue.createElement(AQ, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ue.createElement(Ue.Fragment, null, i, s));
});
pQ(Ue.createElement);
mf`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function FQ(e) {
  const { error: t } = e, n = "arkynAudioUploadError";
  return t ? /* @__PURE__ */ B.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ B.jsx(B.Fragment, {});
}
function RQ(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynAudioUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ B.jsx("strong", { className: o.trim(), children: t });
}
function NQ(e) {
  const { onChange: t, value: n, disableDrag: r = !1, onDragging: o } = e, [i, s] = _(!1), a = Ye(null), l = () => {
    s(!0);
  }, u = () => {
    s(!1);
  }, c = (f) => {
    if (r || !i || !a.current) return;
    const m = a.current.getBoundingClientRect(), h = f.clientX - m.left, C = Math.min(Math.max(h / m.width * 100, 0), 100);
    t(C);
  }, d = (f) => {
    if (!a.current) return;
    const m = a.current.getBoundingClientRect(), h = f.clientX - m.left, C = Math.min(Math.max(h / m.width * 100, 0), 100);
    t(C);
  };
  y(() => (i ? (o && o(!0), document.addEventListener("mousemove", c), document.addEventListener("mouseup", u)) : (o && o(!1), document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u)), () => {
    document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
  }), [i]);
  const g = `arkynSliderTrack ${i ? "isDragging" : "isNotDragging"}`;
  return /* @__PURE__ */ B.jsxs(
    "div",
    {
      className: g,
      ref: a,
      onMouseDown: l,
      onClick: d,
      children: [
        /* @__PURE__ */ B.jsx("div", { className: "arkynSliderFill", style: { width: `${n}%` } }),
        /* @__PURE__ */ B.jsx("div", { className: "arkynSliderThumb", style: { left: `${n}%` } })
      ]
    }
  );
}
function zQ(e) {
  var L, z, k, R;
  const {
    filePath: t,
    disabled: n,
    acceptAudio: r,
    handleSelectFile: o,
    isLoading: i,
    reSendAudio: s,
    changeAudioButtonText: a
  } = e, [l, u] = _(0), c = Ye(null), [d, p] = _(!1), [g, f] = _(!1);
  y(() => {
    const A = c.current;
    if (!A) return;
    const U = () => {
      const V = A.duration, Z = A.currentTime / V * 100;
      u(Z);
    };
    return A.addEventListener("timeupdate", U), () => {
      A.removeEventListener("timeupdate", U);
    };
  }, []);
  function m(A) {
    const U = c.current;
    if (!U) return;
    const V = U.duration, N = A / 100 * V;
    U.currentTime = N;
  }
  function h() {
    var A;
    (A = c.current) == null || A.play(), f(!0);
  }
  function C() {
    var A;
    (A = c.current) == null || A.pause(), f(!1);
  }
  function w() {
    g ? C() : h();
  }
  const P = (L = c.current) == null ? void 0 : L.currentTime, E = (z = c.current) == null ? void 0 : z.duration;
  function v(A) {
    if (!A) return "00:00";
    const U = Math.floor(A / 60), V = Math.floor(A % 60), N = String(U).padStart(2, "0"), Z = String(V).padStart(2, "0");
    return `${N}:${Z}`;
  }
  d || !g ? (k = c.current) == null || k.pause() : g && ((R = c.current) == null || R.play());
  function x() {
    if (n) return;
    const A = document.createElement("input");
    A.type = "file", A.accept = r, A.onchange = (U) => {
      var N;
      const V = (N = U.target.files) == null ? void 0 : N[0];
      V && o(V);
    }, A.click();
  }
  return /* @__PURE__ */ B.jsxs("div", { className: "arkynAudioUploadHasFileContentContainer", children: [
    /* @__PURE__ */ B.jsx("audio", { ref: c, src: t, onEnded: C }),
    /* @__PURE__ */ B.jsxs("div", { className: "arkynAudioUploadAudioPlayer", children: [
      /* @__PURE__ */ B.jsxs("button", { type: "button", onClick: w, children: [
        g && /* @__PURE__ */ B.jsx(DI, {}),
        !g && /* @__PURE__ */ B.jsx(PI, {})
      ] }),
      /* @__PURE__ */ B.jsx("p", { children: v(P) }),
      /* @__PURE__ */ B.jsx(
        NQ,
        {
          value: l,
          onChange: m,
          onDragging: p
        }
      ),
      /* @__PURE__ */ B.jsx("p", { children: v(E) })
    ] }),
    /* @__PURE__ */ B.jsx(y$, {}),
    /* @__PURE__ */ B.jsxs("div", { className: "arkynAudioUploadButtonsContainer", children: [
      !!s && /* @__PURE__ */ B.jsx(bG, { orientation: "bottom", text: "Reenviar áudio", children: /* @__PURE__ */ B.jsx(
        yG,
        {
          type: "button",
          "aria-label": "resend image",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: i,
          onClick: s,
          icon: tv,
          disabled: n
        }
      ) }),
      /* @__PURE__ */ B.jsx(
        Zy,
        {
          isLoading: i,
          onClick: x,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: n,
          children: a
        }
      )
    ] })
  ] });
}
function $Q(e) {
  const {
    dropAudioText: t,
    isLoading: n,
    acceptAudio: r,
    handleSelectFile: o,
    selectAudioButtonText: i,
    disabled: s
  } = e;
  function a(u) {
    if (s) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (s) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var p;
      const d = (p = c.target.files) == null ? void 0 : p[0];
      d && o(d);
    }, u.click();
  }
  return /* @__PURE__ */ B.jsxs("div", { onDrop: a, className: "arkynAudioUploadNoFileContent", children: [
    /* @__PURE__ */ B.jsx(
      Zy,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: s,
        children: i
      }
    ),
    /* @__PURE__ */ B.jsx("p", { children: t })
  ] });
}
function due(e) {
  const {
    name: t,
    label: n,
    fileName: r = "file",
    method: o = "POST",
    onUpload: i,
    fileResponseName: s = "url",
    selectAudioButtonText: a = "Selecionar arquivo de áudio",
    dropAudioText: l = "Ou arraste e solte um arquivo de áudio aqui",
    changeAudioButtonText: u = "Trocar arquivo de áudio",
    acceptAudio: c = "audio/*",
    action: d,
    defaultValue: p = "",
    showAsterisk: g = !1,
    disabled: f = !1
  } = e, h = vG()[t], [C, w] = _(p), [P, E] = _(""), [v, x] = _(null), [L, z] = _(p), [k, R] = _(!1);
  async function A(X) {
    if (f) return;
    R(!0), x(X), E("");
    const te = new FormData();
    te.append(r, X), await fetch(d, { method: o, body: te }).then(async (ee) => await ee.json()).then((ee) => {
      ee != null && ee.error ? E(ee.error) : w(ee == null ? void 0 : ee[s]), i && i(ee == null ? void 0 : ee[s]);
    }).catch((ee) => {
      console.error(ee), E("Erro ao enviar audio");
    }).finally(() => R(!1));
  }
  function U(X) {
    if (!f) {
      if (console.log(X.type), X.type.indexOf("audio") === -1) {
        E("O arquivo selecionado não é um arquivo de áudio");
        return;
      }
      z(URL.createObjectURL(X)), A(X);
    }
  }
  const V = h || P, K = `arkynAudioUpload ${V ? "hasError" : "noHasError"} ${L ? "hasAudio" : "noHasAudio"}`;
  return /* @__PURE__ */ B.jsxs("div", { className: "arkynAudioUploadContainer", children: [
    n && /* @__PURE__ */ B.jsx(RQ, { label: n, showAsterisk: g }),
    /* @__PURE__ */ B.jsxs("div", { className: K, children: [
      /* @__PURE__ */ B.jsx("input", { type: "hidden", name: t, value: C || "" }),
      !L && /* @__PURE__ */ B.jsx(
        $Q,
        {
          disabled: f,
          isLoading: k,
          acceptAudio: c,
          dropAudioText: l,
          handleSelectFile: U,
          selectAudioButtonText: a
        }
      ),
      L && /* @__PURE__ */ B.jsx(
        zQ,
        {
          filePath: L,
          acceptAudio: c,
          changeAudioButtonText: u,
          disabled: f,
          handleSelectFile: U,
          isLoading: k,
          reSendAudio: V && v ? () => A(v) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ B.jsx(FQ, { error: V })
  ] });
}
function kl(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: s,
    rightIcon: a,
    disabled: l,
    className: u = "",
    children: c,
    ...d
  } = e, g = { xs: 12, sm: 16, md: 20, lg: 24 }[i], h = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ B.jsxs("button", { className: h, disabled: l || t, ...d, children: [
    /* @__PURE__ */ B.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ B.jsx(vo, { size: g, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ B.jsxs("div", { className: "arkynButtonContent", children: [
      Fc(g, s),
      c,
      Fc(g, a)
    ] })
  ] });
}
function lb() {
  const e = ov(), t = jP(), n = iv(), [r, o] = _(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function s() {
    r && o(null);
  }
  y(() => {
    var c, d;
    let u = ((d = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : d.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, e]), y(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && s();
  }, [n, t]);
  const a = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(a || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const PA = Ve({});
function H_(e) {
  var d;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = lb(), s = Ye(null), a = ((d = s.current) == null ? void 0 : d.name) || "", l = (i == null ? void 0 : i[a]) || null, u = xI(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ B.jsx(PA.Provider, { value: { error: l, id: u, inputRef: s }, children: /* @__PURE__ */ B.jsx(
    "section",
    {
      id: r || a || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function Er() {
  return _e(PA);
}
function pue(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: s = null,
    onCheck: a,
    value: l,
    ...u
  } = e, { id: c, inputRef: d, error: p } = Er(), g = o || !!p, [f, m] = _(i || !1), h = typeof s == "boolean" ? s : f, P = `arkynCheckbox ${r} ${g ? "errorTrue" : "errorFalse"} ${h ? "checkedTrue" : "checkedFalse"} ${n}`;
  function E() {
    const v = f;
    m(!v), a && a(v ? "" : l || "checked");
  }
  return /* @__PURE__ */ B.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: P,
      onClick: E,
      ...u,
      children: [
        /* @__PURE__ */ B.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: d,
            value: h ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ B.jsx(Xd, {})
      ]
    }
  );
}
function UQ(e) {
  const { error: t } = e, n = "arkynFileUploadError";
  return t ? /* @__PURE__ */ B.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ B.jsx(B.Fragment, {});
}
function HQ(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynFileUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ B.jsx("strong", { className: o.trim(), children: t });
}
function SA(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: s,
    className: a = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, d = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${a}`;
  return /* @__PURE__ */ B.jsxs(
    "button",
    {
      disabled: s || t,
      className: d.trim(),
      ...l,
      children: [
        /* @__PURE__ */ B.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ B.jsx(vo, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ B.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ B.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function MA(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...s
  } = e, a = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ B.jsxs("div", { className: a.trim(), ...s, children: [
    r,
    /* @__PURE__ */ B.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function WQ(e) {
  const {
    disabled: t,
    file: n,
    isLoading: r,
    acceptFile: o,
    changeFileButtonText: i,
    handleSelectFile: s,
    reSendFile: a
  } = e;
  function l() {
    if (t) return;
    const c = document.createElement("input");
    c.type = "file", c.accept = o, c.onchange = (d) => {
      var g;
      const p = (g = d.target.files) == null ? void 0 : g[0];
      p && s(p);
    }, c.click();
  }
  function u() {
    return n.type.startsWith("image/") ? /* @__PURE__ */ B.jsx(SI, {}) : n.type.startsWith("audio/") ? /* @__PURE__ */ B.jsx(MI, {}) : n.type.startsWith("application/zip") ? /* @__PURE__ */ B.jsx(TI, {}) : /* @__PURE__ */ B.jsx(jI, {});
  }
  return /* @__PURE__ */ B.jsxs("div", { className: "arkynFileUploadHasFileContent", children: [
    /* @__PURE__ */ B.jsxs("section", { className: "arkynFileUploadFileContainer", children: [
      /* @__PURE__ */ B.jsx(u, {}),
      /* @__PURE__ */ B.jsx("p", { children: n.name })
    ] }),
    /* @__PURE__ */ B.jsx(mS, {}),
    /* @__PURE__ */ B.jsxs("div", { className: "arkynFileUploadButtonsContainer", children: [
      !!a && /* @__PURE__ */ B.jsx(MA, { orientation: "bottom", text: "Reenviar arquivo", children: /* @__PURE__ */ B.jsx(
        SA,
        {
          type: "button",
          "aria-label": "resend file",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: r,
          onClick: a,
          icon: tv,
          disabled: t
        }
      ) }),
      /* @__PURE__ */ B.jsx(
        kl,
        {
          isLoading: r,
          onClick: l,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: t,
          children: i
        }
      )
    ] })
  ] });
}
function VQ(e) {
  const {
    dropFileText: t,
    isLoading: n,
    acceptFile: r,
    handleSelectFile: o,
    selectFileButtonText: i,
    disabled: s
  } = e;
  function a(u) {
    if (s) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (s) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var p;
      const d = (p = c.target.files) == null ? void 0 : p[0];
      d && o(d);
    }, u.click();
  }
  return /* @__PURE__ */ B.jsxs("div", { onDrop: a, className: "arkynFileUploadNoFileContent", children: [
    /* @__PURE__ */ B.jsx(
      Zy,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: s,
        children: i
      }
    ),
    /* @__PURE__ */ B.jsx("p", { children: t })
  ] });
}
function fue(e) {
  const {
    name: t,
    label: n,
    showAsterisk: r = !1,
    action: o,
    fileName: i = "file",
    method: s = "POST",
    acceptFile: a = "*",
    fileResponseName: l = "url",
    changeFileButtonText: u = "Alterar arquivo",
    selectFileButtonText: c = "Selecionar arquivo",
    dropFileText: d = "Ou arraste e solte o arquivo aqui",
    onUpload: p,
    disabled: g = !1
  } = e, m = lb()[t], [h, C] = _(""), [w, P] = _(""), [E, v] = _(null), [x, L] = _(!1);
  async function z(N) {
    if (g) return;
    L(!0), v(N), P("");
    const Z = new FormData();
    Z.append(i, N), await fetch(o, { method: s, body: Z }).then(async (K) => await K.json()).then((K) => {
      K != null && K.error ? P(K.error) : C(K == null ? void 0 : K[l]), p && p(K == null ? void 0 : K[l]);
    }).catch((K) => {
      console.error(K), P("Erro ao enviar o arquivo");
    }).finally(() => L(!1));
  }
  function k(N) {
    g || z(N);
  }
  const R = m || w, V = `arkynFileUpload ${R ? "hasError" : "noHasError"} ${E ? "hasFile" : "noHasFile"}`;
  return /* @__PURE__ */ B.jsxs("div", { className: "arkynFileUploadContainer", children: [
    n && /* @__PURE__ */ B.jsx(HQ, { label: n, showAsterisk: r }),
    /* @__PURE__ */ B.jsxs("div", { className: V, children: [
      /* @__PURE__ */ B.jsx("input", { type: "hidden", name: t, value: h || "" }),
      !E && /* @__PURE__ */ B.jsx(
        VQ,
        {
          disabled: g,
          isLoading: x,
          acceptFile: a,
          dropFileText: d,
          handleSelectFile: k,
          selectFileButtonText: c
        }
      ),
      E && /* @__PURE__ */ B.jsx(
        WQ,
        {
          disabled: g,
          isLoading: x,
          acceptFile: a,
          file: E,
          handleSelectFile: k,
          changeFileButtonText: u,
          reSendFile: R && E ? () => z(E) : void 0
        }
      )
    ] }),
    R && /* @__PURE__ */ B.jsx(UQ, { error: R })
  ] });
}
function hue(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = Er();
  return t ? /* @__PURE__ */ B.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ B.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ B.jsx(B.Fragment, {});
}
function W_(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = Er(), s = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ B.jsx("label", { className: s.trim(), htmlFor: o, ...r });
}
function ZQ(e) {
  const {
    disabled: t,
    filePath: n,
    isLoading: r,
    acceptImage: o,
    changeImageButtonText: i,
    handleSelectFile: s,
    reSendImage: a
  } = e;
  function l() {
    if (t) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = o, u.onchange = (c) => {
      var p;
      const d = (p = c.target.files) == null ? void 0 : p[0];
      d && s(d);
    }, u.click();
  }
  return /* @__PURE__ */ B.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${n}")` },
      children: [
        a && /* @__PURE__ */ B.jsx(MA, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ B.jsx(
          SA,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: r,
            onClick: a,
            icon: tv,
            disabled: t
          }
        ) }),
        /* @__PURE__ */ B.jsx(
          kl,
          {
            isLoading: r,
            onClick: l,
            variant: "outline",
            size: "sm",
            type: "button",
            disabled: t,
            children: i
          }
        )
      ]
    }
  );
}
function qQ(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ B.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ B.jsx(B.Fragment, {});
}
function GQ(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ B.jsx("strong", { className: o.trim(), children: t });
}
function YQ(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i,
    disabled: s
  } = e;
  function a(u) {
    if (s) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (s) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var p;
      const d = (p = c.target.files) == null ? void 0 : p[0];
      d && o(d);
    }, u.click();
  }
  return /* @__PURE__ */ B.jsxs("div", { onDrop: a, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ B.jsx(
      kl,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: s,
        children: i
      }
    ),
    /* @__PURE__ */ B.jsx("p", { children: t })
  ] });
}
function KQ(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: s = "file",
    method: a = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: d = "Selecionar imagem",
    dropImageText: p = "Ou arraste e solte a imagem aqui",
    onUpload: g,
    disabled: f = !1
  } = e, h = lb()[t], [C, w] = _(n), [P, E] = _(""), [v, x] = _(null), [L, z] = _(n), [k, R] = _(!1);
  async function A(X) {
    if (f) return;
    R(!0), x(X), E("");
    const te = new FormData();
    te.append(s, X), await fetch(i, { method: a, body: te }).then(async (ee) => await ee.json()).then((ee) => {
      ee != null && ee.error ? E(ee.error) : w(ee == null ? void 0 : ee[u]), g && g(ee == null ? void 0 : ee[u]);
    }).catch((ee) => {
      console.error(ee), E("Erro ao enviar imagem");
    }).finally(() => R(!1));
  }
  function U(X) {
    f || (z(URL.createObjectURL(X)), A(X));
  }
  const V = h || P, K = `arkynImageUpload ${V ? "hasError" : "noHasError"} ${L ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ B.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ B.jsx(GQ, { label: r, showAsterisk: o }),
    /* @__PURE__ */ B.jsxs("div", { className: K, children: [
      /* @__PURE__ */ B.jsx("input", { type: "hidden", name: t, value: C || "" }),
      !L && /* @__PURE__ */ B.jsx(
        YQ,
        {
          disabled: f,
          isLoading: k,
          acceptImage: l,
          dropImageText: p,
          handleSelectFile: U,
          selectImageButtonText: d
        }
      ),
      L && /* @__PURE__ */ B.jsx(
        ZQ,
        {
          disabled: f,
          isLoading: k,
          acceptImage: l,
          filePath: L,
          handleSelectFile: U,
          changeImageButtonText: c,
          reSendImage: V && v ? () => A(v) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ B.jsx(qQ, { error: V })
  ] });
}
function hi(e, t, n) {
  if (!e) return /* @__PURE__ */ B.jsx(B.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ B.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ B.jsx("p", { className: n, children: /* @__PURE__ */ B.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function ub(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function TA(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function jA(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const cb = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, AA = ub(cb.CNPJ).length;
function XQ(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: d,
    defaultValue: p,
    readOnly: g,
    onFocus: f,
    onBlur: m,
    title: h,
    style: C,
    onChange: w,
    ...P
  } = e;
  function E(N) {
    let Z = ub(N);
    const K = jA(Z);
    if (!(Z.length > AA))
      return Z = TA(Z, cb[K]), Z;
  }
  const v = c ? "right" : "left", A = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${d || g || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: A,
    prefix: hi(a, V, "prefix"),
    sufix: hi(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: E(p || ""),
    disabled: d,
    readOnly: g,
    onFocus: f,
    onBlur: m,
    title: h,
    style: C,
    onChange: w,
    loadingPosition: v,
    iconSize: V,
    Spinner: /* @__PURE__ */ B.jsx(vo, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...P
  };
}
function JQ(e) {
  const [t, n] = _(!1), r = Ye(null), { inputRef: o, id: i, error: s } = Er(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: d,
    className: p,
    prefix: g,
    sufix: f,
    iconSize: m,
    loadingPosition: h,
    isLoading: C,
    LeftIcon: w,
    readOnly: P,
    onFocus: E,
    onBlur: v,
    RightIcon: x,
    Spinner: L,
    onChange: z,
    value: k,
    defaultValue: R,
    ...A
  } = XQ({ ...e, id: i, isError: l }, t), [U, V] = _(R), N = w && !C, Z = x && !C, K = h === "left" && C, X = h === "right" && C;
  function te() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function ee(G) {
    let S = ub(G.target.value);
    const Y = jA(S);
    S.length > AA || (S = TA(S, cb[Y]), G.target.value = S, V(S), z && z(G));
  }
  function D(G) {
    n(!0), E && E(G);
  }
  function j(G) {
    n(!1), v && v(G);
  }
  return /* @__PURE__ */ B.jsxs(
    "section",
    {
      title: c,
      style: d,
      onClick: te,
      className: p,
      children: [
        g,
        K && L,
        N && /* @__PURE__ */ B.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ B.jsx(
          "input",
          {
            disabled: u || C,
            readOnly: P,
            ref: a,
            value: k || U,
            onFocus: D,
            onChange: ee,
            onBlur: j,
            ...A
          }
        ),
        Z && /* @__PURE__ */ B.jsx(x, { size: m, strokeWidth: 2.5 }),
        X && L,
        f
      ]
    }
  );
}
const QQ = 3, eee = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? QQ : 0), lc = 2, V_ = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), Fm = (e) => {
  let t = e;
  return typeof e == "string" ? (t = V_(e), t % 1 !== 0 && (t = t.toFixed(lc))) : t = Number.isInteger(e) ? Number(e) * 10 ** lc : e.toFixed(lc), V_(t) / 10 ** lc;
}, Z_ = (e, t, n) => {
  if (!t) return [0, ""];
  const r = Fm(t), o = eee(e, r, n);
  return [r, o];
};
function tee(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: d,
    readOnly: p,
    onFocus: g,
    onBlur: f,
    title: m,
    style: h,
    // showCents = false,
    max: C = 1e9,
    locale: w = "pt-BR",
    currency: P = "BRL",
    ...E
  } = e, v = c ? "right" : "left", A = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${d || p || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: A,
    prefix: hi(a, V, "prefix"),
    sufix: hi(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: d,
    locale: w,
    currency: P,
    readOnly: p,
    onFocus: g,
    onBlur: f,
    title: m,
    style: h,
    max: C,
    // showCents,
    loadingPosition: v,
    iconSize: V,
    Spinner: /* @__PURE__ */ B.jsx(vo, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...E
  };
}
function nee(e) {
  const [t, n] = _(!1), [r, o] = _("0"), i = Ye(null), { inputRef: s, id: a, error: l } = Er(), u = s || i, c = e.isError || !!l, {
    disabled: d,
    title: p,
    style: g,
    className: f,
    prefix: m,
    sufix: h,
    iconSize: C,
    loadingPosition: w,
    isLoading: P,
    LeftIcon: E,
    readOnly: v,
    onFocus: x,
    onBlur: L,
    RightIcon: z,
    Spinner: k,
    value: R,
    max: A,
    onChangeValue: U,
    onKeyPress: V,
    currency: N,
    locale: Z,
    name: K,
    defaultValue: X,
    ...te
  } = tee({ ...e, id: a, isError: c }, t), ee = E && !P, D = z && !P, j = w === "left" && P, G = w === "right" && P;
  function S() {
    d || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function Y(q) {
    n(!0), x && x(q);
  }
  function O(q) {
    n(!1), L && L(q);
  }
  const M = (q) => {
    const [I, J] = Z_(
      Z,
      q,
      N
    );
    return !A || I <= A ? (o(J), [I, J]) : [Fm(r), r];
  }, W = (q) => {
    q.preventDefault();
    const [I, J] = M(q.target.value);
    U && U(q, String(I), String(J));
  }, T = (q) => V && V(q, q.key, q.key);
  return y(() => {
    const q = R || +X || void 0, [, I] = Z_(Z, q, N);
    o(I);
  }, [N, X, R]), /* @__PURE__ */ B.jsxs(
    "section",
    {
      title: p,
      style: g,
      onClick: S,
      className: f,
      children: [
        m,
        j && k,
        ee && /* @__PURE__ */ B.jsx(E, { size: C, strokeWidth: 2.5 }),
        /* @__PURE__ */ B.jsx(
          "input",
          {
            value: r,
            onChange: W,
            onBlur: O,
            onFocus: Y,
            onKeyUp: T,
            disabled: d || P,
            readOnly: v,
            ...te
          }
        ),
        /* @__PURE__ */ B.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: K,
            value: Fm(r)
          }
        ),
        G && k,
        D && /* @__PURE__ */ B.jsx(z, { size: C, strokeWidth: 2.5 }),
        h
      ]
    }
  );
}
function ree(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: d,
    readOnly: p,
    onFocus: g,
    onBlur: f,
    title: m,
    style: h,
    onChange: C,
    showMask: w = !1,
    type: P,
    ...E
  } = e, v = c ? "right" : "left", A = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${d || p || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: A,
    prefix: hi(a, V, "prefix"),
    sufix: hi(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: d,
    readOnly: p,
    onFocus: g,
    onBlur: f,
    title: m,
    style: h,
    onChange: C,
    loadingPosition: v,
    iconSize: V,
    showMask: w,
    Spinner: /* @__PURE__ */ B.jsx(vo, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...E
  };
}
const oee = Tr((e, t) => /* @__PURE__ */ B.jsx("input", { ref: t, ...e }));
function iee(e) {
  const [t, n] = _(!1), r = Ye(null), { inputRef: o, id: i, error: s } = Er(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: d,
    className: p,
    prefix: g,
    sufix: f,
    iconSize: m,
    loadingPosition: h,
    isLoading: C,
    LeftIcon: w,
    readOnly: P,
    onFocus: E,
    onBlur: v,
    RightIcon: x,
    Spinner: L,
    ...z
  } = ree({ ...e, id: i, isError: l }, t), k = w && !C, R = x && !C, A = h === "left" && C, U = h === "right" && C;
  function V() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function N(K) {
    n(!0), E && E(K);
  }
  function Z(K) {
    n(!1), v && v(K);
  }
  return /* @__PURE__ */ B.jsxs(
    "section",
    {
      title: c,
      style: d,
      onClick: V,
      className: p,
      children: [
        g,
        A && L,
        k && /* @__PURE__ */ B.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ B.jsx(
          Ml,
          {
            component: oee,
            ref: a,
            onFocus: N,
            onBlur: Z,
            disabled: u,
            ...z
          }
        ),
        R && /* @__PURE__ */ B.jsx(x, { size: m, strokeWidth: 2.5 }),
        U && L,
        f
      ]
    }
  );
}
function see(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: d,
    readOnly: p,
    onFocus: g,
    onBlur: f,
    title: m,
    style: h,
    onChange: C,
    ...w
  } = e, P = c ? "right" : "left", k = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${d || p || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, A = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: k,
    prefix: hi(a, A, "prefix"),
    sufix: hi(l, A, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: d,
    readOnly: p,
    onFocus: g,
    onBlur: f,
    title: m,
    style: h,
    onChange: C,
    loadingPosition: P,
    iconSize: A,
    Spinner: /* @__PURE__ */ B.jsx(vo, { className: "spinner", size: A, strokeWidth: 2.5 }),
    ...w
  };
}
function aee(e) {
  const [t, n] = _(!1), r = Ye(null), { inputRef: o, id: i, error: s } = Er(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: d,
    className: p,
    prefix: g,
    sufix: f,
    iconSize: m,
    loadingPosition: h,
    isLoading: C,
    LeftIcon: w,
    readOnly: P,
    onFocus: E,
    onBlur: v,
    RightIcon: x,
    type: L,
    Spinner: z,
    ...k
  } = see({ ...e, id: i, isError: l }, t), R = w && !C, A = x && !C, U = h === "left" && C, V = h === "right" && C;
  function N() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function Z(X) {
    n(!0), E && E(X);
  }
  function K(X) {
    n(!1), v && v(X);
  }
  return L === "hidden" ? /* @__PURE__ */ B.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: a,
      ...k
    }
  ) : /* @__PURE__ */ B.jsxs(
    "section",
    {
      title: c,
      style: d,
      onClick: N,
      className: p,
      children: [
        g,
        U && z,
        R && /* @__PURE__ */ B.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ B.jsx(
          "input",
          {
            disabled: u || C,
            readOnly: P,
            ref: a,
            onFocus: Z,
            onBlur: K,
            type: L,
            ...k
          }
        ),
        A && /* @__PURE__ */ B.jsx(x, { size: m, strokeWidth: 2.5 }),
        V && z,
        f
      ]
    }
  );
}
function vf(e) {
  return e.type === "currency" ? /* @__PURE__ */ B.jsx(nee, { ...e }) : e.type === "masked" ? /* @__PURE__ */ B.jsx(iee, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ B.jsx(JQ, { ...e }) : /* @__PURE__ */ B.jsx(aee, { ...e });
}
function lee(e) {
  const { iconSize: t, isLoading: n, disabled: r, readOnly: o, isFocused: i } = e, l = `arkynMultiSelectChevron ${r || o ? "notAnimate" : ""} ${i ? "focused" : ""}`;
  return n ? /* @__PURE__ */ B.jsx(B.Fragment, {}) : /* @__PURE__ */ B.jsx(nv, { className: l, size: t, strokeWidth: 2.5 });
}
function uee(e) {
  const {
    children: t,
    handleContainerFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: s,
    className: a,
    readOnly: l,
    variant: u,
    size: c,
    id: d,
    prefixExists: p
  } = e, g = p ? "hasPrefix" : "", f = o ? "errored" : "", m = r || l || i ? "opacity" : "", h = s ? "focused" : "";
  return /* @__PURE__ */ B.jsx(
    "section",
    {
      id: d,
      className: `arkynMultiSelectContainer ${g} ${u} ${c} ${m} ${f} ${h} ${a}`,
      onClick: n,
      children: t
    }
  );
}
function cee(e) {
  const { children: t, size: n } = e, r = `arkynMultiSelectContent ${n}`;
  return /* @__PURE__ */ B.jsx("div", { className: r, children: t });
}
function dee(e) {
  const { label: t, value: n, handleChangeValue: r } = e;
  return /* @__PURE__ */ B.jsxs("div", { className: "arkynMultiSelectMark", children: [
    t,
    /* @__PURE__ */ B.jsx(
      "button",
      {
        type: "button",
        onClick: (o) => {
          o.stopPropagation(), r(n);
        },
        children: /* @__PURE__ */ B.jsx(rv, {})
      }
    )
  ] });
}
function pee(e) {
  const { label: t, optionHasSelected: n, handleChangeValue: r, value: o, size: i } = e, s = n(o) ? "active" : "", a = `arkynMultiSelectOption ${i} ${s}`;
  return /* @__PURE__ */ B.jsxs("div", { onClick: () => r(o), className: a, children: [
    t,
    " ",
    /* @__PURE__ */ B.jsx(Xd, {})
  ] });
}
function fee(e) {
  const { children: t, isFocused: n, isSearchable: r, onSearch: o } = e;
  function i(s) {
    r && o(s.target.value);
  }
  return n ? /* @__PURE__ */ B.jsxs("div", { className: "arkynMultiSelectOptionsContainer", children: [
    r && /* @__PURE__ */ B.jsx(
      vf,
      {
        type: "search",
        name: "search-select",
        variant: "underline",
        leftIcon: TP,
        onChange: i
      }
    ),
    t
  ] }) : /* @__PURE__ */ B.jsx(B.Fragment, {});
}
function hee(e) {
  const { isFocused: t, handleBlur: n } = e;
  return t ? /* @__PURE__ */ B.jsx("aside", { className: "arkynMultiSelectOverlay", onClick: n }) : /* @__PURE__ */ B.jsx(B.Fragment, {});
}
function gee(e) {
  const { iconSize: t, isLoading: n } = e;
  return n ? /* @__PURE__ */ B.jsx(
    vo,
    {
      className: "arkynMultiSelectSpinner",
      size: t,
      strokeWidth: 2.5
    }
  ) : /* @__PURE__ */ B.jsx(B.Fragment, {});
}
function gue(e) {
  const {
    name: t,
    options: n,
    className: r = "",
    placeholder: o = "Selecione...",
    closeOnSelect: i = !1,
    defaultValue: s = [],
    isError: a,
    isLoading: l = !1,
    readOnly: u = !1,
    isSearchable: c = !1,
    leftIcon: d,
    onSearch: p,
    onSelect: g,
    onBlur: f,
    notFoundText: m = "Sem opções disponíveis",
    onFocus: h,
    disabled: C = !1,
    prefix: w,
    size: P = "md",
    value: E,
    variant: v = "solid"
  } = e, x = Er(), L = Ye(null), z = x.inputRef || L, k = x.id, R = a || !!x.error, U = { md: 20, lg: 20 }[P], V = gS(w, U, "prefix"), [N, Z] = _(""), [K, X] = _(!1), [te, ee] = _(s), D = E || te;
  function j(T) {
    return D.includes(T);
  }
  function G(T) {
    const q = n.find((I) => I.value === T);
    return (q == null ? void 0 : q.label) || "";
  }
  function S() {
    C || !(z != null && z.current) || K || (X(!0), z.current.focus(), h && h());
  }
  function Y() {
    X(!1), f && z.current && z.current.blur();
  }
  function O(T) {
    Z(T), p && p(T);
  }
  function M(T) {
    j(T) ? ee(te.filter((q) => q !== T)) : ee([...te, T]), g && g(te), i && Y();
  }
  const W = n.filter((T) => !!(e.onSearch || !e.isSearchable || T.label.toLowerCase().includes(N.toLowerCase())));
  return /* @__PURE__ */ B.jsxs(
    uee,
    {
      handleContainerFocus: S,
      disabled: C,
      isError: R,
      isFocused: K,
      isLoading: l,
      readOnly: u,
      size: P,
      variant: v,
      className: r,
      prefixExists: !!w,
      id: k,
      children: [
        /* @__PURE__ */ B.jsx(
          "input",
          {
            ref: z,
            name: t,
            value: JSON.stringify(D),
            type: "hidden"
          }
        ),
        V,
        d && /* @__PURE__ */ B.jsx(d, { size: U, strokeWidth: 2.5 }),
        /* @__PURE__ */ B.jsxs(cee, { size: P, children: [
          D.map((T) => /* @__PURE__ */ B.jsx(
            dee,
            {
              label: G(T),
              value: T,
              handleChangeValue: M
            },
            T
          )),
          D.length <= 0 && /* @__PURE__ */ B.jsx("p", { children: o })
        ] }),
        /* @__PURE__ */ B.jsxs(
          fee,
          {
            isFocused: K,
            isSearchable: c,
            onSearch: O,
            children: [
              W.map(({ label: T, value: q }) => /* @__PURE__ */ B.jsx(
                pee,
                {
                  label: T,
                  value: q,
                  size: P,
                  handleChangeValue: M,
                  optionHasSelected: j
                },
                q
              )),
              W.length <= 0 && /* @__PURE__ */ B.jsx("p", { children: m })
            ]
          }
        ),
        /* @__PURE__ */ B.jsx(
          lee,
          {
            disabled: C,
            isFocused: K,
            readOnly: u,
            iconSize: U,
            isLoading: l
          }
        ),
        /* @__PURE__ */ B.jsx(gee, { iconSize: U, isLoading: l }),
        /* @__PURE__ */ B.jsx(hee, { handleBlur: Y, isFocused: K })
      ]
    }
  );
}
const Ms = [
  {
    name: "Afghanistan",
    code: "+93",
    prefix: null,
    iso: "AF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/af.svg",
    mask: "__-___-____"
  },
  {
    name: "Aland Islands",
    code: "+358",
    prefix: null,
    iso: "AX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ax.svg",
    mask: "(___)___-__-__"
  },
  {
    name: "Albania",
    code: "+355",
    prefix: null,
    iso: "AL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/al.svg",
    mask: "(___)___-___"
  },
  {
    name: "Algeria",
    code: "+213",
    prefix: null,
    iso: "DZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dz.svg",
    mask: "__-___-____"
  },
  {
    name: "American Samoa",
    code: "+1",
    prefix: "684",
    iso: "AS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/as.svg",
    mask: "(684)___-____"
  },
  {
    name: "Andorra",
    code: "+376",
    prefix: null,
    iso: "AD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ad.svg",
    mask: "___-___"
  },
  {
    name: "Angola",
    code: "+244",
    prefix: null,
    iso: "AO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ao.svg",
    mask: "(___)___-___"
  },
  {
    name: "Anguilla",
    code: "+1",
    prefix: "264",
    iso: "AI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ai.svg",
    mask: "(264)___-____"
  },
  {
    name: "Antarctica",
    code: "+672",
    prefix: "1",
    iso: "AQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/aq.svg",
    mask: "1__-___"
  },
  {
    name: "Antigua and Barbuda",
    code: "+1",
    prefix: "268",
    iso: "AG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ag.svg",
    mask: "(268)___-____"
  },
  {
    name: "Argentina",
    code: "+54",
    prefix: null,
    iso: "AR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ar.svg",
    mask: "(___)___-____"
  },
  {
    name: "Armenia",
    code: "+374",
    prefix: null,
    iso: "AM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/am.svg",
    mask: "__-___-___"
  },
  {
    name: "Aruba",
    code: "+297",
    prefix: null,
    iso: "AW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/aw.svg",
    mask: "___-____"
  },
  {
    name: "Ascension Island",
    code: "+247",
    prefix: null,
    iso: "AC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sh.svg",
    mask: "____"
  },
  {
    name: "Australia",
    code: "+61",
    prefix: null,
    iso: "AU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/au.svg",
    mask: "_-____-____"
  },
  {
    name: "Austria",
    code: "+43",
    prefix: null,
    iso: "AT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/at.svg",
    mask: "(___)___-____"
  },
  {
    name: "Azerbaijan",
    code: "+994",
    prefix: null,
    iso: "AZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/az.svg",
    mask: "__-___-__-__"
  },
  {
    name: "Bahamas",
    code: "+1",
    prefix: "242",
    iso: "BS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bs.svg",
    mask: "(242)___-____"
  },
  {
    name: "Bahrain",
    code: "+973",
    prefix: null,
    iso: "BH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bh.svg",
    mask: "____-____"
  },
  {
    name: "Bangladesh",
    code: "+880",
    prefix: "1",
    iso: "BD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bd.svg",
    mask: "1___-______"
  },
  {
    name: "Barbados",
    code: "+1",
    prefix: "246",
    iso: "BB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bb.svg",
    mask: "(246)___-____"
  },
  {
    name: "Belarus",
    code: "+375",
    prefix: null,
    iso: "BY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/by.svg",
    mask: "(__)___-__-__"
  },
  {
    name: "Belgium",
    code: "+32",
    prefix: null,
    iso: "BE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/be.svg",
    mask: "(___)___-___"
  },
  {
    name: "Belize",
    code: "+501",
    prefix: null,
    iso: "BZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bz.svg",
    mask: "___-____"
  },
  {
    name: "Benin",
    code: "+229",
    prefix: null,
    iso: "BJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bj.svg",
    mask: "__-__-____"
  },
  {
    name: "Bermuda",
    code: "+1",
    prefix: "441",
    iso: "BM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bm.svg",
    mask: "(441)___-____"
  },
  {
    name: "Bhutan",
    code: "+975",
    prefix: null,
    iso: "BT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bt.svg",
    mask: "_-___-___"
  },
  {
    name: "Bolivia",
    code: "+591",
    prefix: null,
    iso: "BO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bo.svg",
    mask: "_-___-____"
  },
  {
    name: "Bosnia and Herzegovina",
    code: "+387",
    prefix: null,
    iso: "BA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ba.svg",
    mask: "__-_____"
  },
  {
    name: "Botswana",
    code: "+267",
    prefix: null,
    iso: "BW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bw.svg",
    mask: "__-___-___"
  },
  {
    name: "Brasil",
    code: "+55",
    prefix: null,
    iso: "BR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/br.svg",
    mask: "(__) _____-____"
  },
  {
    name: "British Indian Ocean Territory",
    code: "+246",
    prefix: null,
    iso: "IO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/io.svg",
    mask: "___-____"
  },
  {
    name: "Brunei Darussalam",
    code: "+673",
    prefix: null,
    iso: "BN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bn.svg",
    mask: "___-____"
  },
  {
    name: "Bulgaria",
    code: "+359",
    prefix: null,
    iso: "BG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bg.svg",
    mask: "(___)___-___"
  },
  {
    name: "Burkina Faso",
    code: "+226",
    prefix: null,
    iso: "BF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bf.svg",
    mask: "__-__-____"
  },
  {
    name: "Burundi",
    code: "+257",
    prefix: null,
    iso: "BI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bi.svg",
    mask: "__-__-____"
  },
  {
    name: "Cambodia",
    code: "+855",
    prefix: null,
    iso: "KH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kh.svg",
    mask: "__-___-___"
  },
  {
    name: "Cameroon",
    code: "+237",
    prefix: null,
    iso: "CM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cm.svg",
    mask: "____-____"
  },
  {
    name: "Canada",
    code: "+1",
    prefix: null,
    iso: "CA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ca.svg",
    mask: "(___)___-____"
  },
  {
    name: "Cape Verde",
    code: "+238",
    prefix: null,
    iso: "CV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cv.svg",
    mask: "(___)__-__"
  },
  {
    name: "Cayman Islands",
    code: "+1",
    prefix: "345",
    iso: "KY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ky.svg",
    mask: "(345)___-____"
  },
  {
    name: "Central African Republic",
    code: "+236",
    prefix: null,
    iso: "CF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cf.svg",
    mask: "__-__-____"
  },
  {
    name: "Chad",
    code: "+235",
    prefix: null,
    iso: "TD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/td.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Chile",
    code: "+56",
    prefix: null,
    iso: "CL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cl.svg",
    mask: "_-____-____"
  },
  {
    name: "China",
    code: "+86",
    prefix: null,
    iso: "CN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cn.svg",
    mask: "__-_____-_____"
  },
  {
    name: "Christmas Island",
    code: "+61",
    prefix: null,
    iso: "CX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cx.svg",
    mask: "_-____-____"
  },
  {
    name: "Cocos (Keeling) Islands",
    code: "+61",
    prefix: null,
    iso: "CC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cc.svg",
    mask: "_-____-____"
  },
  {
    name: "Colombia",
    code: "+57",
    prefix: null,
    iso: "CO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/co.svg",
    mask: "(___)___-____"
  },
  {
    name: "Comoros",
    code: "+269",
    prefix: null,
    iso: "KM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/km.svg",
    mask: "__-_____"
  },
  {
    name: "Congo",
    code: "+242",
    prefix: null,
    iso: "CG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cg.svg",
    mask: "__-_____"
  },
  {
    name: "Cook Islands",
    code: "+682",
    prefix: null,
    iso: "CK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ck.svg",
    mask: "__-___"
  },
  {
    name: "Costa Rica",
    code: "+506",
    prefix: null,
    iso: "CR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cr.svg",
    mask: "____-____"
  },
  {
    name: "Croatia",
    code: "+385",
    prefix: null,
    iso: "HR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hr.svg",
    mask: "__-___-___"
  },
  {
    name: "Cuba",
    code: "+53",
    prefix: null,
    iso: "CU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cu.svg",
    mask: "_-___-____"
  },
  {
    name: "Cyprus",
    code: "+357",
    prefix: null,
    iso: "CY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cy.svg",
    mask: "__-___-___"
  },
  {
    name: "Czech Republic",
    code: "+420",
    prefix: null,
    iso: "CZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cz.svg",
    mask: "(___)___-___"
  },
  {
    name: "Democratic Republic of the Congo",
    code: "+243",
    prefix: null,
    iso: "CD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cd.svg",
    mask: "(___)___-___"
  },
  {
    name: "Denmark",
    code: "+45",
    prefix: null,
    iso: "DK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dk.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Djibouti",
    code: "+253",
    prefix: null,
    iso: "DJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dj.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Dominica",
    code: "+1",
    prefix: "767",
    iso: "DM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dm.svg",
    mask: "(767)___-____"
  },
  {
    name: "Dominican Republic",
    code: "+1",
    prefix: "849",
    iso: "DO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/do.svg",
    mask: "(894)___-____"
  },
  {
    name: "Ecuador",
    code: "+593",
    prefix: null,
    iso: "EC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ec.svg",
    mask: "__-___-____"
  },
  {
    name: "Egypt",
    code: "+20",
    prefix: null,
    iso: "EG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/eg.svg",
    mask: "(___)___-____"
  },
  {
    name: "El Salvador",
    code: "+503",
    prefix: null,
    iso: "SV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sv.svg",
    mask: "__-__-____"
  },
  {
    name: "Equatorial Guinea",
    code: "+240",
    prefix: null,
    iso: "GQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gq.svg",
    mask: "__-___-____"
  },
  {
    name: "Eritrea",
    code: "+291",
    prefix: null,
    iso: "ER",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/er.svg",
    mask: "_-___-___"
  },
  {
    name: "Estonia",
    code: "+372",
    prefix: null,
    iso: "EE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ee.svg",
    mask: "____-____"
  },
  {
    name: "Eswatini",
    code: "+268",
    prefix: null,
    iso: "SZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sz.svg",
    mask: "__-__-____"
  },
  {
    name: "Ethiopia",
    code: "+251",
    prefix: null,
    iso: "ET",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/et.svg",
    mask: "__-___-____"
  },
  {
    name: "Falkland Islands (Malvinas)",
    code: "+500",
    prefix: null,
    iso: "FK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fk.svg",
    mask: "_____"
  },
  {
    name: "Faroe Islands",
    code: "+298",
    prefix: null,
    iso: "FO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fo.svg",
    mask: "__ __ __"
  },
  {
    name: "Fiji",
    code: "+679",
    prefix: null,
    iso: "FJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fj.svg",
    mask: "__-_____"
  },
  {
    name: "Finland",
    code: "+358",
    prefix: null,
    iso: "FI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fi.svg",
    mask: "__ ___ ____"
  },
  {
    name: "France",
    code: "+33",
    prefix: null,
    iso: "FR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fr.svg",
    mask: "_ __ __ __ __"
  },
  {
    name: "French Guiana",
    code: "+594",
    prefix: null,
    iso: "GF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gf.svg",
    mask: "___ __ __ __"
  },
  {
    name: "French Polynesia",
    code: "+689",
    prefix: null,
    iso: "PF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pf.svg",
    mask: "__ __ __ __"
  },
  {
    name: "Gabon",
    code: "+241",
    prefix: null,
    iso: "GA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ga.svg",
    mask: "_ __ __ __"
  },
  {
    name: "Gambia",
    code: "+220",
    prefix: null,
    iso: "GM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gm.svg",
    mask: "___ ____"
  },
  {
    name: "Georgia",
    code: "+995",
    prefix: null,
    iso: "GE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ge.svg",
    mask: "(___)___-___"
  },
  {
    name: "Germany",
    code: "+49",
    prefix: "3",
    iso: "DE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/de.svg",
    mask: "(3____) __-____"
  },
  {
    name: "Ghana",
    code: "+233",
    prefix: "03",
    iso: "GH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gh.svg",
    mask: "03_ ___ ____"
  },
  {
    name: "Gibraltar",
    code: "+350",
    prefix: null,
    iso: "GI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gi.svg",
    mask: "___-_____"
  },
  {
    name: "Greece",
    code: "+30",
    prefix: null,
    iso: "GR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gr.svg",
    mask: "(___)___-____"
  },
  {
    name: "Greenland",
    code: "+299",
    prefix: null,
    iso: "GL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gl.svg",
    mask: "__-__-__"
  },
  {
    name: "Grenada",
    code: "+1",
    prefix: "473",
    iso: "GD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gd.svg",
    mask: "(473)___-____"
  },
  {
    name: "Guadeloupe",
    code: "+590",
    prefix: null,
    iso: "GP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gp.svg",
    mask: "___ __ __ __"
  },
  {
    name: "Guam",
    code: "+1",
    prefix: "671",
    iso: "GU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gu.svg",
    mask: "671 ___ ____"
  },
  {
    name: "Guatemala",
    code: "+502",
    prefix: null,
    iso: "GT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gt.svg",
    mask: "_-___-____"
  },
  {
    name: "Guernsey",
    code: "+44",
    prefix: null,
    iso: "GG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gg.svg",
    mask: "(____)______"
  },
  {
    name: "Guinea",
    code: "+224",
    prefix: null,
    iso: "GN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gn.svg",
    mask: "__-___-___"
  },
  {
    name: "Guinea-Bissau",
    code: "+245",
    prefix: null,
    iso: "GW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gw.svg",
    mask: "_-______"
  },
  {
    name: "Guyana",
    code: "+592",
    prefix: null,
    iso: "GY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gy.svg",
    mask: "___-____"
  },
  {
    name: "Haiti",
    code: "+509",
    prefix: null,
    iso: "HT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ht.svg",
    mask: "__-__-____"
  },
  {
    name: "Holy See (Vatican City State)",
    code: "+39",
    prefix: "06698",
    iso: "VA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/va.svg",
    mask: "06 698_____"
  },
  {
    name: "Honduras",
    code: "+504",
    prefix: null,
    iso: "HN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hn.svg",
    mask: "____-____"
  },
  {
    name: "Hong Kong",
    code: "+852",
    prefix: null,
    iso: "HK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hk.svg",
    mask: "____-____"
  },
  {
    name: "Hungary",
    code: "+36",
    prefix: null,
    iso: "HU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hu.svg",
    mask: "__ ___ ____"
  },
  {
    name: "Iceland",
    code: "+354",
    prefix: null,
    iso: "IS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/is.svg",
    mask: "___-____"
  },
  {
    name: "India",
    code: "+91",
    prefix: null,
    iso: "IN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/in.svg",
    mask: "(____)___-___"
  },
  {
    name: "Indonesia",
    code: "+62",
    prefix: "8",
    iso: "ID",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/id.svg",
    mask: "(8__)___-__-___"
  },
  {
    name: "Iran",
    code: "+98",
    prefix: null,
    iso: "IR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ir.svg",
    mask: "(___)___-____"
  },
  {
    name: "Iraq",
    code: "+964",
    prefix: null,
    iso: "IQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/iq.svg",
    mask: "(___)___-____"
  },
  {
    name: "Ireland",
    code: "+353",
    prefix: null,
    iso: "IE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ie.svg",
    mask: "(___)___-___"
  },
  {
    name: "Isle of Man",
    code: "+44",
    prefix: null,
    iso: "IM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/im.svg",
    mask: "(____)______"
  },
  {
    name: "Israel",
    code: "+972",
    prefix: "5",
    iso: "IL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/il.svg",
    mask: "__-___-____"
  },
  {
    name: "Italy",
    code: "+39",
    prefix: null,
    iso: "IT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/it.svg",
    mask: "(___)____-___"
  },
  {
    name: "Ivory Coast / Cote d'Ivoire",
    code: "+225",
    prefix: null,
    iso: "CI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ci.svg",
    mask: "__-___-___"
  },
  {
    name: "Jamaica",
    code: "+1",
    prefix: "876",
    iso: "JM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jm.svg",
    mask: "(876)___-____"
  },
  {
    name: "Japan",
    code: "+81",
    prefix: null,
    iso: "JP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jp.svg",
    mask: "__-____-____"
  },
  {
    name: "Jersey",
    code: "+44",
    prefix: null,
    iso: "JE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/je.svg",
    mask: "(____)____-______"
  },
  {
    name: "Jordan",
    code: "+962",
    prefix: null,
    iso: "JO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jo.svg",
    mask: "_-____-____"
  },
  {
    name: "Kazakhstan",
    code: "+77",
    prefix: null,
    iso: "KZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kz.svg",
    mask: "(_____) _ __ __"
  },
  {
    name: "Kenya",
    code: "+254",
    prefix: null,
    iso: "KE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ke.svg",
    mask: "___-______"
  },
  {
    name: "Kiribati",
    code: "+686",
    prefix: null,
    iso: "KI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ki.svg",
    mask: "__-___"
  },
  {
    name: "Korea, Democratic People's Republic of Korea",
    code: "+850",
    prefix: null,
    iso: "KP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kp.svg",
    mask: "____-_____________"
  },
  {
    name: "Korea, Republic of South Korea",
    code: "+82",
    prefix: null,
    iso: "KR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kr.svg",
    mask: "__-___-____"
  },
  {
    name: "Kosovo",
    code: "+383",
    prefix: null,
    iso: "XK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/xk.svg",
    mask: "___-___-___"
  },
  {
    name: "Kuwait",
    code: "+965",
    prefix: null,
    iso: "KW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kw.svg",
    mask: "____-____"
  },
  {
    name: "Kyrgyzstan",
    code: "+996",
    prefix: null,
    iso: "KG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kg.svg",
    mask: "(___)___-___"
  },
  {
    name: "Laos",
    code: "+856",
    prefix: "20",
    iso: "LA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/la.svg",
    mask: "(20__)___-___"
  },
  {
    name: "Latvia",
    code: "+371",
    prefix: null,
    iso: "LV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lv.svg",
    mask: "__-___-___"
  },
  {
    name: "Lebanon",
    code: "+961",
    prefix: null,
    iso: "LB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lb.svg",
    mask: "__-___-___"
  },
  {
    name: "Lesotho",
    code: "+266",
    prefix: null,
    iso: "LS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ls.svg",
    mask: "_-___-____"
  },
  {
    name: "Liberia",
    code: "+231",
    prefix: null,
    iso: "LR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lr.svg",
    mask: "__-___-___"
  },
  {
    name: "Libya",
    code: "+218",
    prefix: "21",
    iso: "LY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ly.svg",
    mask: "21-___-____"
  },
  {
    name: "Liechtenstein",
    code: "+423",
    prefix: null,
    iso: "LI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/li.svg",
    mask: "(___)___-____"
  },
  {
    name: "Lithuania",
    code: "+370",
    prefix: null,
    iso: "LT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lt.svg",
    mask: "(___)__-___"
  },
  {
    name: "Luxembourg",
    code: "+352",
    prefix: null,
    iso: "LU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lu.svg",
    mask: "(___)___-___"
  },
  {
    name: "Macau",
    code: "+853",
    prefix: null,
    iso: "MO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mo.svg",
    mask: "____-____"
  },
  {
    name: "Madagascar",
    code: "+261",
    prefix: null,
    iso: "MG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mg.svg",
    mask: "__-__-_____"
  },
  {
    name: "Malawi",
    code: "+265",
    prefix: null,
    iso: "MW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mw.svg",
    mask: "_-____-____"
  },
  {
    name: "Malaysia",
    code: "+60",
    prefix: null,
    iso: "MY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/my.svg",
    mask: "__-___-____"
  },
  {
    name: "Maldives",
    code: "+960",
    prefix: null,
    iso: "MV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mv.svg",
    mask: "___-____"
  },
  {
    name: "Mali",
    code: "+223",
    prefix: null,
    iso: "ML",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ml.svg",
    mask: "__-__-____"
  },
  {
    name: "Malta",
    code: "+356",
    prefix: null,
    iso: "MT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mt.svg",
    mask: "____-____"
  },
  {
    name: "Marshall Islands",
    code: "+692",
    prefix: null,
    iso: "MH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mh.svg",
    mask: "___-____"
  },
  {
    name: "Martinique",
    code: "+596",
    prefix: null,
    iso: "MQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mq.svg",
    mask: "(___)__-__-__"
  },
  {
    name: "Mauritania",
    code: "+222",
    prefix: null,
    iso: "MR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mr.svg",
    mask: "__-__-____"
  },
  {
    name: "Mauritius",
    code: "+230",
    prefix: null,
    iso: "MU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mu.svg",
    mask: "___-____"
  },
  {
    name: "Mayotte",
    code: "+262",
    prefix: null,
    iso: "YT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/yt.svg",
    mask: "_____-____"
  },
  {
    name: "Mexico",
    code: "+52",
    prefix: null,
    iso: "MX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mx.svg",
    mask: "(___)___-____"
  },
  {
    name: "Micronesia, Federated States of Micronesia",
    code: "+691",
    prefix: null,
    iso: "FM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fm.svg",
    mask: "___-____"
  },
  {
    name: "Moldova",
    code: "+373",
    prefix: null,
    iso: "MD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/md.svg",
    mask: "____-____"
  },
  {
    name: "Monaco",
    code: "+377",
    prefix: null,
    iso: "MC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mc.svg",
    mask: "(___)___-___"
  },
  {
    name: "Mongolia",
    code: "+976",
    prefix: null,
    iso: "MN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mn.svg",
    mask: "__-__-____"
  },
  {
    name: "Montenegro",
    code: "+382",
    prefix: null,
    iso: "ME",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/me.svg",
    mask: "__-___-___"
  },
  {
    name: "Montserrat",
    code: "+1",
    prefix: "664",
    iso: "MS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ms.svg",
    mask: "(664)___-____"
  },
  {
    name: "Morocco",
    code: "+212",
    prefix: null,
    iso: "MA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ma.svg",
    mask: "__-____-___"
  },
  {
    name: "Mozambique",
    code: "+258",
    prefix: null,
    iso: "MZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mz.svg",
    mask: "__-___-___"
  },
  {
    name: "Myanmar",
    code: "+95",
    prefix: null,
    iso: "MM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mm.svg",
    mask: "__-___-___"
  },
  {
    name: "Namibia",
    code: "+264",
    prefix: null,
    iso: "NA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/na.svg",
    mask: "__-___-____"
  },
  {
    name: "Nauru",
    code: "+674",
    prefix: null,
    iso: "NR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nr.svg",
    mask: "___-____"
  },
  {
    name: "Nepal",
    code: "+977",
    prefix: null,
    iso: "NP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/np.svg",
    mask: "__-___-___"
  },
  {
    name: "Netherlands",
    code: "+31",
    prefix: null,
    iso: "NL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nl.svg",
    mask: "__-___-____"
  },
  {
    name: "New Caledonia",
    code: "+687",
    prefix: null,
    iso: "NC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nc.svg",
    mask: "__-____"
  },
  {
    name: "New Zealand",
    code: "+64",
    prefix: null,
    iso: "NZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nz.svg",
    mask: "(___)___-____"
  },
  {
    name: "Nicaragua",
    code: "+505",
    prefix: null,
    iso: "NI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ni.svg",
    mask: "____-____"
  },
  {
    name: "Niger",
    code: "+227",
    prefix: null,
    iso: "NE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ne.svg",
    mask: "__-__-____"
  },
  {
    name: "Nigeria",
    code: "+234",
    prefix: null,
    iso: "NG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ng.svg",
    mask: "(___)___-____"
  },
  {
    name: "Niue",
    code: "+683",
    prefix: null,
    iso: "NU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nu.svg",
    mask: "____"
  },
  {
    name: "Norfolk Island",
    code: "+672",
    prefix: "3",
    iso: "NF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nf.svg",
    mask: "3__-___"
  },
  {
    name: "North Macedonia",
    code: "+389",
    prefix: null,
    iso: "MK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mk.svg",
    mask: "__-___-___"
  },
  {
    name: "Northern Mariana Islands",
    code: "+1",
    prefix: "670",
    iso: "MP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mp.svg",
    mask: "(670)___-____"
  },
  {
    name: "Norway",
    code: "+47",
    prefix: null,
    iso: "NO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/no.svg",
    mask: "(___)__-___"
  },
  {
    name: "Oman",
    code: "+968",
    prefix: null,
    iso: "OM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/om.svg",
    mask: "__-___-___"
  },
  {
    name: "Pakistan",
    code: "+92",
    prefix: null,
    iso: "PK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pk.svg",
    mask: "(___)___-____"
  },
  {
    name: "Palau",
    code: "+680",
    prefix: null,
    iso: "PW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pw.svg",
    mask: "___-____"
  },
  {
    name: "Palestine",
    code: "+970",
    prefix: null,
    iso: "PS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ps.svg",
    mask: "__-___-____"
  },
  {
    name: "Panama",
    code: "+507",
    prefix: null,
    iso: "PA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pa.svg",
    mask: "___-____"
  },
  {
    name: "Papua New Guinea",
    code: "+675",
    prefix: null,
    iso: "PG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pg.svg",
    mask: "(___)__-___"
  },
  {
    name: "Paraguay",
    code: "+595",
    prefix: null,
    iso: "PY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/py.svg",
    mask: "(___)___-___"
  },
  {
    name: "Peru",
    code: "+51",
    prefix: null,
    iso: "PE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pe.svg",
    mask: "(___)___-___"
  },
  {
    name: "Philippines",
    code: "+63",
    prefix: null,
    iso: "PH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ph.svg",
    mask: "(___)___-____"
  },
  {
    name: "Pitcairn",
    code: "+870",
    prefix: null,
    iso: "PN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pn.svg",
    mask: "___-___-___"
  },
  {
    name: "Poland",
    code: "+48",
    prefix: null,
    iso: "PL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pl.svg",
    mask: "(___)___-___"
  },
  {
    name: "Portugal",
    code: "+351",
    prefix: null,
    iso: "PT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pt.svg",
    mask: "__-___-____"
  },
  {
    name: "Puerto Rico",
    code: "+1",
    prefix: null,
    iso: "PR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pr.svg",
    mask: "(___) ___ ____"
  },
  {
    name: "Qatar",
    code: "+974",
    prefix: null,
    iso: "QA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/qa.svg",
    mask: "____-____"
  },
  {
    name: "Reunion",
    code: "+262",
    prefix: null,
    iso: "RE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/re.svg",
    mask: "_____-____"
  },
  {
    name: "Romania",
    code: "+40",
    prefix: null,
    iso: "RO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ro.svg",
    mask: "__-___-____"
  },
  {
    name: "Russia",
    code: "+7",
    prefix: null,
    iso: "RU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ru.svg",
    mask: "(___)___-__-__"
  },
  {
    name: "Rwanda",
    code: "+250",
    prefix: null,
    iso: "RW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/rw.svg",
    mask: "(___)___-___"
  },
  {
    name: "Saint Barthelemy",
    code: "+590",
    prefix: null,
    iso: "BL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bl.svg",
    mask: "___-__-__-__"
  },
  {
    name: "Saint Helena, Ascension and Tristan Da Cunha",
    code: "+290",
    prefix: null,
    iso: "SH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sh.svg",
    mask: "____"
  },
  {
    name: "Saint Kitts and Nevis",
    code: "+1",
    prefix: null,
    iso: "KN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kn.svg",
    mask: "(869)___-____"
  },
  {
    name: "Saint Lucia",
    code: "+1",
    prefix: "758",
    iso: "LC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lc.svg",
    mask: "(758)___-____"
  },
  {
    name: "Saint Martin",
    code: "+590",
    prefix: null,
    iso: "MF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mf.svg",
    mask: "(___)___-___"
  },
  {
    name: "Saint Pierre and Miquelon",
    code: "+508",
    prefix: null,
    iso: "PM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pm.svg",
    mask: "__-____"
  },
  {
    name: "Saint Vincent and the Grenadines",
    code: "+1",
    prefix: "784",
    iso: "VC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vc.svg",
    mask: "(784)___-____"
  },
  {
    name: "Samoa",
    code: "+685",
    prefix: null,
    iso: "WS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ws.svg",
    mask: "__-____"
  },
  {
    name: "San Marino",
    code: "+378",
    prefix: null,
    iso: "SM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sm.svg",
    mask: "____-______"
  },
  {
    name: "Sao Tome and Principe",
    code: "+239",
    prefix: null,
    iso: "ST",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/st.svg",
    mask: "__-_____"
  },
  {
    name: "Saudi Arabia",
    code: "+966",
    prefix: null,
    iso: "SA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sa.svg",
    mask: "_-____-____"
  },
  {
    name: "Senegal",
    code: "+221",
    prefix: null,
    iso: "SN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sn.svg",
    mask: "__-___-____"
  },
  {
    name: "Serbia",
    code: "+381",
    prefix: null,
    iso: "RS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/rs.svg",
    mask: "__-___-____"
  },
  {
    name: "Seychelles",
    code: "+248",
    prefix: null,
    iso: "SC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sc.svg",
    mask: "_-___-___"
  },
  {
    name: "Sierra Leone",
    code: "+232",
    prefix: null,
    iso: "SL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sl.svg",
    mask: "__-______"
  },
  {
    name: "Singapore",
    code: "+65",
    prefix: null,
    iso: "SG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sg.svg",
    mask: "____-____"
  },
  {
    name: "Sint Maarten",
    code: "+1",
    prefix: "721",
    iso: "SX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sx.svg",
    mask: "(721)___-____"
  },
  {
    name: "Slovakia",
    code: "+421",
    prefix: null,
    iso: "SK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sk.svg",
    mask: "(___)___-___"
  },
  {
    name: "Slovenia",
    code: "+386",
    prefix: null,
    iso: "SI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/si.svg",
    mask: "__-___-___"
  },
  {
    name: "Solomon Islands",
    code: "+677",
    prefix: null,
    iso: "SB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sb.svg",
    mask: "___-____"
  },
  {
    name: "Somalia",
    code: "+252",
    prefix: null,
    iso: "SO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/so.svg",
    mask: "__-___-___"
  },
  {
    name: "South Africa",
    code: "+27",
    prefix: null,
    iso: "ZA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/za.svg",
    mask: "__-___-____"
  },
  {
    name: "South Georgia and the South Sandwich Islands",
    code: "+500",
    prefix: null,
    iso: "GS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gs.svg",
    mask: "_____"
  },
  {
    name: "South Sudan",
    code: "+211",
    prefix: null,
    iso: "SS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ss.svg",
    mask: "__-___-____"
  },
  {
    name: "Spain",
    code: "+34",
    prefix: null,
    iso: "ES",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/es.svg",
    mask: "(___)___-___"
  },
  {
    name: "Sri Lanka",
    code: "+94",
    prefix: null,
    iso: "LK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lk.svg",
    mask: "__-___-____"
  },
  {
    name: "Sudan",
    code: "+249",
    prefix: null,
    iso: "SD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sd.svg",
    mask: "__-___-____"
  },
  {
    name: "Suriname",
    code: "+597",
    prefix: null,
    iso: "SR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sr.svg",
    mask: "___-____"
  },
  {
    name: "Svalbard and Jan Mayen",
    code: "+47",
    prefix: null,
    iso: "SJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sj.svg",
    mask: "(___)__-___"
  },
  {
    name: "Sweden",
    code: "+46",
    prefix: null,
    iso: "SE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/se.svg",
    mask: "__-___-____"
  },
  {
    name: "Switzerland",
    code: "+41",
    prefix: null,
    iso: "CH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ch.svg",
    mask: "__-___-____"
  },
  {
    name: "Syrian Arab Republic",
    code: "+963",
    prefix: null,
    iso: "SY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sy.svg",
    mask: "__-____-___"
  },
  {
    name: "Taiwan",
    code: "+886",
    prefix: null,
    iso: "TW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tw.svg",
    mask: "_-____-____"
  },
  {
    name: "Tajikistan",
    code: "+992",
    prefix: null,
    iso: "TJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tj.svg",
    mask: "__-___-____"
  },
  {
    name: "United Republic of Tanzania",
    code: "+255",
    prefix: null,
    iso: "TZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tz.svg",
    mask: "__-___-____"
  },
  {
    name: "Thailand",
    code: "+66",
    prefix: null,
    iso: "TH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/th.svg",
    mask: "__-___-____"
  },
  {
    name: "Timor-Leste",
    code: "+670",
    prefix: null,
    iso: "TL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tl.svg",
    mask: "___-_____"
  },
  {
    name: "Togo",
    code: "+228",
    prefix: null,
    iso: "TG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tg.svg",
    mask: "__-___-___"
  },
  {
    name: "Tokelau",
    code: "+690",
    prefix: null,
    iso: "TK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tk.svg",
    mask: "____"
  },
  {
    name: "Tonga",
    code: "+676",
    prefix: null,
    iso: "TO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/to.svg",
    mask: "_____"
  },
  {
    name: "Trinidad and Tobago",
    code: "+1",
    prefix: "868",
    iso: "TT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tt.svg",
    mask: "(868)___-____"
  },
  {
    name: "Tunisia",
    code: "+216",
    prefix: null,
    iso: "TN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tn.svg",
    mask: "__-___-___"
  },
  {
    name: "Turkey",
    code: "+90",
    prefix: null,
    iso: "TR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tr.svg",
    mask: "(___)___-____"
  },
  {
    name: "Turkmenistan",
    code: "+993",
    prefix: null,
    iso: "TM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tm.svg",
    mask: "_-___-____"
  },
  {
    name: "Turks and Caicos Islands",
    code: "+1",
    prefix: "249",
    iso: "TC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tc.svg",
    mask: "(249)___-___"
  },
  {
    name: "Tuvalu",
    code: "+688",
    prefix: null,
    iso: "TV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tv.svg",
    mask: "______"
  },
  {
    name: "Uganda",
    code: "+256",
    prefix: null,
    iso: "UG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ug.svg",
    mask: "(___)___-___"
  },
  {
    name: "Ukraine",
    code: "+380",
    prefix: null,
    iso: "UA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ua.svg",
    mask: "(__)___-__-__"
  },
  {
    name: "United Arab Emirates",
    code: "+971",
    prefix: null,
    iso: "AE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ae.svg",
    mask: "_-___-____"
  },
  {
    name: "United Kingdom",
    code: "+44",
    prefix: null,
    iso: "GB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gb.svg",
    mask: "__-____-____"
  },
  {
    name: "United States",
    code: "+1",
    prefix: "408",
    iso: "US",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/us.svg",
    mask: "(408)___-____"
  },
  {
    name: "Uruguay",
    code: "+598",
    prefix: null,
    iso: "UY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/uy.svg",
    mask: "_-___-__-__"
  },
  {
    name: "Uzbekistan",
    code: "+998",
    prefix: null,
    iso: "UZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/uz.svg",
    mask: "__-___-____"
  },
  {
    name: "Vanuatu",
    code: "+678",
    prefix: null,
    iso: "VU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vu.svg",
    mask: "__-_____"
  },
  {
    name: "Venezuela, Bolivarian Republic of Venezuela",
    code: "+58",
    prefix: null,
    iso: "VE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ve.svg",
    mask: "(___)___-____"
  },
  {
    name: "Vietnam",
    code: "+84",
    prefix: null,
    iso: "VN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vn.svg",
    mask: "(___)____-___"
  },
  {
    name: "Virgin Islands, British",
    code: "+1",
    prefix: "284",
    iso: "VG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vg.svg",
    mask: "(284)___-____"
  },
  {
    name: "Virgin Islands, U.S.",
    code: "+1",
    prefix: "340",
    iso: "VI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vi.svg",
    mask: "(340)___-____"
  },
  {
    name: "Wallis and Futuna",
    code: "+681",
    prefix: null,
    iso: "WF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/wf.svg",
    mask: "__-____"
  },
  {
    name: "Yemen",
    code: "+967",
    prefix: null,
    iso: "YE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ye.svg",
    mask: "___-___-___"
  },
  {
    name: "Zambia",
    code: "+260",
    prefix: null,
    iso: "ZM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/zm.svg",
    mask: "__-___-____"
  },
  {
    name: "Zimbabwe",
    code: "+263",
    prefix: null,
    iso: "ZW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/zw.svg",
    mask: "_-______"
  }
];
function mee(e) {
  const {
    children: t,
    onFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: s,
    className: a = "",
    readOnly: l,
    variant: u,
    size: c,
    id: d
  } = e, m = `arkynPhoneInputContainer ${u} ${c} ${r || l || i ? "opacity" : ""} ${o ? "errored" : ""} ${s ? "focused" : ""} ${a}`;
  return /* @__PURE__ */ B.jsx("section", { id: d, className: m.trim(), onClick: n, children: t });
}
function vee(e) {
  const { isOpen: t, onClick: n } = e;
  return t ? /* @__PURE__ */ B.jsx("aside", { className: "arkynPhoneInputCountriesOverlay", onClick: n }) : /* @__PURE__ */ B.jsx(B.Fragment, {});
}
function yee(e) {
  const { country: t, isActive: n, handleChangeValue: r, size: o } = e, s = `arkynPhoneInputCountryOption ${o} ${n ? "active" : ""}`;
  return /* @__PURE__ */ B.jsxs("div", { onClick: () => r(t), className: s, children: [
    /* @__PURE__ */ B.jsx("img", { src: t.flag, alt: t.name, className: "flag" }),
    t.name,
    " ",
    /* @__PURE__ */ B.jsx("span", { children: t.code }),
    /* @__PURE__ */ B.jsx(Xd, { className: "check" })
  ] });
}
function bee(e) {
  const { children: t, isOpen: n, onSearch: r, search: o, placeholder: i } = e;
  function s(a) {
    r(a.target.value);
  }
  return n ? /* @__PURE__ */ B.jsxs("div", { className: "arkynPhoneInputCountryOptionsContainer", children: [
    /* @__PURE__ */ B.jsx(
      "input",
      {
        type: "search",
        name: "search-select",
        className: "arkynPhoneInputCountryOptionsContainerSearchSelect",
        value: o,
        id: "input-search",
        placeholder: i,
        onChange: s
      }
    ),
    t
  ] }) : /* @__PURE__ */ B.jsx(B.Fragment, {});
}
function wee(e) {
  const { currentCountry: t, onClick: n } = e;
  return /* @__PURE__ */ B.jsxs("div", { className: "phoneInputSelectCountry", onClick: n, children: [
    /* @__PURE__ */ B.jsx(
      "img",
      {
        className: "flag",
        src: t.flag,
        alt: t.name
      }
    ),
    /* @__PURE__ */ B.jsx(nv, { className: "chevronDown", strokeWidth: 2.5 }),
    /* @__PURE__ */ B.jsx(mS, { orientation: "vertical" })
  ] });
}
function db(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const pb = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function BA(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function IA(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const FA = db(pb.NINE).length, Cee = Tr((e, t) => /* @__PURE__ */ B.jsx("input", { ref: t, ...e })), Eee = Tr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: s, currentCountry: a, disabled: l } = e, [u, c] = _(!1);
    y(() => {
      u ? i(a.mask) : c(!0);
    }, [a]);
    const d = `phoneInputMask ${o}`;
    function p(g) {
      let f = db(g.target.value);
      const m = IA(f);
      f.length > FA || (f = BA(f, pb[m]), g.target.value = f, i(f));
    }
    return a.code === "+55" ? /* @__PURE__ */ B.jsx(
      "input",
      {
        value: s,
        onChange: p,
        className: d,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ B.jsx(
      Ml,
      {
        value: s,
        onChange: (g) => i(g.target.value),
        className: d,
        component: Cee,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: a.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
function q_(e, t) {
  if (t.code === "+55") {
    let o = db(e);
    const i = IA(o);
    return o.length > FA ? void 0 : (o = BA(o, pb[i]), o);
  }
  let r = t.mask;
  if (t.prefix) {
    const o = /\$+/g;
    r = r.replace(o, t.prefix);
  }
  for (let o = 0, i = 0; o < r.length && i < e.length; o++)
    r[o] === "_" && (r = r.substring(0, o) + e[i] + r.substring(o + 1), i++);
  return r;
}
function xee(e, t) {
  const n = Ms.find(
    (r) => r.code === e && r.prefix === t
  );
  return n || null;
}
function Oee(e) {
  const t = Ms.find((n) => n.code === e);
  return t || null;
}
function kee(e) {
  const t = e.split(" ")[0].split("-")[0], n = e.split(" ")[0].split("-")[1], r = e.split(" ")[1];
  if (!t || !r)
    return { country: null, formattedNumber: "" };
  if (n) {
    const a = xee(t, n);
    if (!a) return { country: null, formattedNumber: "" };
    const l = q_(r, a);
    return { country: a, formattedNumber: l };
  }
  const o = Oee(t);
  if (!o) return { country: null, formattedNumber: "" };
  const i = q_(r, o);
  return { country: o, formattedNumber: i };
}
function mue(e) {
  const {
    defaultCountry: t,
    className: n = "",
    disabled: r = !1,
    isError: o = !1,
    isLoading: i = !1,
    readOnly: s = !1,
    size: a = "md",
    defaultValue: l = "",
    variant: u = "solid",
    name: c,
    onChange: d,
    searchCountryPlaceholder: p = "Pesquisar país",
    notFoundCountryText: g = "Nenhum país encontrado",
    ...f
  } = e, m = kee(l), [h, C] = _(!1), [w, P] = _(""), [E, v] = _(!1), [x, L] = _(m.formattedNumber || ""), [z, k] = _(() => {
    if (m.country) return m.country;
    const S = Ms.find((Y) => Y.iso === t);
    return S || Ms[30];
  }), { id: R, inputRef: A, error: U } = Er(), V = o || !!U, N = Ye(null);
  function Z() {
    h || E || (C(!0), N.current && N.current.focus());
  }
  function K() {
    v(!0), C(!0);
  }
  function X() {
    v(!1), C(!1);
  }
  function te() {
    C(!0);
  }
  function ee() {
    C(!1);
  }
  function D(S) {
    return S.name.toLowerCase().includes(w.toLowerCase());
  }
  function j(S) {
    return z.prefix ? S.replace(z.prefix, "").replaceAll(" ", "").replaceAll("-", "").replaceAll("(", "").replaceAll(")", "").trim() : S.replaceAll(" ", "").replaceAll("-", "").replaceAll("(", "").replaceAll(")", "").trim();
  }
  function G(S) {
    let Y = z.code;
    return z.prefix && (Y += `-${z.prefix}`), Y += " ", Y += j(S || x), Y;
  }
  return /* @__PURE__ */ B.jsxs(
    mee,
    {
      id: R,
      disabled: r,
      isError: V,
      isLoading: i,
      isFocused: h,
      readOnly: s,
      size: a,
      variant: u,
      className: n,
      onFocus: Z,
      children: [
        /* @__PURE__ */ B.jsx(
          wee,
          {
            currentCountry: z,
            onClick: K,
            size: a
          }
        ),
        /* @__PURE__ */ B.jsxs(
          bee,
          {
            isOpen: E,
            search: w,
            placeholder: p,
            onSearch: P,
            children: [
              Ms.filter((S) => D(S)).map((S) => /* @__PURE__ */ B.jsx(
                yee,
                {
                  country: S,
                  handleChangeValue: () => {
                    k(S), v(!1), L(S.mask);
                  },
                  isActive: S.iso === z.iso,
                  size: a
                },
                S.iso
              )),
              Ms.filter((S) => D(S)).length === 0 && /* @__PURE__ */ B.jsx("p", { children: g })
            ]
          }
        ),
        /* @__PURE__ */ B.jsx(
          vee,
          {
            isOpen: E,
            onClick: X
          }
        ),
        /* @__PURE__ */ B.jsx(
          Eee,
          {
            ref: N,
            currentCountry: z,
            value: x,
            onChange: (S) => {
              L(S), d && d(G(S));
            },
            disabled: r,
            onBlur: ee,
            onFocus: te,
            size: a
          }
        ),
        /* @__PURE__ */ B.jsx("input", { ref: A, type: "hidden", name: c, value: G() })
      ]
    }
  );
}
const RA = Ve({});
function _ee() {
  return _e(RA);
}
function vue(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: s = "",
    ...a
  } = e, [l, u] = _(t || ""), { inputRef: c, id: d } = Er();
  function p(f) {
    u(f), o && o(f);
  }
  const g = `arkynRadioGroup ${i} ${s}`;
  return /* @__PURE__ */ B.jsxs(
    RA.Provider,
    {
      value: { onChange: p, value: r || l, size: i },
      children: [
        /* @__PURE__ */ B.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: d,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ B.jsx("div", { className: g.trim(), ...a })
      ]
    }
  );
}
function yue(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...s
  } = e, { onChange: a, size: l, value: u } = _ee(), { error: c } = Er(), m = `arkynRadioBox ${n || l} ${u === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ B.jsxs("label", { className: m.trim(), children: [
    /* @__PURE__ */ B.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => a(t),
        onFocus: () => a(t),
        ...s
      }
    ),
    o
  ] });
}
var Uo = {};
Object.defineProperty(Uo, "__esModule", {
  value: !0
});
var Lee = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), eg = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, NA = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: Lee ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, fb = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var uc = 1; uc < 20; uc++)
  fb["f" + uc] = 111 + uc;
function yf(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return zA(s, t);
  }), o = function(a) {
    return r.some(function(l) {
      return $A(l, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function Dee(e, t) {
  return yf(e, t);
}
function Pee(e, t) {
  return yf(e, { byKey: !0 }, t);
}
function zA(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in eg)
    r[eg[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), d; !(a = (d = c.next()).done); a = !0) {
      var p = d.value, g = p.endsWith("?") && p.length > 1;
      g && (p = p.slice(0, -1));
      var f = hb(p), m = eg[f];
      if (p.length > 1 && !m && !NA[p] && !fb[f])
        throw new TypeError('Unknown modifier: "' + p + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = UA(p)), m && (r[m] = g ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function $A(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function UA(e) {
  e = hb(e);
  var t = fb[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function hb(e) {
  return e = e.toLowerCase(), e = NA[e] || e, e;
}
var See = Uo.default = yf, tg = Uo.isHotkey = yf;
Uo.isCodeHotkey = Dee;
Uo.isKeyHotkey = Pee;
Uo.parseHotkey = zA;
Uo.compareHotkey = $A;
Uo.toKeyCode = UA;
Uo.toKeyName = hb;
var Mee = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return tr(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || pi.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || pi.isOperationList(e.undos[0].operations));
  }
}, ng = /* @__PURE__ */ new WeakMap(), Ca = /* @__PURE__ */ new WeakMap(), is = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return Mee.isHistory(e.history) && F.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return Ca.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return ng.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = is.isMerging(e);
    Ca.set(e, !0), t(), Ca.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = is.isMerging(e);
    Ca.set(e, !1), t(), Ca.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = is.isSaving(e);
    ng.set(e, !1), t(), ng.set(e, n);
  }
}, Tee = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && ve.setSelection(t, i.selectionBefore), is.withoutSaving(t, () => {
        F.withoutNormalizing(t, () => {
          for (var s of i.operations)
            t.apply(s);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      is.withoutSaving(t, () => {
        F.withoutNormalizing(t, () => {
          var s = i.operations.map(pi.inverse).reverse();
          for (var a of s)
            t.apply(a);
          i.selectionBefore && ve.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: s
    } = i, a = s[s.length - 1], l = a && a.operations[a.operations.length - 1], u = is.isSaving(t), c = is.isMerging(t);
    if (u == null && (u = Aee(r)), u) {
      if (c == null && (a == null ? c = !1 : o.length !== 0 ? c = !0 : c = jee(r, l)), a && c)
        a.operations.push(r);
      else {
        var d = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", d);
      }
      for (; s.length > 100; )
        s.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, jee = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && ne.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && ne.equals(e.path, t.path)), Aee = (e, t) => e.type !== "set_selection", Bee = Ree, HA = "֑-߿יִ-﷽ﹰ-ﻼ", WA = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", Iee = new RegExp("^[^" + WA + "]*[" + HA + "]"), Fee = new RegExp("^[^" + HA + "]*[" + WA + "]");
function Ree(e) {
  return e = String(e || ""), Iee.test(e) ? "rtl" : Fee.test(e) ? "ltr" : "neutral";
}
const VA = /* @__PURE__ */ Jd(Bee);
function Nee(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var gb = Nee, zee = typeof rn == "object" && rn && rn.Object === Object && rn, $ee = zee, Uee = $ee, Hee = typeof self == "object" && self && self.Object === Object && self, Wee = Uee || Hee || Function("return this")(), ZA = Wee, Vee = ZA, Zee = function() {
  return Vee.Date.now();
}, qee = Zee, Gee = /\s/;
function Yee(e) {
  for (var t = e.length; t-- && Gee.test(e.charAt(t)); )
    ;
  return t;
}
var Kee = Yee, Xee = Kee, Jee = /^\s+/;
function Qee(e) {
  return e && e.slice(0, Xee(e) + 1).replace(Jee, "");
}
var ete = Qee, tte = ZA, nte = tte.Symbol, qA = nte, G_ = qA, GA = Object.prototype, rte = GA.hasOwnProperty, ote = GA.toString, Ea = G_ ? G_.toStringTag : void 0;
function ite(e) {
  var t = rte.call(e, Ea), n = e[Ea];
  try {
    e[Ea] = void 0;
    var r = !0;
  } catch {
  }
  var o = ote.call(e);
  return r && (t ? e[Ea] = n : delete e[Ea]), o;
}
var ste = ite, ate = Object.prototype, lte = ate.toString;
function ute(e) {
  return lte.call(e);
}
var cte = ute, Y_ = qA, dte = ste, pte = cte, fte = "[object Null]", hte = "[object Undefined]", K_ = Y_ ? Y_.toStringTag : void 0;
function gte(e) {
  return e == null ? e === void 0 ? hte : fte : K_ && K_ in Object(e) ? dte(e) : pte(e);
}
var mte = gte;
function vte(e) {
  return e != null && typeof e == "object";
}
var yte = vte, bte = mte, wte = yte, Cte = "[object Symbol]";
function Ete(e) {
  return typeof e == "symbol" || wte(e) && bte(e) == Cte;
}
var xte = Ete, Ote = ete, X_ = gb, kte = xte, J_ = NaN, _te = /^[-+]0x[0-9a-f]+$/i, Lte = /^0b[01]+$/i, Dte = /^0o[0-7]+$/i, Pte = parseInt;
function Ste(e) {
  if (typeof e == "number")
    return e;
  if (kte(e))
    return J_;
  if (X_(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = X_(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = Ote(e);
  var n = Lte.test(e);
  return n || Dte.test(e) ? Pte(e.slice(2), n ? 2 : 8) : _te.test(e) ? J_ : +e;
}
var Mte = Ste, Tte = gb, rg = qee, Q_ = Mte, jte = "Expected a function", Ate = Math.max, Bte = Math.min;
function Ite(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, d = !1, p = !0;
  if (typeof e != "function")
    throw new TypeError(jte);
  t = Q_(t) || 0, Tte(n) && (c = !!n.leading, d = "maxWait" in n, i = d ? Ate(Q_(n.maxWait) || 0, t) : i, p = "trailing" in n ? !!n.trailing : p);
  function g(x) {
    var L = r, z = o;
    return r = o = void 0, u = x, s = e.apply(z, L), s;
  }
  function f(x) {
    return u = x, a = setTimeout(C, t), c ? g(x) : s;
  }
  function m(x) {
    var L = x - l, z = x - u, k = t - L;
    return d ? Bte(k, i - z) : k;
  }
  function h(x) {
    var L = x - l, z = x - u;
    return l === void 0 || L >= t || L < 0 || d && z >= i;
  }
  function C() {
    var x = rg();
    if (h(x))
      return w(x);
    a = setTimeout(C, m(x));
  }
  function w(x) {
    return a = void 0, p && r ? g(x) : (r = o = void 0, s);
  }
  function P() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function E() {
    return a === void 0 ? s : w(rg());
  }
  function v() {
    var x = rg(), L = h(x);
    if (r = arguments, o = this, l = x, L) {
      if (a === void 0)
        return f(l);
      if (d)
        return clearTimeout(a), a = setTimeout(C, t), g(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return v.cancel = P, v.flush = E, v;
}
var YA = Ite;
const Fte = /* @__PURE__ */ Jd(YA);
var Rte = YA, Nte = gb, zte = "Expected a function";
function $te(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(zte);
  return Nte(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Rte(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var Ute = $te;
const Hte = /* @__PURE__ */ Jd(Ute), eL = (e) => typeof e == "object" && e != null && e.nodeType === 1, tL = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", cc = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return tL(n.overflowY, t) || tL(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, dc = (e, t, n, r, o, i, s, a) => i < e && s > t || i > e && s < t ? 0 : i <= e && a <= n || s >= t && a >= n ? i - e - r : s > t && a < n || i < e && a > n ? s - t + o : 0, Wte = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, nL = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: s, block: a, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, d = typeof u == "function" ? u : (K) => K !== u;
  if (!eL(e)) throw new TypeError("Invalid target");
  const p = document.scrollingElement || document.documentElement, g = [];
  let f = e;
  for (; eL(f) && d(f); ) {
    if (f = Wte(f), f === p) {
      g.push(f);
      break;
    }
    f != null && f === document.body && cc(f) && !cc(document.documentElement) || f != null && cc(f, c) && g.push(f);
  }
  const m = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, h = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: C, scrollY: w } = window, { height: P, width: E, top: v, right: x, bottom: L, left: z } = e.getBoundingClientRect(), { top: k, right: R, bottom: A, left: U } = ((K) => {
    const X = window.getComputedStyle(K);
    return { top: parseFloat(X.scrollMarginTop) || 0, right: parseFloat(X.scrollMarginRight) || 0, bottom: parseFloat(X.scrollMarginBottom) || 0, left: parseFloat(X.scrollMarginLeft) || 0 };
  })(e);
  let V = a === "start" || a === "nearest" ? v - k : a === "end" ? L + A : v + P / 2 - k + A, N = l === "center" ? z + E / 2 - U + R : l === "end" ? x + R : z - U;
  const Z = [];
  for (let K = 0; K < g.length; K++) {
    const X = g[K], { height: te, width: ee, top: D, right: j, bottom: G, left: S } = X.getBoundingClientRect();
    if (s === "if-needed" && v >= 0 && z >= 0 && L <= h && x <= m && (X === p && !cc(X) || v >= D && L <= G && z >= S && x <= j)) return Z;
    const Y = getComputedStyle(X), O = parseInt(Y.borderLeftWidth, 10), M = parseInt(Y.borderTopWidth, 10), W = parseInt(Y.borderRightWidth, 10), T = parseInt(Y.borderBottomWidth, 10);
    let q = 0, I = 0;
    const J = "offsetWidth" in X ? X.offsetWidth - X.clientWidth - O - W : 0, H = "offsetHeight" in X ? X.offsetHeight - X.clientHeight - M - T : 0, ce = "offsetWidth" in X ? X.offsetWidth === 0 ? 0 : ee / X.offsetWidth : 0, ye = "offsetHeight" in X ? X.offsetHeight === 0 ? 0 : te / X.offsetHeight : 0;
    if (p === X) q = a === "start" ? V : a === "end" ? V - h : a === "nearest" ? dc(w, w + h, h, M, T, w + V, w + V + P, P) : V - h / 2, I = l === "start" ? N : l === "center" ? N - m / 2 : l === "end" ? N - m : dc(C, C + m, m, O, W, C + N, C + N + E, E), q = Math.max(0, q + w), I = Math.max(0, I + C);
    else {
      q = a === "start" ? V - D - M : a === "end" ? V - G + T + H : a === "nearest" ? dc(D, G, te, M, T + H, V, V + P, P) : V - (D + te / 2) + H / 2, I = l === "start" ? N - S - O : l === "center" ? N - (S + ee / 2) + J / 2 : l === "end" ? N - j + W + J : dc(S, j, ee, O, W + J, N, N + E, E);
      const { scrollLeft: ie, scrollTop: Te } = X;
      q = ye === 0 ? 0 : Math.max(0, Math.min(Te + q / ye, X.scrollHeight - te / ye + H)), I = ce === 0 ? 0 : Math.max(0, Math.min(ie + I / ce, X.scrollWidth - ee / ce + J)), V += Te - q, N += ie - I;
    }
    Z.push({ el: X, top: q, left: I });
  }
  return Z;
}, Vte = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function Zte(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior(nL(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: s } of nL(e, Vte(t))) {
    const a = i - n.top + n.bottom, l = s - n.left + n.right;
    o.scroll({ top: a, left: l, behavior: r });
  }
}
var us = [], qte = function() {
  return us.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Gte = function() {
  return us.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, rL = "ResizeObserver loop completed with undelivered notifications.", Yte = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: rL
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = rL), window.dispatchEvent(e);
}, _l;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(_l || (_l = {}));
var cs = function(e) {
  return Object.freeze(e);
}, Kte = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, cs(this);
  }
  return e;
}(), KA = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, cs(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), mb = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, XA = function(e) {
  if (mb(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, s = o.offsetHeight;
  return !(i || s || e.getClientRects().length);
}, oL = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, Xte = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, Ga = typeof window < "u" ? window : {}, pc = /* @__PURE__ */ new WeakMap(), iL = /auto|scroll/, Jte = /^tb|vertical/, Qte = /msie|trident/i.test(Ga.navigator && Ga.navigator.userAgent), ao = function(e) {
  return parseFloat(e || "0");
}, Is = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Kte((n ? t : e) || 0, (n ? e : t) || 0);
}, sL = cs({
  devicePixelContentBoxSize: Is(),
  borderBoxSize: Is(),
  contentBoxSize: Is(),
  contentRect: new KA(0, 0, 0, 0)
}), JA = function(e, t) {
  if (t === void 0 && (t = !1), pc.has(e) && !t)
    return pc.get(e);
  if (XA(e))
    return pc.set(e, sL), sL;
  var n = getComputedStyle(e), r = mb(e) && e.ownerSVGElement && e.getBBox(), o = !Qte && n.boxSizing === "border-box", i = Jte.test(n.writingMode || ""), s = !r && iL.test(n.overflowY || ""), a = !r && iL.test(n.overflowX || ""), l = r ? 0 : ao(n.paddingTop), u = r ? 0 : ao(n.paddingRight), c = r ? 0 : ao(n.paddingBottom), d = r ? 0 : ao(n.paddingLeft), p = r ? 0 : ao(n.borderTopWidth), g = r ? 0 : ao(n.borderRightWidth), f = r ? 0 : ao(n.borderBottomWidth), m = r ? 0 : ao(n.borderLeftWidth), h = d + u, C = l + c, w = m + g, P = p + f, E = a ? e.offsetHeight - P - e.clientHeight : 0, v = s ? e.offsetWidth - w - e.clientWidth : 0, x = o ? h + w : 0, L = o ? C + P : 0, z = r ? r.width : ao(n.width) - x - v, k = r ? r.height : ao(n.height) - L - E, R = z + h + v + w, A = k + C + E + P, U = cs({
    devicePixelContentBoxSize: Is(Math.round(z * devicePixelRatio), Math.round(k * devicePixelRatio), i),
    borderBoxSize: Is(R, A, i),
    contentBoxSize: Is(z, k, i),
    contentRect: new KA(d, l, z, k)
  });
  return pc.set(e, U), U;
}, QA = function(e, t, n) {
  var r = JA(e, n), o = r.borderBoxSize, i = r.contentBoxSize, s = r.devicePixelContentBoxSize;
  switch (t) {
    case _l.DEVICE_PIXEL_CONTENT_BOX:
      return s;
    case _l.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, ene = /* @__PURE__ */ function() {
  function e(t) {
    var n = JA(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = cs([n.borderBoxSize]), this.contentBoxSize = cs([n.contentBoxSize]), this.devicePixelContentBoxSize = cs([n.devicePixelContentBoxSize]);
  }
  return e;
}(), eB = function(e) {
  if (XA(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, tne = function() {
  var e = 1 / 0, t = [];
  us.forEach(function(s) {
    if (s.activeTargets.length !== 0) {
      var a = [];
      s.activeTargets.forEach(function(u) {
        var c = new ene(u.target), d = eB(u.target);
        a.push(c), u.lastReportedSize = QA(u.target, u.observedBox), d < e && (e = d);
      }), t.push(function() {
        s.callback.call(s.observer, a, s.observer);
      }), s.activeTargets.splice(0, s.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, aL = function(e) {
  us.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (eB(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, nne = function() {
  var e = 0;
  for (aL(e); qte(); )
    e = tne(), aL(e);
  return Gte() && Yte(), e > 0;
}, og, tB = [], rne = function() {
  return tB.splice(0).forEach(function(e) {
    return e();
  });
}, one = function(e) {
  if (!og) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return rne();
    }).observe(n, r), og = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  tB.push(e), og();
}, ine = function(e) {
  one(function() {
    requestAnimationFrame(e);
  });
}, Mc = 0, sne = function() {
  return !!Mc;
}, ane = 250, lne = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, lL = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], uL = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, ig = !1, une = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = ane), !ig) {
      ig = !0;
      var r = uL(t);
      ine(function() {
        var o = !1;
        try {
          o = nne();
        } finally {
          if (ig = !1, t = r - uL(), !sne())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, lne);
    };
    document.body ? n() : Ga.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), lL.forEach(function(n) {
      return Ga.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), lL.forEach(function(n) {
      return Ga.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), Rm = new une(), cL = function(e) {
  !Mc && e > 0 && Rm.start(), Mc += e, !Mc && Rm.stop();
}, cne = function(e) {
  return !mb(e) && !Xte(e) && getComputedStyle(e).display === "inline";
}, dne = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || _l.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = QA(this.target, this.observedBox, !0);
    return cne(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), pne = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), fc = /* @__PURE__ */ new WeakMap(), dL = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, hc = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new pne(t, n);
    fc.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = fc.get(t), i = o.observationTargets.length === 0;
    dL(o.observationTargets, n) < 0 && (i && us.push(o), o.observationTargets.push(new dne(n, r && r.box)), cL(1), Rm.schedule());
  }, e.unobserve = function(t, n) {
    var r = fc.get(t), o = dL(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && us.splice(us.indexOf(r), 1), r.observationTargets.splice(o, 1), cL(-1));
  }, e.disconnect = function(t) {
    var n = this, r = fc.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), fne = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    hc.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!oL(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    hc.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!oL(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    hc.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    hc.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function hne(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Hs(e, t) {
  if (e == null) return {};
  var n = hne(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function Ll(e) {
  "@babel/helpers - typeof";
  return Ll = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ll(e);
}
function gne(e, t) {
  if (Ll(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ll(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function mne(e) {
  var t = gne(e, "string");
  return Ll(t) === "symbol" ? t : String(t);
}
function Qr(e, t, n) {
  return t = mne(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var vb = /* @__PURE__ */ Ve(null), Si = () => {
  var e = _e(vb);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, sg, ag, nB = parseInt(Oe.version.split(".")[0], 10), rB = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, pL = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), mr = typeof navigator < "u" && /Android/.test(navigator.userAgent), Ts = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Xi = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), vne = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), oB = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), yne = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), bne = mr && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), wne = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), Cne = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), Ene = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), Tc = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((sg = navigator.userAgent.match(/Version\/(\d+)/)) !== null && sg !== void 0 && sg[1] && parseInt((ag = navigator.userAgent.match(/Version\/(\d+)/)) === null || ag === void 0 ? void 0 : ag[1], 10) < 17);
var Yo = (!yne || !bne) && !vne && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", Fs = /* @__PURE__ */ new WeakMap(), yb = /* @__PURE__ */ new WeakMap(), bb = /* @__PURE__ */ new WeakMap(), iB = /* @__PURE__ */ new WeakMap(), jc = /* @__PURE__ */ new WeakMap(), Nm = /* @__PURE__ */ new WeakMap(), Dl = /* @__PURE__ */ new WeakMap(), ds = /* @__PURE__ */ new WeakMap(), Rd = /* @__PURE__ */ new WeakMap(), bf = /* @__PURE__ */ new WeakMap(), zm = /* @__PURE__ */ new WeakMap(), fi = /* @__PURE__ */ new WeakMap(), ss = /* @__PURE__ */ new WeakMap(), Ya = /* @__PURE__ */ new WeakMap(), $m = /* @__PURE__ */ new WeakMap(), wb = /* @__PURE__ */ new WeakMap(), no = /* @__PURE__ */ new WeakMap(), jo = /* @__PURE__ */ new WeakMap(), xr = /* @__PURE__ */ new WeakMap(), ii = /* @__PURE__ */ new WeakMap(), si = /* @__PURE__ */ new WeakMap(), sB = /* @__PURE__ */ new WeakMap(), Ws = Symbol("placeholder"), aB = Symbol("mark-placeholder"), lB = globalThis.Node, xne = globalThis.Text, Cb = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, One = (e) => gi(e) && e.nodeType === 8, Jr = (e) => gi(e) && e.nodeType === 1, gi = (e) => {
  var t = Cb(e);
  return !!t && e instanceof t.Node;
}, Um = (e) => {
  var t = e && e.anchorNode && Cb(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, uB = (e) => gi(e) && e.nodeType === 3, kne = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, _ne = (e) => {
  var [t, n] = e;
  if (Jr(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = cB(t, o, r ? "backward" : "forward"), r = o < n; Jr(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = Dne(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, Lne = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, cB = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (One(o) || Jr(o) && o.childNodes.length === 0 || Jr(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, Dne = (e, t, n) => {
  var [r] = cB(e, t, n);
  return r;
}, dB = (e) => {
  var t = "";
  if (uB(e) && e.nodeValue)
    return e.nodeValue;
  if (Jr(e)) {
    for (var n of Array.from(e.childNodes))
      t += dB(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, Pne = /data-slate-fragment="(.+?)"/m, Sne = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(Pne) || [];
  return n;
}, Ka = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Eb = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Jr(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = de.getWindow(e);
  if (o.contains(r))
    return de.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Eb(e, i, n);
}, Mne = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, fL = (e, t) => !!(e.compareDocumentPosition(t) & lB.DOCUMENT_POSITION_PRECEDING), Tne = (e, t) => !!(e.compareDocumentPosition(t) & lB.DOCUMENT_POSITION_FOLLOWING), jne = 0;
class Ane {
  constructor() {
    Qr(this, "id", void 0), this.id = "".concat(jne++);
  }
}
var de = {
  androidPendingDiffs: (e) => xr.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = wb.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = de.toDOMNode(e, e), n = de.findDocumentOrShadowRoot(e);
    fi.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = de.findDocumentOrShadowRoot(e), r = Ka(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && ve.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = de.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = de.toSlateNode(e, t.target), s = de.findPath(e, i);
    if (je.isElement(i) && F.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = F.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? F.before(e, u) : F.after(e, u);
      if (c) {
        var d = F.range(e, c);
        return d;
      }
    }
    var p, {
      document: g
    } = de.getWindow(e);
    if (g.caretRangeFromPoint)
      p = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (p = g.createRange(), p.setStart(f.offsetNode, f.offset), p.setEnd(f.offsetNode, f.offset));
    }
    if (!p)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = de.toSlateRange(e, p, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = Rd.get(t);
    return n || (n = new Ane(), Rd.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = bb.get(r);
      if (o == null) {
        if (F.isEditor(r))
          return n;
        break;
      }
      var i = yb.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(er.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!fi.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          de.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = de.toDOMNode(t, t), o = de.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = Ka(o), s = de.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(s);
        }
        t.selection || ve.select(t, F.start(t, [])), fi.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = iB.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = de.toDOMNode(t, t), s;
    try {
      s = Jr(n) ? n : n.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return s ? s.closest("[data-slate-editor]") === i && (!o || s.isContentEditable ? !0 : typeof s.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    s.closest('[contenteditable="false"]') === i || !!s.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => gi(t) && de.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return F.hasPath(e, n.path) && F.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => de.hasEditableTarget(e, t) || de.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => gi(t) && de.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!ss.get(e),
  isFocused: (e) => !!fi.get(e),
  isReadOnly: (e) => !!zm.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (zm.get(e)) return !1;
    var n = de.hasTarget(e, t) && de.toSlateNode(e, t);
    return je.isElement(n) && F.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = bf.get(e), r = F.isEditor(t) ? jc.get(e) : n == null ? void 0 : n.get(de.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(er.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = F.node(e, t.path), r = de.toDOMNode(e, n), o;
    F.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: d
        } = c.textContent, p = u.getAttribute("data-slate-length"), g = p == null ? d : parseInt(p, 10), f = a + g, m = s[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var h, C = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            C instanceof xne ? C : m,
            (h = m.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(d, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(er.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = ae.isBackward(t), i = de.toDOMPoint(e, n), s = ae.isCollapsed(t) ? i : de.toDOMPoint(e, r), a = de.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [d, p] = o ? i : s, g = Jr(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = Jr(d) ? d : d.parentElement, h = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(d, h ? 1 : p), l;
  },
  toSlateNode: (e, t) => {
    var n = Jr(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Dl.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : _ne(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var d, p, g = de.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), C = h && g.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), P = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var E = de.getWindow(e), v = E.document.createRange();
          v.setStart(u, 0), v.setEnd(s, a);
          var x = v.cloneContents(), L = [...Array.prototype.slice.call(x.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(x.querySelectorAll("[contenteditable=false]"))];
          L.forEach((S) => {
            if (mr && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = x.textContent.length, P = u;
        }
      } else if (m) {
        for (var z = m.querySelectorAll("[data-slate-leaf]"), k = 0; k < z.length; k++) {
          var R = z[k];
          if (de.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), P = w, c = P.textContent.length, P.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (C) {
        var A = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], U = C.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, N = [...A(U), ...A(U == null ? void 0 : U.nextElementSibling)];
          w = (V = N.find((S) => Tne(C, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...A(U == null ? void 0 : U.previousElementSibling), ...A(U)];
          w = (Z = K.findLast((S) => fL(C, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), P = w, i === "forward" ? c = 0 : (c = P.textContent.length, P.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      P && c === P.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      mr && P.getAttribute("data-slate-zero-width") === "z" && (d = P.textContent) !== null && d !== void 0 && d.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Ts && (p = P.textContent) !== null && p !== void 0 && p.endsWith(`

`)) && c--;
    }
    if (mr && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && de.hasDOMNode(e, X, {
        editable: !0
      })) {
        var te = de.toSlateNode(e, X), {
          path: ee,
          offset: D
        } = F.start(e, de.findPath(e, te));
        return X.querySelector("[data-slate-leaf]") || (D = a), {
          path: ee,
          offset: D
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var j = de.toSlateNode(e, u), G = de.findPath(e, j);
    return {
      path: G,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = Um(t) ? t.anchorNode : t.startContainer, a, l, u, c, d;
    if (s)
      if (Um(t)) {
        if (Ts && t.rangeCount > 1) {
          u = t.focusNode;
          var p = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && p.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let x = function(L) {
              return L.childElementCount > 0 ? x(L.children[0]) : L;
            };
            var f = p.startContainer, m = g.startContainer, h = x(f.children[p.startOffset]), C = x(m.children[g.startOffset]);
            c = 0, C.childNodes.length > 0 ? a = C.childNodes[0] : a = C, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, C instanceof HTMLElement ? l = C.innerHTML.length : l = 0;
          } else
            p.startContainer === u ? (a = g.endContainer, l = g.endOffset, c = p.startOffset) : (a = p.startContainer, l = p.endOffset, c = g.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        oB && Lne(a) || Ts ? d = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : d = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, d = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Ts && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = de.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var P = fL(a, u) || a === u && c < l, E = d ? w : de.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: P ? "forward" : "backward"
    });
    if (!E)
      return null;
    var v = {
      anchor: w,
      focus: E
    };
    return ae.isExpanded(v) && ae.isForward(v) && Jr(u) && F.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = F.unhangRange(e, v, {
      voids: !0
    })), v;
  }
};
function Bne(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!F.hasPath(e, n))
    return !1;
  var o = xe.get(e, n);
  if (!Ae.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = ne.next(n);
  if (!F.hasPath(e, i))
    return !1;
  var s = xe.get(e, i);
  return Ae.isText(s) && s.text.startsWith(r.text);
}
function pB(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function Ine(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function Fne(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function fB(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), s = Ine(i, o), a = Math.min(i.length - s, o.length - s), l = Fne(i, o, a), u = {
    start: n + s,
    end: r - l,
    text: o.slice(s, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function Rne(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = pB(e, t, n), s = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), a = i.slice(r, s), l = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return fB(e, {
    start: r,
    end: l,
    text: a
  });
}
function Nne(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function Hm(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!F.hasPath(e, n))
    return null;
  var o = xe.get(e, n);
  if (!Ae.isText(o))
    return null;
  var i = F.above(e, {
    match: (a) => je.isElement(a) && F.isBlock(e, a),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var s = F.next(e, {
      at: n,
      match: Ae.isText
    });
    if (!s || !ne.isDescendant(s[1], i[1]))
      return null;
    r -= o.text.length, o = s[0], n = s[1];
  }
  return {
    path: n,
    offset: r
  };
}
function hL(e, t) {
  var n = Hm(e, t.anchor);
  if (!n)
    return null;
  if (ae.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = Hm(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function Wm(e, t, n) {
  var r = xr.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: d
    } = c;
    return ne.equals(d, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return ct.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var s = {
      path: t.path,
      offset: i.start
    }, a = ct.transform(s, n, {
      affinity: "backward"
    });
    return a ? {
      path: a.path,
      offset: a.offset + t.offset - i.start
    } : null;
  }
  var l = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, u = ct.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && ne.equals(n.path, t.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function gL(e, t, n) {
  var r = Wm(e, t.anchor, n);
  if (!r)
    return null;
  if (ae.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = Wm(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function zne(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !ne.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !ne.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !ne.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: ne.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: ne.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return ne.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: ne.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: ne.transform(n, t)
      };
  }
  var i = ne.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function mL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mL(Object(n), !0).forEach(function(r) {
      Qr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $ne = 25, Une = 200, Hne = function() {
}, Wne = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function Vne(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, s = null, a = null, l = 0, u = !1, c = () => {
    var U = si.get(t);
    if (si.delete(t), U) {
      var {
        selection: V
      } = t, N = hL(t, U);
      N && (!V || !ae.equals(N, V)) && ve.select(t, N);
    }
  }, d = () => {
    var U = ii.get(t);
    if (ii.delete(t), !!U) {
      if (U.at) {
        var V = ct.isPoint(U.at) ? Hm(t, U.at) : hL(t, U.at);
        if (!V)
          return;
        var N = F.range(t, V);
        (!t.selection || !ae.equals(t.selection, N)) && ve.select(t, V);
      }
      U.run();
    }
  }, p = () => {
    if (s && (clearTimeout(s), s = null), a && (clearTimeout(a), a = null), !E() && !P()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), P() && (o = "action");
    var U = t.selection && F.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    jo.set(t, t.marks), Hne("flush", ii.get(t), xr.get(t));
    for (var V = E(), N; N = (Z = xr.get(t)) === null || Z === void 0 ? void 0 : Z[0]; ) {
      var Z, K, X = no.get(t);
      X !== void 0 && (no.delete(t), t.marks = X), X && u === !1 && (u = null);
      var te = Nne(N);
      (!t.selection || !ae.equals(t.selection, te)) && ve.select(t, te), N.diff.text ? F.insertText(t, N.diff.text) : F.deleteFragment(t), xr.set(t, (K = xr.get(t)) === null || K === void 0 ? void 0 : K.filter((j) => {
        var {
          id: G
        } = j;
        return G !== N.id;
      })), Bne(t, N) || (V = !1, ii.delete(t), jo.delete(t), o = "action", si.delete(t), n.cancel(), r.cancel(), U == null || U.unref());
    }
    var ee = U == null ? void 0 : U.unref();
    if (ee && !si.get(t) && (!t.selection || !ae.equals(ee, t.selection)) && ve.select(t, ee), P()) {
      d();
      return;
    }
    V && n(), n.flush(), r.flush(), c();
    var D = jo.get(t);
    jo.delete(t), D !== void 0 && (t.marks = D, t.onChange());
  }, g = (U) => {
    i && clearTimeout(i), i = setTimeout(() => {
      ss.set(t, !1), p();
    }, $ne);
  }, f = (U) => {
    ss.set(t, !0), i && (clearTimeout(i), i = null);
  }, m = function() {
    var V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, N = Nm.get(t);
    if (N) {
      if (E() || V) {
        N.style.display = "none";
        return;
      }
      N.style.removeProperty("display");
    }
  }, h = (U, V) => {
    var N, Z = (N = xr.get(t)) !== null && N !== void 0 ? N : [];
    xr.set(t, Z);
    var K = xe.leaf(t, U), X = Z.findIndex((D) => ne.equals(D.path, U));
    if (X < 0) {
      var te = fB(K.text, V);
      te && Z.push({
        path: U,
        diff: V,
        id: l++
      }), m();
      return;
    }
    var ee = Rne(K.text, Z[X].diff, V);
    if (!ee) {
      Z.splice(X, 1), m();
      return;
    }
    Z[X] = gc(gc({}, Z[X]), {}, {
      diff: ee
    });
  }, C = function(V) {
    var {
      at: N
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, si.delete(t), n.cancel(), r.cancel(), P() && p(), ii.set(t, {
      at: N,
      run: V
    }), a = setTimeout(p);
  }, w = (U) => {
    var V;
    if (s && (clearTimeout(s), s = null), !Fs.get(t)) {
      var {
        inputType: N
      } = U, Z = null, K = U.dataTransfer || U.data || void 0;
      u !== !1 && N !== "insertText" && N !== "insertCompositionText" && (u = !1);
      var [X] = U.getTargetRanges();
      X && (Z = de.toSlateRange(t, X, {
        exactMatch: !1,
        suppressThrow: !0
      }));
      var te = de.getWindow(t), ee = te.getSelection();
      if (!Z && ee && (X = ee, Z = de.toSlateRange(t, ee, {
        exactMatch: !1,
        suppressThrow: !0
      })), Z = (V = Z) !== null && V !== void 0 ? V : t.selection, !!Z) {
        var D = !0;
        if (N.startsWith("delete")) {
          if (ae.isExpanded(Z)) {
            var [j, G] = ae.edges(Z), S = xe.leaf(t, j.path);
            if (S.text.length === j.offset && G.offset === 0) {
              var Y = F.next(t, {
                at: j.path,
                match: Ae.isText
              });
              Y && ne.equals(Y[1], G.path) && (Z = {
                anchor: G,
                focus: G
              });
            }
          }
          var O = N.endsWith("Backward") ? "backward" : "forward", [M, W] = ae.edges(Z), [T, q] = F.leaf(t, M.path), I = {
            text: "",
            start: M.offset,
            end: W.offset
          }, J = xr.get(t), H = J == null ? void 0 : J.find((He) => ne.equals(He.path, q)), ce = H ? [H.diff, I] : [I], ye = pB(T.text, ...ce);
          if (ye.length === 0 && (D = !1), ae.isExpanded(Z)) {
            if (D && ne.equals(Z.anchor.path, Z.focus.path)) {
              var ie = {
                path: Z.anchor.path,
                offset: M.offset
              }, Te = F.range(t, ie, ie);
              return L(Te), h(Z.anchor.path, {
                text: "",
                end: W.offset,
                start: M.offset
              });
            }
            return C(() => F.deleteFragment(t, {
              direction: O
            }), {
              at: Z
            });
          }
        }
        switch (N) {
          case "deleteByComposition":
          case "deleteByCut":
          case "deleteByDrag":
            return C(() => F.deleteFragment(t), {
              at: Z
            });
          case "deleteContent":
          case "deleteContentForward": {
            var {
              anchor: Re
            } = Z;
            if (D && ae.isCollapsed(Z)) {
              var Ne = xe.leaf(t, Re.path);
              if (Re.offset < Ne.text.length)
                return h(Re.path, {
                  text: "",
                  start: Re.offset,
                  end: Re.offset + 1
                });
            }
            return C(() => F.deleteForward(t), {
              at: Z
            });
          }
          case "deleteContentBackward": {
            var Ie, {
              anchor: Ke
            } = Z, Ze = Um(X) ? X.isCollapsed : !!((Ie = X) !== null && Ie !== void 0 && Ie.collapsed);
            return D && Ze && ae.isCollapsed(Z) && Ke.offset > 0 ? h(Ke.path, {
              text: "",
              start: Ke.offset - 1,
              end: Ke.offset
            }) : C(() => F.deleteBackward(t), {
              at: Z
            });
          }
          case "deleteEntireSoftLine":
            return C(() => {
              F.deleteBackward(t, {
                unit: "line"
              }), F.deleteForward(t, {
                unit: "line"
              });
            }, {
              at: Z
            });
          case "deleteHardLineBackward":
            return C(() => F.deleteBackward(t, {
              unit: "block"
            }), {
              at: Z
            });
          case "deleteSoftLineBackward":
            return C(() => F.deleteBackward(t, {
              unit: "line"
            }), {
              at: Z
            });
          case "deleteHardLineForward":
            return C(() => F.deleteForward(t, {
              unit: "block"
            }), {
              at: Z
            });
          case "deleteSoftLineForward":
            return C(() => F.deleteForward(t, {
              unit: "line"
            }), {
              at: Z
            });
          case "deleteWordBackward":
            return C(() => F.deleteBackward(t, {
              unit: "word"
            }), {
              at: Z
            });
          case "deleteWordForward":
            return C(() => F.deleteForward(t, {
              unit: "word"
            }), {
              at: Z
            });
          case "insertLineBreak":
            return C(() => F.insertSoftBreak(t), {
              at: Z
            });
          case "insertParagraph":
            return C(() => F.insertBreak(t), {
              at: Z
            });
          case "insertCompositionText":
          case "deleteCompositionText":
          case "insertFromComposition":
          case "insertFromDrop":
          case "insertFromPaste":
          case "insertFromYank":
          case "insertReplacementText":
          case "insertText": {
            if (Wne(K))
              return C(() => de.insertData(t, K), {
                at: Z
              });
            var Se = K ?? "";
            if (no.get(t) && (Se = Se.replace("\uFEFF", "")), N === "insertText" && /.*\n.*\n$/.test(Se) && (Se = Se.slice(0, -1)), Se.includes(`
`))
              return C(() => {
                var He = Se.split(`
`);
                He.forEach(($e, ot) => {
                  $e && F.insertText(t, $e), ot !== He.length - 1 && F.insertSoftBreak(t);
                });
              }, {
                at: Z
              });
            if (ne.equals(Z.anchor.path, Z.focus.path)) {
              var [qe, rt] = ae.edges(Z), Pe = {
                start: qe.offset,
                end: rt.offset,
                text: Se
              };
              if (Se && u && N === "insertCompositionText") {
                var Me = u.start + u.text.search(/\S|$/), Ge = Pe.start + Pe.text.search(/\S|$/);
                Ge === Me + 1 && Pe.end === u.start + u.text.length ? (Pe.start -= 1, u = null, R()) : u = !1;
              } else N === "insertText" ? u === null ? u = Pe : u && ae.isCollapsed(Z) && u.end + u.text.length === qe.offset ? u = gc(gc({}, u), {}, {
                text: u.text + Se
              }) : u = !1 : u = !1;
              if (D) {
                h(qe.path, Pe);
                return;
              }
            }
            return C(() => F.insertText(t, Se), {
              at: Z
            });
          }
        }
      }
    }
  }, P = () => !!ii.get(t), E = () => {
    var U;
    return !!((U = xr.get(t)) !== null && U !== void 0 && U.length);
  }, v = () => P() || E(), x = () => o, L = (U) => {
    si.set(t, U), s && (clearTimeout(s), s = null);
    var {
      selection: V
    } = t;
    if (U) {
      var N = !V || !ne.equals(V.anchor.path, U.anchor.path), Z = !V || !ne.equals(V.anchor.path.slice(0, -1), U.anchor.path.slice(0, -1));
      (N && u || Z) && (u = !1), (N || E()) && (s = setTimeout(p, Une));
    }
  }, z = () => {
    (P() || !E()) && p();
  }, k = (U) => {
    E() || (m(!0), setTimeout(m));
  }, R = () => {
    P() || (a = setTimeout(p));
  }, A = (U) => {
    if (!(E() || P()) && U.some((N) => Eb(t, N, U))) {
      var V;
      (V = sB.get(t)) === null || V === void 0 || V();
    }
  };
  return {
    flush: p,
    scheduleFlush: R,
    hasPendingDiffs: E,
    hasPendingAction: P,
    hasPendingChanges: v,
    isFlushing: x,
    handleUserSelect: L,
    handleCompositionEnd: g,
    handleCompositionStart: f,
    handleDOMBeforeInput: w,
    handleKeyDown: k,
    handleDomMutations: A,
    handleInput: z
  };
}
function Zne() {
  var e = Ye(!1);
  return y(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var Pl = Tc ? OI : y;
function qne(e, t, n) {
  var [r] = _(() => new MutationObserver(t));
  Pl(() => {
    r.takeRecords();
  }), y(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var Gne = ["node"];
function vL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yne(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vL(Object(n), !0).forEach(function(r) {
      Qr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Kne = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, Xne = mr ? (e) => {
  var {
    node: t
  } = e, n = Hs(e, Gne);
  if (!mr)
    return null;
  var r = Si(), o = Zne(), [i] = _(() => Vne(Yne({
    editor: r
  }, n)));
  return qne(t, i.handleDomMutations, Kne), wb.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, Jne = ["anchor", "focus"], Qne = ["anchor", "focus"], ere = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), hB = (e, t) => {
  var n = Hs(e, Jne), r = Hs(t, Qne);
  return e[Ws] === t[Ws] && ere(n, r);
}, tre = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!ae.equals(r, o) || !hB(r, o))
      return !1;
  }
  return !0;
}, nre = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !hB(r, o))
      return !1;
  }
  return !0;
};
function yL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rre(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yL(Object(n), !0).forEach(function(r) {
      Qr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ore = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = Si(), s = de.findPath(i, o), a = ne.parent(s), l = !!n[aB];
  return i.isVoid(r) ? /* @__PURE__ */ Oe.createElement(lg, {
    length: xe.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && F.string(i, a) === "" ? /* @__PURE__ */ Oe.createElement(lg, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ Oe.createElement(lg, {
    isMarkPlaceholder: l
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ Oe.createElement(bL, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ Oe.createElement(bL, {
    text: n.text
  });
}, bL = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = Ye(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = _(o);
  return Pl(() => {
    var s = o();
    r.current && r.current.textContent !== s && (r.current.textContent = s);
  }), /* @__PURE__ */ Oe.createElement(ire, {
    ref: r
  }, i);
}, ire = /* @__PURE__ */ De(/* @__PURE__ */ Tr((e, t) => /* @__PURE__ */ Oe.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), lg = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ Oe.createElement("span", rre({}, o), !(mr || rB) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ Oe.createElement("br", null) : null);
};
function wL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wL(Object(n), !0).forEach(function(r) {
      Qr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sre = mr ? 300 : 0;
function are(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function CL(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var lre = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: s = (w) => /* @__PURE__ */ Oe.createElement(cre, gB({}, w))
  } = e, a = Si(), l = Ye(null), u = Ye(null), [c, d] = _(!1), p = Ye(null), g = Yt((w) => {
    if (are(l, w == null), w == null) {
      var P;
      Nm.delete(a), (P = t.onPlaceholderResize) === null || P === void 0 || P.call(t, null);
    } else {
      if (Nm.set(a, w), !l.current) {
        var E = window.ResizeObserver || fne;
        l.current = new E(() => {
          var v;
          (v = t.onPlaceholderResize) === null || v === void 0 || v.call(t, w);
        });
      }
      l.current.observe(w), u.current = w;
    }
  }, [u, t, a]), f = /* @__PURE__ */ Oe.createElement(ore, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), m = !!t[Ws];
  if (y(() => (m ? p.current || (p.current = setTimeout(() => {
    d(!0), p.current = null;
  }, sre)) : (CL(p), d(!1)), () => CL(p)), [m, d]), m && c) {
    var h = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: Xi ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: g
      }
    };
    f = /* @__PURE__ */ Oe.createElement(Oe.Fragment, null, i(h), f);
  }
  var C = {
    "data-slate-leaf": !0
  };
  return s({
    attributes: C,
    children: f,
    leaf: t,
    text: r
  });
}, ure = /* @__PURE__ */ Oe.memo(lre, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && Ae.equals(t.leaf, e.leaf) && t.leaf[Ws] === e.leaf[Ws]), cre = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ Oe.createElement("span", gB({}, t), n);
}, dre = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: s
  } = e, a = Si(), l = Ye(null), u = Ae.decorations(s, t), c = de.findKey(a, s), d = [], p = 0; p < u.length; p++) {
    var g = u[p];
    d.push(/* @__PURE__ */ Oe.createElement(ure, {
      isLast: n && p === u.length - 1,
      key: "".concat(c.id, "-").concat(p),
      renderPlaceholder: o,
      leaf: g,
      text: s,
      parent: r,
      renderLeaf: i
    }));
  }
  var f = Yt((m) => {
    var h = bf.get(a);
    m ? (h == null || h.set(c, m), ds.set(s, m), Dl.set(m, s)) : (h == null || h.delete(c), ds.delete(s), l.current && Dl.delete(l.current)), l.current = m;
  }, [l, a, c, s]);
  return /* @__PURE__ */ Oe.createElement("span", {
    "data-slate-node": "text",
    ref: f
  }, d);
}, mB = /* @__PURE__ */ Oe.memo(dre, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && nre(t.decorations, e.decorations));
function EL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EL(Object(n), !0).forEach(function(r) {
      Qr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pre = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (w) => /* @__PURE__ */ Oe.createElement(hre, Vm({}, w)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  } = e, a = Si(), l = vre(), u = a.isInline(n), c = de.findKey(a, n), d = Yt((w) => {
    var P = bf.get(a);
    w ? (P == null || P.set(c, w), ds.set(n, w), Dl.set(w, n)) : (P == null || P.delete(c), ds.delete(n));
  }, [a, c, n]), p = yB({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  }), g = {
    "data-slate-node": "element",
    ref: d
  };
  if (u && (g["data-slate-inline"] = !0), !u && F.hasInlines(a, n)) {
    var f = xe.string(n), m = VA(f);
    m === "rtl" && (g.dir = m);
  }
  if (F.isVoid(a, n)) {
    g["data-slate-void"] = !0, !l && u && (g.contentEditable = !1);
    var h = u ? "span" : "div", [[C]] = xe.texts(n);
    p = /* @__PURE__ */ Oe.createElement(h, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ Oe.createElement(mB, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: C
    })), yb.set(C, 0), bb.set(C, n);
  }
  return r({
    attributes: g,
    children: p,
    element: n
  });
}, fre = /* @__PURE__ */ Oe.memo(pre, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && tre(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && ae.equals(e.selection, t.selection))), hre = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = Si(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ Oe.createElement(i, Vm(Vm({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, vB = /* @__PURE__ */ Ve(() => []), gre = () => _e(vB), mre = /* @__PURE__ */ Ve(!1), yB = (e) => {
  var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  } = e, a = gre(), l = Si();
  Fs.set(l, !1);
  for (var u = de.findPath(l, n), c = [], d = je.isElement(n) && !l.isInline(n) && F.hasInlines(l, n), p = 0; p < n.children.length; p++) {
    var g = u.concat(p), f = n.children[p], m = de.findKey(l, f), h = F.range(l, g), C = s && ae.intersection(h, s), w = a([f, g]);
    for (var P of t) {
      var E = ae.intersection(P, h);
      E && w.push(E);
    }
    je.isElement(f) ? c.push(/* @__PURE__ */ Oe.createElement(mre.Provider, {
      key: "provider-".concat(m.id),
      value: !!C
    }, /* @__PURE__ */ Oe.createElement(fre, {
      decorations: w,
      element: f,
      key: m.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: C
    }))) : c.push(/* @__PURE__ */ Oe.createElement(mB, {
      decorations: w,
      key: m.id,
      isLast: d && p === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: f
    })), yb.set(f, p), bb.set(f, n);
  }
  return c;
}, bB = /* @__PURE__ */ Ve(!1), vre = () => _e(bB), wB = /* @__PURE__ */ Ve(null), wf = () => {
  var e = _e(wB);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function yre() {
  var e = Si(), t = Ye(!1), n = Ye(0), r = Yt(() => {
    if (!t.current) {
      t.current = !0;
      var o = de.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return y(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var bre = 3, wre = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, Cre = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, Ere = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Dn = (e) => {
  var t = wre[e], n = Cre[e], r = Ere[e], o = t && tg(t), i = n && tg(n), s = r && tg(r);
  return (a) => !!(o && o(a) || pL && i && i(a) || !pL && s && s(a));
}, Mn = {
  isBold: Dn("bold"),
  isCompose: Dn("compose"),
  isMoveBackward: Dn("moveBackward"),
  isMoveForward: Dn("moveForward"),
  isDeleteBackward: Dn("deleteBackward"),
  isDeleteForward: Dn("deleteForward"),
  isDeleteLineBackward: Dn("deleteLineBackward"),
  isDeleteLineForward: Dn("deleteLineForward"),
  isDeleteWordBackward: Dn("deleteWordBackward"),
  isDeleteWordForward: Dn("deleteWordForward"),
  isExtendBackward: Dn("extendBackward"),
  isExtendForward: Dn("extendForward"),
  isExtendLineBackward: Dn("extendLineBackward"),
  isExtendLineForward: Dn("extendLineForward"),
  isItalic: Dn("italic"),
  isMoveLineBackward: Dn("moveLineBackward"),
  isMoveLineForward: Dn("moveLineForward"),
  isMoveWordBackward: Dn("moveWordBackward"),
  isMoveWordForward: Dn("moveWordForward"),
  isRedo: Dn("redo"),
  isSoftBreak: Dn("insertSoftBreak"),
  isSplitBlock: Dn("splitBlock"),
  isTransposeCharacter: Dn("transposeCharacter"),
  isUndo: Dn("undo")
}, xre = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => Eb(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, Ore = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class CB extends Kd {
  constructor() {
    super(...arguments), Qr(this, "context", null), Qr(this, "manager", null), Qr(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, Ore);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = xre(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Qr(CB, "contextType", vb);
var kre = mr ? CB : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ Oe.createElement(Oe.Fragment, null, t);
}, _re = /* @__PURE__ */ Ve(!1), Lre = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], Dre = ["text"];
function xL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xL(Object(n), !0).forEach(function(r) {
      Qr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Pre = (e) => /* @__PURE__ */ Oe.createElement(Oe.Fragment, null, yB(e)), Sre = /* @__PURE__ */ Tr((e, t) => {
  var n = Yt((M) => /* @__PURE__ */ Oe.createElement(Mre, lo({}, M)), []), {
    autoFocus: r,
    decorate: o = Tre,
    onDOMBeforeInput: i,
    placeholder: s,
    readOnly: a = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: d = jre,
    style: p = {},
    as: g = "div",
    disableDefaultStyles: f = !1
  } = e, m = Hs(e, Lre), h = wf(), [C, w] = _(!1), P = Ye(null), E = Ye([]), [v, x] = _(), L = Ye(!1), {
    onUserInput: z,
    receivedUserInput: k
  } = yre(), [, R] = kI((M) => M + 1, 0);
  sB.set(h, R), zm.set(h, a);
  var A = qn(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  y(() => {
    P.current && r && P.current.focus();
  }, [r]);
  var U = Ye(), V = qn(() => Hte(() => {
    if (Fs.get(h)) {
      V();
      return;
    }
    var M = de.toDOMNode(h, h), W = M.getRootNode();
    if (!L.current && Xi && W instanceof ShadowRoot) {
      L.current = !0;
      var T = Mne();
      T ? document.execCommand("indent") : ve.deselect(h), L.current = !1;
      return;
    }
    var q = U.current;
    if ((mr || !de.isComposing(h)) && (!A.isUpdatingSelection || q != null && q.isFlushing()) && !A.isDraggingInternally) {
      var I = de.findDocumentOrShadowRoot(h), {
        activeElement: J
      } = I, H = de.toDOMNode(h, h), ce = Ka(I);
      if (J === H ? (A.latestElement = J, fi.set(h, !0)) : fi.delete(h), !ce)
        return ve.deselect(h);
      var {
        anchorNode: ye,
        focusNode: ie
      } = ce, Te = de.hasEditableTarget(h, ye) || de.isTargetInsideNonReadonlyVoid(h, ye), Re = de.hasTarget(h, ie);
      if (Te && Re) {
        var Ne = de.toSlateRange(h, ce, {
          exactMatch: !1,
          suppressThrow: !0
        });
        Ne && (!de.isComposing(h) && !(q != null && q.hasPendingChanges()) && !(q != null && q.isFlushing()) ? ve.select(h, Ne) : q == null || q.handleUserSelect(Ne));
      }
      a && (!Te || !Re) && ve.deselect(h);
    }
  }, 100), [h, a, A]), N = qn(() => Fte(V, 0), [V]);
  U.current = Xne({
    node: P,
    onDOMSelectionChange: V,
    scheduleOnDOMSelectionChange: N
  }), Pl(() => {
    var M, W, T;
    P.current && (T = Cb(P.current)) ? (iB.set(h, T), jc.set(h, P.current), ds.set(h, P.current), Dl.set(P.current, h)) : ds.delete(h);
    var {
      selection: q
    } = h, I = de.findDocumentOrShadowRoot(h), J = Ka(I);
    if (!(!J || !de.isFocused(h) || (M = U.current) !== null && M !== void 0 && M.hasPendingAction())) {
      var H = (Te) => {
        var Re = J.type !== "None";
        if (!(!q && !Re)) {
          var Ne = J.focusNode, Ie;
          if (Ts && J.rangeCount > 1) {
            var Ke = J.getRangeAt(0), Ze = J.getRangeAt(J.rangeCount - 1);
            Ke.startContainer === Ne ? Ie = Ze.endContainer : Ie = Ke.startContainer;
          } else
            Ie = J.anchorNode;
          var Se = jc.get(h), qe = !1;
          if (Se.contains(Ie) && Se.contains(Ne) && (qe = !0), Re && qe && q && !Te) {
            var rt = de.toSlateRange(h, J, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (rt && ae.equals(rt, q)) {
              var Pe;
              if (!A.hasMarkPlaceholder || (Pe = Ie) !== null && Pe !== void 0 && (Pe = Pe.parentElement) !== null && Pe !== void 0 && Pe.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (q && !de.hasRange(h, q)) {
            h.selection = de.toSlateRange(h, J, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          A.isUpdatingSelection = !0;
          var Me = q && de.toDOMRange(h, q);
          return Me ? (de.isComposing(h) && !mr ? J.collapseToEnd() : ae.isBackward(q) ? J.setBaseAndExtent(Me.endContainer, Me.endOffset, Me.startContainer, Me.startOffset) : J.setBaseAndExtent(Me.startContainer, Me.startOffset, Me.endContainer, Me.endOffset), d(h, Me)) : J.removeAllRanges(), Me;
        }
      };
      J.rangeCount <= 1 && H();
      var ce = ((W = U.current) === null || W === void 0 ? void 0 : W.isFlushing()) === "action";
      if (!mr || !ce) {
        setTimeout(() => {
          A.isUpdatingSelection = !1;
        });
        return;
      }
      var ye = null, ie = requestAnimationFrame(() => {
        if (ce) {
          var Te = (Re) => {
            try {
              var Ne = de.toDOMNode(h, h);
              Ne.focus(), H(Re);
            } catch {
            }
          };
          Te(), ye = setTimeout(() => {
            Te(!0), A.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(ie), ye && clearTimeout(ye);
      };
    }
  });
  var Z = Yt((M) => {
    var W = de.toDOMNode(h, h), T = W.getRootNode();
    if (L != null && L.current && Xi && T instanceof ShadowRoot) {
      var q = M.getTargetRanges(), I = q[0], J = new window.Range();
      J.setStart(I.startContainer, I.startOffset), J.setEnd(I.endContainer, I.endOffset);
      var H = de.toSlateRange(h, J, {
        exactMatch: !1,
        suppressThrow: !1
      });
      ve.select(h, H), M.preventDefault(), M.stopImmediatePropagation();
      return;
    }
    if (z(), !a && de.hasEditableTarget(h, M.target) && !Are(M, i)) {
      var ce;
      if (U.current)
        return U.current.handleDOMBeforeInput(M);
      N.flush(), V.flush();
      var {
        selection: ye
      } = h, {
        inputType: ie
      } = M, Te = M.dataTransfer || M.data || void 0, Re = ie === "insertCompositionText" || ie === "deleteCompositionText";
      if (Re && de.isComposing(h))
        return;
      var Ne = !1;
      if (ie === "insertText" && ye && ae.isCollapsed(ye) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      M.data && M.data.length === 1 && /[a-z ]/i.test(M.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      ye.anchor.offset !== 0 && (Ne = !0, h.marks && (Ne = !1), !Fs.get(h))) {
        var Ie, Ke, {
          anchor: Ze
        } = ye, [Se, qe] = de.toDOMPoint(h, Ze), rt = (Ie = Se.parentElement) === null || Ie === void 0 ? void 0 : Ie.closest("a"), Pe = de.getWindow(h);
        if (Ne && rt && de.hasDOMNode(h, rt)) {
          var Me, Ge = Pe == null ? void 0 : Pe.document.createTreeWalker(rt, NodeFilter.SHOW_TEXT).lastChild();
          Ge === Se && ((Me = Ge.textContent) === null || Me === void 0 ? void 0 : Me.length) === qe && (Ne = !1);
        }
        if (Ne && Se.parentElement && (Pe == null || (Ke = Pe.getComputedStyle(Se.parentElement)) === null || Ke === void 0 ? void 0 : Ke.whiteSpace) === "pre") {
          var He = F.above(h, {
            at: Ze.path,
            match: (ht) => je.isElement(ht) && F.isBlock(h, ht)
          });
          He && xe.string(He[0]).includes("	") && (Ne = !1);
        }
      }
      if ((!ie.startsWith("delete") || ie.startsWith("deleteBy")) && !Fs.get(h)) {
        var [$e] = M.getTargetRanges();
        if ($e) {
          var ot = de.toSlateRange(h, $e, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!ye || !ae.equals(ye, ot)) {
            Ne = !1;
            var Fe = !Re && h.selection && F.rangeRef(h, h.selection);
            ve.select(h, ot), Fe && Ya.set(h, Fe);
          }
        }
      }
      if (Re)
        return;
      if (Ne || M.preventDefault(), ye && ae.isExpanded(ye) && ie.startsWith("delete")) {
        var Kt = ie.endsWith("Backward") ? "backward" : "forward";
        F.deleteFragment(h, {
          direction: Kt
        });
        return;
      }
      switch (ie) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          F.deleteFragment(h);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          F.deleteForward(h);
          break;
        }
        case "deleteContentBackward": {
          F.deleteBackward(h);
          break;
        }
        case "deleteEntireSoftLine": {
          F.deleteBackward(h, {
            unit: "line"
          }), F.deleteForward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          F.deleteBackward(h, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          F.deleteBackward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          F.deleteForward(h, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          F.deleteForward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          F.deleteBackward(h, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          F.deleteForward(h, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          F.insertSoftBreak(h);
          break;
        case "insertParagraph": {
          F.insertBreak(h);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          ie === "insertFromComposition" && de.isComposing(h) && (w(!1), ss.set(h, !1)), (Te == null ? void 0 : Te.constructor.name) === "DataTransfer" ? de.insertData(h, Te) : typeof Te == "string" && (Ne ? E.current.push(() => F.insertText(h, Te)) : F.insertText(h, Te));
          break;
        }
      }
      var lt = (ce = Ya.get(h)) === null || ce === void 0 ? void 0 : ce.unref();
      Ya.delete(h), lt && (!h.selection || !ae.equals(h.selection, lt)) && ve.select(h, lt);
    }
  }, [h, V, z, i, a, N]), K = Yt((M) => {
    M == null ? (V.cancel(), N.cancel(), jc.delete(h), ds.delete(h), P.current && Yo && P.current.removeEventListener("beforeinput", Z)) : Yo && M.addEventListener("beforeinput", Z), P.current = M, typeof t == "function" ? t(M) : t && (t.current = M);
  }, [V, N, h, Z, t]);
  Pl(() => {
    var M = de.getWindow(h);
    M.document.addEventListener("selectionchange", N);
    var W = () => {
      A.isDraggingInternally = !1;
    };
    return M.document.addEventListener("dragend", W), M.document.addEventListener("drop", W), () => {
      M.document.removeEventListener("selectionchange", N), M.document.removeEventListener("dragend", W), M.document.removeEventListener("drop", W);
    };
  }, [N, A]);
  var X = o([h, []]), te = s && h.children.length === 1 && Array.from(xe.texts(h)).length === 1 && xe.string(h) === "" && !C, ee = Yt((M) => {
    if (M && te) {
      var W;
      x((W = M.getBoundingClientRect()) === null || W === void 0 ? void 0 : W.height);
    } else
      x(void 0);
  }, [te]);
  if (te) {
    var D = F.start(h, []);
    X.push({
      [Ws]: !0,
      placeholder: s,
      onPlaceholderResize: ee,
      anchor: D,
      focus: D
    });
  }
  var {
    marks: j
  } = h;
  if (A.hasMarkPlaceholder = !1, h.selection && ae.isCollapsed(h.selection) && j) {
    var {
      anchor: G
    } = h.selection, S = xe.leaf(h, G.path), Y = Hs(S, Dre);
    if (!Ae.equals(S, j, {
      loose: !0
    })) {
      A.hasMarkPlaceholder = !0;
      var O = Object.fromEntries(Object.keys(Y).map((M) => [M, null]));
      X.push(lo(lo(lo({
        [aB]: !0
      }, O), j), {}, {
        anchor: G,
        focus: G
      }));
    }
  }
  return y(() => {
    setTimeout(() => {
      var {
        selection: M
      } = h;
      if (M) {
        var {
          anchor: W
        } = M, T = xe.leaf(h, W.path);
        if (j && !Ae.equals(T, j, {
          loose: !0
        })) {
          no.set(h, j);
          return;
        }
      }
      no.delete(h);
    });
  }), /* @__PURE__ */ Oe.createElement(bB.Provider, {
    value: a
  }, /* @__PURE__ */ Oe.createElement(_re.Provider, {
    value: C
  }, /* @__PURE__ */ Oe.createElement(vB.Provider, {
    value: o
  }, /* @__PURE__ */ Oe.createElement(kre, {
    node: P,
    receivedUserInput: k
  }, /* @__PURE__ */ Oe.createElement(g, lo(lo({
    role: a ? void 0 : "textbox",
    "aria-multiline": a ? void 0 : !0
  }, m), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: Yo || !Tc ? m.spellCheck : !1,
    autoCorrect: Yo || !Tc ? m.autoCorrect : "false",
    autoCapitalize: Yo || !Tc ? m.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !a,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: K,
    style: lo(lo({}, f ? {} : lo({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, v ? {
      minHeight: v
    } : {})), p),
    onBeforeInput: Yt((M) => {
      if (!Yo && !a && !hr(M, m.onBeforeInput) && de.hasSelectableTarget(h, M.target) && (M.preventDefault(), !de.isComposing(h))) {
        var W = M.data;
        F.insertText(h, W);
      }
    }, [m.onBeforeInput, h, a]),
    onInput: Yt((M) => {
      if (!hr(M, m.onInput)) {
        if (U.current) {
          U.current.handleInput();
          return;
        }
        for (var W of E.current)
          W();
        if (E.current = [], !de.isFocused(h)) {
          var T = M.nativeEvent, q = h;
          if (T.inputType === "historyUndo" && typeof q.undo == "function") {
            q.undo();
            return;
          }
          if (T.inputType === "historyRedo" && typeof q.redo == "function") {
            q.redo();
            return;
          }
        }
      }
    }, [m.onInput, h]),
    onBlur: Yt((M) => {
      if (!(a || A.isUpdatingSelection || !de.hasSelectableTarget(h, M.target) || hr(M, m.onBlur))) {
        var W = de.findDocumentOrShadowRoot(h);
        if (A.latestElement !== W.activeElement) {
          var {
            relatedTarget: T
          } = M, q = de.toDOMNode(h, h);
          if (T !== q && !(Jr(T) && T.hasAttribute("data-slate-spacer"))) {
            if (T != null && gi(T) && de.hasDOMNode(h, T)) {
              var I = de.toSlateNode(h, T);
              if (je.isElement(I) && !h.isVoid(I))
                return;
            }
            if (Xi) {
              var J = Ka(W);
              J == null || J.removeAllRanges();
            }
            fi.delete(h);
          }
        }
      }
    }, [a, A.isUpdatingSelection, A.latestElement, h, m.onBlur]),
    onClick: Yt((M) => {
      if (de.hasTarget(h, M.target) && !hr(M, m.onClick) && gi(M.target)) {
        var W = de.toSlateNode(h, M.target), T = de.findPath(h, W);
        if (!F.hasPath(h, T) || xe.get(h, T) !== W)
          return;
        if (M.detail === bre && T.length >= 1) {
          var q = T;
          if (!(je.isElement(W) && F.isBlock(h, W))) {
            var I, J = F.above(h, {
              match: (Ne) => je.isElement(Ne) && F.isBlock(h, Ne),
              at: T
            });
            q = (I = J == null ? void 0 : J[1]) !== null && I !== void 0 ? I : T.slice(0, 1);
          }
          var H = F.range(h, q);
          ve.select(h, H);
          return;
        }
        if (a)
          return;
        var ce = F.start(h, T), ye = F.end(h, T), ie = F.void(h, {
          at: ce
        }), Te = F.void(h, {
          at: ye
        });
        if (ie && Te && ne.equals(ie[1], Te[1])) {
          var Re = F.range(h, ce);
          ve.select(h, Re);
        }
      }
    }, [h, m.onClick, a]),
    onCompositionEnd: Yt((M) => {
      if (de.hasSelectableTarget(h, M.target)) {
        var W;
        if (de.isComposing(h) && Promise.resolve().then(() => {
          w(!1), ss.set(h, !1);
        }), (W = U.current) === null || W === void 0 || W.handleCompositionEnd(M), hr(M, m.onCompositionEnd) || mr)
          return;
        if (!Xi && !wne && !rB && !Ene && !Cne && M.data) {
          var T = no.get(h);
          no.delete(h), T !== void 0 && (jo.set(h, h.marks), h.marks = T), F.insertText(h, M.data);
          var q = jo.get(h);
          jo.delete(h), q !== void 0 && (h.marks = q);
        }
      }
    }, [m.onCompositionEnd, h]),
    onCompositionUpdate: Yt((M) => {
      de.hasSelectableTarget(h, M.target) && !hr(M, m.onCompositionUpdate) && (de.isComposing(h) || (w(!0), ss.set(h, !0)));
    }, [m.onCompositionUpdate, h]),
    onCompositionStart: Yt((M) => {
      if (de.hasSelectableTarget(h, M.target)) {
        var W;
        if ((W = U.current) === null || W === void 0 || W.handleCompositionStart(M), hr(M, m.onCompositionStart) || mr)
          return;
        w(!0);
        var {
          selection: T
        } = h;
        if (T && ae.isExpanded(T)) {
          F.deleteFragment(h);
          return;
        }
      }
    }, [m.onCompositionStart, h]),
    onCopy: Yt((M) => {
      de.hasSelectableTarget(h, M.target) && !hr(M, m.onCopy) && !OL(M) && (M.preventDefault(), de.setFragmentData(h, M.clipboardData, "copy"));
    }, [m.onCopy, h]),
    onCut: Yt((M) => {
      if (!a && de.hasSelectableTarget(h, M.target) && !hr(M, m.onCut) && !OL(M)) {
        M.preventDefault(), de.setFragmentData(h, M.clipboardData, "cut");
        var {
          selection: W
        } = h;
        if (W)
          if (ae.isExpanded(W))
            F.deleteFragment(h);
          else {
            var T = xe.parent(h, W.anchor.path);
            F.isVoid(h, T) && ve.delete(h);
          }
      }
    }, [a, h, m.onCut]),
    onDragOver: Yt((M) => {
      if (de.hasTarget(h, M.target) && !hr(M, m.onDragOver)) {
        var W = de.toSlateNode(h, M.target);
        je.isElement(W) && F.isVoid(h, W) && M.preventDefault();
      }
    }, [m.onDragOver, h]),
    onDragStart: Yt((M) => {
      if (!a && de.hasTarget(h, M.target) && !hr(M, m.onDragStart)) {
        var W = de.toSlateNode(h, M.target), T = de.findPath(h, W), q = je.isElement(W) && F.isVoid(h, W) || F.void(h, {
          at: T,
          voids: !0
        });
        if (q) {
          var I = F.range(h, T);
          ve.select(h, I);
        }
        A.isDraggingInternally = !0, de.setFragmentData(h, M.dataTransfer, "drag");
      }
    }, [a, h, m.onDragStart, A]),
    onDrop: Yt((M) => {
      if (!a && de.hasTarget(h, M.target) && !hr(M, m.onDrop)) {
        M.preventDefault();
        var W = h.selection, T = de.findEventRange(h, M), q = M.dataTransfer;
        ve.select(h, T), A.isDraggingInternally && W && !ae.equals(W, T) && !F.void(h, {
          at: T,
          voids: !0
        }) && ve.delete(h, {
          at: W
        }), de.insertData(h, q), de.isFocused(h) || de.focus(h);
      }
    }, [a, h, m.onDrop, A]),
    onDragEnd: Yt((M) => {
      !a && A.isDraggingInternally && m.onDragEnd && de.hasTarget(h, M.target) && m.onDragEnd(M);
    }, [a, A, m, h]),
    onFocus: Yt((M) => {
      if (!a && !A.isUpdatingSelection && de.hasEditableTarget(h, M.target) && !hr(M, m.onFocus)) {
        var W = de.toDOMNode(h, h), T = de.findDocumentOrShadowRoot(h);
        if (A.latestElement = T.activeElement, Ts && M.target !== W) {
          W.focus();
          return;
        }
        fi.set(h, !0);
      }
    }, [a, A, h, m.onFocus]),
    onKeyDown: Yt((M) => {
      if (!a && de.hasEditableTarget(h, M.target)) {
        var W;
        (W = U.current) === null || W === void 0 || W.handleKeyDown(M);
        var {
          nativeEvent: T
        } = M;
        if (de.isComposing(h) && T.isComposing === !1 && (ss.set(h, !1), w(!1)), hr(M, m.onKeyDown) || de.isComposing(h))
          return;
        var {
          selection: q
        } = h, I = h.children[q !== null ? q.focus.path[0] : 0], J = VA(xe.string(I)) === "rtl";
        if (Mn.isRedo(T)) {
          M.preventDefault();
          var H = h;
          typeof H.redo == "function" && H.redo();
          return;
        }
        if (Mn.isUndo(T)) {
          M.preventDefault();
          var ce = h;
          typeof ce.undo == "function" && ce.undo();
          return;
        }
        if (Mn.isMoveLineBackward(T)) {
          M.preventDefault(), ve.move(h, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (Mn.isMoveLineForward(T)) {
          M.preventDefault(), ve.move(h, {
            unit: "line"
          });
          return;
        }
        if (Mn.isExtendLineBackward(T)) {
          M.preventDefault(), ve.move(h, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (Mn.isExtendLineForward(T)) {
          M.preventDefault(), ve.move(h, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (Mn.isMoveBackward(T)) {
          M.preventDefault(), q && ae.isCollapsed(q) ? ve.move(h, {
            reverse: !J
          }) : ve.collapse(h, {
            edge: J ? "end" : "start"
          });
          return;
        }
        if (Mn.isMoveForward(T)) {
          M.preventDefault(), q && ae.isCollapsed(q) ? ve.move(h, {
            reverse: J
          }) : ve.collapse(h, {
            edge: J ? "start" : "end"
          });
          return;
        }
        if (Mn.isMoveWordBackward(T)) {
          M.preventDefault(), q && ae.isExpanded(q) && ve.collapse(h, {
            edge: "focus"
          }), ve.move(h, {
            unit: "word",
            reverse: !J
          });
          return;
        }
        if (Mn.isMoveWordForward(T)) {
          M.preventDefault(), q && ae.isExpanded(q) && ve.collapse(h, {
            edge: "focus"
          }), ve.move(h, {
            unit: "word",
            reverse: J
          });
          return;
        }
        if (Yo) {
          if ((oB || Xi) && q && (Mn.isDeleteBackward(T) || Mn.isDeleteForward(T)) && ae.isCollapsed(q)) {
            var ye = xe.parent(h, q.anchor.path);
            if (je.isElement(ye) && F.isVoid(h, ye) && (F.isInline(h, ye) || F.isBlock(h, ye))) {
              M.preventDefault(), F.deleteBackward(h, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (Mn.isBold(T) || Mn.isItalic(T) || Mn.isTransposeCharacter(T)) {
            M.preventDefault();
            return;
          }
          if (Mn.isSoftBreak(T)) {
            M.preventDefault(), F.insertSoftBreak(h);
            return;
          }
          if (Mn.isSplitBlock(T)) {
            M.preventDefault(), F.insertBreak(h);
            return;
          }
          if (Mn.isDeleteBackward(T)) {
            M.preventDefault(), q && ae.isExpanded(q) ? F.deleteFragment(h, {
              direction: "backward"
            }) : F.deleteBackward(h);
            return;
          }
          if (Mn.isDeleteForward(T)) {
            M.preventDefault(), q && ae.isExpanded(q) ? F.deleteFragment(h, {
              direction: "forward"
            }) : F.deleteForward(h);
            return;
          }
          if (Mn.isDeleteLineBackward(T)) {
            M.preventDefault(), q && ae.isExpanded(q) ? F.deleteFragment(h, {
              direction: "backward"
            }) : F.deleteBackward(h, {
              unit: "line"
            });
            return;
          }
          if (Mn.isDeleteLineForward(T)) {
            M.preventDefault(), q && ae.isExpanded(q) ? F.deleteFragment(h, {
              direction: "forward"
            }) : F.deleteForward(h, {
              unit: "line"
            });
            return;
          }
          if (Mn.isDeleteWordBackward(T)) {
            M.preventDefault(), q && ae.isExpanded(q) ? F.deleteFragment(h, {
              direction: "backward"
            }) : F.deleteBackward(h, {
              unit: "word"
            });
            return;
          }
          if (Mn.isDeleteWordForward(T)) {
            M.preventDefault(), q && ae.isExpanded(q) ? F.deleteFragment(h, {
              direction: "forward"
            }) : F.deleteForward(h, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [a, h, m.onKeyDown]),
    onPaste: Yt((M) => {
      !a && de.hasEditableTarget(h, M.target) && !hr(M, m.onPaste) && (!Yo || kne(M.nativeEvent) || Xi) && (M.preventDefault(), de.insertData(h, M.clipboardData));
    }, [a, h, m.onPaste])
  }), /* @__PURE__ */ Oe.createElement(Pre, {
    decorations: X,
    node: h,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: h.selection
  }))))));
}), Mre = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ Oe.createElement("span", lo({}, t), n, mr && /* @__PURE__ */ Oe.createElement("br", null))
  );
}, Tre = () => [], jre = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && ae.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), Zte(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, hr = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, OL = (e) => gi(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), Are = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, Bre = /* @__PURE__ */ Ve(!1), Ire = /* @__PURE__ */ Ve({});
function Fre(e) {
  var t = Ye([]).current, n = Ye({
    editor: e
  }).current, r = Yt((i) => {
    n.editor = i, t.forEach((s) => s(i));
  }, [t, n]), o = qn(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var Rre = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], Nre = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: s
  } = e, a = Hs(e, Rre), [l, u] = Oe.useState(() => {
    if (!xe.isNodeList(s))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(er.stringify(s)));
    if (!F.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(er.stringify(t)));
    return t.children = s, Object.assign(t, a), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: d
  } = Fre(t), p = Yt((m) => {
    var h;
    switch (r && r(t.children), m == null || (h = m.operation) === null || h === void 0 ? void 0 : h.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    u((C) => ({
      v: C.v + 1,
      editor: t
    })), d(t);
  }, [t, d, r, o, i]);
  y(() => ($m.set(t, p), () => {
    $m.set(t, () => {
    });
  }), [t, p]);
  var [g, f] = _(de.isFocused(t));
  return y(() => {
    f(de.isFocused(t));
  }, [t]), Pl(() => {
    var m = () => f(de.isFocused(t));
    return nB >= 17 ? (document.addEventListener("focusin", m), document.addEventListener("focusout", m), () => {
      document.removeEventListener("focusin", m), document.removeEventListener("focusout", m);
    }) : (document.addEventListener("focus", m, !0), document.addEventListener("blur", m, !0), () => {
      document.removeEventListener("focus", m, !0), document.removeEventListener("blur", m, !0);
    });
  }, []), /* @__PURE__ */ Oe.createElement(Ire.Provider, {
    value: c
  }, /* @__PURE__ */ Oe.createElement(wB.Provider, {
    value: l
  }, /* @__PURE__ */ Oe.createElement(vb.Provider, {
    value: l.editor
  }, /* @__PURE__ */ Oe.createElement(Bre.Provider, {
    value: g
  }, n))));
}, kL = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, _L = (e, t, n) => {
  var r = de.toDOMRange(e, t).getBoundingClientRect(), o = de.toDOMRange(e, n).getBoundingClientRect();
  return kL(r, o) && kL(o, r);
}, zre = (e, t) => {
  var n = F.range(e, ae.end(t)), r = Array.from(F.positions(e, {
    at: t
  })), o = 0, i = r.length, s = Math.floor(i / 2);
  if (_L(e, F.range(e, r[o]), n))
    return F.range(e, r[o], n);
  if (r.length < 2)
    return F.range(e, r[r.length - 1], n);
  for (; s !== r.length && s !== o; )
    _L(e, F.range(e, r[s]), n) ? i = s : o = s, s = Math.floor((o + i) / 2);
  return F.range(e, r[i], n);
};
function LL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function DL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LL(Object(n), !0).forEach(function(r) {
      Qr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $re = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: s,
    addMark: a,
    removeMark: l
  } = r;
  return bf.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var d, p;
    (d = wb.get(r)) === null || d === void 0 || d(), !no.get(r) && (p = xr.get(r)) !== null && p !== void 0 && p.length && no.set(r, null), jo.delete(r), a(u, c);
  }, r.removeMark = (u) => {
    var c;
    !no.get(r) && (c = xr.get(r)) !== null && c !== void 0 && c.length && no.set(r, null), jo.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return s(u);
    if (r.selection && ae.isCollapsed(r.selection)) {
      var c = F.above(r, {
        match: (f) => je.isElement(f) && F.isBlock(r, f),
        at: r.selection
      });
      if (c) {
        var [, d] = c, p = F.range(r, d, r.selection.anchor), g = zre(r, p);
        ae.isCollapsed(g) || ve.delete(r, {
          at: g
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], d = [], p = xr.get(r);
    if (p != null && p.length) {
      var g = p.map((N) => zne(N, u)).filter(Boolean);
      xr.set(r, g);
    }
    var f = si.get(r);
    f && si.set(r, gL(r, f, u));
    var m = ii.get(r);
    if (m != null && m.at) {
      var h = ct.isPoint(m == null ? void 0 : m.at) ? Wm(r, m.at, u) : gL(r, m.at, u);
      ii.set(r, h ? DL(DL({}, m), {}, {
        at: h
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...Ps(r, u.path));
        break;
      }
      case "set_selection": {
        var C;
        (C = Ya.get(r)) === null || C === void 0 || C.unref(), Ya.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...Ps(r, ne.parent(u.path)));
        break;
      }
      case "merge_node": {
        var w = ne.previous(u.path);
        c.push(...Ps(r, w));
        break;
      }
      case "move_node": {
        var P = ne.common(ne.parent(u.path), ne.parent(u.newPath));
        c.push(...Ps(r, P));
        var E;
        ne.isBefore(u.path, u.newPath) ? (c.push(...Ps(r, ne.parent(u.path))), E = u.newPath) : (c.push(...Ps(r, ne.parent(u.newPath))), E = u.path);
        var v = xe.get(t, ne.parent(E)), x = de.findKey(r, v), L = F.pathRef(r, ne.parent(E));
        d.push([L, x]);
        break;
      }
    }
    switch (o(u), u.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "move_node":
      case "split_node":
        Fs.set(r, !0);
    }
    for (var [z, k] of c) {
      var [R] = F.node(r, z);
      Rd.set(R, k);
    }
    for (var [A, U] of d) {
      if (A.current) {
        var [V] = F.node(r, A.current);
        Rd.set(V, U);
      }
      A.unref();
    }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [d, p] = ae.edges(c), g = F.void(r, {
        at: d.path
      }), f = F.void(r, {
        at: p.path
      });
      if (!(ae.isCollapsed(c) && !g)) {
        var m = de.toDOMRange(r, c), h = m.cloneContents(), C = h.childNodes[0];
        if (h.childNodes.forEach((R) => {
          R.textContent && R.textContent.trim() !== "" && (C = R);
        }), f) {
          var [w] = f, P = m.cloneRange(), E = de.toDOMNode(r, w);
          P.setEndAfter(E), h = P.cloneContents();
        }
        if (g && (C = h.querySelector("[data-slate-spacer]")), Array.from(h.querySelectorAll("[data-slate-zero-width]")).forEach((R) => {
          var A = R.getAttribute("data-slate-zero-width") === "n";
          R.textContent = A ? `
` : "";
        }), uB(C)) {
          var v = C.ownerDocument.createElement("span");
          v.style.whiteSpace = "pre", v.appendChild(C), h.appendChild(v), C = v;
        }
        var x = r.getFragment(), L = JSON.stringify(x), z = window.btoa(encodeURIComponent(L));
        C.setAttribute("data-slate-fragment", z), u.setData("application/".concat(n), z);
        var k = h.ownerDocument.createElement("div");
        return k.appendChild(h), k.setAttribute("hidden", "true"), h.ownerDocument.body.appendChild(k), u.setData("text/html", k.innerHTML), u.setData("text/plain", dB(k)), h.ownerDocument.body.removeChild(k), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || Sne(u);
    if (c) {
      var d = decodeURIComponent(window.atob(c)), p = JSON.parse(d);
      return r.insertFragment(p), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var d = c.split(/\r\n|\r|\n/), p = !1;
      for (var g of d)
        p && ve.splitNodes(r, {
          always: !0
        }), r.insertText(g), p = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = nB < 18 ? Tl.unstable_batchedUpdates : (d) => d();
    c(() => {
      var d = $m.get(r);
      d && d(u), i(u);
    });
  }, r;
}, Ps = (e, t) => {
  var n = [];
  for (var [r, o] of F.levels(e, {
    at: t
  })) {
    var i = de.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function EB(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    F.nodes(e, {
      at: F.unhangRange(e, r),
      match: (i) => !F.isEditor(i) && je.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const PL = ["listItem", "numberedList"], Ac = ["left", "center", "right", "justify"];
function Ure(e, t) {
  const n = Ac.includes(t) ? "align" : "type", r = EB(e, t, n), o = PL.includes(t);
  ve.unwrapNodes(e, {
    match: (s) => !F.isEditor(s) && je.isElement(s) && PL.includes(s.type) && !Ac.includes(t),
    split: !0
  });
  let i;
  if (Ac.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, ve.setNodes(e, i), !r && o) {
    const s = { type: t, children: [] };
    ve.wrapNodes(e, s);
  }
}
function Wi({ format: e, icon: t }) {
  const n = wf(), r = Ac.includes(e) ? "align" : "type", i = EB(n, e, r) ? "activeTrue" : "activeFalse";
  function s(a) {
    a.preventDefault(), Ure(n, e);
  }
  return /* @__PURE__ */ B.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: s,
      children: /* @__PURE__ */ B.jsx(t, {})
    }
  );
}
function Hre({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ B.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ B.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ B.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ B.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ B.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ B.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    case "image":
      return /* @__PURE__ */ B.jsxs("div", { style: r, ...e, children: [
        /* @__PURE__ */ B.jsx(
          "img",
          {
            className: "arkynElementImage",
            alt: "arkynElementImage",
            src: (n == null ? void 0 : n.src) || ""
          }
        ),
        t
      ] });
    default:
      return /* @__PURE__ */ B.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
const xB = Ve({});
function Wre(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, a = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ B.jsx(xB.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ B.jsx(BP, { children: t && /* @__PURE__ */ B.jsxs("aside", { className: a.trim(), ...i, children: [
    /* @__PURE__ */ B.jsx(
      Qa.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ B.jsx(
      Qa.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function Vre(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ B.jsx("footer", { className: o.trim(), ...r });
}
function Zre(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = _e(xB), s = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ B.jsxs("header", { className: s.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ B.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ B.jsx(rv, { size: 24 })
      }
    )
  ] });
}
const Zm = Ve({});
function qre() {
  if (!Zm)
    throw new Error("useTabContext must be used within a TabProvider");
  return _e(Zm);
}
function Gre(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [s, a] = _(r || ""), [l, u] = _(!0), c = Ye(null), d = `arkynTabContainer ${o || ""}`, [p, g] = _({
    width: "0px",
    left: "0px",
    transition: "none"
  }), f = (h, C) => {
    const w = h.getBoundingClientRect(), P = c.current.getBoundingClientRect(), E = C ? void 0 : "none";
    u(!1), g({
      transition: E,
      width: `${w.width}px`,
      left: `${w.left - P.left}px`
    });
  };
  y(() => {
    const h = c.current;
    if (!h) return;
    let C = null;
    C = h.querySelector("button.activeTrue"), C && f(C);
  }, []);
  const m = (h) => {
    const C = h.target;
    C && (a(C.value), C.classList.add("activeTrue"), f(C, !0), n && n(C.value));
  };
  return /* @__PURE__ */ B.jsxs("nav", { ref: c, className: d.trim(), ...i, children: [
    /* @__PURE__ */ B.jsx(Zm.Provider, { value: { handleTabClick: m, showInitialTab: l, value: s }, children: t }),
    /* @__PURE__ */ B.jsx("div", { className: "activeLine", style: p })
  ] });
}
function SL(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: s, handleTabClick: a } = qre(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && s ? "showBorderBottom" : ""} ${l} ${n}`;
  function d(p) {
    a(p), r && r(p);
  }
  return /* @__PURE__ */ B.jsx(
    "button",
    {
      onClick: d,
      className: c.trim(),
      ...o,
      type: "button",
      children: t
    }
  );
}
function Yre(e) {
  const {
    action: t,
    tabLabels: n = ["Adicionar URL", "Upload de arquivo"],
    modalCancelButton: r = "Cancelar",
    modalConfirmButton: o = "Confirmar",
    modalInputImageLabel: i = "Imagem:",
    modalInputUrlLabel: s = "URL da imagem:",
    modalTitle: a = "Inserir imagem"
  } = e, l = wf(), [u, c] = _(!1), [d, p] = _(""), [g, f] = _("url");
  function m(h) {
    h.preventDefault(), !(!d || d === "") && (l.insertNodes([
      { type: "paragraph", children: [{ text: "" }] },
      { type: "image", src: d, children: [{ text: "" }] },
      { type: "paragraph", children: [{ text: "" }] }
    ]), c(!1));
  }
  return /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
    /* @__PURE__ */ B.jsx(
      "button",
      {
        type: "button",
        className: "arkynRichTextInsertImage",
        onMouseDown: () => c(!0),
        children: /* @__PURE__ */ B.jsx(AI, {})
      }
    ),
    /* @__PURE__ */ B.jsxs(
      Wre,
      {
        isVisibled: u,
        makeInvisible: () => c(!1),
        children: [
          /* @__PURE__ */ B.jsx(Zre, { children: a }),
          /* @__PURE__ */ B.jsxs("div", { className: "arkynRichTextInsertImageModalContent", children: [
            /* @__PURE__ */ B.jsxs(Gre, { defaultActive: g, onClick: f, children: [
              /* @__PURE__ */ B.jsx(SL, { value: "url", children: n[0] }),
              /* @__PURE__ */ B.jsx(SL, { value: "file", children: n[1] })
            ] }),
            g === "url" && /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
              /* @__PURE__ */ B.jsxs(H_, { children: [
                /* @__PURE__ */ B.jsx(W_, { children: s }),
                /* @__PURE__ */ B.jsx(
                  vf,
                  {
                    type: "text",
                    name: "richTextimageURL",
                    defaultValue: d,
                    onChange: (h) => p(h.target.value)
                  }
                )
              ] }),
              d && /* @__PURE__ */ B.jsx(
                "img",
                {
                  className: "arkynRichTextInsertImageModalPreviewImage",
                  src: d,
                  alt: "preview"
                }
              )
            ] }),
            g === "file" && /* @__PURE__ */ B.jsxs(H_, { children: [
              /* @__PURE__ */ B.jsx(W_, { children: i }),
              /* @__PURE__ */ B.jsx(
                KQ,
                {
                  name: "richTextimageURL",
                  action: t,
                  defaultValue: d,
                  onUpload: (h) => p(h || "")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ B.jsxs(Vre, { children: [
            /* @__PURE__ */ B.jsx(
              kl,
              {
                type: "button",
                scheme: "danger",
                variant: "outline",
                onClick: () => c(!1),
                children: r
              }
            ),
            /* @__PURE__ */ B.jsx(kl, { type: "button", onClick: m, children: o })
          ] })
        ]
      }
    )
  ] });
}
function Kre({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ B.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ B.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ B.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ B.jsx("u", { children: t })), /* @__PURE__ */ B.jsx("span", { ...e, children: t });
}
function OB(e, t) {
  const n = F.marks(e);
  return n ? n[t] === !0 : !1;
}
function kB(e, t) {
  OB(e, t) ? F.removeMark(e, t) : F.addMark(e, t, !0);
}
function mc({ format: e, icon: t }) {
  const n = wf(), o = OB(n, e) ? "activeTrue" : "activeFalse";
  function i(s) {
    s.preventDefault(), kB(n, e);
  }
  return /* @__PURE__ */ B.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ B.jsx(t, {})
    }
  );
}
function Xre({ children: e }) {
  return /* @__PURE__ */ B.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
function ML(e) {
  return e.map((t) => xe.string(t)).join("");
}
const TL = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, vc = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
function bue(e) {
  const {
    name: t,
    hiddenButtons: n,
    imageConfig: r,
    defaultValue: o = "[]",
    enforceCharacterLimit: i = !1,
    onChangeCharactersCount: s,
    maxLimit: a = 2e3,
    onChange: l,
    isError: u
  } = e, c = qn(() => Tee($re(SN())), []), { id: d, inputRef: p, error: g } = Er(), f = Ye(null);
  function m() {
    try {
      const X = JSON.parse(o);
      return !Array.isArray(X) || X.length <= 0 ? vc : X.every(
        (ee) => typeof ee == "object" && ee !== null && "type" in ee && "children" in ee
      ) ? X : vc;
    } catch {
      return vc;
    }
  }
  const h = ML(m()), [C, w] = _(h.length), [P, E] = _(
    JSON.stringify(m()) || "[]"
  ), [v, x] = _(!1), L = p || f, z = u || !!g, k = Yt(Kre, []), R = Yt(Hre, []);
  function A(X) {
    const te = ML(X);
    w(te.length), s && s(te.length), !(i && te.length >= a) && (E(JSON.stringify(X)), l && l(X), c.children = X, ve.setNodes(c, { children: X }));
  }
  const U = v ? "focusTrue" : "focusFalse", N = `arkynRichText ${z || a < C ? "errorTrue" : "errorFalse"} ${U}`, Z = a - C;
  function K(X) {
    return !(n != null && n.includes(X));
  }
  return /* @__PURE__ */ B.jsxs(
    Nre,
    {
      editor: c,
      initialValue: m(),
      onChange: A,
      onValueChange: A,
      children: [
        /* @__PURE__ */ B.jsxs("div", { className: N, children: [
          /* @__PURE__ */ B.jsxs(Xre, { children: [
            K("headingOne") && /* @__PURE__ */ B.jsx(Wi, { format: "headingOne", icon: BI }),
            K("headingTwo") && /* @__PURE__ */ B.jsx(Wi, { format: "headingTwo", icon: II }),
            K("blockQuote") && /* @__PURE__ */ B.jsx(Wi, { format: "blockQuote", icon: FI }),
            K("bold") && /* @__PURE__ */ B.jsx(mc, { format: "bold", icon: RI }),
            K("italic") && /* @__PURE__ */ B.jsx(mc, { format: "italic", icon: NI }),
            K("underline") && /* @__PURE__ */ B.jsx(mc, { format: "underline", icon: zI }),
            K("code") && /* @__PURE__ */ B.jsx(mc, { format: "code", icon: $I }),
            K("left") && /* @__PURE__ */ B.jsx(Wi, { format: "left", icon: UI }),
            K("right") && /* @__PURE__ */ B.jsx(Wi, { format: "right", icon: HI }),
            K("center") && /* @__PURE__ */ B.jsx(Wi, { format: "center", icon: WI }),
            K("justify") && /* @__PURE__ */ B.jsx(Wi, { format: "justify", icon: VI }),
            r && K("image") && /* @__PURE__ */ B.jsx(Yre, { ...r })
          ] }),
          /* @__PURE__ */ B.jsx(
            Sre,
            {
              className: "editorContainer",
              renderElement: R,
              renderLeaf: k,
              spellCheck: !0,
              id: d,
              onFocus: () => x(!0),
              onBlur: () => x(!1),
              onKeyDown: (X) => {
                for (const te in TL)
                  if (See(te, X)) {
                    X.preventDefault();
                    const ee = TL[te];
                    kB(c, ee);
                  }
              }
            }
          ),
          Z < 0 && /* @__PURE__ */ B.jsx("div", { className: "restatesCharacters", children: Z })
        ] }),
        /* @__PURE__ */ B.jsx("input", { type: "hidden", ref: L, name: t, value: P }),
        /* @__PURE__ */ B.jsx("input", { type: "hidden", name: `${t}Count`, value: C })
      ]
    }
  );
}
function Jre(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: d,
    onBlur: p,
    title: g,
    style: f,
    closeOnSelect: m = !0,
    ...h
  } = e, v = `arkyn_select ${a ? "hasPrefix" : ""} ${s} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, L = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: v,
    prefix: gS(a, L, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: d,
    onBlur: p,
    title: g,
    closeOnSelect: m,
    style: f,
    iconSize: L,
    Spinner: /* @__PURE__ */ B.jsx(vo, { className: "spinner", size: L, strokeWidth: 2.5 }),
    ...h
  };
}
function wue(e) {
  var W;
  const [t, n] = _(""), [r, o] = _(!1), { inputRef: i, id: s, error: a } = Er(), l = Ye(null), u = i || l, c = e.isError || !!a, {
    disabled: d,
    title: p,
    style: g,
    className: f,
    prefix: m,
    iconSize: h,
    isLoading: C,
    LeftIcon: w,
    value: P = null,
    defaultValue: E = "",
    onFocus: v,
    onBlur: x,
    Spinner: L,
    name: z,
    placeholder: k,
    onSelect: R,
    options: A,
    optionMaxHeight: U,
    closeOnSelect: V,
    isSearchable: N,
    onSearch: Z,
    ...K
  } = Jre({ ...e, id: s, isError: c }, r), [X, te] = _(E);
  function ee() {
    d || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function D(T) {
    Z && (n(""), Z(T.target.value)), Z || n(T.target.value);
  }
  function j(T) {
    r || (o(!0), v && v(T));
  }
  function G() {
    o(!1), x && u.current && u.current.blur();
  }
  function S(T) {
    const { label: q, value: I } = T;
    te(X !== I ? I : ""), R && R({ label: q, value: I }), V && G();
  }
  const Y = typeof P == "string" ? P : X, O = ((W = A.find((T) => T.value === Y)) == null ? void 0 : W.label) || "", M = () => {
    if (!r && O) return !0;
    if (!r && !O) return !1;
    if (r && O) return !0;
    if (r && !O) return !1;
  };
  return /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
    /* @__PURE__ */ B.jsxs(
      "section",
      {
        title: p,
        style: g,
        onClick: ee,
        className: `${f} placeholder_dark_${M()}`,
        children: [
          m,
          w && /* @__PURE__ */ B.jsx(w, { size: h, strokeWidth: 2.5 }),
          /* @__PURE__ */ B.jsx(
            "input",
            {
              disabled: d,
              readOnly: !0,
              placeholder: O || k,
              onFocus: j,
              ...K
            }
          ),
          /* @__PURE__ */ B.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: z,
              value: Y || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ B.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: U },
              children: [
                N && /* @__PURE__ */ B.jsx(
                  vf,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: TP,
                    onChange: D
                  }
                ),
                A.filter((T) => !!(e.onSearch || !e.isSearchable || T.label.toLowerCase().includes(t.toLowerCase()))).map(({ label: T, value: q }) => /* @__PURE__ */ B.jsxs(
                  "div",
                  {
                    onClick: () => S({ label: T, value: q }),
                    className: Y === q ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      T,
                      " ",
                      /* @__PURE__ */ B.jsx(Xd, {})
                    ]
                  },
                  q
                )),
                A.length <= 0 && /* @__PURE__ */ B.jsx("p", { children: "Sem opções disponíveis" })
              ]
            }
          ),
          !C && /* @__PURE__ */ B.jsx(
            nv,
            {
              className: "arkyn_select_arrow",
              size: h,
              strokeWidth: 2.5
            }
          ),
          C && L
        ]
      }
    ),
    r && /* @__PURE__ */ B.jsx("aside", { className: "arkyn_select_overlay", onClick: G })
  ] });
}
function Cue(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: s,
    className: a = "",
    onCheck: l,
    ...u
  } = e, [c, d] = _(n), { id: p, inputRef: g } = Er(), f = typeof r == "boolean" ? r : c;
  function m() {
    d(!c), l && l(f ? i : o || "checked");
  }
  const C = `arkynSwitch ${f ? "checkedTrue" : "checkedFalse"} ${t} ${a}`;
  return /* @__PURE__ */ B.jsx("button", { type: "button", onClick: m, className: C, ...u, children: /* @__PURE__ */ B.jsx(
    "input",
    {
      id: p,
      type: "hidden",
      name: s,
      ref: g,
      onClick: m,
      value: f ? o || "checked" : i
    }
  ) });
}
function Eue(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: s,
    onBlur: a,
    title: l,
    style: u,
    ...c
  } = e, [d, p] = _(!1), { inputRef: g, id: f, error: m } = Er(), h = Ye(null), C = g || h, P = e.isError || !!m ? "errorTrue" : "errorFalse", x = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${P} ${d ? "focusedTrue" : "focusedFalse"} ${r}`;
  function L() {
    o || !(C != null && C.current) || (p(!0), C.current.focus());
  }
  function z(R) {
    p(!0), s && s(R);
  }
  function k(R) {
    p(!1), a && a(R);
  }
  return /* @__PURE__ */ B.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: L,
      className: x,
      children: /* @__PURE__ */ B.jsx(
        "textarea",
        {
          id: f,
          disabled: o,
          readOnly: i,
          ref: C,
          onFocus: z,
          onBlur: k,
          ...c
        }
      )
    }
  );
}
function xue(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ B.jsx("nav", { className: r, ...n });
}
function Oue(e) {
  const { pathname: t } = sv(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...s
  } = e, l = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ B.jsxs("p", { className: l, children: [
    /* @__PURE__ */ B.jsx(kg, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ B.jsxs(GI, { to: i, className: l, ...s, children: [
    /* @__PURE__ */ B.jsx(kg, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function _B(e = "") {
  const t = sv(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([s, a]) => {
      a === void 0 ? n.delete(`${r}${s}`) : n.set(`${r}${s}`, String(a));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let s = n.toString();
      return s && (s = "?" + s), s;
    }
  };
}
function jL(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function kue(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    currentPage: s = 1,
    registerPerPage: a = 20,
    ...l
  } = e, u = AP(), { getParam: c, getScopedSearch: d } = _B(t), p = Number(c("page")) || s, g = Number(c("per_page")) || a, f = Math.ceil(n / g), m = p > 1 ? jL(p - 1 - i, p - 1) : [], h = p < f ? jL(
    p,
    Math.min(p + i, f)
  ) : [];
  function C(w) {
    u(d({ page: w }));
  }
  return /* @__PURE__ */ B.jsxs("div", { className: "arkynPagination", ...l, children: [
    /* @__PURE__ */ B.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: p <= 1,
        onClick: () => C(p - 1),
        children: /* @__PURE__ */ B.jsx(ZI, {})
      }
    ),
    p > 1 + i && /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
      /* @__PURE__ */ B.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => C(1),
          children: "1"
        }
      ),
      p > 2 + i && /* @__PURE__ */ B.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ B.jsx(Ib, {}) })
    ] }),
    m.length > 0 && m.map((w, P) => /* @__PURE__ */ B.jsx(
      "button",
      {
        onClick: () => C(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      P
    )),
    /* @__PURE__ */ B.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: p }),
    h.length > 0 && h.map((w, P) => /* @__PURE__ */ B.jsx(
      "button",
      {
        onClick: () => C(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      P
    )),
    p + i < f && /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
      p + 1 + i < f && /* @__PURE__ */ B.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ B.jsx(Ib, {}) }),
      /* @__PURE__ */ B.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => C(f),
          children: f
        }
      )
    ] }),
    /* @__PURE__ */ B.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: p >= f,
        onClick: () => C(p + 1),
        children: /* @__PURE__ */ B.jsx(kg, {})
      }
    )
  ] });
}
const LB = Ve({});
function _ue(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...s
  } = e, a = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ B.jsx(LB.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ B.jsx(BP, { children: t && /* @__PURE__ */ B.jsxs("aside", { className: u.trim(), ...s, children: [
    /* @__PURE__ */ B.jsx(
      Qa.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ B.jsx(
      Qa.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${a})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${a})` },
        children: o
      }
    )
  ] }) }) });
}
function Lue(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = _e(LB), s = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ B.jsxs("header", { className: s.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ B.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ B.jsx(rv, { size: 24 })
      }
    )
  ] });
}
function Due(e) {
  const {
    children: t,
    button: n,
    closeOnClick: r,
    className: o = "",
    orientation: i = "bottomLeft"
  } = e, [s, a] = _(!1), u = `arkynPopover ${i} ${s ? "visibleTrue" : "visibleFalse"} ${o}`;
  function c() {
    s || a(!0);
  }
  return /* @__PURE__ */ B.jsxs("div", { className: u, onClick: c, children: [
    n,
    /* @__PURE__ */ B.jsx(
      Qa.div,
      {
        style: { visibility: s ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: s ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && a(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    s && /* @__PURE__ */ B.jsx("div", { onClick: () => a(!1), className: "arkynPopoverOverlay" })
  ] });
}
function Pue(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ B.jsx(MP, {});
      case "danger":
        return /* @__PURE__ */ B.jsx(SP, {});
      default:
        return /* @__PURE__ */ B.jsx(PP, {});
    }
  }
  return /* @__PURE__ */ B.jsxs("div", { className: r, children: [
    /* @__PURE__ */ B.jsxs("div", { children: [
      /* @__PURE__ */ B.jsx("div", { className: "bg" }),
      /* @__PURE__ */ B.jsx(o, {})
    ] }),
    /* @__PURE__ */ B.jsx("p", { children: /* @__PURE__ */ B.jsx("span", { children: t }) })
  ] });
}
var Zn = {}, xb = {}, eu = {}, tu = {}, DB = "Expected a function", AL = NaN, Qre = "[object Symbol]", eoe = /^\s+|\s+$/g, toe = /^[-+]0x[0-9a-f]+$/i, noe = /^0b[01]+$/i, roe = /^0o[0-7]+$/i, ooe = parseInt, ioe = typeof rn == "object" && rn && rn.Object === Object && rn, soe = typeof self == "object" && self && self.Object === Object && self, aoe = ioe || soe || Function("return this")(), loe = Object.prototype, uoe = loe.toString, coe = Math.max, doe = Math.min, ug = function() {
  return aoe.Date.now();
};
function poe(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, d = !1, p = !0;
  if (typeof e != "function")
    throw new TypeError(DB);
  t = BL(t) || 0, Nd(n) && (c = !!n.leading, d = "maxWait" in n, i = d ? coe(BL(n.maxWait) || 0, t) : i, p = "trailing" in n ? !!n.trailing : p);
  function g(x) {
    var L = r, z = o;
    return r = o = void 0, u = x, s = e.apply(z, L), s;
  }
  function f(x) {
    return u = x, a = setTimeout(C, t), c ? g(x) : s;
  }
  function m(x) {
    var L = x - l, z = x - u, k = t - L;
    return d ? doe(k, i - z) : k;
  }
  function h(x) {
    var L = x - l, z = x - u;
    return l === void 0 || L >= t || L < 0 || d && z >= i;
  }
  function C() {
    var x = ug();
    if (h(x))
      return w(x);
    a = setTimeout(C, m(x));
  }
  function w(x) {
    return a = void 0, p && r ? g(x) : (r = o = void 0, s);
  }
  function P() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function E() {
    return a === void 0 ? s : w(ug());
  }
  function v() {
    var x = ug(), L = h(x);
    if (r = arguments, o = this, l = x, L) {
      if (a === void 0)
        return f(l);
      if (d)
        return a = setTimeout(C, t), g(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return v.cancel = P, v.flush = E, v;
}
function foe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(DB);
  return Nd(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), poe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Nd(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function hoe(e) {
  return !!e && typeof e == "object";
}
function goe(e) {
  return typeof e == "symbol" || hoe(e) && uoe.call(e) == Qre;
}
function BL(e) {
  if (typeof e == "number")
    return e;
  if (goe(e))
    return AL;
  if (Nd(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Nd(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(eoe, "");
  var n = noe.test(e);
  return n || roe.test(e) ? ooe(e.slice(2), n ? 2 : 8) : toe.test(e) ? AL : +e;
}
var moe = foe, nu = {};
Object.defineProperty(nu, "__esModule", {
  value: !0
});
nu.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), Bc.has(n) || Bc.set(n, /* @__PURE__ */ new Set());
  var i = Bc.get(n);
  if (!i.has(o)) {
    var s = function() {
      var a = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return a;
    }();
    t.addEventListener(n, r, s ? { passive: !0 } : !1), i.add(o);
  }
};
nu.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), Bc.get(n).delete(r.name || n);
};
var Bc = /* @__PURE__ */ new Map();
Object.defineProperty(tu, "__esModule", {
  value: !0
});
var voe = moe, yoe = boe(voe), IL = nu;
function boe(e) {
  return e && e.__esModule ? e : { default: e };
}
var woe = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, yoe.default)(t, n);
}, Bn = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = woe(function(o) {
        Bn.scrollHandler(t);
      }, n);
      return Bn.scrollSpyContainers.push(t), (0, IL.addPassiveEventListener)(t, "scroll", r), function() {
        (0, IL.removePassiveEventListener)(t, "scroll", r), Bn.scrollSpyContainers.splice(Bn.scrollSpyContainers.indexOf(t), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(t) {
    return Bn.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.scrollY !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.scrollX : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.scrollX !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.scrollY : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = Bn.scrollSpyContainers[Bn.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(Bn.currentPositionX(t), Bn.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    Bn.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = Bn.scrollSpyContainers[Bn.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t);
  },
  updateStates: function() {
    Bn.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    Bn.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), Bn.spySetState && Bn.spySetState.length && Bn.spySetState.indexOf(t) > -1 && Bn.spySetState.splice(Bn.spySetState.indexOf(t), 1), document.removeEventListener("scroll", Bn.scrollHandler);
  },
  update: function() {
    return Bn.scrollSpyContainers.forEach(function(t) {
      return Bn.scrollHandler(t);
    });
  }
};
tu.default = Bn;
var ta = {}, ru = {};
Object.defineProperty(ru, "__esModule", {
  value: !0
});
var Coe = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, s = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", s) : history.replaceState(history.state, "", s);
}, Eoe = function() {
  return window.location.hash.replace(/^#/, "");
}, xoe = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, Ooe = function(t) {
  return getComputedStyle(t).position !== "static";
}, cg = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, koe = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Ooe(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = cg(n, o), s = i.offsetTop, a = i.offsetParent;
      if (a !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return s;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return cg(n, l).offsetTop - cg(t, l).offsetTop;
};
ru.default = {
  updateHash: Coe,
  getHash: Eoe,
  filterElementInContainer: xoe,
  scrollOffset: koe
};
var Cf = {}, Ob = {};
Object.defineProperty(Ob, "__esModule", {
  value: !0
});
Ob.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var kb = {};
Object.defineProperty(kb, "__esModule", {
  value: !0
});
var _oe = nu, Loe = ["mousedown", "wheel", "touchmove", "keydown"];
kb.default = {
  subscribe: function(t) {
    return typeof document < "u" && Loe.forEach(function(n) {
      return (0, _oe.addPassiveEventListener)(document, n, t);
    });
  }
};
var ou = {};
Object.defineProperty(ou, "__esModule", {
  value: !0
});
var qm = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      qm.registered[t] = n;
    },
    remove: function(t) {
      qm.registered[t] = null;
    }
  }
};
ou.default = qm;
Object.defineProperty(Cf, "__esModule", {
  value: !0
});
var Doe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Poe = ru;
Ef(Poe);
var Soe = Ob, FL = Ef(Soe), Moe = kb, Toe = Ef(Moe), joe = ou, fo = Ef(joe);
function Ef(e) {
  return e && e.__esModule ? e : { default: e };
}
var PB = function(t) {
  return FL.default[t.smooth] || FL.default.defaultEasing;
}, Aoe = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, Boe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Gm = function() {
  return Boe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), SB = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, MB = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, TB = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, Ioe = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, Foe = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, Roe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    fo.default.registered.end && fo.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Gm.call(window, i);
    return;
  }
  fo.default.registered.end && fo.default.registered.end(o.to, o.target, o.currentPosition);
}, _b = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, iu = function(t, n, r, o) {
  n.data = n.data || SB(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (Toe.default.subscribe(i), _b(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? MB(n) : TB(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    fo.default.registered.end && fo.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = Aoe(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var s = PB(n), a = Roe.bind(null, s, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      fo.default.registered.begin && fo.default.registered.begin(n.data.to, n.data.target), Gm.call(window, a);
    }, n.delay);
    return;
  }
  fo.default.registered.begin && fo.default.registered.begin(n.data.to, n.data.target), Gm.call(window, a);
}, xf = function(t) {
  return t = Doe({}, t), t.data = t.data || SB(), t.absolute = !0, t;
}, Noe = function(t) {
  iu(0, xf(t));
}, zoe = function(t, n) {
  iu(t, xf(n));
}, $oe = function(t) {
  t = xf(t), _b(t), iu(t.horizontal ? Ioe(t) : Foe(t), t);
}, Uoe = function(t, n) {
  n = xf(n), _b(n);
  var r = n.horizontal ? MB(n) : TB(n);
  iu(t + r, n);
};
Cf.default = {
  animateTopScroll: iu,
  getAnimationType: PB,
  scrollToTop: Noe,
  scrollToBottom: $oe,
  scrollTo: zoe,
  scrollMore: Uoe
};
Object.defineProperty(ta, "__esModule", {
  value: !0
});
var Hoe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Woe = ru, Voe = Lb(Woe), Zoe = Cf, qoe = Lb(Zoe), Goe = ou, yc = Lb(Goe);
function Lb(e) {
  return e && e.__esModule ? e : { default: e };
}
var bc = {}, RL = void 0;
ta.default = {
  unmount: function() {
    bc = {};
  },
  register: function(t, n) {
    bc[t] = n;
  },
  unregister: function(t) {
    delete bc[t];
  },
  get: function(t) {
    return bc[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return RL = t;
  },
  getActiveLink: function() {
    return RL;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = Hoe({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, s = void 0;
    o ? s = document.getElementById(o) : i && i.nodeType ? s = i : s = document, n.absolute = !0;
    var a = n.horizontal, l = Voe.default.scrollOffset(s, r, a) + (n.offset || 0);
    if (!n.smooth) {
      yc.default.registered.begin && yc.default.registered.begin(t, r), s === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : s.scrollTop = l, yc.default.registered.end && yc.default.registered.end(t, r);
      return;
    }
    qoe.default.animateTopScroll(l, n, t, r);
  }
};
var Ym = { exports: {} }, wc = { exports: {} }, qt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var NL;
function Yoe() {
  if (NL) return qt;
  NL = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function P(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case d:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case a:
                case c:
                case f:
                case g:
                case s:
                  return v;
                default:
                  return x;
              }
          }
        case n:
          return x;
      }
    }
  }
  function E(v) {
    return P(v) === u;
  }
  return qt.AsyncMode = l, qt.ConcurrentMode = u, qt.ContextConsumer = a, qt.ContextProvider = s, qt.Element = t, qt.ForwardRef = c, qt.Fragment = r, qt.Lazy = f, qt.Memo = g, qt.Portal = n, qt.Profiler = i, qt.StrictMode = o, qt.Suspense = d, qt.isAsyncMode = function(v) {
    return E(v) || P(v) === l;
  }, qt.isConcurrentMode = E, qt.isContextConsumer = function(v) {
    return P(v) === a;
  }, qt.isContextProvider = function(v) {
    return P(v) === s;
  }, qt.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, qt.isForwardRef = function(v) {
    return P(v) === c;
  }, qt.isFragment = function(v) {
    return P(v) === r;
  }, qt.isLazy = function(v) {
    return P(v) === f;
  }, qt.isMemo = function(v) {
    return P(v) === g;
  }, qt.isPortal = function(v) {
    return P(v) === n;
  }, qt.isProfiler = function(v) {
    return P(v) === i;
  }, qt.isStrictMode = function(v) {
    return P(v) === o;
  }, qt.isSuspense = function(v) {
    return P(v) === d;
  }, qt.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === d || v === p || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === s || v.$$typeof === a || v.$$typeof === c || v.$$typeof === h || v.$$typeof === C || v.$$typeof === w || v.$$typeof === m);
  }, qt.typeOf = P, qt;
}
var Gt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zL;
function Koe() {
  return zL || (zL = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function P(H) {
      return typeof H == "string" || typeof H == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      H === r || H === u || H === i || H === o || H === d || H === p || typeof H == "object" && H !== null && (H.$$typeof === f || H.$$typeof === g || H.$$typeof === s || H.$$typeof === a || H.$$typeof === c || H.$$typeof === h || H.$$typeof === C || H.$$typeof === w || H.$$typeof === m);
    }
    function E(H) {
      if (typeof H == "object" && H !== null) {
        var ce = H.$$typeof;
        switch (ce) {
          case t:
            var ye = H.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case d:
                return ye;
              default:
                var ie = ye && ye.$$typeof;
                switch (ie) {
                  case a:
                  case c:
                  case f:
                  case g:
                  case s:
                    return ie;
                  default:
                    return ce;
                }
            }
          case n:
            return ce;
        }
      }
    }
    var v = l, x = u, L = a, z = s, k = t, R = c, A = r, U = f, V = g, N = n, Z = i, K = o, X = d, te = !1;
    function ee(H) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), D(H) || E(H) === l;
    }
    function D(H) {
      return E(H) === u;
    }
    function j(H) {
      return E(H) === a;
    }
    function G(H) {
      return E(H) === s;
    }
    function S(H) {
      return typeof H == "object" && H !== null && H.$$typeof === t;
    }
    function Y(H) {
      return E(H) === c;
    }
    function O(H) {
      return E(H) === r;
    }
    function M(H) {
      return E(H) === f;
    }
    function W(H) {
      return E(H) === g;
    }
    function T(H) {
      return E(H) === n;
    }
    function q(H) {
      return E(H) === i;
    }
    function I(H) {
      return E(H) === o;
    }
    function J(H) {
      return E(H) === d;
    }
    Gt.AsyncMode = v, Gt.ConcurrentMode = x, Gt.ContextConsumer = L, Gt.ContextProvider = z, Gt.Element = k, Gt.ForwardRef = R, Gt.Fragment = A, Gt.Lazy = U, Gt.Memo = V, Gt.Portal = N, Gt.Profiler = Z, Gt.StrictMode = K, Gt.Suspense = X, Gt.isAsyncMode = ee, Gt.isConcurrentMode = D, Gt.isContextConsumer = j, Gt.isContextProvider = G, Gt.isElement = S, Gt.isForwardRef = Y, Gt.isFragment = O, Gt.isLazy = M, Gt.isMemo = W, Gt.isPortal = T, Gt.isProfiler = q, Gt.isStrictMode = I, Gt.isSuspense = J, Gt.isValidElementType = P, Gt.typeOf = E;
  }()), Gt;
}
var $L;
function jB() {
  return $L || ($L = 1, process.env.NODE_ENV === "production" ? wc.exports = Yoe() : wc.exports = Koe()), wc.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var dg, UL;
function Xoe() {
  if (UL) return dg;
  UL = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return dg = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var d in a)
        t.call(a, d) && (l[d] = a[d]);
      if (e) {
        u = e(a);
        for (var p = 0; p < u.length; p++)
          n.call(a, u[p]) && (l[u[p]] = a[u[p]]);
      }
    }
    return l;
  }, dg;
}
var pg, HL;
function Db() {
  if (HL) return pg;
  HL = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return pg = e, pg;
}
var fg, WL;
function AB() {
  return WL || (WL = 1, fg = Function.call.bind(Object.prototype.hasOwnProperty)), fg;
}
var hg, VL;
function Joe() {
  if (VL) return hg;
  VL = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Db(), n = {}, r = AB();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var d;
          try {
            if (typeof i[c] != "function") {
              var p = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            d = i[c](s, c, l, a, null, t);
          } catch (f) {
            d = f;
          }
          if (d && !(d instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in n)) {
            n[d.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + a + " type: " + d.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, hg = o, hg;
}
var gg, ZL;
function Qoe() {
  if (ZL) return gg;
  ZL = 1;
  var e = jB(), t = Xoe(), n = Db(), r = AB(), o = Joe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return gg = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function d(D) {
      var j = D && (u && D[u] || D[c]);
      if (typeof j == "function")
        return j;
    }
    var p = "<<anonymous>>", g = {
      array: C("array"),
      bigint: C("bigint"),
      bool: C("boolean"),
      func: C("function"),
      number: C("number"),
      object: C("object"),
      string: C("string"),
      symbol: C("symbol"),
      any: w(),
      arrayOf: P,
      element: E(),
      elementType: v(),
      instanceOf: x,
      node: R(),
      objectOf: z,
      oneOf: L,
      oneOfType: k,
      shape: U,
      exact: V
    };
    function f(D, j) {
      return D === j ? D !== 0 || 1 / D === 1 / j : D !== D && j !== j;
    }
    function m(D, j) {
      this.message = D, this.data = j && typeof j == "object" ? j : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function h(D) {
      if (process.env.NODE_ENV !== "production")
        var j = {}, G = 0;
      function S(O, M, W, T, q, I, J) {
        if (T = T || p, I = I || W, J !== n) {
          if (l) {
            var H = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw H.name = "Invariant Violation", H;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ce = T + ":" + W;
            !j[ce] && // Avoid spamming the console because they are often not actionable except for lib authors
            G < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + I + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), j[ce] = !0, G++);
          }
        }
        return M[W] == null ? O ? M[W] === null ? new m("The " + q + " `" + I + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + I + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : D(M, W, T, q, I);
      }
      var Y = S.bind(null, !1);
      return Y.isRequired = S.bind(null, !0), Y;
    }
    function C(D) {
      function j(G, S, Y, O, M, W) {
        var T = G[S], q = K(T);
        if (q !== D) {
          var I = X(T);
          return new m(
            "Invalid " + O + " `" + M + "` of type " + ("`" + I + "` supplied to `" + Y + "`, expected ") + ("`" + D + "`."),
            { expectedType: D }
          );
        }
        return null;
      }
      return h(j);
    }
    function w() {
      return h(s);
    }
    function P(D) {
      function j(G, S, Y, O, M) {
        if (typeof D != "function")
          return new m("Property `" + M + "` of component `" + Y + "` has invalid PropType notation inside arrayOf.");
        var W = G[S];
        if (!Array.isArray(W)) {
          var T = K(W);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + T + "` supplied to `" + Y + "`, expected an array."));
        }
        for (var q = 0; q < W.length; q++) {
          var I = D(W, q, Y, O, M + "[" + q + "]", n);
          if (I instanceof Error)
            return I;
        }
        return null;
      }
      return h(j);
    }
    function E() {
      function D(j, G, S, Y, O) {
        var M = j[G];
        if (!a(M)) {
          var W = K(M);
          return new m("Invalid " + Y + " `" + O + "` of type " + ("`" + W + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(D);
    }
    function v() {
      function D(j, G, S, Y, O) {
        var M = j[G];
        if (!e.isValidElementType(M)) {
          var W = K(M);
          return new m("Invalid " + Y + " `" + O + "` of type " + ("`" + W + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(D);
    }
    function x(D) {
      function j(G, S, Y, O, M) {
        if (!(G[S] instanceof D)) {
          var W = D.name || p, T = ee(G[S]);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + T + "` supplied to `" + Y + "`, expected ") + ("instance of `" + W + "`."));
        }
        return null;
      }
      return h(j);
    }
    function L(D) {
      if (!Array.isArray(D))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function j(G, S, Y, O, M) {
        for (var W = G[S], T = 0; T < D.length; T++)
          if (f(W, D[T]))
            return null;
        var q = JSON.stringify(D, function(J, H) {
          var ce = X(H);
          return ce === "symbol" ? String(H) : H;
        });
        return new m("Invalid " + O + " `" + M + "` of value `" + String(W) + "` " + ("supplied to `" + Y + "`, expected one of " + q + "."));
      }
      return h(j);
    }
    function z(D) {
      function j(G, S, Y, O, M) {
        if (typeof D != "function")
          return new m("Property `" + M + "` of component `" + Y + "` has invalid PropType notation inside objectOf.");
        var W = G[S], T = K(W);
        if (T !== "object")
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + T + "` supplied to `" + Y + "`, expected an object."));
        for (var q in W)
          if (r(W, q)) {
            var I = D(W, q, Y, O, M + "." + q, n);
            if (I instanceof Error)
              return I;
          }
        return null;
      }
      return h(j);
    }
    function k(D) {
      if (!Array.isArray(D))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var j = 0; j < D.length; j++) {
        var G = D[j];
        if (typeof G != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(G) + " at index " + j + "."
          ), s;
      }
      function S(Y, O, M, W, T) {
        for (var q = [], I = 0; I < D.length; I++) {
          var J = D[I], H = J(Y, O, M, W, T, n);
          if (H == null)
            return null;
          H.data && r(H.data, "expectedType") && q.push(H.data.expectedType);
        }
        var ce = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + W + " `" + T + "` supplied to " + ("`" + M + "`" + ce + "."));
      }
      return h(S);
    }
    function R() {
      function D(j, G, S, Y, O) {
        return N(j[G]) ? null : new m("Invalid " + Y + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return h(D);
    }
    function A(D, j, G, S, Y) {
      return new m(
        (D || "React class") + ": " + j + " type `" + G + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Y + "`."
      );
    }
    function U(D) {
      function j(G, S, Y, O, M) {
        var W = G[S], T = K(W);
        if (T !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + T + "` " + ("supplied to `" + Y + "`, expected `object`."));
        for (var q in D) {
          var I = D[q];
          if (typeof I != "function")
            return A(Y, O, M, q, X(I));
          var J = I(W, q, Y, O, M + "." + q, n);
          if (J)
            return J;
        }
        return null;
      }
      return h(j);
    }
    function V(D) {
      function j(G, S, Y, O, M) {
        var W = G[S], T = K(W);
        if (T !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + T + "` " + ("supplied to `" + Y + "`, expected `object`."));
        var q = t({}, G[S], D);
        for (var I in q) {
          var J = D[I];
          if (r(D, I) && typeof J != "function")
            return A(Y, O, M, I, X(J));
          if (!J)
            return new m(
              "Invalid " + O + " `" + M + "` key `" + I + "` supplied to `" + Y + "`.\nBad object: " + JSON.stringify(G[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(D), null, "  ")
            );
          var H = J(W, I, Y, O, M + "." + I, n);
          if (H)
            return H;
        }
        return null;
      }
      return h(j);
    }
    function N(D) {
      switch (typeof D) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !D;
        case "object":
          if (Array.isArray(D))
            return D.every(N);
          if (D === null || a(D))
            return !0;
          var j = d(D);
          if (j) {
            var G = j.call(D), S;
            if (j !== D.entries) {
              for (; !(S = G.next()).done; )
                if (!N(S.value))
                  return !1;
            } else
              for (; !(S = G.next()).done; ) {
                var Y = S.value;
                if (Y && !N(Y[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(D, j) {
      return D === "symbol" ? !0 : j ? j["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && j instanceof Symbol : !1;
    }
    function K(D) {
      var j = typeof D;
      return Array.isArray(D) ? "array" : D instanceof RegExp ? "object" : Z(j, D) ? "symbol" : j;
    }
    function X(D) {
      if (typeof D > "u" || D === null)
        return "" + D;
      var j = K(D);
      if (j === "object") {
        if (D instanceof Date)
          return "date";
        if (D instanceof RegExp)
          return "regexp";
      }
      return j;
    }
    function te(D) {
      var j = X(D);
      switch (j) {
        case "array":
        case "object":
          return "an " + j;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + j;
        default:
          return j;
      }
    }
    function ee(D) {
      return !D.constructor || !D.constructor.name ? p : D.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, gg;
}
var mg, qL;
function eie() {
  if (qL) return mg;
  qL = 1;
  var e = Db();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, mg = function() {
    function r(s, a, l, u, c, d) {
      if (d !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, mg;
}
if (process.env.NODE_ENV !== "production") {
  var tie = jB(), nie = !0;
  Ym.exports = Qoe()(tie.isElement, nie);
} else
  Ym.exports = eie()();
var Of = Ym.exports, kf = {};
Object.defineProperty(kf, "__esModule", {
  value: !0
});
var rie = ru, vg = oie(rie);
function oie(e) {
  return e && e.__esModule ? e : { default: e };
}
var iie = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return vg.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && vg.default.getHash() !== t && vg.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
kf.default = iie;
Object.defineProperty(eu, "__esModule", {
  value: !0
});
var Cc = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, sie = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), aie = Oe, GL = su(aie), lie = tu, Ec = su(lie), uie = ta, cie = su(uie), die = Of, Pn = su(die), pie = kf, Ko = su(pie);
function su(e) {
  return e && e.__esModule ? e : { default: e };
}
function fie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function hie(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function gie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var YL = {
  to: Pn.default.string.isRequired,
  containerId: Pn.default.string,
  container: Pn.default.object,
  activeClass: Pn.default.string,
  activeStyle: Pn.default.object,
  spy: Pn.default.bool,
  horizontal: Pn.default.bool,
  smooth: Pn.default.oneOfType([Pn.default.bool, Pn.default.string]),
  offset: Pn.default.number,
  delay: Pn.default.number,
  isDynamic: Pn.default.bool,
  onClick: Pn.default.func,
  duration: Pn.default.oneOfType([Pn.default.number, Pn.default.func]),
  absolute: Pn.default.bool,
  onSetActive: Pn.default.func,
  onSetInactive: Pn.default.func,
  ignoreCancelEvents: Pn.default.bool,
  hashSpy: Pn.default.bool,
  saveHashHistory: Pn.default.bool,
  spyThrottle: Pn.default.number
};
eu.default = function(e, t) {
  var n = t || cie.default, r = function(i) {
    gie(s, i);
    function s(a) {
      fie(this, s);
      var l = hie(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return sie(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          if (!Ec.default.isMounted(l)) {
            var u = Ec.default.mount(l, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(u);
          }
          this.props.hashSpy && (Ko.default.isMounted() || Ko.default.mount(n), Ko.default.mapContainer(this.props.to, l)), Ec.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Ec.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(l) {
          return l();
        });
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = Cc({}, this.props.style, this.props.activeStyle) : u = Cc({}, this.props.style);
        var c = Cc({}, this.props);
        for (var d in YL)
          c.hasOwnProperty(d) && delete c[d];
        return c.className = l, c.style = u, c.onClick = this.handleClick, GL.default.createElement(e, c);
      }
    }]), s;
  }(GL.default.PureComponent), o = function() {
    var s = this;
    this.scrollTo = function(a, l) {
      n.scrollTo(a, Cc({}, s.state, l));
    }, this.handleClick = function(a) {
      s.props.onClick && s.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), s.scrollTo(s.props.to, s.props);
    }, this.spyHandler = function(a, l) {
      var u = s.getScrollSpyContainer();
      if (!(Ko.default.isMounted() && !Ko.default.isInitialized())) {
        var c = s.props.horizontal, d = s.props.to, p = null, g = void 0, f = void 0;
        if (c) {
          var m = 0, h = 0, C = 0;
          if (u.getBoundingClientRect) {
            var w = u.getBoundingClientRect();
            C = w.left;
          }
          if (!p || s.props.isDynamic) {
            if (p = n.get(d), !p)
              return;
            var P = p.getBoundingClientRect();
            m = P.left - C + a, h = m + P.width;
          }
          var E = a - s.props.offset;
          g = E >= Math.floor(m) && E < Math.floor(h), f = E < Math.floor(m) || E >= Math.floor(h);
        } else {
          var v = 0, x = 0, L = 0;
          if (u.getBoundingClientRect) {
            var z = u.getBoundingClientRect();
            L = z.top;
          }
          if (!p || s.props.isDynamic) {
            if (p = n.get(d), !p)
              return;
            var k = p.getBoundingClientRect();
            v = k.top - L + l, x = v + k.height;
          }
          var R = l - s.props.offset;
          g = R >= Math.floor(v) && R < Math.floor(x), f = R < Math.floor(v) || R >= Math.floor(x);
        }
        var A = n.getActiveLink();
        if (f) {
          if (d === A && n.setActiveLink(void 0), s.props.hashSpy && Ko.default.getHash() === d) {
            var U = s.props.saveHashHistory, V = U === void 0 ? !1 : U;
            Ko.default.changeHash("", V);
          }
          s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive(d, p));
        }
        if (g && (A !== d || s.state.active === !1)) {
          n.setActiveLink(d);
          var N = s.props.saveHashHistory, Z = N === void 0 ? !1 : N;
          s.props.hashSpy && Ko.default.changeHash(d, Z), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(d, p));
        }
      }
    };
  };
  return r.propTypes = YL, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(xb, "__esModule", {
  value: !0
});
var mie = Oe, KL = BB(mie), vie = eu, yie = BB(vie);
function BB(e) {
  return e && e.__esModule ? e : { default: e };
}
function bie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function XL(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function wie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Cie = function(e) {
  wie(t, e);
  function t() {
    var n, r, o, i;
    bie(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = XL(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return KL.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), XL(o, i);
  }
  return t;
}(KL.default.Component);
xb.default = (0, yie.default)(Cie);
var Pb = {};
Object.defineProperty(Pb, "__esModule", {
  value: !0
});
var Eie = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), xie = Oe, JL = IB(xie), Oie = eu, kie = IB(Oie);
function IB(e) {
  return e && e.__esModule ? e : { default: e };
}
function _ie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Lie(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Die(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Pie = function(e) {
  Die(t, e);
  function t() {
    return _ie(this, t), Lie(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Eie(t, [{
    key: "render",
    value: function() {
      return JL.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(JL.default.Component);
Pb.default = (0, kie.default)(Pie);
var Sb = {}, _f = {};
Object.defineProperty(_f, "__esModule", {
  value: !0
});
var Sie = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Mie = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Tie = Oe, QL = Lf(Tie), jie = Tl;
Lf(jie);
var Aie = ta, eD = Lf(Aie), Bie = Of, tD = Lf(Bie);
function Lf(e) {
  return e && e.__esModule ? e : { default: e };
}
function Iie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Fie(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Rie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
_f.default = function(e) {
  var t = function(n) {
    Rie(r, n);
    function r(o) {
      Iie(this, r);
      var i = Fie(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Mie(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        eD.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        eD.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return QL.default.createElement(e, Sie({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(QL.default.Component);
  return t.propTypes = {
    name: tD.default.string,
    id: tD.default.string
  }, t;
};
Object.defineProperty(Sb, "__esModule", {
  value: !0
});
var nD = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Nie = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), zie = Oe, rD = Mb(zie), $ie = _f, Uie = Mb($ie), Hie = Of, oD = Mb(Hie);
function Mb(e) {
  return e && e.__esModule ? e : { default: e };
}
function Wie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Vie(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Zie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var FB = function(e) {
  Zie(t, e);
  function t() {
    return Wie(this, t), Vie(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Nie(t, [{
    key: "render",
    value: function() {
      var r = this, o = nD({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, rD.default.createElement(
        "div",
        nD({}, o, { ref: function(s) {
          r.props.parentBindings.domNode = s;
        } }),
        this.props.children
      );
    }
  }]), t;
}(rD.default.Component);
FB.propTypes = {
  name: oD.default.string,
  id: oD.default.string
};
Sb.default = (0, Uie.default)(FB);
var yg = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, iD = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function sD(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function aD(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function lD(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var xc = Oe, Vi = tu, bg = ta, Nn = Of, Xo = kf, uD = {
  to: Nn.string.isRequired,
  containerId: Nn.string,
  container: Nn.object,
  activeClass: Nn.string,
  spy: Nn.bool,
  smooth: Nn.oneOfType([Nn.bool, Nn.string]),
  offset: Nn.number,
  delay: Nn.number,
  isDynamic: Nn.bool,
  onClick: Nn.func,
  duration: Nn.oneOfType([Nn.number, Nn.func]),
  absolute: Nn.bool,
  onSetActive: Nn.func,
  onSetInactive: Nn.func,
  ignoreCancelEvents: Nn.bool,
  hashSpy: Nn.bool,
  spyThrottle: Nn.number
}, qie = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || bg, o = function(s) {
      lD(a, s);
      function a(l) {
        sD(this, a);
        var u = aD(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return iD(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            Vi.isMounted(u) || Vi.mount(u, this.props.spyThrottle), this.props.hashSpy && (Xo.isMounted() || Xo.mount(r), Xo.mapContainer(this.props.to, u)), this.props.spy && Vi.addStateHandler(this.stateHandler), Vi.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Vi.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = yg({}, this.props);
          for (var d in uD)
            c.hasOwnProperty(d) && delete c[d];
          return c.className = u, c.onClick = this.handleClick, xc.createElement(t, c);
        }
      }]), a;
    }(xc.Component), i = function() {
      var a = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, yg({}, a.state, u));
      }, this.handleClick = function(l) {
        a.props.onClick && a.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), a.scrollTo(a.props.to, a.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== a.props.to && (a.state !== null && a.state.active && a.props.onSetInactive && a.props.onSetInactive(), a.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = a.getScrollSpyContainer();
        if (!(Xo.isMounted() && !Xo.isInitialized())) {
          var c = a.props.to, d = null, p = 0, g = 0, f = 0;
          if (u.getBoundingClientRect) {
            var m = u.getBoundingClientRect();
            f = m.top;
          }
          if (!d || a.props.isDynamic) {
            if (d = r.get(c), !d)
              return;
            var h = d.getBoundingClientRect();
            p = h.top - f + l, g = p + h.height;
          }
          var C = l - a.props.offset, w = C >= Math.floor(p) && C < Math.floor(g), P = C < Math.floor(p) || C >= Math.floor(g), E = r.getActiveLink();
          if (P)
            return c === E && r.setActiveLink(void 0), a.props.hashSpy && Xo.getHash() === c && Xo.changeHash(), a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive()), Vi.updateStates();
          if (w && E !== c)
            return r.setActiveLink(c), a.props.hashSpy && Xo.changeHash(c), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(c)), Vi.updateStates();
        }
      };
    };
    return o.propTypes = uD, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      lD(o, r);
      function o(i) {
        sD(this, o);
        var s = aD(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return s.childBindings = {
          domNode: null
        }, s;
      }
      return iD(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(s) {
          this.props.name !== s.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          bg.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(s) {
          bg.register(s, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return xc.createElement(t, yg({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(xc.Component);
    return n.propTypes = {
      name: Nn.string,
      id: Nn.string
    }, n;
  }
}, Gie = qie;
Object.defineProperty(Zn, "__esModule", {
  value: !0
});
Zn.Helpers = Zn.ScrollElement = Zn.ScrollLink = GB = Zn.animateScroll = Zn.scrollSpy = Zn.Events = Zn.scroller = Zn.Element = Zn.Button = Zn.Link = void 0;
var Yie = xb, RB = Co(Yie), Kie = Pb, NB = Co(Kie), Xie = Sb, zB = Co(Xie), Jie = ta, $B = Co(Jie), Qie = ou, UB = Co(Qie), ese = tu, HB = Co(ese), tse = Cf, WB = Co(tse), nse = eu, VB = Co(nse), rse = _f, ZB = Co(rse), ose = Gie, qB = Co(ose);
function Co(e) {
  return e && e.__esModule ? e : { default: e };
}
Zn.Link = RB.default;
Zn.Button = NB.default;
Zn.Element = zB.default;
Zn.scroller = $B.default;
Zn.Events = UB.default;
Zn.scrollSpy = HB.default;
var GB = Zn.animateScroll = WB.default;
Zn.ScrollLink = VB.default;
Zn.ScrollElement = ZB.default;
Zn.Helpers = qB.default;
Zn.default = { Link: RB.default, Button: NB.default, Element: zB.default, scroller: $B.default, Events: UB.default, scrollSpy: HB.default, animateScroll: WB.default, ScrollLink: VB.default, ScrollElement: ZB.default, Helpers: qB.default };
const Tb = Ve({}), YB = Ve({});
function ise() {
  const e = _e(YB);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function cD(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function Sue() {
  const e = ov(), { closeModal: t, closeAll: n, modalIsOpen: r } = _e(Tb), { showToast: o } = ise(), { getParam: i } = _B(), { pathname: s } = sv(), a = AP(), l = i("closeAllModals"), u = iv();
  y(() => {
    var p, g;
    const c = ((g = (p = u[0]) == null ? void 0 : p.data) == null ? void 0 : g.closeModalKey) || "", d = r(c);
    c && d && t(c);
  }, [u]), y(() => {
    l === "true" && (n(), a(s));
  }, [l]), y(() => {
    const c = e == null ? void 0 : e.closeModalKey;
    c && t(c);
  }, [e]), y(() => {
    const c = e == null ? void 0 : e.closeAllModals;
    typeof c == "boolean" && c && n();
  }, [e]), y(() => {
    const c = e == null ? void 0 : e.toast, d = e == null ? void 0 : e.message;
    cD(c) && o(c), !cD(c) && d && o({ message: d, type: "danger" });
  }, [e]), y(() => {
    var c, d;
    if (typeof ((c = e == null ? void 0 : e.data) == null ? void 0 : c.scrollTo) == "string") {
      const p = document.getElementById((d = e == null ? void 0 : e.data) == null ? void 0 : d.scrollTo);
      p && GB.scrollTo(p.offsetTop - 200);
    }
  }, [e]);
}
const KB = Ve({});
function Mue(e) {
  const t = _e(KB);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, s = r(e), a = n(e);
    return { drawerIsOpen: s, drawerData: a, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function sse() {
  return () => {
  };
}
function ase() {
  return _I(
    sse,
    () => !0,
    () => !1
  );
}
function Tue(e) {
  const t = _e(Tb);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, s = r(e), a = n(e);
    return { modalIsOpen: s, modalData: a, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function jue(e) {
  const { children: t = !1 } = e, [n, r] = _([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function s(l, u) {
    const c = o(l);
    r(c ? (d) => [...d.filter((g) => g.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function a(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ B.jsx(
    KB.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: s, closeDrawer: a },
      children: t
    }
  );
}
function Sl(e) {
  "@babel/helpers - typeof";
  return Sl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Sl(e);
}
function lse(e, t) {
  if (Sl(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Sl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function use(e) {
  var t = lse(e, "string");
  return Sl(t) == "symbol" ? t : t + "";
}
function ue(e, t, n) {
  return (t = use(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function XB(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var wg, dD;
function cse() {
  if (dD) return wg;
  dD = 1;
  var e = process.env.NODE_ENV, t = function(r, o, i, s, a, l, u, c) {
    if (e !== "production" && o === void 0)
      throw new Error("invariant requires an error message argument");
    if (!r) {
      var d;
      if (o === void 0)
        d = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [i, s, a, l, u, c], g = 0;
        d = new Error(o.replace(/%s/g, function() {
          return p[g++];
        })), d.name = "Invariant Violation";
      }
      throw d.framesToPop = 1, d;
    }
  };
  return wg = t, wg;
}
var dse = cse(), Qn = /* @__PURE__ */ XB(dse), nt = Ve(null);
function pse() {
  Qn(!!_e, "useGoogleMap is React hook and requires React version 16.8+");
  var e = _e(nt);
  return Qn(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function fse(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function hse(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function gse(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return hse(e, i), o;
}
function mse(e, t, n) {
  var r = fse(n, function(i, s, a) {
    return typeof e[a] == "function" && i.push(google.maps.event.addListener(t, s, e[a])), i;
  }, []);
  return r;
}
function vse(e) {
  google.maps.event.removeListener(e);
}
function wt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(vse);
}
function gt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = mse(o, i, n);
  return gse(t, r, o, i), s;
}
var pD = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, fD = {
  extraMapTypes(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center(e, t) {
    e.setCenter(t);
  },
  clickableIcons(e, t) {
    e.setClickableIcons(t);
  },
  heading(e, t) {
    e.setHeading(t);
  },
  mapTypeId(e, t) {
    e.setMapTypeId(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  streetView(e, t) {
    e.setStreetView(t);
  },
  tilt(e, t) {
    e.setTilt(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
function yse(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: d,
    onMouseMove: p,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: h,
    onRightClick: C,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: P,
    onUnmount: E
  } = e, [v, x] = _(null), L = Ye(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null), [T, q] = _(null), [I, J] = _(null);
  return y(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), y(() => {
    v !== null && typeof s < "u" && v.setCenter(s);
  }, [v, s]), y(() => {
    v && l && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), y(() => {
    v && c && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), y(() => {
    v && d && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(v, "dragstart", d)));
  }, [d]), y(() => {
    v && m && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", m)));
  }, [m]), y(() => {
    v && p && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(v, "mousemove", p)));
  }, [p]), y(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), y(() => {
    v && f && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), y(() => {
    v && h && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(v, "mouseup", h)));
  }, [h]), y(() => {
    v && C && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(v, "rightclick", C)));
  }, [C]), y(() => {
    v && a && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", a)));
  }, [a]), y(() => {
    v && u && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(v, "drag", u)));
  }, [u]), y(() => {
    v && w && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(v, "center_changed", w)));
  }, [a]), y(() => {
    var H = L.current === null ? null : new google.maps.Map(L.current, n);
    return x(H), H !== null && P && P(H), () => {
      H !== null && E && E(H);
    };
  }, []), B.jsx("div", {
    id: r,
    ref: L,
    style: o,
    className: i,
    children: B.jsx(nt.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
De(yse);
let bse = class extends Ee {
  constructor() {
    super(...arguments), ue(this, "state", {
      map: null
    }), ue(this, "registeredEvents", []), ue(this, "mapRef", null), ue(this, "getInstance", () => this.mapRef === null ? null : new google.maps.Map(this.mapRef, this.props.options)), ue(this, "panTo", (t) => {
      var n = this.getInstance();
      n && n.panTo(t);
    }), ue(this, "setMapCallback", () => {
      this.state.map !== null && this.props.onLoad && this.props.onLoad(this.state.map);
    }), ue(this, "getRef", (t) => {
      this.mapRef = t;
    });
  }
  componentDidMount() {
    var t = this.getInstance();
    this.registeredEvents = gt({
      updaterMap: fD,
      eventMap: pD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        map: t
      };
    }, this.setMapCallback);
  }
  componentDidUpdate(t) {
    this.state.map !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: fD,
      eventMap: pD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.map
    }));
  }
  componentWillUnmount() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), wt(this.registeredEvents));
  }
  render() {
    return B.jsx("div", {
      id: this.props.id,
      ref: this.getRef,
      style: this.props.mapContainerStyle,
      className: this.props.mapContainerClassName,
      children: B.jsx(nt.Provider, {
        value: this.state.map,
        children: this.state.map !== null ? this.props.children : null
      })
    });
  }
};
function hD(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function JB(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        hD(i, r, o, s, a, "next", l);
      }
      function a(l) {
        hD(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function QB(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Qn(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var as = typeof document < "u";
function eI(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return as ? new Promise(function(i, s) {
    var a = document.getElementById(n), l = window;
    if (a) {
      var u = a.getAttribute("data-state");
      if (a.src === t && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, d = a.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, a.onerror = function(g) {
          d && d(g), s(g);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(f) {
      p.setAttribute("data-state", "error"), s(f);
    }, l.initMap = function() {
      p.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function gD(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function tI() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return gD(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return gD(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
var xa = !1;
function nI() {
  return B.jsx("div", {
    children: "Loading..."
  });
}
var Km = {
  id: "script-loader",
  version: "weekly"
};
class rI extends Ee {
  constructor() {
    super(...arguments), ue(this, "check", null), ue(this, "state", {
      loaded: !1
    }), ue(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ue(this, "isCleaningUp", /* @__PURE__ */ JB(function* () {
      function t(n) {
        if (!xa)
          n();
        else if (as)
          var r = window.setInterval(function() {
            xa || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ue(this, "cleanup", () => {
      xa = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(r) {
        return typeof r.src == "string" && r.src.includes("maps.googleapis");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(r) {
        return r.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(r) {
        return r.innerText !== void 0 && r.innerText.length > 0 && r.innerText.includes(".gm-");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      });
    }), ue(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && tI(), Qn(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: QB(this.props)
      };
      eI(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), ue(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (as) {
      if (window.google && window.google.maps && !xa) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), as && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (as) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, xa = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return B.jsxs(B.Fragment, {
      children: [B.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || B.jsx(nI, {})]
    });
  }
}
ue(rI, "defaultProps", Km);
function wse(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function jb(e, t) {
  if (e == null) return {};
  var n, r, o = wse(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var mD;
function Cse(e) {
  var {
    id: t = Km.id,
    version: n = Km.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: d,
    authReferrerPolicy: p
  } = e, g = Ye(!1), [f, m] = _(!1), [h, C] = _(void 0);
  y(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), y(function() {
    as && u && tI();
  }, [u]), y(function() {
    f && Qn(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = QB({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: d,
    authReferrerPolicy: p
  });
  y(function() {
    if (!as)
      return;
    function v() {
      g.current && (m(!0), mD = w);
    }
    if (window.google && window.google.maps && mD === w) {
      v();
      return;
    }
    eI({
      id: t,
      url: w,
      nonce: r
    }).then(v).catch(function(L) {
      g.current && C(L), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(L);
    });
  }, [t, w, r]);
  var P = Ye(void 0);
  return y(function() {
    P.current && l !== P.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), P.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var Ese = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], xse = B.jsx(nI, {});
function Ose(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = jb(e, Ese), {
    isLoaded: a,
    loadError: l
  } = Cse(s);
  return y(function() {
    a && typeof n == "function" && n();
  }, [a, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || xse;
}
De(Ose);
var vD;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(vD || (vD = {}));
function yD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yD(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var bD = {}, wD = {
  options(e, t) {
    e.setOptions(t);
  }
};
function kse(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = _e(nt), [i, s] = _(null);
  return y(() => {
    i !== null && i.setMap(o);
  }, [o]), y(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), y(() => {
    var a = new google.maps.TrafficLayer(zd(zd({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
De(kse);
class _se extends Ee {
  constructor() {
    super(...arguments), ue(this, "state", {
      trafficLayer: null
    }), ue(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ue(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(zd(zd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: wD,
      eventMap: bD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: wD,
      eventMap: bD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), wt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ue(_se, "contextType", nt);
function Lse(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = _e(nt), [o, i] = _(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
De(Lse);
class Dse extends Ee {
  constructor() {
    super(...arguments), ue(this, "state", {
      bicyclingLayer: null
    }), ue(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ue(Dse, "contextType", nt);
function Pse(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = _e(nt), [o, i] = _(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
De(Pse);
class Sse extends Ee {
  constructor() {
    super(...arguments), ue(this, "state", {
      transitLayer: null
    }), ue(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ue(Sse, "contextType", nt);
function CD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $d(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CD(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ED = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, xD = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Mse(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, d = _e(nt), [p, g] = _(null), [f, m] = _(null), [h, C] = _(null), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null);
  return y(() => {
    p !== null && p.setMap(d);
  }, [d]), y(() => {
    t && p !== null && p.setOptions(t);
  }, [p, t]), y(() => {
    p !== null && p.setDrawingMode(n ?? null);
  }, [p, n]), y(() => {
    p && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(p, "circlecomplete", r)));
  }, [p, r]), y(() => {
    p && o && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(p, "markercomplete", o)));
  }, [p, o]), y(() => {
    p && i && (w !== null && google.maps.event.removeListener(w), P(google.maps.event.addListener(p, "overlaycomplete", i)));
  }, [p, i]), y(() => {
    p && s && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(p, "polygoncomplete", s)));
  }, [p, s]), y(() => {
    p && a && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(p, "polylinecomplete", a)));
  }, [p, a]), y(() => {
    p && l && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(p, "rectanglecomplete", l)));
  }, [p, l]), y(() => {
    Qn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager($d($d({}, t), {}, {
      map: d
    }));
    return n && R.setDrawingMode(n), r && m(google.maps.event.addListener(R, "circlecomplete", r)), o && C(google.maps.event.addListener(R, "markercomplete", o)), i && P(google.maps.event.addListener(R, "overlaycomplete", i)), s && v(google.maps.event.addListener(R, "polygoncomplete", s)), a && L(google.maps.event.addListener(R, "polylinecomplete", a)), l && k(google.maps.event.addListener(R, "rectanglecomplete", l)), g(R), u && u(R), () => {
      p !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), E && google.maps.event.removeListener(E), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), c && c(p), p.setMap(null));
    };
  }, []), null;
}
De(Mse);
class Tse extends Ee {
  constructor(t) {
    super(t), ue(this, "registeredEvents", []), ue(this, "state", {
      drawingManager: null
    }), ue(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Qn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager($d($d({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: xD,
      eventMap: ED,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: xD,
      eventMap: ED,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), wt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ue(Tse, "contextType", nt);
function OD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OD(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kD = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, _D = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Ud = {};
function jse(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: d,
    label: p,
    opacity: g,
    shape: f,
    title: m,
    zIndex: h,
    onClick: C,
    onDblClick: w,
    onDrag: P,
    onDragEnd: E,
    onDragStart: v,
    onMouseOut: x,
    onMouseOver: L,
    onMouseUp: z,
    onMouseDown: k,
    onRightClick: R,
    onClickableChanged: A,
    onCursorChanged: U,
    onAnimationChanged: V,
    onDraggableChanged: N,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: D,
    onZindexChanged: j,
    onLoad: G,
    onUnmount: S
  } = e, Y = _e(nt), [O, M] = _(null), [W, T] = _(null), [q, I] = _(null), [J, H] = _(null), [ce, ye] = _(null), [ie, Te] = _(null), [Re, Ne] = _(null), [Ie, Ke] = _(null), [Ze, Se] = _(null), [qe, rt] = _(null), [Pe, Me] = _(null), [Ge, He] = _(null), [$e, ot] = _(null), [Fe, Kt] = _(null), [lt, ht] = _(null), [Dt, ln] = _(null), [Pt, St] = _(null), [ut, Xe] = _(null), [un, cn] = _(null), [Nt, Gn] = _(null), [zt, Yn] = _(null), [$t, Sn] = _(null);
  y(() => {
    O !== null && O.setMap(Y);
  }, [Y]), y(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), y(() => {
    typeof s < "u" && O !== null && O.setDraggable(s);
  }, [O, s]), y(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), y(() => {
    typeof a < "u" && O !== null && O.setVisible(a);
  }, [O, a]), y(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), y(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), y(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), y(() => {
    O && d !== void 0 && O.setIcon(d);
  }, [O, d]), y(() => {
    O && p !== void 0 && O.setLabel(p);
  }, [O, p]), y(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), y(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), y(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), y(() => {
    O && h !== void 0 && O.setZIndex(h);
  }, [O, h]), y(() => {
    O && w && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), y(() => {
    O && E && (q !== null && google.maps.event.removeListener(q), I(google.maps.event.addListener(O, "dragend", E)));
  }, [E]), y(() => {
    O && v && (J !== null && google.maps.event.removeListener(J), H(google.maps.event.addListener(O, "dragstart", v)));
  }, [v]), y(() => {
    O && k && (ce !== null && google.maps.event.removeListener(ce), ye(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), y(() => {
    O && x && (ie !== null && google.maps.event.removeListener(ie), Te(google.maps.event.addListener(O, "mouseout", x)));
  }, [x]), y(() => {
    O && L && (Re !== null && google.maps.event.removeListener(Re), Ne(google.maps.event.addListener(O, "mouseover", L)));
  }, [L]), y(() => {
    O && z && (Ie !== null && google.maps.event.removeListener(Ie), Ke(google.maps.event.addListener(O, "mouseup", z)));
  }, [z]), y(() => {
    O && R && (Ze !== null && google.maps.event.removeListener(Ze), Se(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), y(() => {
    O && C && (qe !== null && google.maps.event.removeListener(qe), rt(google.maps.event.addListener(O, "click", C)));
  }, [C]), y(() => {
    O && P && (Pe !== null && google.maps.event.removeListener(Pe), Me(google.maps.event.addListener(O, "drag", P)));
  }, [P]), y(() => {
    O && A && (Ge !== null && google.maps.event.removeListener(Ge), He(google.maps.event.addListener(O, "clickable_changed", A)));
  }, [A]), y(() => {
    O && U && ($e !== null && google.maps.event.removeListener($e), ot(google.maps.event.addListener(O, "cursor_changed", U)));
  }, [U]), y(() => {
    O && V && (Fe !== null && google.maps.event.removeListener(Fe), Kt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), y(() => {
    O && N && (lt !== null && google.maps.event.removeListener(lt), ht(google.maps.event.addListener(O, "draggable_changed", N)));
  }, [N]), y(() => {
    O && Z && (Dt !== null && google.maps.event.removeListener(Dt), ln(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), y(() => {
    O && K && (Pt !== null && google.maps.event.removeListener(Pt), St(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), y(() => {
    O && X && (ut !== null && google.maps.event.removeListener(ut), Xe(google.maps.event.addListener(O, "position_changed", X)));
  }, [X]), y(() => {
    O && te && (un !== null && google.maps.event.removeListener(un), cn(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), y(() => {
    O && ee && (Nt !== null && google.maps.event.removeListener(Nt), Gn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), y(() => {
    O && D && (zt !== null && google.maps.event.removeListener(zt), Yn(google.maps.event.addListener(O, "visible_changed", D)));
  }, [D]), y(() => {
    O && j && ($t !== null && google.maps.event.removeListener($t), Sn(google.maps.event.addListener(O, "zindex_changed", j)));
  }, [j]), y(() => {
    var Ut = Rs(Rs(Rs({}, n || Ud), r ? Ud : {
      map: Y
    }), {}, {
      position: t
    }), oe = new google.maps.Marker(Ut);
    return r ? r.addMarker(oe, !!o) : oe.setMap(Y), t && oe.setPosition(t), typeof a < "u" && oe.setVisible(a), typeof s < "u" && oe.setDraggable(s), typeof u < "u" && oe.setClickable(u), typeof c == "string" && oe.setCursor(c), d && oe.setIcon(d), typeof p < "u" && oe.setLabel(p), typeof g < "u" && oe.setOpacity(g), f && oe.setShape(f), typeof m == "string" && oe.setTitle(m), typeof h == "number" && oe.setZIndex(h), w && T(google.maps.event.addListener(oe, "dblclick", w)), E && I(google.maps.event.addListener(oe, "dragend", E)), v && H(google.maps.event.addListener(oe, "dragstart", v)), k && ye(google.maps.event.addListener(oe, "mousedown", k)), x && Te(google.maps.event.addListener(oe, "mouseout", x)), L && Ne(google.maps.event.addListener(oe, "mouseover", L)), z && Ke(google.maps.event.addListener(oe, "mouseup", z)), R && Se(google.maps.event.addListener(oe, "rightclick", R)), C && rt(google.maps.event.addListener(oe, "click", C)), P && Me(google.maps.event.addListener(oe, "drag", P)), A && He(google.maps.event.addListener(oe, "clickable_changed", A)), U && ot(google.maps.event.addListener(oe, "cursor_changed", U)), V && Kt(google.maps.event.addListener(oe, "animation_changed", V)), N && ht(google.maps.event.addListener(oe, "draggable_changed", N)), Z && ln(google.maps.event.addListener(oe, "flat_changed", Z)), K && St(google.maps.event.addListener(oe, "icon_changed", K)), X && Xe(google.maps.event.addListener(oe, "position_changed", X)), te && cn(google.maps.event.addListener(oe, "shape_changed", te)), ee && Gn(google.maps.event.addListener(oe, "title_changed", ee)), D && Yn(google.maps.event.addListener(oe, "visible_changed", D)), j && Sn(google.maps.event.addListener(oe, "zindex_changed", j)), M(oe), G && G(oe), () => {
      W !== null && google.maps.event.removeListener(W), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ce !== null && google.maps.event.removeListener(ce), ie !== null && google.maps.event.removeListener(ie), Re !== null && google.maps.event.removeListener(Re), Ie !== null && google.maps.event.removeListener(Ie), Ze !== null && google.maps.event.removeListener(Ze), qe !== null && google.maps.event.removeListener(qe), Ge !== null && google.maps.event.removeListener(Ge), $e !== null && google.maps.event.removeListener($e), Fe !== null && google.maps.event.removeListener(Fe), lt !== null && google.maps.event.removeListener(lt), Dt !== null && google.maps.event.removeListener(Dt), Pt !== null && google.maps.event.removeListener(Pt), ut !== null && google.maps.event.removeListener(ut), Nt !== null && google.maps.event.removeListener(Nt), zt !== null && google.maps.event.removeListener(zt), $t !== null && google.maps.event.removeListener($t), S && S(oe), r ? r.removeMarker(oe, !!o) : oe && oe.setMap(null);
    };
  }, []);
  var pr = qn(() => i ? Ct.map(i, (Ut) => {
    if (!mi(Ut))
      return Ut;
    var oe = Ut;
    return vi(oe, {
      anchor: O
    });
  }) : null, [i, O]);
  return B.jsx(B.Fragment, {
    children: pr
  }) || null;
}
De(jse);
class oI extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return JB(function* () {
      var n = Rs(Rs(Rs({}, t.props.options || Ud), t.props.clusterer ? Ud : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = gt({
        updaterMap: _D,
        eventMap: kD,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: _D,
      eventMap: kD,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), wt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? Ct.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ue(oI, "contextType", nt);
var Ase = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), d = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(d !== null ? "".concat(d.y, "px") : "0", "; left: ").concat(d !== null ? "".concat(d.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var p = document.createElement("img");
        p.alt = a, p.src = this.url, p.width = this.width, p.height = this.height, p.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (p.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(p), this.div.appendChild(g), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), Bse = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new Ase(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function Ise(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Fse = 2e3, Rse = 500, Nse = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", zse = "png", $se = [53, 56, 66, 78, 90], Use = "cluster", iI = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Nse, this.imageExtension = r.imageExtension || zse, this.imageSizes = r.imageSizes || $se, this.calculator = r.calculator || Ise, this.batchSize = r.batchSize || Fse, this.batchSizeIE = r.batchSizeIE || Rse, this.clusterClass = r.clusterClass || Use, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new Bse(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var d = 0, p = this.clusters; d < p.length; d++) {
            var g = p[d];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var s = i;
          this.prototype[s] = o.prototype[s];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function LD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hse(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LD(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xr = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Ft = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Wse = {};
function Vse(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: d,
    imageSizes: p,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: h,
    zoomOnClick: C,
    onClick: w,
    onClusteringBegin: P,
    onClusteringEnd: E,
    onMouseOver: v,
    onMouseOut: x,
    onLoad: L,
    onUnmount: z
  } = e, [k, R] = _(null), A = _e(nt), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null);
  return y(() => {
    k && x && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(k, Xr.onMouseOut, x)));
  }, [x]), y(() => {
    k && v && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(k, Xr.onMouseOver, v)));
  }, [v]), y(() => {
    k && w && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(k, Xr.onClick, w)));
  }, [w]), y(() => {
    k && P && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(k, Xr.onClusteringBegin, P)));
  }, [P]), y(() => {
    k && E && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(k, Xr.onClusteringEnd, E)));
  }, [E]), y(() => {
    typeof r < "u" && k !== null && Ft.averageCenter(k, r);
  }, [k, r]), y(() => {
    typeof o < "u" && k !== null && Ft.batchSizeIE(k, o);
  }, [k, o]), y(() => {
    typeof i < "u" && k !== null && Ft.calculator(k, i);
  }, [k, i]), y(() => {
    typeof s < "u" && k !== null && Ft.clusterClass(k, s);
  }, [k, s]), y(() => {
    typeof a < "u" && k !== null && Ft.enableRetinaIcons(k, a);
  }, [k, a]), y(() => {
    typeof l < "u" && k !== null && Ft.gridSize(k, l);
  }, [k, l]), y(() => {
    typeof u < "u" && k !== null && Ft.ignoreHidden(k, u);
  }, [k, u]), y(() => {
    typeof c < "u" && k !== null && Ft.imageExtension(k, c);
  }, [k, c]), y(() => {
    typeof d < "u" && k !== null && Ft.imagePath(k, d);
  }, [k, d]), y(() => {
    typeof p < "u" && k !== null && Ft.imageSizes(k, p);
  }, [k, p]), y(() => {
    typeof g < "u" && k !== null && Ft.maxZoom(k, g);
  }, [k, g]), y(() => {
    typeof f < "u" && k !== null && Ft.minimumClusterSize(k, f);
  }, [k, f]), y(() => {
    typeof m < "u" && k !== null && Ft.styles(k, m);
  }, [k, m]), y(() => {
    typeof h < "u" && k !== null && Ft.title(k, h);
  }, [k, h]), y(() => {
    typeof C < "u" && k !== null && Ft.zoomOnClick(k, C);
  }, [k, C]), y(() => {
    if (A) {
      var G = Hse({}, n || Wse), S = new iI(A, [], G);
      return r && Ft.averageCenter(S, r), o && Ft.batchSizeIE(S, o), i && Ft.calculator(S, i), s && Ft.clusterClass(S, s), a && Ft.enableRetinaIcons(S, a), l && Ft.gridSize(S, l), u && Ft.ignoreHidden(S, u), c && Ft.imageExtension(S, c), d && Ft.imagePath(S, d), p && Ft.imageSizes(S, p), g && Ft.maxZoom(S, g), f && Ft.minimumClusterSize(S, f), m && Ft.styles(S, m), h && Ft.title(S, h), C && Ft.zoomOnClick(S, C), x && ee(google.maps.event.addListener(S, Xr.onMouseOut, x)), v && j(google.maps.event.addListener(S, Xr.onMouseOver, v)), w && V(google.maps.event.addListener(S, Xr.onClick, w)), P && Z(google.maps.event.addListener(S, Xr.onClusteringBegin, P)), E && X(google.maps.event.addListener(S, Xr.onClusteringEnd, E)), R(S), L && L(S), () => {
        te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), z && z(S);
      };
    }
  }, []), k !== null && t(k) || null;
}
De(Vse);
class Zse extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      markerClusterer: null
    }), ue(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new iI(this.context, [], this.props.options);
      this.registeredEvents = gt({
        updaterMap: Ft,
        eventMap: Xr,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: Ft,
      eventMap: Xr,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), wt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ue(Zse, "contextType", nt);
function DD(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var sI = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(c) {
        c.returnValue = !1, c.preventDefault && c.preventDefault(), t.enableEventPropagation || DD(c);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, DD));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, d = this.div.offsetWidth, p = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), h = m.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + g ? r = h.x + u - g : h.x + d + u + g > a && (r = h.x + d + u + g - a), this.alignBottom ? h.y < -c + f + p ? o = h.y + c - f - p : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + p + c + f > l && (o = h.y + p + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), qse = ["position"], Gse = ["position"];
function PD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PD(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var SD = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, MD = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Yse = {};
function Kse(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: p
  } = e, g = _e(nt), [f, m] = _(null), [h, C] = _(null), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), R = Ye(null);
  return y(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    if (o && f !== null) {
      var A = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(A);
    }
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), P(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    if (g) {
      var A = r || Yse, {
        position: U
      } = A, V = jb(A, qse), N;
      U && !(U instanceof google.maps.LatLng) && (N = new google.maps.LatLng(U.lat, U.lng));
      var Z = new sI(Hd(Hd({}, V), N ? {
        position: N
      } : {}));
      R.current = document.createElement("div"), m(Z), s && C(google.maps.event.addListener(Z, "closeclick", s)), a && P(google.maps.event.addListener(Z, "domready", a)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && L(google.maps.event.addListener(Z, "position_changed", u)), c && k(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(R.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : Qn(!1, "You must provide either an anchor or a position prop for <InfoBox>."), d && d(Z);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), p && p(f), f.close());
    };
  }, []), R.current ? dr(Ct.only(t), R.current) : null;
}
De(Kse);
class Xse extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "containerElement", null), ue(this, "state", {
      infoBox: null
    }), ue(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Qn(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ue(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = jb(t, Gse), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new sI(Hd(Hd({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = gt({
      updaterMap: MD,
      eventMap: SD,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: MD,
      eventMap: SD,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), wt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? dr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
ue(Xse, "contextType", nt);
var Cg, TD;
function Jse() {
  return TD || (TD = 1, Cg = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), Cg;
}
var Qse = Jse(), jD = /* @__PURE__ */ XB(Qse), AD = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Eg = 1, Oa = 8;
class Ab {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Eg)
      throw new Error("Got v".concat(o, " data when expected v").concat(Eg, "."));
    var i = AD[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new Ab(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = AD.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Oa, t), this.coords = new this.ArrayType(this.data, Oa + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Oa + s + a + l), this.ids = new this.IndexArrayType(this.data, Oa, t), this.coords = new this.ArrayType(this.data, Oa + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Eg << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return Xm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, d = l.pop() || 0, p = l.pop() || 0;
      if (d - p <= a) {
        for (var g = p; g <= d; g++) {
          var f = s[2 * g], m = s[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var h = p + d >> 1, C = s[2 * h], w = s[2 * h + 1];
      C >= t && C <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= C : n <= w) && (l.push(p), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= C : o >= w) && (l.push(h + 1), l.push(d), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, d = a.pop() || 0, p = a.pop() || 0;
      if (d - p <= s) {
        for (var g = p; g <= d; g++)
          BD(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = p + d >> 1, m = i[2 * f], h = i[2 * f + 1];
      BD(m, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= h) && (a.push(p), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= m : n + r >= h) && (a.push(f + 1), a.push(d), a.push(1 - c));
    }
    return l;
  }
}
function Xm(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    aI(e, t, s, r, o, i), Xm(e, t, n, r, s - 1, 1 - i), Xm(e, t, n, s + 1, o, 1 - i);
  }
}
function aI(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), d = Math.max(r, Math.floor(n - a * u / s + c)), p = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      aI(e, t, n, d, p, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (ka(e, t, r, n), t[2 * o + i] > g && ka(e, t, r, o); f < m; ) {
      for (ka(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? ka(e, t, r, m) : (m++, ka(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function ka(e, t, n, r) {
  xg(e, n, r), xg(t, 2 * n, 2 * r), xg(t, 2 * n + 1, 2 * r + 1);
}
function xg(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function BD(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var eae = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, ID = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Zi = 2, ai = 3, Og = 4, ti = 5, lI = 6;
class tae {
  constructor(t) {
    this.options = Object.assign(Object.create(eae), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, d = ID(Oc(u)), p = ID(kc(c));
        s.push(
          d,
          p,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Oc(r), kc(s), Oc(i), kc(o)), d = u.data, p = [];
    for (var g of c) {
      var f = this.stride * g;
      p.push(d[f + ti] > 1 ? FD(d, f, this.clusterProps) : this.points[d[f + ai]]);
    }
    return p;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), d = [];
    for (var p of c) {
      var g = p * this.stride;
      s[g + Og] === t && d.push(s[g + ti] > 1 ? FD(s, g, this.clusterProps) : this.points[s[g + ai]]);
    }
    if (d.length === 0) throw new Error(o);
    return d;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, d = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, d), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, d), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, d), d.features.length ? d : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Ab(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + ti] > 1, c = void 0, d = void 0, p = void 0;
      if (u)
        c = uI(n, l, this.clusterProps), d = n[l], p = n[l + 1];
      else {
        var g = this.points[n[l + ai]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        d = Oc(f), p = kc(m);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (d * i - r)), Math.round(this.options.extent * (p * i - o))]],
        tags: c
      }, C = void 0;
      u || this.options.generateId ? C = n[l + ai] : C = this.points[n[l + ai]].id, C !== void 0 && (h.id = C), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, d = 0; d < l.length; d += c)
      if (!(l[d + Zi] <= n)) {
        l[d + Zi] = n;
        var p = l[d], g = l[d + 1], f = t.within(l[d], l[d + 1], a), m = l[d + ti], h = m;
        for (var C of f) {
          var w = C * c;
          l[w + Zi] > n && (h += l[w + ti]);
        }
        if (h > m && h >= s) {
          var P = p * m, E = g * m, v = void 0, x = -1, L = ((d / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var k = z * c;
            if (!(l[k + Zi] <= n)) {
              l[k + Zi] = n;
              var R = l[k + ti];
              P += l[k] * R, E += l[k + 1] * R, l[k + Og] = L, i && (v || (v = this._map(l, d, !0), x = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, k)));
            }
          }
          l[d + Og] = L, u.push(P / h, E / h, 1 / 0, L, -1, h), i && u.push(x);
        } else {
          for (var A = 0; A < c; A++) u.push(l[d + A]);
          if (h > 1)
            for (var U of f) {
              var V = U * c;
              if (!(l[V + Zi] <= n)) {
                l[V + Zi] = n;
                for (var N = 0; N < c; N++) u.push(l[V + N]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ti] > 1) {
      var o = this.clusterProps[t[n + lI]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + ai]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function FD(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ai],
    properties: uI(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [nae(e[t]), rae(e[t + 1])]
    }
  };
}
function uI(e, t, n) {
  var r = e[t + ti], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + lI], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + ai],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Oc(e) {
  return e / 360 + 0.5;
}
function kc(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function nae(e) {
  return (e - 0.5) * 360;
}
function rae(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function oae(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Nr {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Jm {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Nr.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Nr.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Nr.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class iae {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return sae(n);
  }
}
var sae = (e) => {
  var t = e.map((n) => new Jm({
    position: Nr.getPosition(n),
    markers: [n]
  }));
  return t;
};
class aae extends iae {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = oae(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new tae(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!jD(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = Nr.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !jD(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Jm({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Jm({
      markers: [i],
      position: Nr.getPosition(i)
    });
  }
}
class lae {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class uae {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Nr.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), d = c.parseFromString(a, "image/svg+xml").documentElement;
      d.setAttribute("transform", "translate(0 25)");
      var p = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: d
      };
      return new google.maps.marker.AdvancedMarkerElement(p);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function cae(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Bb {
  constructor() {
    cae(Bb, google.maps.OverlayView);
  }
}
var Xa;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Xa || (Xa = {}));
var dae = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class pae extends Bb {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new aae(o),
      renderer: s = new uae(),
      onClusterClick: a = dae
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Nr.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Xa.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || Nr.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => Nr.setMap(l, null)));
      }
      google.maps.event.trigger(this, Xa.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Nr.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new lae(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Nr.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Xa.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Nr.setMap(r.marker, n);
    });
  }
}
function RD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ND(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RD(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function fae(e) {
  var t = pse(), [n, r] = _(null);
  return y(() => {
    if (t && n === null) {
      var o = new pae(ND(ND({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function hae(e) {
  var {
    children: t,
    options: n
  } = e, r = fae(n);
  return r !== null ? t(r) : null;
}
De(hae);
var zD = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, $D = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function gae(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: p
  } = e, g = _e(nt), [f, m] = _(null), [h, C] = _(null), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), R = Ye(null);
  return y(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), P(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    var A = new google.maps.InfoWindow(r);
    return m(A), R.current = document.createElement("div"), s && C(google.maps.event.addListener(A, "closeclick", s)), a && P(google.maps.event.addListener(A, "domready", a)), l && v(google.maps.event.addListener(A, "content_changed", l)), u && L(google.maps.event.addListener(A, "position_changed", u)), c && k(google.maps.event.addListener(A, "zindex_changed", c)), A.setContent(R.current), o && A.setPosition(o), i && A.setZIndex(i), n ? A.open(g, n) : A.getPosition() ? A.open(g) : Qn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), d && d(A), () => {
      h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), p && p(A), A.close();
    };
  }, []), R.current ? dr(Ct.only(t), R.current) : null;
}
De(gae);
class mae extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "containerElement", null), ue(this, "state", {
      infoWindow: null
    }), ue(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Qn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ue(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = gt({
      updaterMap: $D,
      eventMap: zD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: $D,
      eventMap: zD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (wt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? dr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
ue(mae, "contextType", nt);
function UD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UD(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var HD = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, WD = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, vae = {};
function yae(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: p,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onLoad: C,
    onUnmount: w
  } = e, P = _e(nt), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null);
  return y(() => {
    E !== null && E.setMap(P);
  }, [P]), y(() => {
    typeof t < "u" && E !== null && E.setOptions(t);
  }, [E, t]), y(() => {
    typeof n < "u" && E !== null && E.setDraggable(n);
  }, [E, n]), y(() => {
    typeof r < "u" && E !== null && E.setEditable(r);
  }, [E, r]), y(() => {
    typeof o < "u" && E !== null && E.setVisible(o);
  }, [E, o]), y(() => {
    typeof i < "u" && E !== null && E.setPath(i);
  }, [E, i]), y(() => {
    E && s && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(E, "dblclick", s)));
  }, [s]), y(() => {
    E && a && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(E, "dragend", a)));
  }, [a]), y(() => {
    E && l && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(E, "dragstart", l)));
  }, [l]), y(() => {
    E && u && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(E, "mousedown", u)));
  }, [u]), y(() => {
    E && c && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(() => {
    E && d && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(E, "mouseout", d)));
  }, [d]), y(() => {
    E && p && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(E, "mouseover", p)));
  }, [p]), y(() => {
    E && g && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(E, "mouseup", g)));
  }, [g]), y(() => {
    E && f && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(E, "rightclick", f)));
  }, [f]), y(() => {
    E && m && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(E, "click", m)));
  }, [m]), y(() => {
    E && h && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(E, "drag", h)));
  }, [h]), y(() => {
    var T = new google.maps.Polyline(Wd(Wd({}, t || vae), {}, {
      map: P
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), s && L(google.maps.event.addListener(T, "dblclick", s)), a && k(google.maps.event.addListener(T, "dragend", a)), l && A(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), d && X(google.maps.event.addListener(T, "mouseout", d)), p && ee(google.maps.event.addListener(T, "mouseover", p)), g && j(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && O(google.maps.event.addListener(T, "click", m)), h && W(google.maps.event.addListener(T, "drag", h)), v(T), C && C(T), () => {
      x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), G !== null && google.maps.event.removeListener(G), Y !== null && google.maps.event.removeListener(Y), w && w(T), T.setMap(null);
    };
  }, []), null;
}
De(yae);
class bae extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      polyline: null
    }), ue(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Wd(Wd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: WD,
      eventMap: HD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: WD,
      eventMap: HD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), wt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ue(bae, "contextType", nt);
function VD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ZD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VD(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qD = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, GD = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function wae(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: p,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: C,
    onLoad: w,
    onUnmount: P,
    onEdit: E
  } = e, v = _e(nt), [x, L] = _(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null), [T, q] = _(null);
  return y(() => {
    x !== null && x.setMap(v);
  }, [v]), y(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), y(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), y(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), y(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), y(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), y(() => {
    typeof s < "u" && x !== null && x.setPaths(s);
  }, [x, s]), y(() => {
    x && typeof a == "function" && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), y(() => {
    x && (google.maps.event.addListener(x.getPath(), "insert_at", () => {
      E == null || E(x);
    }), google.maps.event.addListener(x.getPath(), "set_at", () => {
      E == null || E(x);
    }), google.maps.event.addListener(x.getPath(), "remove_at", () => {
      E == null || E(x);
    }));
  }, [x, E]), y(() => {
    x && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(x, "dragend", l)));
  }, [l]), y(() => {
    x && typeof u == "function" && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(x, "dragstart", u)));
  }, [u]), y(() => {
    x && typeof c == "function" && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(x, "mousedown", c)));
  }, [c]), y(() => {
    x && typeof d == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(x, "mousemove", d)));
  }, [d]), y(() => {
    x && typeof p == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), y(() => {
    x && typeof g == "function" && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(x, "mouseover", g)));
  }, [g]), y(() => {
    x && typeof f == "function" && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(x, "mouseup", f)));
  }, [f]), y(() => {
    x && typeof m == "function" && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(x, "rightclick", m)));
  }, [m]), y(() => {
    x && typeof h == "function" && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(x, "click", h)));
  }, [h]), y(() => {
    x && typeof C == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(x, "drag", C)));
  }, [C]), y(() => {
    var I = new google.maps.Polygon(ZD(ZD({}, t), {}, {
      map: v
    }));
    return i && I.setPath(i), s && I.setPaths(s), typeof o < "u" && I.setVisible(o), typeof r < "u" && I.setEditable(r), typeof n < "u" && I.setDraggable(n), a && k(google.maps.event.addListener(I, "dblclick", a)), l && A(google.maps.event.addListener(I, "dragend", l)), u && V(google.maps.event.addListener(I, "dragstart", u)), c && Z(google.maps.event.addListener(I, "mousedown", c)), d && X(google.maps.event.addListener(I, "mousemove", d)), p && ee(google.maps.event.addListener(I, "mouseout", p)), g && j(google.maps.event.addListener(I, "mouseover", g)), f && S(google.maps.event.addListener(I, "mouseup", f)), m && O(google.maps.event.addListener(I, "rightclick", m)), h && W(google.maps.event.addListener(I, "click", h)), C && q(google.maps.event.addListener(I, "drag", C)), L(I), w && w(I), () => {
      z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), G !== null && google.maps.event.removeListener(G), Y !== null && google.maps.event.removeListener(Y), M !== null && google.maps.event.removeListener(M), P && P(I), I.setMap(null);
    };
  }, []), null;
}
De(wae);
class Cae extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = gt({
      updaterMap: GD,
      eventMap: qD,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: GD,
      eventMap: qD,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), wt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ue(Cae, "contextType", nt);
function YD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YD(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var KD = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, XD = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Eae(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: p,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onBoundsChanged: C,
    onLoad: w,
    onUnmount: P
  } = e, E = _e(nt), [v, x] = _(null), [L, z] = _(null), [k, R] = _(null), [A, U] = _(null), [V, N] = _(null), [Z, K] = _(null), [X, te] = _(null), [ee, D] = _(null), [j, G] = _(null), [S, Y] = _(null), [O, M] = _(null), [W, T] = _(null), [q, I] = _(null);
  return y(() => {
    v !== null && v.setMap(E);
  }, [E]), y(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), y(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), y(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), y(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), y(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), y(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), z(google.maps.event.addListener(v, "dblclick", s)));
  }, [s]), y(() => {
    v && a && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(v, "dragend", a)));
  }, [a]), y(() => {
    v && l && (A !== null && google.maps.event.removeListener(A), U(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), y(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), N(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), y(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), y(() => {
    v && d && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(v, "mouseout", d)));
  }, [d]), y(() => {
    v && p && (ee !== null && google.maps.event.removeListener(ee), D(google.maps.event.addListener(v, "mouseover", p)));
  }, [p]), y(() => {
    v && g && (j !== null && google.maps.event.removeListener(j), G(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), y(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), Y(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), y(() => {
    v && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(v, "click", m)));
  }, [m]), y(() => {
    v && h && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(v, "drag", h)));
  }, [h]), y(() => {
    v && C && (q !== null && google.maps.event.removeListener(q), I(google.maps.event.addListener(v, "bounds_changed", C)));
  }, [C]), y(() => {
    var J = new google.maps.Rectangle(Vd(Vd({}, t), {}, {
      map: E
    }));
    return typeof i < "u" && J.setVisible(i), typeof o < "u" && J.setEditable(o), typeof r < "u" && J.setDraggable(r), typeof n < "u" && J.setBounds(n), s && z(google.maps.event.addListener(J, "dblclick", s)), a && R(google.maps.event.addListener(J, "dragend", a)), l && U(google.maps.event.addListener(J, "dragstart", l)), u && N(google.maps.event.addListener(J, "mousedown", u)), c && K(google.maps.event.addListener(J, "mousemove", c)), d && te(google.maps.event.addListener(J, "mouseout", d)), p && D(google.maps.event.addListener(J, "mouseover", p)), g && G(google.maps.event.addListener(J, "mouseup", g)), f && Y(google.maps.event.addListener(J, "rightclick", f)), m && M(google.maps.event.addListener(J, "click", m)), h && T(google.maps.event.addListener(J, "drag", h)), C && I(google.maps.event.addListener(J, "bounds_changed", C)), x(J), w && w(J), () => {
      L !== null && google.maps.event.removeListener(L), k !== null && google.maps.event.removeListener(k), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), q !== null && google.maps.event.removeListener(q), P && P(J), J.setMap(null);
    };
  }, []), null;
}
De(Eae);
class xae extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      rectangle: null
    }), ue(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Vd(Vd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: XD,
      eventMap: KD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: XD,
      eventMap: KD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), wt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ue(xae, "contextType", nt);
function JD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JD(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var QD = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, eP = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Oae = {};
function kae(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: p,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: C,
    onCenterChanged: w,
    onRadiusChanged: P,
    onLoad: E,
    onUnmount: v
  } = e, x = _e(nt), [L, z] = _(null), [k, R] = _(null), [A, U] = _(null), [V, N] = _(null), [Z, K] = _(null), [X, te] = _(null), [ee, D] = _(null), [j, G] = _(null), [S, Y] = _(null), [O, M] = _(null), [W, T] = _(null), [q, I] = _(null), [J, H] = _(null), [ce, ye] = _(null);
  return y(() => {
    L !== null && L.setMap(x);
  }, [x]), y(() => {
    typeof t < "u" && L !== null && L.setOptions(t);
  }, [L, t]), y(() => {
    typeof o < "u" && L !== null && L.setDraggable(o);
  }, [L, o]), y(() => {
    typeof i < "u" && L !== null && L.setEditable(i);
  }, [L, i]), y(() => {
    typeof s < "u" && L !== null && L.setVisible(s);
  }, [L, s]), y(() => {
    typeof r == "number" && L !== null && L.setRadius(r);
  }, [L, r]), y(() => {
    typeof n < "u" && L !== null && L.setCenter(n);
  }, [L, n]), y(() => {
    L && a && (k !== null && google.maps.event.removeListener(k), R(google.maps.event.addListener(L, "dblclick", a)));
  }, [a]), y(() => {
    L && l && (A !== null && google.maps.event.removeListener(A), U(google.maps.event.addListener(L, "dragend", l)));
  }, [l]), y(() => {
    L && u && (V !== null && google.maps.event.removeListener(V), N(google.maps.event.addListener(L, "dragstart", u)));
  }, [u]), y(() => {
    L && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(L, "mousedown", c)));
  }, [c]), y(() => {
    L && d && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(L, "mousemove", d)));
  }, [d]), y(() => {
    L && p && (ee !== null && google.maps.event.removeListener(ee), D(google.maps.event.addListener(L, "mouseout", p)));
  }, [p]), y(() => {
    L && g && (j !== null && google.maps.event.removeListener(j), G(google.maps.event.addListener(L, "mouseover", g)));
  }, [g]), y(() => {
    L && f && (S !== null && google.maps.event.removeListener(S), Y(google.maps.event.addListener(L, "mouseup", f)));
  }, [f]), y(() => {
    L && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(L, "rightclick", m)));
  }, [m]), y(() => {
    L && h && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(L, "click", h)));
  }, [h]), y(() => {
    L && C && (q !== null && google.maps.event.removeListener(q), I(google.maps.event.addListener(L, "drag", C)));
  }, [C]), y(() => {
    L && w && (J !== null && google.maps.event.removeListener(J), H(google.maps.event.addListener(L, "center_changed", w)));
  }, [h]), y(() => {
    L && P && (ce !== null && google.maps.event.removeListener(ce), ye(google.maps.event.addListener(L, "radius_changed", P)));
  }, [P]), y(() => {
    var ie = new google.maps.Circle(Zd(Zd({}, t || Oae), {}, {
      map: x
    }));
    return typeof r == "number" && ie.setRadius(r), typeof n < "u" && ie.setCenter(n), typeof r == "number" && ie.setRadius(r), typeof s < "u" && ie.setVisible(s), typeof i < "u" && ie.setEditable(i), typeof o < "u" && ie.setDraggable(o), a && R(google.maps.event.addListener(ie, "dblclick", a)), l && U(google.maps.event.addListener(ie, "dragend", l)), u && N(google.maps.event.addListener(ie, "dragstart", u)), c && K(google.maps.event.addListener(ie, "mousedown", c)), d && te(google.maps.event.addListener(ie, "mousemove", d)), p && D(google.maps.event.addListener(ie, "mouseout", p)), g && G(google.maps.event.addListener(ie, "mouseover", g)), f && Y(google.maps.event.addListener(ie, "mouseup", f)), m && M(google.maps.event.addListener(ie, "rightclick", m)), h && T(google.maps.event.addListener(ie, "click", h)), C && I(google.maps.event.addListener(ie, "drag", C)), w && H(google.maps.event.addListener(ie, "center_changed", w)), P && ye(google.maps.event.addListener(ie, "radius_changed", P)), z(ie), E && E(ie), () => {
      k !== null && google.maps.event.removeListener(k), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), ee !== null && google.maps.event.removeListener(ee), j !== null && google.maps.event.removeListener(j), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), J !== null && google.maps.event.removeListener(J), ce !== null && google.maps.event.removeListener(ce), v && v(ie), ie.setMap(null);
    };
  }, []), null;
}
De(kae);
class _ae extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      circle: null
    }), ue(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Zd(Zd({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: eP,
      eventMap: QD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: eP,
      eventMap: QD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), wt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ue(_ae, "contextType", nt);
function tP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tP(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nP = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, rP = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Lae(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: d,
    onRemoveProperty: p,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: h
  } = e, C = _e(nt), [w, P] = _(null), [E, v] = _(null), [x, L] = _(null), [z, k] = _(null), [R, A] = _(null), [U, V] = _(null), [N, Z] = _(null), [K, X] = _(null), [te, ee] = _(null), [D, j] = _(null), [G, S] = _(null), [Y, O] = _(null), [M, W] = _(null), [T, q] = _(null);
  return y(() => {
    w !== null && w.setMap(C);
  }, [C]), y(() => {
    w && r && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), y(() => {
    w && o && (x !== null && google.maps.event.removeListener(x), L(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), y(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), y(() => {
    w && s && (R !== null && google.maps.event.removeListener(R), A(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), y(() => {
    w && a && (U !== null && google.maps.event.removeListener(U), V(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), y(() => {
    w && l && (N !== null && google.maps.event.removeListener(N), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), y(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), y(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), y(() => {
    w && c && (D !== null && google.maps.event.removeListener(D), j(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), y(() => {
    w && d && (G !== null && google.maps.event.removeListener(G), S(google.maps.event.addListener(w, "removefeature", d)));
  }, [d]), y(() => {
    w && p && (Y !== null && google.maps.event.removeListener(Y), O(google.maps.event.addListener(w, "removeproperty", p)));
  }, [p]), y(() => {
    w && g && (M !== null && google.maps.event.removeListener(M), W(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), y(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), y(() => {
    if (C !== null) {
      var I = new google.maps.Data(qd(qd({}, t), {}, {
        map: C
      }));
      r && v(google.maps.event.addListener(I, "dblclick", r)), o && L(google.maps.event.addListener(I, "mousedown", o)), i && k(google.maps.event.addListener(I, "mousemove", i)), s && A(google.maps.event.addListener(I, "mouseout", s)), a && V(google.maps.event.addListener(I, "mouseover", a)), l && Z(google.maps.event.addListener(I, "mouseup", l)), u && X(google.maps.event.addListener(I, "rightclick", u)), n && ee(google.maps.event.addListener(I, "click", n)), c && j(google.maps.event.addListener(I, "addfeature", c)), d && S(google.maps.event.addListener(I, "removefeature", d)), p && O(google.maps.event.addListener(I, "removeproperty", p)), g && W(google.maps.event.addListener(I, "setgeometry", g)), f && q(google.maps.event.addListener(I, "setproperty", f)), P(I), m && m(I);
    }
    return () => {
      w && (E !== null && google.maps.event.removeListener(E), x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), D !== null && google.maps.event.removeListener(D), G !== null && google.maps.event.removeListener(G), Y !== null && google.maps.event.removeListener(Y), M !== null && google.maps.event.removeListener(M), T !== null && google.maps.event.removeListener(T), h && h(w), w.setMap(null));
    };
  }, []), null;
}
De(Lae);
class Dae extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      data: null
    }), ue(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(qd(qd({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = gt({
        updaterMap: rP,
        eventMap: nP,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: rP,
      eventMap: nP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), wt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ue(Dae, "contextType", nt);
function oP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oP(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sP = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, aP = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class Pae extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      kmlLayer: null
    }), ue(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(iP(iP({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: aP,
      eventMap: sP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: aP,
      eventMap: sP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), wt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ue(Pae, "contextType", nt);
function cI(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Sae(e, t) {
  return new t(e.lat, e.lng);
}
function Mae(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Tae(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function jae(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Aae(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Bae(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function dI(e, t, n, r) {
  return n !== void 0 ? Aae(e, t, jae(n, google.maps.LatLngBounds, Mae)) : Bae(e, t, Tae(r, google.maps.LatLng, Sae));
}
function Iae(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function lP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fae(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lP(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Rae(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = Fae({}, this.container ? cI(this.container, o) : {
        x: 0,
        y: 0
      }), u = dI(a, l, this.bounds, this.position);
      for (var [c, d] of Object.entries(u))
        this.container.style[c] = d;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function uP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nae(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uP(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function cP(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function dP(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function zae(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = _e(nt), c = qn(() => {
    var p = document.createElement("div");
    return p.style.position = "absolute", p;
  }, []), d = qn(() => Rae(c, r, t, n, a), [c, r, t, n]);
  return y(() => (i == null || i(d), d == null || d.setMap(u), () => {
    s == null || s(d), d == null || d.setMap(null);
  }), [u, d]), y(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
De(zae);
class na extends Ee {
  constructor(t) {
    super(t), ue(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ue(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Qn(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ue(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ue(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Nae({
        x: 0,
        y: 0
      }, this.containerRef.current ? cI(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = dI(r, o, this.props.bounds, this.props.position);
      if (!Iae(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ue(this, "draw", () => {
      this.onPositionElement();
    }), ue(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = eo();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = cP(t.position), r = cP(this.props.position), o = dP(t.bounds), i = dP(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(B.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: Ct.only(this.props.children)
    }), t) : null;
  }
}
ue(na, "FLOAT_PANE", "floatPane");
ue(na, "MAP_PANE", "mapPane");
ue(na, "MARKER_LAYER", "markerLayer");
ue(na, "OVERLAY_LAYER", "overlayLayer");
ue(na, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ue(na, "contextType", nt);
function $ae() {
}
function pP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pP(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hP = {
  onDblClick: "dblclick",
  onClick: "click"
}, gP = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Uae(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = _e(nt), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = qn(() => new google.maps.GroundOverlay(t, s, r), []);
  return y(() => {
    a !== null && a.setMap(i);
  }, [i]), y(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), y(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), y(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
De(Uae);
class pI extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      groundOverlay: null
    }), ue(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Qn(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, fP(fP({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: gP,
      eventMap: hP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: gP,
      eventMap: hP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ue(pI, "defaultProps", {
  onLoad: $ae
});
ue(pI, "contextType", nt);
function mP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mP(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vP = {}, yP = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Hae(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = _e(nt), [s, a] = _(null);
  return y(() => {
    google.maps.visualization || Qn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(() => {
    Qn(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), y(() => {
    s !== null && s.setMap(i);
  }, [i]), y(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), y(() => {
    var l = new google.maps.visualization.HeatmapLayer(Gd(Gd({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
De(Hae);
class Wae extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      heatmapLayer: null
    }), ue(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Qn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Qn(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Gd(Gd({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: yP,
      eventMap: vP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: yP,
      eventMap: vP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), wt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ue(Wae, "contextType", nt);
var bP = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, wP = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Vae extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      streetViewPanorama: null
    }), ue(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = gt({
      updaterMap: wP,
      eventMap: bP,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: wP,
      eventMap: bP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), wt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ue(Vae, "contextType", nt);
class Zae extends Ee {
  constructor() {
    super(...arguments), ue(this, "state", {
      streetViewService: null
    }), ue(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ue(Zae, "contextType", nt);
var CP = {
  onDirectionsChanged: "directions_changed"
}, EP = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class qae extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      directionsRenderer: null
    }), ue(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = gt({
      updaterMap: EP,
      eventMap: CP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: EP,
      eventMap: CP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), wt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ue(qae, "contextType", nt);
var xP = {
  onPlacesChanged: "places_changed"
}, OP = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class fI extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "containerElement", eo()), ue(this, "state", {
      searchBox: null
    }), ue(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Qn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = gt({
          updaterMap: OP,
          eventMap: xP,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: OP,
      eventMap: xP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), wt(this.registeredEvents));
  }
  render() {
    return B.jsx("div", {
      ref: this.containerElement,
      children: Ct.only(this.props.children)
    });
  }
}
ue(fI, "contextType", nt);
var kP = {
  onPlaceChanged: "place_changed"
}, _P = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class hI extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "containerElement", eo()), ue(this, "state", {
      autocomplete: null
    }), ue(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Qn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = gt({
        updaterMap: _P,
        eventMap: kP,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: _P,
      eventMap: kP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && wt(this.registeredEvents);
  }
  render() {
    return B.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: Ct.only(this.props.children)
    });
  }
}
ue(hI, "defaultProps", {
  className: ""
});
ue(hI, "contextType", nt);
function Bue({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ B.jsx(
    rI,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function Iue(e) {
  const { children: t = !1 } = e, [n, r] = _([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((d) => d.key === u)) == null ? void 0 : c.data;
  }
  function s(u, c) {
    const d = o(u);
    r(d ? (p) => [...p.filter((f) => f.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function a(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ B.jsx(
    Tb.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: s, closeModal: a, closeAll: l },
      children: t
    }
  );
}
let Gae = { data: "" }, Yae = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Gae, Kae = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Xae = /\/\*[^]*?\*\/|  +/g, LP = /\n+/g, di = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? di(s, i) : i + "{" + di(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += di(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += di.p ? di.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Po = {}, gI = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + gI(e[n]);
    return t;
  }
  return e;
}, Jae = (e, t, n, r, o) => {
  let i = gI(e), s = Po[i] || (Po[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Po[s]) {
    let l = i !== e ? e : ((u) => {
      let c, d, p = [{}];
      for (; c = Kae.exec(u.replace(Xae, "")); ) c[4] ? p.shift() : c[3] ? (d = c[3].replace(LP, " ").trim(), p.unshift(p[0][d] = p[0][d] || {})) : p[0][c[1]] = c[2].replace(LP, " ").trim();
      return p[0];
    })(e);
    Po[s] = di(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Po.g ? Po.g : null;
  return n && (Po.g = Po[s]), ((l, u, c, d) => {
    d ? u.data = u.data.replace(d, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Po[s], t, r, a), s;
}, Qae = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : di(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function Df(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Jae(n.unshift ? n.raw ? Qae(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Yae(t.target), t.g, t.o, t.k);
}
let mI, Qm, ev;
Df.bind({ g: 1 });
let Ro = Df.bind({ k: 1 });
function ele(e, t, n, r) {
  di.p = t, mI = e, Qm = n, ev = r;
}
function Mi(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: Qm && Qm() }, a), n.o = / *go\d+/.test(l), a.className = Df.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), ev && u[0] && ev(a), mI(u, a);
    }
    return o;
  };
}
var tle = (e) => typeof e == "function", Yd = (e, t) => tle(e) ? e(t) : e, nle = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), vI = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), rle = 20, yI = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, rle) };
    case 1:
      return { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return yI(e, { type: e.toasts.find((i) => i.id === n.id) ? 1 : 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, dismissed: !0, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, Ic = [], ls = { toasts: [], pausedAt: void 0 }, Ds = (e) => {
  ls = yI(ls, e), Ic.forEach((t) => {
    t(ls);
  });
}, ole = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, ile = (e = {}) => {
  let [t, n] = _(ls), r = Ye(ls);
  y(() => (r.current !== ls && n(ls), Ic.push(n), () => {
    let i = Ic.indexOf(n);
    i > -1 && Ic.splice(i, 1);
  }), []);
  let o = t.toasts.map((i) => {
    var s, a, l;
    return { ...e, ...e[i.type], ...i, removeDelay: i.removeDelay || ((s = e[i.type]) == null ? void 0 : s.removeDelay) || (e == null ? void 0 : e.removeDelay), duration: i.duration || ((a = e[i.type]) == null ? void 0 : a.duration) || (e == null ? void 0 : e.duration) || ole[i.type], style: { ...e.style, ...(l = e[i.type]) == null ? void 0 : l.style, ...i.style } };
  });
  return { ...t, toasts: o };
}, sle = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, dismissed: !1, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || nle() }), au = (e) => (t, n) => {
  let r = sle(t, e, n);
  return Ds({ type: 2, toast: r }), r.id;
}, gr = (e, t) => au("blank")(e, t);
gr.error = au("error");
gr.success = au("success");
gr.loading = au("loading");
gr.custom = au("custom");
gr.dismiss = (e) => {
  Ds({ type: 3, toastId: e });
};
gr.remove = (e) => Ds({ type: 4, toastId: e });
gr.promise = (e, t, n) => {
  let r = gr.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return typeof e == "function" && (e = e()), e.then((o) => {
    let i = t.success ? Yd(t.success, o) : void 0;
    return i ? gr.success(i, { id: r, ...n, ...n == null ? void 0 : n.success }) : gr.dismiss(r), o;
  }).catch((o) => {
    let i = t.error ? Yd(t.error, o) : void 0;
    i ? gr.error(i, { id: r, ...n, ...n == null ? void 0 : n.error }) : gr.dismiss(r);
  }), e;
};
var ale = (e, t) => {
  Ds({ type: 1, toast: { id: e, height: t } });
}, lle = () => {
  Ds({ type: 5, time: Date.now() });
}, Ja = /* @__PURE__ */ new Map(), ule = 1e3, cle = (e, t = ule) => {
  if (Ja.has(e)) return;
  let n = setTimeout(() => {
    Ja.delete(e), Ds({ type: 4, toastId: e });
  }, t);
  Ja.set(e, n);
}, dle = (e) => {
  let { toasts: t, pausedAt: n } = ile(e);
  y(() => {
    if (n) return;
    let i = Date.now(), s = t.map((a) => {
      if (a.duration === 1 / 0) return;
      let l = (a.duration || 0) + a.pauseDuration - (i - a.createdAt);
      if (l < 0) {
        a.visible && gr.dismiss(a.id);
        return;
      }
      return setTimeout(() => gr.dismiss(a.id), l);
    });
    return () => {
      s.forEach((a) => a && clearTimeout(a));
    };
  }, [t, n]);
  let r = Yt(() => {
    n && Ds({ type: 6, time: Date.now() });
  }, [n]), o = Yt((i, s) => {
    let { reverseOrder: a = !1, gutter: l = 8, defaultPosition: u } = s || {}, c = t.filter((g) => (g.position || u) === (i.position || u) && g.height), d = c.findIndex((g) => g.id === i.id), p = c.filter((g, f) => f < d && g.visible).length;
    return c.filter((g) => g.visible).slice(...a ? [p + 1] : [0, p]).reduce((g, f) => g + (f.height || 0) + l, 0);
  }, [t]);
  return y(() => {
    t.forEach((i) => {
      if (i.dismissed) cle(i.id, i.removeDelay);
      else {
        let s = Ja.get(i.id);
        s && (clearTimeout(s), Ja.delete(i.id));
      }
    });
  }, [t]), { toasts: t, handlers: { updateHeight: ale, startPause: lle, endPause: r, calculateOffset: o } };
}, ple = Ro`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, fle = Ro`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, hle = Ro`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, gle = Mi("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${ple} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${fle} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${hle} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, mle = Ro`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, vle = Mi("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${mle} 1s linear infinite;
`, yle = Ro`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, ble = Ro`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, wle = Mi("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${yle} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${ble} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Cle = Mi("div")`
  position: absolute;
`, Ele = Mi("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, xle = Ro`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Ole = Mi("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${xle} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, kle = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ue.createElement(Ole, null, t) : t : n === "blank" ? null : Ue.createElement(Ele, null, Ue.createElement(vle, { ...r }), n !== "loading" && Ue.createElement(Cle, null, n === "error" ? Ue.createElement(gle, { ...r }) : Ue.createElement(wle, { ...r })));
}, _le = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Lle = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, Dle = "0%{opacity:0;} 100%{opacity:1;}", Ple = "0%{opacity:1;} 100%{opacity:0;}", Sle = Mi("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Mle = Mi("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Tle = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = vI() ? [Dle, Ple] : [_le(n), Lle(n)];
  return { animation: t ? `${Ro(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ro(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, jle = Ue.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? Tle(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ue.createElement(kle, { toast: e }), s = Ue.createElement(Mle, { ...e.ariaProps }, Yd(e.message, e));
  return Ue.createElement(Sle, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ue.createElement(Ue.Fragment, null, i, s));
});
ele(Ue.createElement);
var Ale = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = Ue.useCallback((s) => {
    if (s) {
      let a = () => {
        let l = s.getBoundingClientRect().height;
        r(e, l);
      };
      a(), new MutationObserver(a).observe(s, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return Ue.createElement("div", { ref: i, className: t, style: n }, o);
}, Ble = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: vI() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, Ile = Df`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, _c = 16, Fle = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: s }) => {
  let { toasts: a, handlers: l } = dle(n);
  return Ue.createElement("div", { id: "_rht_toaster", style: { position: "fixed", zIndex: 9999, top: _c, left: _c, right: _c, bottom: _c, pointerEvents: "none", ...i }, className: s, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, a.map((u) => {
    let c = u.position || t, d = l.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }), p = Ble(c, d);
    return Ue.createElement(Ale, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? Ile : "", style: p }, u.type === "custom" ? Yd(u.message, u) : o ? o(u) : Ue.createElement(jle, { toast: u, position: c }));
  }));
}, DP = gr;
function Fue({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return DP.success(n.message, {
          style: {
            background: "#10B981",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#059669",
            secondary: "#ffffff"
          }
        });
      case "danger":
        return DP.error(n.message, {
          style: {
            background: "#E11D48",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#BE123C",
            secondary: "#ffffff"
          }
        });
    }
  }
  return /* @__PURE__ */ B.jsxs(YB.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ B.jsx(
      Fle,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
function bI({ children: e, fallback: t = null }) {
  return ase() ? /* @__PURE__ */ B.jsx(B.Fragment, { children: e() }) : /* @__PURE__ */ B.jsx(B.Fragment, { children: t });
}
let Rle = class {
  constructor(t, n) {
    lu(this, "pixelId");
    lu(this, "autoConfig");
    lu(this, "initialized");
    this.pixelId = t, this.autoConfig = (n == null ? void 0 : n.autoConfig) || !0, this.initialized = !1;
  }
  loadFacebookPixel() {
    if (window.fbq) return;
    const t = function(...o) {
      t.callMethod ? t.callMethod.apply(t, o) : t.queue.push(o);
    };
    window._fbq || (window._fbq = t), t.push = t, t.loaded = !0, t.version = "2.0", t.queue = [];
    const n = document.createElement("script");
    n.async = !0, n.src = "https://connect.facebook.net/en_US/fbevents.js";
    const r = document.getElementsByTagName("script")[0];
    if (!r.parentNode)
      throw new Error("No script tag found in the document");
    r.parentNode.insertBefore(n, r), window.fbq = t;
  }
  init(t = {}) {
    if (this.initialized = typeof window < "u" && !!window.fbq, this.loadFacebookPixel(), !window.fbq)
      throw new Error("window.fbq is not defined");
    this.autoConfig === !1 ? window.fbq("set", "autoConfig", !1, this.pixelId) : window.fbq("init", this.pixelId, t), this.initialized = !0;
  }
  pageView() {
    this.initialized && window.fbq && window.fbq("track", "PageView");
  }
  track(t, n) {
    this.initialized && window.fbq && window.fbq("track", t, n);
  }
  trackSingle(t, n, r) {
    this.initialized && window.fbq && window.fbq("trackSingle", t, n, r);
  }
  trackCustom(t, n) {
    this.initialized && window.fbq && window.fbq("trackCustom", t, n);
  }
  trackSingleCustom(t, n, r) {
    this.initialized && window.fbq && window.fbq("trackSingle", t, n, r);
  }
  grantConsent() {
    this.initialized && window.fbq && window.fbq("consent", "grant");
  }
  revokeConsent() {
    this.initialized && window.fbq && window.fbq("consent", "revoke");
  }
};
function Nle(e) {
  const {
    pixelId: t,
    options: n,
    pageView: r,
    track: o,
    trackCustom: i,
    trackSingle: s,
    trackSingleCustom: a,
    grantConsent: l,
    revokeConsent: u
  } = e, c = new Rle(t, n);
  return c.init(), r && c.pageView(), l && c.grantConsent(), u && c.revokeConsent(), o && c.track(...o), i && c.trackCustom(...i), s && c.trackSingle(t, ...s), a && c.trackSingleCustom(t, ...a), /* @__PURE__ */ B.jsx(B.Fragment, {});
}
function Nue(e) {
  return process.env.NODE_ENV !== "production" && !e.showInDevMode ? /* @__PURE__ */ B.jsx(B.Fragment, {}) : /* @__PURE__ */ B.jsx(bI, { children: () => /* @__PURE__ */ B.jsx(Nle, { ...e }) });
}
function zue({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ B.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ B.jsx(
    bse,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ B.jsx(oI, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ B.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ B.jsx(qI, {}) });
}
function $ue({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = _(null), s = (l) => i(l), a = () => {
    var g, f, m, h;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function d(C) {
      const w = c.find((P) => P.types[0] === C);
      return w ? w.long_name : "";
    }
    function p(C) {
      const w = c.find((P) => P.types[0] === C);
      return w ? w.short_name : "";
    }
    if (u) {
      const C = d("route"), w = d("street_number"), P = d("sublocality_level_1"), E = d("administrative_area_level_2"), v = d("administrative_area_level_1"), x = p("administrative_area_level_1"), L = d("postal_code"), z = (f = (g = u.geometry) == null ? void 0 : g.location) == null ? void 0 : f.lat(), k = (h = (m = u.geometry) == null ? void 0 : m.location) == null ? void 0 : h.lng();
      t && t({
        street: C,
        city: E,
        state: v,
        district: P,
        cep: L,
        streetNumber: w,
        stateShortName: x,
        coordinates: { lat: z, lng: k }
      });
    }
  };
  return /* @__PURE__ */ B.jsx(
    fI,
    {
      onLoad: s,
      onPlacesChanged: a,
      options: n,
      children: /* @__PURE__ */ B.jsx(vf, { type: "text", onChange: (l) => e(l.target.value), ...r })
    }
  );
}
function wI(e) {
  const { dataLayer: t, dataLayerName: n } = e;
  return `
  window.${n} = window.${n} || [];
  window.${n}.push(${JSON.stringify(t)})`;
}
function zle(e) {
  const { id: t, events: n, dataLayer: r, dataLayerName: o, preview: i, auth: s } = e, a = `&gtm_auth=${s}`, l = `&gtm_preview=${i}`;
  t || console.warn("GTM Id is required");
  const u = `
    <iframe src="https://www.googletagmanager.com/ns.html?id=${t}${a}${l}&gtm_cookies_win=x"
      height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>`, c = `
    (function(w,d,s,l,i){w[l]=w[l]||[];
      w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', ${JSON.stringify(
    n
  ).slice(1, -1)}});
      var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
      j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'${a}${l}&gtm_cookies_win=x';
      f.parentNode.insertBefore(j,f);
    })(window,document,'script','${o}','${t}');`, d = wI({ dataLayer: r, dataLayerName: o });
  return {
    iframe: u,
    script: c,
    dataLayerVar: d
  };
}
let $le = class {
  initializeDataScript(t) {
    const n = document.createElement("script");
    return n.innerHTML = t, n;
  }
  initializeGTMElements(t) {
    const n = zle(t), r = () => {
      const s = document.createElement("noscript");
      return s.innerHTML = n.iframe, s;
    }, o = () => {
      const s = document.createElement("script");
      return s.innerHTML = n.script, s;
    }, i = this.initializeDataScript(n.dataLayerVar);
    return {
      noScript: r,
      script: o,
      dataScript: i
    };
  }
  initializeDataLayer(t) {
    const { dataLayer: n, dataLayerName: r } = t;
    if (window[r]) return window[r].push(n);
    const o = wI({ dataLayer: n, dataLayerName: r }), i = this.initializeDataScript(o);
    document.head.insertBefore(i, document.head.childNodes[0]);
  }
  initialize(t) {
    const {
      events: n,
      gtmId: r,
      dataLayer: o,
      auth: i = "",
      preview: s = "",
      dataLayerName: a = "dataLayer"
    } = t, l = this.initializeGTMElements({
      id: r,
      events: n,
      dataLayer: o || void 0,
      dataLayerName: a,
      auth: i,
      preview: s
    });
    o && document.head.appendChild(l.dataScript), document.head.insertBefore(l.script(), document.head.childNodes[0]), document.body.insertBefore(l.noScript(), document.body.childNodes[0]);
  }
};
function Ule(e) {
  return new $le().initialize(e), /* @__PURE__ */ B.jsx(B.Fragment, {});
}
function Hue(e) {
  const {
    gtmId: t,
    auth: n = "",
    preview: r = "",
    dataLayerName: o = "dataLayer",
    events: i = {},
    dataLayer: s = {},
    showInDevMode: a = !1
  } = e;
  return process.env.NODE_ENV !== "production" && !a ? /* @__PURE__ */ B.jsx(B.Fragment, {}) : /* @__PURE__ */ B.jsx(bI, { children: () => /* @__PURE__ */ B.jsx(
    Ule,
    {
      auth: n,
      dataLayer: s,
      dataLayerName: o,
      events: i,
      gtmId: t,
      preview: r
    }
  ) });
}
export {
  Kle as AlertContainer,
  Xle as AlertContent,
  Jle as AlertDescription,
  Qle as AlertIcon,
  XI as AlertTitle,
  due as AudioUpload,
  rue as Badge,
  xue as BreadcrumbContainer,
  Oue as BreadcrumbLink,
  kl as Button,
  oue as Card,
  pue as Checkbox,
  bI as ClientOnly,
  mS as Divider,
  _ue as DrawerContainer,
  Lue as DrawerHeader,
  jue as DrawerProvider,
  Nue as FacebookPixel,
  fue as FileUpload,
  H_ as FormController,
  hue as FormError,
  W_ as FormLabel,
  zue as GoogleMap,
  Bue as GoogleProvider,
  $ue as GoogleSearchPlaces,
  Hue as GoogleTagManager,
  SA as IconButton,
  KQ as ImageUpload,
  vf as Input,
  Wre as ModalContainer,
  Vre as ModalFooter,
  Zre as ModalHeader,
  Iue as ModalProvider,
  gue as MultiSelect,
  kue as Pagination,
  mue as PhoneInput,
  Due as Popover,
  yue as RadioBox,
  vue as RadioGroup,
  bue as RichText,
  wue as Select,
  iue as Skeleton,
  NQ as Slider,
  Cue as Switch,
  SL as TabButton,
  Gre as TabContainer,
  sue as TableBody,
  aue as TableCaption,
  lue as TableContainer,
  uue as TableFooter,
  cue as TableHeader,
  Eue as Textarea,
  Pue as Toast,
  Fue as ToastProvider,
  MA as Tooltip,
  eue as getHtmlFromRichTextValue,
  tue as getRichTextValueFromHtml,
  nue as isHtml,
  gS as morpheme,
  Sue as useAutomation,
  Mue as useDrawer,
  lb as useFieldErrors,
  Er as useFormController,
  ase as useHydrated,
  Tue as useModal,
  _B as useScopedParams,
  ise as useToast
};
